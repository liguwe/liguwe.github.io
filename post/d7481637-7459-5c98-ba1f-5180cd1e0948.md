
# 实现批量请求并控制最大并发数

<Badge type="warning">#前端</Badge> <Badge type="info">#2023/04/26</Badge> 

为了实现批量请求并控制最大并发数，我们可以使用`Promise.all()`和`Promise.race()`结合循环来实现

## 先使用 setimeout 模拟请求

```javascript
/**
 * 模拟异步请求
 * @param {*} id 标识符
 * @param {*} delay 延迟时间
 */
const mockRequest = (id, delay) => {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log(`完成请求 ${id}`);
            resolve(`响应 ${id}`);
        }, delay);
    });
};
```

## 主要逻辑

**关键点：**
- 使用 `set` 来存储任务集合
- 使用 `next` 来标识处理每一个请求逻辑，这里是**主要逻辑**
	- 每次执行完成需要从集合中 `delete` 掉
		- 失败也需要从集合中  `delete` 掉
	- 判断是否达到最大并发数
		- 达到，等待任意请求完成
			- 使用 `Promise.race` 来竞赛，完成后 `then` 继续执行 `next`
		- 没达到
			- 直接启动下个任务 `next()`


```javascript
/**
 * 批量执行请求，控制最大并发数
 * @param {Array} tasks 任务数组
 * @param {number} maxConcurrency 最大并发数
 */
async function runBatchRequests(tasks, maxConcurrency) {
    let i = 0; // 当前处理的任务索引
    const total = tasks.length;
    const executing = new Set(); // 正在执行的任务集合

    // 下一个任务 , 递归调用
    const next = () => {
        // 所有任务已经启动
        if (i === total) {
            return Promise.resolve();
        }
        const task = tasks[i++](); // 获取任务并执行
        executing.add(task);

        const clean = () => executing.delete(task);
        task.then(clean).catch(clean);

        let p = Promise.resolve();

        if (executing.size >= maxConcurrency) {
            // 达到最大并发数，等待任意任务完成
            p = Promise.race(executing).then(() => next());
        } else {
            // 未达到最大并发数，直接启动下一个任务
            p = next();
        }
        return p;
    };

    await next().then(() => Promise.all(executing)); // 确保所有任务都完成了
}
```


## 测试

```javascript
// 示例使用
const awaitList = [1000, 500, 1000, 300, 800, 700, 900];
const tasks = awaitList.map((item, index) => () => mockRequest(index + 1, item));

runBatchRequests(tasks, 10).then(() => console.log('所有请求完成'));

```


## 总结

- `runBatchRequests` 函数接受一个任务数组和最大并发数作为参数。每个任务都是一个返回Promise的函数。
	- 函数内部，通过**递归调用**  `next 函数` 来不断地启动新的任务，直到所有任务都被处理。
	- 通过维护一个`executing集合`来跟踪当前正在执行的任务，并使用`Promise.race()`在达到最大并发限制时等待至少一个任务完成。这样可以在任何任务完成后立即启动新的任务，从而维持最大并发数，直到所有任务都完成。



---
# 阅读原文
- https://liguwe.github.io/post/d7481637-7459-5c98-ba1f-5180cd1e0948