
# Pinia状态管理库文档笔记


<Badge type="warning">#pinia</Badge>  <Badge type="danger">#vue</Badge> <Badge type="tip">#2024/01/07</Badge>

文档地址： https://pinia.vuejs.org/zh/core-concepts/getters.html

## 为什么？

- Pinia抛弃了Mutation，这意味着你可以直接更新状态，不用再注册 Commit
- 语法上更加贴近Composition Api
- 数据持久化使用： `pinia-plugin-persistedstate`
- 允许构建工具自动进行**代码分割**以及 **TypeScript 推断**


## 两种定义方式

约定：所有的 store 定义，都使用 **use 开头**

### 方式一：Option Store

 Store 是用 defineStore() 定义的，它的第一个参数要求是一个独一无二的名字

```javascript
// 第一个参数是你的应用中 Store 的唯一 ID。
export const useCounterStore = defineStore('counter', {
  // 为了完整类型推理，推荐使用箭头函数
  state: () => ({ count: 0 }),
  getters: {
    double: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

`state` 是 store 的数据 (data)，`getters` 是 store 的计算属性 (computed)，而 `actions` 则是方法 (methods)

### 方式二：Setup Store

```javascript
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  function increment() {
    count.value++
  }

  return { count, increment }
})
```

- `ref()` 就是 state 属性
- `computed() `就是 getters
- `function() `就是 actions

### 使用场景选择

- Setup store 比 Option Store 带来了更多的**灵活性**，因为你可以在一个 store 内创建侦听器，并自由地使用任何组合式函数。
- 不过，请记住，使用组合式函数会让 **SSR** 变得更加复杂

## 使用 TS 定义 state，并使用它

```typescript
interface State {
  userList: UserInfo[]
  user: UserInfo | null
}

const useStore = defineStore('storeId', {
  state: (): State => {
    return {
      userList: [],
      user: null,
    }
  },
})

interface UserInfo {
  name: string
  age: number
}
```

### 使用 Store

```typescript
const store = useStore()

store.count++


// 重置，将 state 重置为初始值。
store.$reset()
```

### 选项式的重置与管理

直接调用内部返回的 `$reset()` 即可

```typescript
const store = useStore()

store.$reset()
```

选项式中

- 你可以使用 `mapState` 来辅助管理状态，将 state 属性映射为**只读的计算属性**
- 可以使用 `mapWritableState()` 来修改 state 属性

### 组合式的重置

需要自定义 `$reset()`

```typescript
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)

  function $reset() {
    count.value = 0
  }

  return { count, $reset }
})
```

### 变更 state

```typescript
① 同一时间更改多个属性
store.$patch({
  count: store.count + 1,
  age: 120,
  name: 'DIO',
})

② 函数来组合控制更复杂的变更操作
store.$patch((state) => {
  state.items.push({ name: 'shoes', quantity: 1 })
  state.hasChanged = true
})
```

### 替换 state

```typescript
// 这实际上并没有替换`$state`
store.$state = { count: 24 }
// 在它内部调用 `$patch()`：
store.$patch({ count: 24 })
```

### 监听或者订阅 state

使用 `$subscribe`

```typescript
cartStore.$subscribe((mutation, state) => {
  // import { MutationType } from 'pinia'
  mutation.type // 'direct' | 'patch object' | 'patch function'
  // 和 cartStore.$id 一样
  mutation.storeId // 'cart'
  // 只有 mutation.type === 'patch object'的情况下才可用
  mutation.payload // 传递给 cartStore.$patch() 的补丁对象。

  // 每当状态发生变化时，将整个 state 持久化到本地存储。
  localStorage.setItem('cart', JSON.stringify(state))
})
```

卸载后监听仍然保留

```typescript
<script setup>
const someStore = useSomeStore()
// 此订阅器即便在组件卸载之后仍会被保留
someStore.$subscribe(callback, { detached: true })
</script>
```


当然，你可以使用 `watch` 来监听，即在 pinia 实例上使用 watch() 函数侦听整个 state

```typescript
watch(
  pinia.state,
  (state) => {
    // 每当状态发生变化时，将整个 state 持久化到本地存储。
    localStorage.setItem('piniaState', JSON.stringify(state))
  },
  { deep: true }
)
```


## Action

### 基本使用

- Action 相当于组件中的 `method`
- action 可以是**异步**的，也可以是 **同步**

```typescript
import { mande } from 'mande'

const api = mande('/api/users')

export const useUsers = defineStore('users', {
  state: () => ({
    userData: null,
    // ...
  }),

  actions: {
   
   同步的
   increment() {
      this.count++
    },
    异步的
    async registerUser(login, password) {
      try {
        this.userData = await api.post({ login, password })
        showTooltip(`Welcome back ${this.userData.name}!`)
      } catch (error) {
        showTooltip(error)
        // 让表单组件显示错误
        return error
      }
    },
  },
})
```

Action 可以像函数或者通常意义上的方法一样被调用，如下：

```html
<script setup>
const store = useCounterStore()
// 将 action 作为 store 的方法进行调用
store.randomizeCounter()
</script>
<template>
  <!-- 即使在模板中也可以 -->
  <button @click="store.randomizeCounter()">Randomize</button>
</template>
```

### 访问其他 store 的 action

直接引入调用就好了，这样的好处是，可以**全局管理所有的 store**

```typescript
import { useAuthStore } from './auth-store'

export const useSettingsStore = defineStore('settings', {
  state: () => ({
    preferences: null,
    // ...
  }),
  actions: {
    async fetchUserPreferences() {
      const auth = useAuthStore()
      if (auth.isAuthenticated) {
        this.preferences = await fetchPreferences()
      } else {
        throw new Error('User must be authenticated')
      }
    },
  },
})

```

### Action 选项式 API 的用法

先看看 组合式的用法，**更易用**

```html
<script>
import { useCounterStore } from '../stores/counter'
export default defineComponent({
  setup() {
    const counterStore = useCounterStore()
    return { counterStore }
  },
  methods: {
    incrementAndPrint() {
      this.counterStore.increment()
      console.log('New Count:', this.counterStore.count)
    },
  },
})
</script>
```

可使用 `mapActions()` 辅助函数将 action 属性**映射为你组件中的方法**

```typescript
import { mapActions } from 'pinia'
import { useCounterStore } from '../stores/counter'

export default {
  methods: {
    // 访问组件内的 this.increment()
    // 与从 store.increment() 调用相同
    ...mapActions(useCounterStore, ['increment'])
     
    ① 与上述相同，但将其注册为this.myOwnName()
    
    ...mapActions(useCounterStore, { myOwnName: 'increment' }),
  },
}
```

### 订阅或监听 Action

即 监听 action 方法执行后的结果

```typescript
const unsubscribe = someStore.$onAction(
  ({
    name, // action 名称
    store, // store 实例，类似 `someStore`
    args, // 传递给 action 的参数数组
    after, // 在 action 返回或解决后的钩子
    onError, // action 抛出或拒绝的钩子
  }) => {
    // 为这个特定的 action 调用提供一个共享变量
    const startTime = Date.now()
    // 这将在执行 "store "的 action 之前触发。
    console.log(`Start "${name}" with params [${args.join(', ')}].`)

    // 这将在 action 成功并完全运行后触发。
    // 它等待着任何返回的 promise
    after((result) => {
      console.log(
        `Finished "${name}" after ${
          Date.now() - startTime
        }ms.\nResult: ${result}.`
      )
    })

    // 如果 action 抛出或返回一个拒绝的 promise，这将触发
    onError((error) => {
      console.warn(
        `Failed "${name}" after ${Date.now() - startTime}ms.\nError: ${error}.`
      )
    })
  }
)

// 手动删除监听器
unsubscribe()
```


第二次参数：`someStore.$onAction(callback, true)`

```typescript
<script setup>
const someStore = useSomeStore()
// 此订阅器即便在组件卸载之后仍会被保留
someStore.$onAction(callback, true)
</script>
```

## Pinia 插件

插件是通过` pinia.use() `添加到` pinia 实例`的 ，使用插件的场景有

- 添加新的状态属性到store
- 定义store时创建新的选项
- 为store增加新的方法
- 包装现有的方法
- 改变或取消action
- 实现副作用，比如本地存储
- 扩展store的属性

### 最简单的一个示例

通过返回一个对象**将一个静态属性添加到所有 store**，如：

```typescript
import { createPinia } from 'pinia'

// 创建的每个 store 中都会添加一个名为 `secret` 的属性。
// 在安装此插件后，插件可以保存在不同的文件中
function SecretPiniaPlugin() {
  return { secret: 'the cake is a lie' }
}

const pinia = createPinia()
// 将该插件交给 Pinia
pinia.use(SecretPiniaPlugin)

// 在另一个文件中
const store = useStore()
store.secret // 'the cake is a lie'
```

这对添加**全局对象**很有用，如**路由器、modal 或 toast 管理器**

### 如何定义插件

```typescript
export function myPiniaPlugin(context) {
  context.pinia // 用 `createPinia()` 创建的 pinia。 
  context.app // 用 `createApp()` 创建的当前应用(仅 Vue 3)。
  context.store // 该插件想扩展的 store
  context.options // 定义传给 `defineStore()` 的 store 的可选对象。
  // ...
}
```


### 每个 store 都添加上特定属性

```typescript
// 上文示例
pinia.use(({ store }) => {
  store.hello = 'world'
  // 确保你的构建工具能处理这个问题，webpack 和 vite 在默认情况下应该能处理。
  if (process.env.NODE_ENV === 'development') {
    // 添加你在 store 中设置的键值
    store._customProperties.add('hello')
  }
})
```

>  每个 `store` 都被 `reactive` 包装过


### 添加新的外部属性

```typescript
import { markRaw } from 'vue'
// 根据你的路由器的位置来调整
import { router } from './router'

pinia.use(({ store }) => {
  store.router = markRaw(router)
})
```

使用 `markRaw` 标记一个对象，使其在响应式系统中变为非响应式的，避免无意义的渲染


### 在插件中调用 $subscribe

你也可以在插件中使用 `store.$subscribe 和 store.$onAction `。

```typescript
pinia.use(({ store }) => {
  store.$subscribe(() => {
    // 响应 store 变化
  })
  store.$onAction(() => {
    // 响应 store actions
  })
})
```


### 在定义 store 时，可添加新的 options

比如，你可以创建一个 `debounce` 选项，允许你让**任何 action 实现防抖**。

## TS 支持

具体再参考文档


## 组件外部使用 Store

在组件外部使用store时，情况会有所不同。

在单页面应用程序中，只需在创建pinia实例之后调用`useStore()`函数即可正常工作。确保在pinia安装后才调用`useStore()`函数即可。

例如，在Vue Router的导航守卫中使用 `store` 时，应将 useStore() 的调用放在`beforeEach()`函数中


---
# 阅读原文
- https://liguwe.github.io/post/b3055a75-f4cc-52a0-93da-90e2eb1c913f