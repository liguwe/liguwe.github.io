
# 0017.Vue3 的非原始值响应式方案


#vue 


前文讲了 [[0012.Vue 的响应式的系统设计原理]]  ，本文，主要讲解更复杂场景 ，比如

- 如何拦截 `for-in` ?
- 如何拦截 `Map WeakMap  Set  WeakSet` 等？ 

## 一、先看看 `Proxy` 与 `Reflect` 

### 基本操作

拦截对象的 `读 get 、取 set`   

```javascript
const obj = {foo: 1}

const p = new Proxy(obj, {
    get() {
        return obj.foo
    },
    set(target, key, value) {
        obj[key] = value
    }
})
```

拦截函数的`调用 apply`

```javascript
const fn = (name) => {
    console.log('我是：', name)
}

const p2 = new Proxy(fn, {
    apply(target, thisArg, argArray) {
        target.call(thisArg, ...argArray)
    }
})
```

### 复合操作

读取一个对象的方法，如 `obj.fn()` ， 分两步：
- 先 `get` 读取 `obj.fn`
- 然后`apply` 调用，`obj.fn()`

### Reflect

![image.png](images/89f6df0dbb53ae4746460d060a860c99.png)

> `Reflect` 与 `Proxy` 的 API  一一对应，比如 `get / set / apply` 等

`Reflect` 还接受`第三个参数`，如下：

![image.png](images/6f6465918bdc361e993206a4b58d401d.png)

前文 [[0012.Vue 的响应式的系统设计原理]] 的` Effect` 函数，如果对于下面的数据结构有问题，`无法正常收集响应信息`。这时候就需要用到 `Reflect 的第三个参数了`

```javascript
const obj = {
  foo: 1,
  get bar() {
     return this.foo
  }
}
```

> 具体解决方法，代码见 Demo 仓库

## 二、Javascript 对象 与 Proxy 对象

### 如何判断是 `普通对象` 还是`函数对象` 

JS 中一切都是对象，函数也是对象，那么如何区分呢？

- 对象真正语义由`内部方法`实现，即对对象进行某个操作时，`引擎内部`实际调用的方法，对用户是不可见的

![image.png](images/facf27b921187c6c77f36e11511f2d2d.png)

如上图，是 常规对象 的 `内部方法`，下面是`函数对象的内部方法`

![image.png](images/5ffa20e66f443a16309655b8ae9201c4.png)

所以，根据是否部署 `[[Call]]`  方法，就可以判断是 `普通对象` 还是`函数对象` 

> https://262.ecma-international.org/#sec-ordinary-and-exotic-objects-behaviours


### `常规对象` 与 `异质对象`

ES 规范，JS 中有`两种对象`：
- `常规对象`
- `异质对象`： 如 Proxy 对象，如下图：

![image.png](images/a519e54f6ddf360657463d503143b1ca.png)

- `[[Call]]` 和 `[[construct]]` 两个内部方法只有被代理对象是函数和构造函数时才会调用
- 内部方法的`多态性` 即 普通对象 和 Proxy 都有 `[[Get]]`  ，但规范定义是完全不同的。

> https://262.ecma-international.org/#sec-proxy-object-internal-methods-and-internal-slots


### 示例：代理 `delete` 操作

所以根据以上可知，可通过**下面**的方式 `拦截删除属性操作` 

![image.png](images/29799983481927d8818c33386d0b94e6.png)
``

> [!bug]
> 注意：需要删除被 `proxy` 的对象，才会拦截，如下图，下面的方式就不会
> **自己丢到坑里了，搞了一会，才发现都写错了**

![image.png](images/b125b5237dd8ce6ea39f9e95e472d7fa.png)

## 三、如何代理 Object

如何拦截对象的`一切读取操作`，比如

- 访问属性：`obj.foo`  ， `obj['foo']`
	- `Proxy get` 
- `in`操作符：`foo in obj`
	- 根据 ECMA-262中，in 操作符运算时的逻辑，通过 `Proxy has` 拦截
- 遍历：`for(const key in obj)`
	- 还是通过规范可知，使用` Proxy ownKeys 操作` 可拦截
- 删除某个属性： `delete p.foo`
	- 通过看规范可知，可通过拦截 `Proxy deleteProperty ` 拦截
- 等等。。。

所以，结论就是：首先需要`查阅规范`，找到可拦截的方法，另外一些`复合操作`，依赖于一些基本操作，我们需要分析，通过拦截`基本操作`，达到`间接拦截复合操作`的目的。


另外，比如 添加、删除属性时对 `for-in`  的`执行次数`有影响，需要定义 `const ITERATE_KEY = Symbol()`，即`遍历key` 与 副作用函数相关联，避免重复执行。


> [!info]
>  更多的参考代码，不展开了，真正需要的时候再说吧！


### 合理的触发响应

如下代码：期望改变 `p.foo` 时，触发 `effect` 函数

```javascript
const obj = {foo:0}
const p = reactive(obj);

effect(() => {
    console.log(p.foo);
})

p.foo = 1;
p.foo = 2;
p.foo = 3;

```

打印如下：
![image.png](images/583cf5d8cf0ab1a883d7a49d63b4a3d2.png)


然而，`NaN === NaN` 永远为 `false` ，需要兼容。如下图：

![image.png](images/e0dfc40ac7fec65a89882cd170810a47.png)


最后，访问`原型链上的属性`，可能会导致副作用执行两次的问题，也需要解决。

```javascript
const obj = {foo: 0};
const proto = {bar: 1};

const child = reactive(obj);
const parent = reactive(proto);

Object.setPrototypeOf(child, parent);

effect(() => {
    console.log(child.bar);
})

child.bar = 2;
```

所以，代理对象是一个大工程，这里不展开了，以后真正有实际应用场景，再来看`源代码`。

## 四、深响应与浅响应 、深只读 与 浅只读


`深浅`是指：
- `浅`代表`只读或只响应`对象的`第一层`属性，
- `深`则相反，我们需要，我们需要再返回属性值，之前对值进行递归包装，包装成`响应式`的再返回。


如下图：修改嵌套内层的 `bar属性`，也应该触发副作用函数

![image.png](images/53a08f4b30bc2b6d8a8d9247b6de2c82.png)

所以，我们需要再递归再返回属性值，如下图：

![image.png](images/009b93436fd03c02c033d8c930b0f27f.png)



如下代码：

```javascript
import {createApp, reactive, effect,readonly} from 'vue'
const obj = readonly({ text1: 'text1', text2: 'text2' });
obj.text2 = 1; // [Vue warn] Set operation on key "text2" failed: target is readonly
```

执行会警告：如下图
![image.png](images/37944aa17e10affab4b6854774631b0e.png)

再者，`只读数据`不应该和副作用函数`建立响应关系`。如何实现呢？


## 五、对于数组的代理

数组是`异质对象`，因为数组对象的 `[[DefineOwnproperty]]` 内部方法与常规对象不同。

- 通过`索引`直接设置新的元素，可能会`隐式`的改变数组的 `length` 值
- 修改 `length` 值，也可能会影响 `已有元素`
- `for-in`遍历对象与普通对象区别不大，可使用 `length` 作为追踪的 `key`
- 使用 `for-of` 时，会读取数组的 `Symbol.iterator` 的方法。
- 另外对于数组的查找方法：用户可能会对`代理数组对象`进行查找，当然也可能对`原始对象`进行查找，所以我们`重写了`数组的查找方法。

所以，首先，我需要知道 `读取` 和 `写入` 操作都有哪些？

对于数组所有可能的`读取操作`有哪些？
- `arr[0]`
- length
- for-in 
- for-of
- 不改变原数组的方法：如 some /find 、includes 等等

对于数组所有可能的`设置操作`有哪些？
- `arr[0]=1`
- `length=0`
- 栈方法：push pop等等，它还会`隐式`修改 `length`
- 改变原数组的方法：如 spice 、sort  、fill 等

然后，去查文档，看看每个操作后面的调用逻辑是什么？再有针对性的去跟踪建立响应。

为什么我们要重写` includes` 、 `indexOf` 和 `lastIndexof` 呢？
- 以 includes 为例，查阅语言规范，我们发现
	- 这个方法的执行流程中使用了`数组的对象属性的一面`去查找属性，所以 `this` 指向这个`对象`，所以 `reacttive(obj)` 每次都很返回一个新的对象，所以 this 指向肯定有问题。所以我们需要重写 `includes`, 如何重写呢，即 拦截` arr 对象`的 `includes 属性` ，及看 `includes` 是否存在于`arrayInstrumentations`中，如下代码截图

```javascript
const arrayInstrumentations = {}

;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {
  const originMethod = Array.prototype[method]
  arrayInstrumentations[method] = function(...args) {
    // this 是代理对象，先在代理对象中查找，将结果存储到 res 中
    let res = originMethod.apply(this, args)

    if (res === false) {
      // res 为 false 说明没找到，在通过 this.raw 拿到原始数组，再去原始数组中查找，并更新 res 值
      res = originMethod.apply(this.raw, args)
    }
    // 返回最终的结果
    return res
  }
})
```


下面看看为什么重写 栈方法：如 `push`，看下面示例：

> 你可以想想，语言规范里，调用 `push`  肯定有一步是修改 `length` 的


```javascript
const arr = reactive([]);
// ::::第一个 effect
effect(() => {
    arr.push(1); // 间接读取 length,所以会建立依赖
})
// ::::第二个 effect
effect(() => {
    arr.push(1); // 间接读取 length,还会间接修改 length, 然后就执行第 一 已经建立好的effect，然后就死循环了，导致栈溢出
})
```

上面的代码会`栈溢出` ，解决方案是：使用全局变量 `shouldTrack` 来禁止追踪，断开 length 属性 与 副作用函数的响应联系。

```javascript
let shouldTrack = true
;['push','unshift','pop'].forEach(method => {
  const originMethod = Array.prototype[method]
  arrayInstrumentations[method] = function(...args) {
    shouldTrack = false
    // 调用原始方法之前
    let res = originMethod.apply(this, args)
    // 调用原始方法之后，恢复，允许追踪
    shouldTrack = true
    return res;
  }
})
```

以下代码实现`不追踪`：

```javascript
function track(target, key) {
  if (!activeEffect || !shouldTrack) return
}
```

`pop 、 shift、unshift 、splice` 等方法类似。


## 六、对于 Set 和 Map 的代理


可以想想 `Set` 和  `Map` 对应的属性和方法有哪些？
- size clear keys  values()  entries()  等等

同样的你还是需要去查语言规范，比如 `size` 是一个访问器属性，语言规范里规范有 `this` 执行的步骤，所以直接通过代理对象访问，会导致报错，这时候你需要去兼容，如去拦截 `get()` ，然后`bind` 正确的 `this 值`



其实 `delete()` 也是同样的道理

很多思路类似，比如代理迭代器属性和方法，比如 `for in`  和 `foreach` ，又比如 需要去看看文档规范里 `entries keys 和 values` 是如何定义的


另外需要避免数据污染的问题，即把`响应式数据`设置到`原始数据`上的行为。我们可以通过响应式对象的 `row`属性来访问`原始对象`


OK，就到这儿吧，其实已经有一个很现成的库供我们使用了，如果某一天真正需要用到，或者需要仔细研究，那么去看看 `@vue/reactivity` 或者看看本书的附件源码吧


## 七、原始值的响应方案，比如 `Boolean String BigInt Symbol undefined null Number` 


原始值`按值传递`，所以需要`包裹` , 我们使用 `ref()` 来包裹。代码如下：

```javascript
function ref(val) {
	const wrapper = {
		value: val
	}
	// 定义一个不可枚举不可写的属性，用于标识他是一个 ref
	Object.defineProperty(wrapper, '__v_isRef', {
		value: true
	})
	return reactive(wrapper)
}

```

`ref` 还能解决`响应式丢失`的问题，关于`响应式丢失`，我们来看一个例子

```javascript

const obj = reactive({foo: 1, bar: 2});

// :::: 使用 ... 运算符
const newObj = {...obj}; 

effect(() => {
    console.log(newObj.foo); // newObj 没有任何响应能力，所以这里不会触发 effect
})

// :::: 很显然，这里不会触发 effect 
obj.foo = 2; 
```

有没有什么办法，即使使用 `newObj` 普通对象访问属性值，也会被收集响应呢？答案如下：

```javascript
const obj = reactive({foo: 1, bar: 2});
const newObj = {
    foo: {
        get value() {
            return obj.foo
        }
    },
    bar: {
        get value() {
            return bar.foo
        }
    }
}

effect(() => {
    // 这里会触发 get value() ，从而访问了 obj.foo ，从而触发收集依赖
    console.log(newObj.foo); 
})

obj.foo = 2;
```

所以封装两个函数 `toRef`  和 `toRefs` 

```javascript


function toRefs(obj) {
  const ret = {}
  for (const key in obj) {
    ret[key] = toRef(obj, key)
  }
  return ret
}

function toRef(obj, key) {
  const wrapper = {
    get value() {
      return obj[key]
    },
    set value(val) {
      obj[key] = val
    }
  }

  Object.defineProperty(wrapper, '__v_isRef', {
    value: true
  })

  return wrapper
}
```

这样，就能正确的触发收集了。

>  这下知道这个两个函数是干什么的了吧？以前都有一点懵逼


最后，我们说说 自动脱落 `ref` 的能力，啥意思呢？

比如模板代码，每次都需要加一个 `.value` ？

```html
<div>{{foo.value}}</div>
```


有啥办法解决吗？ 其实很简单，如下代码：

![image.png](images/4a689b99b8f3b3e902890b4f5a93765a.png)

上面的代码，如上：