import{_ as e,o as a,c as l,b as n}from"./app.f8a74beb.js";const _=JSON.parse('{"title":"0002.FE.前端框架设计里的”权衡“与选择","description":"","frontmatter":{"title":"0002.FE.前端框架设计里的”权衡“与选择","urlname":"fpb5t4o5q5rnlg4r","date":"2023-03-12 10:25:05 +0800","tags":[],"categories":[]},"headers":[{"level":2,"title":"1、命令式框架与声明式框架","slug":"_1、命令式框架与声明式框架","link":"#_1、命令式框架与声明式框架","children":[]},{"level":2,"title":"2、性能 与 维护性 的平衡","slug":"_2、性能-与-维护性-的平衡","link":"#_2、性能-与-维护性-的平衡","children":[]},{"level":2,"title":"3、运行时 与 编译时","slug":"_3、运行时-与-编译时","link":"#_3、运行时-与-编译时","children":[{"level":3,"title":"纯运行时，即直接Render即可","slug":"纯运行时-即直接render即可","link":"#纯运行时-即直接render即可","children":[]},{"level":3,"title":"运行时 + 编译时 ，如下图，常用的 Vue/Angular/React 都属于这类框架","slug":"运行时-编译时-如下图-常用的-vue-angular-react-都属于这类框架","link":"#运行时-编译时-如下图-常用的-vue-angular-react-都属于这类框架","children":[]},{"level":3,"title":"","slug":"","link":"#","children":[]},{"level":3,"title":"纯编译时框架，代表Svelte","slug":"纯编译时框架-代表svelte","link":"#纯编译时框架-代表svelte","children":[]}]},{"level":2,"title":"4、原生 JS 操作 DOM、InnerHTML 与 虚拟 DOM 快慢对比","slug":"_4、原生-js-操作-dom、innerhtml-与-虚拟-dom-快慢对比","link":"#_4、原生-js-操作-dom、innerhtml-与-虚拟-dom-快慢对比","children":[]},{"level":2,"title":"5、最后","slug":"_5、最后","link":"#_5、最后","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"relativePath":"yuque/fpb5t4o5q5rnlg4r.md"}'),s={name:"yuque/fpb5t4o5q5rnlg4r.md"},t=n(`<h1 id="前端框架设计里的-权衡-与-选择" tabindex="-1">前端框架设计里的 权衡 与 选择 <a class="header-anchor" href="#前端框架设计里的-权衡-与-选择" aria-hidden="true">#</a></h1><h2 id="_1、命令式框架与声明式框架" tabindex="-1">1、命令式框架与声明式框架 <a class="header-anchor" href="#_1、命令式框架与声明式框架" aria-hidden="true">#</a></h2><ul><li><code>Jquery</code> 就是典型的 <strong>命令式框架</strong>，关注<code>过程</code></li><li>Vue 暴露给用户使用的是 <code>声明式</code> ，但底层内部实现肯定也是 <code>命令式</code> ，如下示例：面向用户的是声明式的</li></ul><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello()</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>但问题是，<strong>声明式的代码性能 不会高于 命令式代码的性能 ，所以这是一个选择 或者权衡</strong></p><h2 id="_2、性能-与-维护性-的平衡" tabindex="-1">2、性能 与 维护性 的平衡 <a class="header-anchor" href="#_2、性能-与-维护性-的平衡" aria-hidden="true">#</a></h2><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//FkPqA2uVDAvzBIJAIjpDRdxhQsyp.png" alt=""></p><h2 id="_3、运行时-与-编译时" tabindex="-1">3、运行时 与 编译时 <a class="header-anchor" href="#_3、运行时-与-编译时" aria-hidden="true">#</a></h2><h3 id="纯运行时-即直接render即可" tabindex="-1">纯运行时，即直接<code>Render</code>即可 <a class="header-anchor" href="#纯运行时-即直接render即可" aria-hidden="true">#</a></h3><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//Fg50nk8zQ1iWJbRkEKmVDMyNO4bZ.png" alt=""></p><h3 id="运行时-编译时-如下图-常用的-vue-angular-react-都属于这类框架" tabindex="-1">运行时 + 编译时 ，如下图，常用的 Vue/Angular/React 都属于这类框架 <a class="header-anchor" href="#运行时-编译时-如下图-常用的-vue-angular-react-都属于这类框架" aria-hidden="true">#</a></h3><h3 id="" tabindex="-1"><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//Fq1iu91nLCuPM-w-HHaPfXLX9Bxh.png" alt=""> <a class="header-anchor" href="#" aria-hidden="true">#</a></h3><h3 id="纯编译时框架-代表svelte" tabindex="-1">纯编译时框架，代表<code>Svelte</code> <a class="header-anchor" href="#纯编译时框架-代表svelte" aria-hidden="true">#</a></h3><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//FhVc9j0TN1GNOR6dW_jxUMDygi_n.png" alt=""></p><h2 id="_4、原生-js-操作-dom、innerhtml-与-虚拟-dom-快慢对比" tabindex="-1">4、原生 JS 操作 DOM、InnerHTML 与 虚拟 DOM 快慢对比 <a class="header-anchor" href="#_4、原生-js-操作-dom、innerhtml-与-虚拟-dom-快慢对比" aria-hidden="true">#</a></h2><p>可从以下三个方面来度量</p><ul><li>理解成本上，<strong>原生 JS 操作 DOM &gt; InnerHTML &gt; 虚拟 DOM</strong></li><li>维护性上，<strong>原生 JS 操作 DOM 、 InnerHTML &lt; 虚拟 DOM</strong></li><li>性能上，取决于<code>页面大小</code>，<code>页面变更大小，</code>是<code>新建页面</code> 还是<code> 更新页</code>面 甚至是<code>更新策略</code>等，都有关系，不同场景下有不同结论。</li></ul><h2 id="_5、最后" tabindex="-1">5、最后 <a class="header-anchor" href="#_5、最后" aria-hidden="true">#</a></h2><p>无论是<code>命令式</code>还<code>是声明式</code>，或者框架需要设计成<code>运行时</code>、<code>编译时</code>或<code>运行时+编译时</code>，都需要结合 <code>性能</code>、<code>理解成本</code>、<code>维护性</code>上做权衡选择。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><ul><li>《Vue.js 设计与实现》</li></ul>`,21),r=[t];function o(c,d,i,h,p,u){return a(),l("div",null,r)}const m=e(s,[["render",o]]);export{_ as __pageData,m as default};
