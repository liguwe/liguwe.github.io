import{_ as e,o as a,c as o,V as i}from"./chunks/framework.5e406744.js";const g=JSON.parse('{"title":"Vue3 中 keepAlive组件 的实现原理","description":"","frontmatter":{},"headers":[],"relativePath":"post/0074.md","filePath":"post/0074.md"}'),t={name:"post/0074.md"},l=i('<hr><p>#vue</p><h1 id="vue3-中-keepalive组件-的实现原理" tabindex="-1">Vue3 中 keepAlive组件 的实现原理 <a class="header-anchor" href="#vue3-中-keepalive组件-的实现原理" aria-label="Permalink to &quot;Vue3 中 keepAlive组件 的实现原理&quot;">​</a></h1><h2 id="为什么需要-keepalive" tabindex="-1">为什么需要 keepalive <a class="header-anchor" href="#为什么需要-keepalive" aria-label="Permalink to &quot;为什么需要 keepalive&quot;">​</a></h2><p>类似于HTTP 中的 <code>keepAlive</code> , 为了避免频繁地销毁、创建 HTTP 连接会带来额外 的性能开销；故允许多个请求或响应共用一个 TCP 连接</p><p>同样的， <code>keepAlive组件</code> 可以避免 一个组件被 频繁地销毁/重建</p><h2 id="keepalive-的本质" tabindex="-1">KeepAlive 的本质 <a class="header-anchor" href="#keepalive-的本质" aria-label="Permalink to &quot;KeepAlive 的本质&quot;">​</a></h2><p><strong>本质是缓存管理，再加上特殊的挂载/卸载逻辑</strong></p><p>具体如下图：</p><p><a href="https://www.figma.com/file/yadsH3JL06697MH3uWxPXd/2023.06.LOG?type=whiteboard&amp;node-id=11-37&amp;t=h8yXeRi9xblhKVhW-4" target="_blank" rel="noreferrer">https://www.figma.com/file/yadsH3JL06697MH3uWxPXd/2023.06.LOG?type=whiteboard&amp;node-id=11-37&amp;t=h8yXeRi9xblhKVhW-4</a></p><h2 id="具体的代码架子" tabindex="-1">具体的代码架子 <a class="header-anchor" href="#具体的代码架子" aria-label="Permalink to &quot;具体的代码架子&quot;">​</a></h2><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306231017164.png" alt="image.png|600"></p><blockquote><p>当然，比如卸载时，需要看这个组件是否是<code>内部组件</code>，是的话会对特殊处理。</p></blockquote><p>下面是 <code>move</code> 的一些具体逻辑：</p><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306231021221.png" alt="image.png|600"></p><h2 id="include-和-exclude" tabindex="-1">include 和 exclude <a class="header-anchor" href="#include-和-exclude" aria-label="Permalink to &quot;include 和 exclude&quot;">​</a></h2><p>即能够显示的配置应该 被缓存的组件或不应该缓存的组件，<strong>本质是通过内部组件的名称进行正则匹配，如果匹配到则直接渲染“内部组件”，不对其进行后续的缓存操作</strong></p><h2 id="缓存管理" tabindex="-1">缓存管理 <a class="header-anchor" href="#缓存管理" aria-label="Permalink to &quot;缓存管理&quot;">​</a></h2><p>总结下就是：</p><ul><li>如果缓存存在，则继承组件实例，并将用于描述<code>组件的 vnode 对象</code>标记为 <code>keptAlive</code>，这样渲染器就不会重新创建新的组件实例；</li><li>如果缓存不存在，则设置缓存。</li><li>缓存策略：目前是<code>最近一次访问</code>，另外还需要关注是否设置<code>最大缓存容量</code>，如果设置了，还需要<code>修剪</code></li></ul><blockquote><p>注1：缓存的是组件的实例</p></blockquote><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to &quot;最后&quot;">​</a></h2><p>具体代码见仓库，这里主要是列举了关键点</p><hr><div class="liguwe-doc-footer"><p class="liguwe-doc-footer-update-time"><i>Last updated：2023.06.20</i></p><div id="liguwe-comment"></div><div class="liguwe-doc-footer-edit-link"><a href="https://www.yuque.com/liguwe/post/0074" target="_blank" class="liguwe-doc-footer-edit-link-a">View this page on Yuque（语雀）</a><a href="https://github.com/liguwe/liguwe.github.io/issues/new?title=0074.Vue3 中 keepAlive组件的实现原理@Vue&amp;labels=liguwe.site" target="_blank" class="liguwe-doc-footer-edit-link-a">Comment this page on GitHub Issues</a></div></div>',25),d=[l];function c(p,r,s,n,u,h){return a(),o("div",null,d)}const k=e(t,[["render",c]]);export{g as __pageData,k as default};
