import{_ as e,c as t,o,a as s}from"./app.42f21419.js";const g=JSON.parse('{"title":"React Hook篇（上）","description":"","frontmatter":{"title":"React Hook篇（上）","urlname":"holwfr","date":"2022-07-24 22:17:13 +0800","tags":[],"categories":[]},"headers":[{"level":2,"title":"1、为什么会有 Hooks，先看看两类组件的痛点","slug":"_1、为什么会有-hooks-先看看两类组件的痛点","link":"#_1、为什么会有-hooks-先看看两类组件的痛点","children":[{"level":3,"title":"类组件： → 聪明组件","slug":"类组件-→-聪明组件","link":"#类组件-→-聪明组件","children":[]},{"level":3,"title":"函数组件：UI = render(props)","slug":"函数组件-ui-render-props","link":"#函数组件-ui-render-props","children":[]},{"level":3,"title":"为了解决函数式组件的问题，可以通过 Hooks 给它 加 状态","slug":"为了解决函数式组件的问题-可以通过-hooks-给它-加-状态","link":"#为了解决函数式组件的问题-可以通过-hooks-给它-加-状态","children":[]}]},{"level":2,"title":"2、useState：const [state, setState] = useState(initialValue)","slug":"_2、usestate-const-state-setstate-usestate-initialvalue","link":"#_2、usestate-const-state-setstate-usestate-initialvalue","children":[]},{"level":2,"title":"3、副作用钩子：useEffect：useEffect(effectFn, deps)","slug":"_3、副作用钩子-useeffect-useeffect-effectfn-deps","link":"#_3、副作用钩子-useeffect-useeffect-effectfn-deps","children":[{"level":3,"title":"首先这里的副作用指什么？","slug":"首先这里的副作用指什么","link":"#首先这里的副作用指什么","children":[]},{"level":3,"title":"参数说明","slug":"参数说明","link":"#参数说明","children":[]},{"level":3,"title":"原理，下图多看几遍有助于理解","slug":"原理-下图多看几遍有助于理解","link":"#原理-下图多看几遍有助于理解","children":[]},{"level":3,"title":"传统生命周期与 useEffetch 的对应关系","slug":"传统生命周期与-useeffetch-的对应关系","link":"#传统生命周期与-useeffetch-的对应关系","children":[]},{"level":3,"title":"useEffect 与 useLayoutEffect 的关系","slug":"useeffect-与-uselayouteffect-的关系","link":"#useeffect-与-uselayouteffect-的关系","children":[]},{"level":3,"title":"useEffect 的依赖，每次更新时就会变化","slug":"useeffect-的依赖-每次更新时就会变化","link":"#useeffect-的依赖-每次更新时就会变化","children":[]},{"level":3,"title":"关于 Effect 无限循环(见代码仓库)","slug":"关于-effect-无限循环-见代码仓库","link":"#关于-effect-无限循环-见代码仓库","children":[]}]},{"level":2,"title":"4、useCallback 与 useMemo","slug":"_4、usecallback-与-usememo","link":"#_4、usecallback-与-usememo","children":[]},{"level":2,"title":"5、useRef","slug":"_5、useref","link":"#_5、useref","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"relativePath":"yuque/React Hook篇（上）.md"}'),l={name:"yuque/React Hook篇（上）.md"},a=s(`<h1 id="react-hook-篇-上" tabindex="-1">React Hook 篇（上） <a class="header-anchor" href="#react-hook-篇-上" aria-hidden="true">#</a></h1><h2 id="_1、为什么会有-hooks-先看看两类组件的痛点" tabindex="-1">1、为什么会有 Hooks，<strong>先看看两类组件的痛点</strong> <a class="header-anchor" href="#_1、为什么会有-hooks-先看看两类组件的痛点" aria-hidden="true">#</a></h2><h3 id="类组件-→-聪明组件" tabindex="-1">类组件： → 聪明组件 <a class="header-anchor" href="#类组件-→-聪明组件" aria-hidden="true">#</a></h3><ul><li><code>this</code>问题</li><li>生命周期管理成本高，且无法体现出 <code>**“内聚性”原则**</code></li><li>复用性不佳，组合混乱 ； mixin → 高阶组件 Hoc →</li></ul><h3 id="函数组件-ui-render-props" tabindex="-1">函数组件：<code>UI = render(props)</code> <a class="header-anchor" href="#函数组件-ui-render-props" aria-hidden="true">#</a></h3><ul><li>纯粹的从数据到视图的映射，对状态毫无感知 → <code>**“傻瓜组件”**</code></li><li>函数式组件，每次根据<code>props</code>变化重新渲染</li><li>每次渲染都是独立的 <ul><li>capture value，只记住渲染那时候的<code>**快照**</code></li></ul></li></ul><h3 id="为了解决函数式组件的问题-可以通过-hooks-给它-加-状态" tabindex="-1">为了解决函数式组件的问题，可以通过 Hooks 给它 加 <code>状态</code> <a class="header-anchor" href="#为了解决函数式组件的问题-可以通过-hooks-给它-加-状态" aria-hidden="true">#</a></h3><p>首先函数式组件本身无状态，Hooks 所做的事情：将一个函数组件的状态保存在函数外面 → 通过<code>Hooks</code>这一钩子将状态从函数体外部**“钩进来”**</p><h2 id="_2、usestate-const-state-setstate-usestate-initialvalue" tabindex="-1">2、useState：<code>const [state, setState] = useState(initialValue)</code> <a class="header-anchor" href="#_2、usestate-const-state-setstate-usestate-initialvalue" aria-hidden="true">#</a></h2><ul><li>打破函数组件的<code>UI = render(data)</code> 原则</li><li><code>setState</code>时可触发组件的 <code>**重新渲染**</code> 或 <code>**初始渲染**</code>(<code>initialValue</code>)</li><li><code>f(data = {props , state}) = view</code><ul><li>每次渲染都是<code>独立的</code> ，不互相影响！</li><li><code>render</code> 的执行取决于 <code>data</code> 变化，而 data 中的 <code>state</code> 数据是 保存在<code>链表中</code>** **的。</li></ul></li><li><code>Hooks</code> 所做的事情：<code>**将一个函数组件的状态保存在函数外面**</code>。准确来说，是这个函数组件对应的 Hooks 链表。当函数式组件需要用到该状态的时候，通过<code>Hooks</code>这一钩子将状态从函数体外部“钩进来”。</li><li>props 的改变和 setState 的调用，都会触发 <code>re-render</code>。 <ul><li>hooks 链表中记录着<code>[data, setData]</code></li></ul></li></ul><p><strong>仔细看下面两张动图：</strong><strong>初次渲染</strong></p><ul><li>每次调用<code>useState</code>初始化链表</li><li>链表存储结构为<code> [data,setState]</code> ，两两配对，且前者只能受后者影响；整体不受外界影响</li></ul><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//Fh2tZi_1j0kjq90KQO-65vss_zpy.gif" alt=""><strong>重渲染</strong></p><ul><li>链表结构已经存在，重渲染直接更改链表中的数据即可</li></ul><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//FnH0sZIFC64e4j5b-wyDvie-vSeQ.gif" alt=""></p><h2 id="_3、副作用钩子-useeffect-useeffect-effectfn-deps" tabindex="-1">3、副作用钩子：useEffect：useEffect(effectFn, deps) <a class="header-anchor" href="#_3、副作用钩子-useeffect-useeffect-effectfn-deps" aria-hidden="true">#</a></h2><h3 id="首先这里的副作用指什么" tabindex="-1">首先这里的副作用指什么？ <a class="header-anchor" href="#首先这里的副作用指什么" aria-hidden="true">#</a></h3><p><code>**函数内部与外部发生的任何交互都算副作用**</code>，比如<code>打印个日志</code>、开启一个定时器，发一个请求，读取全局变量等等等等。</p><h3 id="参数说明" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明" aria-hidden="true">#</a></h3><ul><li><code>**第一个**参数</code>回调函数中，做一些<code> 请求数据</code>，<code>事件监听（别忘了返回清除操作）</code>操作</li><li><code>**第二个**参数</code> 作为<code>dep</code>依赖项，当依赖项发生变化，<code>重新执行</code>第一个函数 <ul><li>如果不传第二个参数，任何<code>state</code>和<code>props</code>的变化都会导致执行，所以一定要传，否则就相当于<code>componentDidUpdate</code>和<code>componentwillreceiveprops</code></li><li>如果传参<code>[]</code> 至相等于<code>componentDidMount</code></li></ul></li><li>将初次渲染（<code>componentDidMount</code>）、重渲染（<code>componentDidUpdate</code>）和销毁（<code>componentDidUnmount</code>）三个阶段的逻辑用一个统一的 API 去解决</li><li>useEffect 约定 Effect 函数<code>**要么**</code>没有返回值，<code>**要么**</code>返回一个清理函数 Cleanup 函数，如下面<code>async</code> 函数会隐式地返回一个 Promise, 所以这里是有问题的</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 这里 async 函数会隐式地返回一个 Promise, 所以这里是有问题的</span></span>
<span class="line"><span style="color:#82AAFF;">useEffect</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">response</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fetch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">...</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> [])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><h3 id="原理-下图多看几遍有助于理解" tabindex="-1">原理，下图多看几遍有助于理解 <a class="header-anchor" href="#原理-下图多看几遍有助于理解" aria-hidden="true">#</a></h3><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//FnEch1CFpdL8gW177_wkkGXXDz-6.gif" alt=""></p><ul><li><code>**useEffect**</code> 的执行机制，是在初次渲染时，执行到 <code>useEffect</code> 就将内部的 <code>effectFn</code> 放到两个地方： <ul><li>一个是<code>** hooks 链表**</code>中</li><li>另外一个则是<code>**EffectList 队列**</code>中</li><li><strong>在渲染完成后</strong>，<code>**会依次执行 EffectList 里面的 effectFn 集合**</code></li></ul></li><li><strong>说白了，要不要</strong><code>** re-render**</code><strong>，完全取决于</strong><code>**链表**</code><strong>里面的东西有没有变化</strong></li><li>再强调一遍，渲染完成后，会一次执行<code>** ****EffectList**** 里面的 ****effectFn**** 集合**</code>** ** → 为了提高性能，每个 Effect 必然在渲染之后执行，因此不会阻塞渲染</li></ul><h3 id="传统生命周期与-useeffetch-的对应关系" tabindex="-1">传统生命周期与 useEffetch 的对应关系 <a class="header-anchor" href="#传统生命周期与-useeffetch-的对应关系" aria-hidden="true">#</a></h3><ul><li>将初次渲染（componentDidMount）、重渲染（componentDidUpdate）和销毁（componentDidUnmount）三个阶段的逻辑用一个统一的 API 去解决 <ul><li>相当于三个生命周期合并为一个 api</li><li>componentDidMount，则是传入一个空数组作为依赖来模拟</li><li>而 componentWillUnmount，则是在 effectFn 中返回一个清除函数</li><li>componentDidUpdate ， <code>useEffect(fn)</code> 什么也不传就可以模拟</li></ul></li><li>把相关的逻辑都放到一个 Effect 里面（例如 setInterval 和 clearInterval），更<code>**突出逻辑的内聚性**</code></li><li>指定 <code>deps</code> 为空数组<code>[]</code>，这样可以确保 Effect <code>**只会在组件初次渲染后执行**</code></li></ul><h3 id="useeffect-与-uselayouteffect-的关系" tabindex="-1">useEffect 与 <a href="https://link.segmentfault.com/?enc=mCc6AH5EgOu1D7ZiXG%2BlKA%3D%3D.Z3bpeWYmciLj5PBuitz6r60Kg2pUBQuNMlrttiBwepLbNsJGoQjS5mXrDwAxDgtNoKUc22MiebsRB3%2F5sF3e%2Bw%3D%3D" target="_blank" rel="noreferrer">useLayoutEffect</a> 的关系 <a class="header-anchor" href="#useeffect-与-uselayouteffect-的关系" aria-hidden="true">#</a></h3><ul><li>每个 Effect 必然在渲染之后执行，因此不会阻塞渲染，提高了性能</li><li>在运行每个 <code>Effect</code> 之前，运行前一次渲染的<code> Effect Cleanup</code> 函数（如果有的话）</li><li>当组件销毁时，运行最后一次 Effect 的 Cleanup 函数</li></ul><p><strong>提示</strong> 将 Effect 推迟到渲染完成之后执行是出于性能的考虑，如果你想在渲染之前执行某些逻辑（不惜牺牲渲染性能），那么可使用 <a href="https://link.segmentfault.com/?enc=mCc6AH5EgOu1D7ZiXG%2BlKA%3D%3D.Z3bpeWYmciLj5PBuitz6r60Kg2pUBQuNMlrttiBwepLbNsJGoQjS5mXrDwAxDgtNoKUc22MiebsRB3%2F5sF3e%2Bw%3D%3D" target="_blank" rel="noreferrer">useLayoutEffect</a> 钩子，使用方法与 useEffect 完全一致，只是执行的时机不同。</p><h3 id="useeffect-的依赖-每次更新时就会变化" tabindex="-1">useEffect 的依赖，每次更新时就会变化 <a class="header-anchor" href="#useeffect-的依赖-每次更新时就会变化" aria-hidden="true">#</a></h3><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//FjhDh76Ul_TTqv6GWz0UOZITzWdF.png" alt=""></p><h3 id="关于-effect-无限循环-见代码仓库" tabindex="-1"><a href="https://github.com/liguwe/fuckReact/blob/master/src/pages/6.tsx" target="_blank" rel="noreferrer">关于 Effect 无限循环</a>(见代码仓库) <a class="header-anchor" href="#关于-effect-无限循环-见代码仓库" aria-hidden="true">#</a></h3><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//Fr23SOPJXPRC8Qs2B196k5cUu1v4.png" alt=""></p><p><a href="https://github.com/liguwe/fuckReact/blob/master/src/pages/6.tsx" target="_blank" rel="noreferrer"></a></p><h2 id="_4、usecallback-与-usememo" tabindex="-1">4、useCallback 与 useMemo <a class="header-anchor" href="#_4、usecallback-与-usememo" aria-hidden="true">#</a></h2><ul><li>在大多数情况下，我们都是传入空数组 [] 作为 deps 参数，这样 <code>useCallback</code> 返回的就 **始终是同一个函数，永远不会更新 **</li><li>实际上，<code>useMemo</code> 的功能是 <code>useCallback</code> 的 <strong>超集</strong>。与 <code>useCallback</code> 只能缓存函数相比，<code>useMemo</code> 可以缓存任何类型的值（当然也包括函数）。<code>useMemo</code> 的使用方法如下：<code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code></li><li>他俩完全等价<code>useCallback(fn, deps); &lt;=&gt; useMemo(() =&gt; fn, deps);</code></li></ul><h2 id="_5、useref" tabindex="-1">5、useRef <a class="header-anchor" href="#_5、useref" aria-hidden="true">#</a></h2><ul><li>用来访问 DOM；</li><li>用来保存变量到当前函数式组件外部；独立于<code>capture value</code>之外存储，不用担心获得过时变量的问题；</li><li>**因为 **函数式组件的 capture value 特性 ，具体 state <strong>在这一帧被常量化了</strong></li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><blockquote><p><strong>多看下面参考链接的动图，对理解 hooks 很有帮助</strong></p></blockquote><ul><li><a href="https://segmentfault.com/a/1190000022550613" target="_blank" rel="noreferrer">用动画和实战打开 React Hooks（一）：useState 和 useEffect</a></li><li><a href="https://juejin.cn/post/6844904132164190221" target="_blank" rel="noreferrer">用动画和实战打开 React Hooks（二）：自定义 Hook 和 useCallback - 掘金</a></li><li><a href="https://www.cnblogs.com/zhangnan35/p/14596045.html" target="_blank" rel="noreferrer">[React Hooks 长文总结系列一]初出茅庐，状态与副作用 - 陌上兮月 - 博客园</a></li></ul>`,41),c=[a];function n(i,d,r,u,f,p){return o(),t("div",null,c)}const m=e(l,[["render",n]]);export{g as __pageData,m as default};
