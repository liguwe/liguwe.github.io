import{_ as s,o as a,c as o,V as n}from"./chunks/framework.5e406744.js";const h=JSON.parse('{"title":"Vue的异步组件与函数式组件的实现原理","description":"","frontmatter":{},"headers":[],"relativePath":"post/0070.md","filePath":"post/0070.md"}'),e={name:"post/0070.md"},l=n(`<hr><p>#vue</p><h1 id="vue的异步组件与函数式组件的实现原理" tabindex="-1">Vue的异步组件与函数式组件的实现原理 <a class="header-anchor" href="#vue的异步组件与函数式组件的实现原理" aria-label="Permalink to &quot;Vue的异步组件与函数式组件的实现原理&quot;">​</a></h1><h2 id="异步组件的概念" tabindex="-1">异步组件的概念 <a class="header-anchor" href="#异步组件的概念" aria-label="Permalink to &quot;异步组件的概念&quot;">​</a></h2><p>即，以异步的方式加载并渲染一个组件。 这在<code>页面性能</code> 、 <code>代码分割</code>、<code>服务端下发组件</code>等场景中尤为重要</p><h2 id="异步组件的简易实现" tabindex="-1">异步组件的简易实现 <a class="header-anchor" href="#异步组件的简易实现" aria-label="Permalink to &quot;异步组件的简易实现&quot;">​</a></h2><p>同步渲染，如下面的代码就是同步渲染的</p><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306130836268.png" alt="image.png|314"></p><p>最简单的异步组件加载渲染实现：使用 <code>import()</code></p><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306130837848.png" alt="image.png|353"></p><h3 id="只异步渲染页面的某一部分" tabindex="-1">只异步渲染页面的某一部分 <a class="header-anchor" href="#只异步渲染页面的某一部分" aria-label="Permalink to &quot;只异步渲染页面的某一部分&quot;">​</a></h3><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306130845487.png" alt="image.png|600"></p><blockquote><p>关于 <code>is</code>，是<code>vue</code>内置的特殊 Attributes （其他的如 <code>key</code> 和 <code>ref</code>）, 用于绑定动态组件。 更多参考 <a href="https://cn.vuejs.org/api/built-in-special-attributes.html#is" target="_blank" rel="noreferrer">https://cn.vuejs.org/api/built-in-special-attributes.html#is</a></p></blockquote><h3 id="待完善的点" tabindex="-1">待完善的点 <a class="header-anchor" href="#待完善的点" aria-label="Permalink to &quot;待完善的点&quot;">​</a></h3><ul><li>如果组件加载失败或加载超时，是否要渲染 ==Error 组件==？</li><li>组件在加载时，是否要展示==占位==的内容？例如渲染一个 Loading 组 件。</li><li>组件加载的速度可能很快，也可能很慢，是否要设置一个延迟展 示 Loading 组件的时间？==如果组件在 200ms 内没有加载成功才展示 Loading 组件==，这样可以避免由组件加载过快所导致的<code>闪烁</code>。</li><li>组件加载失败后，是否需要==重试==？</li></ul><blockquote><p>[!abstract] 从根本上来说，异步组件的实现可以完全在<strong>用户层面</strong>实现，而无须框架支持。但一个完善的异步组件仍需要考虑诸多问题，如下</p></blockquote><h2 id="完整的异步组件的实现原理" tabindex="-1">完整的异步组件的实现原理 <a class="header-anchor" href="#完整的异步组件的实现原理" aria-label="Permalink to &quot;完整的异步组件的实现原理&quot;">​</a></h2><h3 id="_1、封装-defineasynccomponent-函数" tabindex="-1">1、封装 defineAsyncComponent 函数 <a class="header-anchor" href="#_1、封装-defineasynccomponent-函数" aria-label="Permalink to &quot;1、封装 defineAsyncComponent 函数&quot;">​</a></h3><p>异步组件<strong>本质上</strong>是通过封装手段来实现友好的用户接口，从而降低<strong>用户层面</strong>的使用复杂度</p><p>具体看 <code>fj</code></p><p><a href="https://www.figma.com/file/yadsH3JL06697MH3uWxPXd/2023.06.LOG?type=whiteboard&amp;node-id=3-157&amp;t=ldGx9XSTfYfsodhA-4" target="_blank" rel="noreferrer">https://www.figma.com/file/yadsH3JL06697MH3uWxPXd/2023.06.LOG?type=whiteboard&amp;node-id=3-157&amp;t=ldGx9XSTfYfsodhA-4</a></p><h3 id="_2、超时与兜底的-error-组件" tabindex="-1">2、超时与兜底的 Error 组件 <a class="header-anchor" href="#_2、超时与兜底的-error-组件" aria-label="Permalink to &quot;2、超时与兜底的 Error 组件&quot;">​</a></h3><p>见 fj , 如上</p><h3 id="_3、延迟-与-loading" tabindex="-1">3、延迟 与 Loading <a class="header-anchor" href="#_3、延迟-与-loading" aria-label="Permalink to &quot;3、延迟 与 Loading&quot;">​</a></h3><p>见 fj , 如上</p><h4 id="延伸" tabindex="-1">延伸 <a class="header-anchor" href="#延伸" aria-label="Permalink to &quot;延伸&quot;">​</a></h4><blockquote><p>[!question] 如果加载需要 <code>201ms</code> , <code>delay = 200</code> , 那么 loading 组件就展示 <code>1ms</code> ？</p></blockquote><p>上面提的问题，还是会导致<code>闪烁</code> ，所以应该再加一个参数，标识至少展示 <code>loading</code> 多久 ，所以参数应该如下：</p><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306150942123.png" alt="image.png|600"></p><blockquote><p>具体代码参考： <a href="https://github.com/yued-fe/fetch-with-loading/blob/main/fetch-with-loading.js" target="_blank" rel="noreferrer">https://github.com/yued-fe/fetch-with-loading/blob/main/fetch-with-loading.js</a></p></blockquote><h3 id="_4、重试机制" tabindex="-1">4、重试机制 <a class="header-anchor" href="#_4、重试机制" aria-label="Permalink to &quot;4、重试机制&quot;">​</a></h3><p>见 <code>fj</code> , 如上</p><h4 id="延伸-1" tabindex="-1">延伸 <a class="header-anchor" href="#延伸-1" aria-label="Permalink to &quot;延伸&quot;">​</a></h4><p>如何重现发起请求，并控制次数</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">retry</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">promiseFn</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">times</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">async</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">times</span><span style="color:#89DDFF;">--</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ret</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">promiseFn</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">ret</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">                </span><span style="color:#676E95;font-style:italic;">// 832: 如果成功了，就直接break了</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#89DDFF;font-style:italic;">break</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">error</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">times</span><span style="color:#F07178;">) </span><span style="color:#82AAFF;">reject</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">error</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><blockquote><p>[!tip] <code>while</code> 里直接使用 <code>break</code> 跳出循环，平时自己很少使用</p></blockquote><h2 id="函数式组件-与-有状态的组件" tabindex="-1">函数式组件 与 有状态的组件 <a class="header-anchor" href="#函数式组件-与-有状态的组件" aria-label="Permalink to &quot;函数式组件 与 有状态的组件&quot;">​</a></h2><p>一个函数式组件<strong>本质上</strong>就是一个普通函数，该函数的<strong>返回值</strong>是虚拟 DOM ， 函数式组件<strong>没有自身状态</strong> ，需要通过 <code>props</code> 的方式传入。下面是一个 函数式组件的示例：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MyFuncComp</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">props</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">h1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> children</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">title</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">MyFuncComp</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">props </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">title</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">default title</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>函数式组件<strong>无需初始化data以及生命周期钩子</strong>。从这一点可以看出，函数式组件的初始化性能消耗小于有状态组件，但其实在 Vue.js 3 中，即使是<strong>有状态组件</strong>，其初始化性能消耗也非常小，</p><p>下面是一个具体的代码实现：</p><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306150959448.png" alt="image.png|600"></p><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306151002929.png" alt="image.png|470"></p><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202306151003232.png" alt="image.png|600"></p><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to &quot;最后&quot;">​</a></h2><p>流程图： <a href="https://www.figma.com/file/yadsH3JL06697MH3uWxPXd/2023.06.LOG?type=whiteboard&amp;node-id=3-157&amp;t=mQRERHjWVhTuLA2a-4" target="_blank" rel="noreferrer">https://www.figma.com/file/yadsH3JL06697MH3uWxPXd/2023.06.LOG?type=whiteboard&amp;node-id=3-157&amp;t=mQRERHjWVhTuLA2a-4</a></p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p>《vue.js 设计与实现》</p><hr><div class="liguwe-doc-footer"><p class="liguwe-doc-footer-update-time"><i>Last updated：2023.06.20</i></p><div id="liguwe-comment"></div><div class="liguwe-doc-footer-edit-link"><a href="https://www.yuque.com/liguwe/post/0070" target="_blank" class="liguwe-doc-footer-edit-link-a">View this page on Yuque（语雀）</a><a href="https://github.com/liguwe/liguwe.github.io/issues/new?title=0070.Vue的异步组件与函数式组件的实现原理@Vue&amp;labels=liguwe.site" target="_blank" class="liguwe-doc-footer-edit-link-a">Comment this page on GitHub Issues</a></div></div>`,50),p=[l];function t(r,c,i,y,d,F){return a(),o("div",null,p)}const u=s(e,[["render",t]]);export{h as __pageData,u as default};
