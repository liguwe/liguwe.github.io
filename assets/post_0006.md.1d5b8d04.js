import{_ as e,o as a,c as o,V as t}from"./chunks/framework.5e406744.js";const m=JSON.parse('{"title":"前端框架设计里的 权衡 与 选择","description":"","frontmatter":{},"headers":[],"relativePath":"post/0006.md","filePath":"post/0006.md"}'),s={name:"post/0006.md"},l=t('<p>#fe #vue #前端框架</p><h1 id="前端框架设计里的-权衡-与-选择" tabindex="-1">前端框架设计里的 权衡 与 选择 <a class="header-anchor" href="#前端框架设计里的-权衡-与-选择" aria-label="Permalink to &quot;前端框架设计里的 权衡 与 选择&quot;">​</a></h1><h2 id="_1、命令式框架与声明式框架" tabindex="-1">1、命令式框架与声明式框架 <a class="header-anchor" href="#_1、命令式框架与声明式框架" aria-label="Permalink to &quot;1、命令式框架与声明式框架&quot;">​</a></h2><ul><li><code>Jquery</code> 就是典型的 <strong>命令式框架</strong>，关注<code>过程</code></li><li>Vue 暴露给用户使用的是 <code>声明式</code> ，但底层内部实现肯定也是 <code>命令式</code> ，如下示例：面向用户的是声明式的</li></ul><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello()</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>但问题是，<strong>声明式的代码性能 不会高于 命令式代码的性能 ，所以这是一个选择 或者权衡</strong></p><h2 id="_2、性能-与-维护性-的平衡" tabindex="-1">2、性能 与 维护性 的平衡 <a class="header-anchor" href="#_2、性能-与-维护性-的平衡" aria-label="Permalink to &quot;2、性能 与 维护性 的平衡&quot;">​</a></h2><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//FkPqA2uVDAvzBIJAIjpDRdxhQsyp.png" alt=""></p><h2 id="_3、运行时-与-编译时" tabindex="-1">3、运行时 与 编译时 <a class="header-anchor" href="#_3、运行时-与-编译时" aria-label="Permalink to &quot;3、运行时 与 编译时&quot;">​</a></h2><h3 id="纯运行时-即直接render即可" tabindex="-1">纯运行时，即直接<code>Render</code>即可 <a class="header-anchor" href="#纯运行时-即直接render即可" aria-label="Permalink to &quot;纯运行时，即直接`Render`即可&quot;">​</a></h3><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//Fg50nk8zQ1iWJbRkEKmVDMyNO4bZ.png" alt=""></p><h3 id="运行时-编译时" tabindex="-1">运行时 + 编译时 <a class="header-anchor" href="#运行时-编译时" aria-label="Permalink to &quot;运行时 + 编译时&quot;">​</a></h3><p>如下图，常用的 Vue/Angular/React 都属于这类框架</p><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//Fq1iu91nLCuPM-w-HHaPfXLX9Bxh.png" alt=""></p><h3 id="纯编译时框架-代表svelte" tabindex="-1">纯编译时框架，代表<code>Svelte</code> <a class="header-anchor" href="#纯编译时框架-代表svelte" aria-label="Permalink to &quot;纯编译时框架，代表`Svelte`&quot;">​</a></h3><p><img src="https://blog-1310531898.cos.ap-beijing.myqcloud.com//FhVc9j0TN1GNOR6dW_jxUMDygi_n.png" alt=""></p><h2 id="_4、原生-js-操作-dom、innerhtml-与-虚拟-dom-快慢对比" tabindex="-1">4、原生 JS 操作 DOM、InnerHTML 与 虚拟 DOM 快慢对比 <a class="header-anchor" href="#_4、原生-js-操作-dom、innerhtml-与-虚拟-dom-快慢对比" aria-label="Permalink to &quot;4、原生 JS 操作 DOM、InnerHTML 与 虚拟 DOM 快慢对比&quot;">​</a></h2><p>可从以下三个方面来度量</p><ul><li>理解成本上，<strong>原生 JS 操作 DOM &gt; InnerHTML &gt; 虚拟 DOM</strong></li><li>维护性上，<strong>原生 JS 操作 DOM 、 InnerHTML &lt; 虚拟 DOM</strong></li><li>性能上，取决于<code>页面大小</code>，<code>页面变更大小，</code>是<code>新建页面</code> 还是<code> 更新页</code>面 甚至是<code>更新策略</code>等，都有关系，不同场景下有不同结论。</li></ul><h2 id="_5、最后" tabindex="-1">5、最后 <a class="header-anchor" href="#_5、最后" aria-label="Permalink to &quot;5、最后&quot;">​</a></h2><p>无论是<code>命令式</code>还<code>是声明式</code>，或者框架需要设计成<code>运行时</code>、<code>编译时</code>或<code>运行时+编译时</code>，都需要结合 <code>性能</code>、<code>理解成本</code>、<code>维护性</code>上做权衡选择。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>《Vue.js 设计与实现》</li></ul><hr><div class="liguwe-doc-footer"><p class="liguwe-doc-footer-update-time"><i>Last updated：2023.03.17</i></p><div class="liguwe-doc-footer-edit-link"><a href="https://www.yuque.com/liguwe/post/0006" target="_blank" class="liguwe-doc-footer-edit-link-a">View this page on Yuque（语雀）</a><a href="https://github.com/liguwe/liguwe.github.io/issues/new?title=0006.前端框架设计里的”权衡“与选择@前端框架&amp;labels=liguwe.site" target="_blank" class="liguwe-doc-footer-edit-link-a">Comment this page on GitHub Issues</a></div></div>',25),n=[l];function c(i,r,d,p,h,u){return a(),o("div",null,n)}const _=e(s,[["render",c]]);export{m as __pageData,_ as default};
