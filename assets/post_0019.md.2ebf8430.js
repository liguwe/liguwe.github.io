import{_ as e,o,c,V as d}from"./chunks/framework.9ad71fd6.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"post/0019.md"}'),a={name:"post/0019.md"},t=d('<p>#算法/二叉树</p><h2 id="二叉树的重要性" tabindex="-1">二叉树的重要性 <a class="header-anchor" href="#二叉树的重要性" aria-label="Permalink to &quot;二叉树的重要性&quot;">​</a></h2><p><code>二叉树模型</code>几乎是所有高级算法的基础，换句话来说，<code>递归</code>有多重要，那么二叉树就有多重要</p><blockquote><p>[!info] 自己想想 <code>递归</code> 有多重要</p></blockquote><h2 id="真正理解二叉树的前后中遍历" tabindex="-1">真正理解二叉树的<code>前后中遍历</code> <a class="header-anchor" href="#真正理解二叉树的前后中遍历" aria-label="Permalink to &quot;真正理解二叉树的`前后中遍历`&quot;">​</a></h2><h3 id="教科书中的二叉树遍历" tabindex="-1">教科书中的二叉树遍历 <a class="header-anchor" href="#教科书中的二叉树遍历" aria-label="Permalink to &quot;教科书中的二叉树遍历&quot;">​</a></h3><ul><li>前序遍历（<code>根 =&gt; 左 =&gt; 右</code>） <ul><li>对于树中的<code>任意节点</code>来说，先访问这个<code>节点本身</code>，然后再访问它的<code>左子树</code>，最后访问它的<code>右子树</code></li><li><strong>场景：</strong> 输出某个文件夹下所有文件名称(可以有子文件夹)</li></ul></li><li>中序遍历（<code>左 =&gt; 根 =&gt; 右</code>） <ul><li>对于树中的<code>任意节点来</code>说，先访问它的<code>左子树</code>，然后再访问<code>它的本身</code>，最后访问它的<code>右子树</code></li><li><strong>应用：</strong> 比如对 二叉搜索树进行排序</li></ul></li><li>后序遍历（<code>左 =&gt; 右 =&gt; 根</code>） <ul><li>对于树中的<code>任意节点</code>来说，先访问它的<code>左子树</code>，然后再访问它的<code>右子树</code>，最后访问<code>它本身</code></li><li><strong>应用：</strong> 需要根据 <code>左右子树的信息</code> 去执行操作，比如删除节点，又比如<code>统计某个文件夹的大小</code> ，你就得知道它下面所有文件或者文件夹的大小。</li></ul></li></ul><p>比如<code>前后遍历</code>的代码如下：</p><p><img src="https://od-1310531898.cos.ap-beijing.myqcloud.com/202304221034781.png" alt="image.png"></p><p>那么，你真正理解了前后中遍历了吗？比如，<code>快速排序</code>就是个<code>二叉树的前序遍历</code>，<code>归并排序</code>就是个<code>二叉树的后序遍历</code> ，你如何理解？</p><h3 id="快速排序就是-二叉树的前序遍历" tabindex="-1"><code>快速排序</code>就是 二叉树的<code>前序遍历</code> <a class="header-anchor" href="#快速排序就是-二叉树的前序遍历" aria-label="Permalink to &quot;`快速排序`就是 二叉树的`前序遍历`&quot;">​</a></h3><h3 id="归并排序-就是-二叉树的后序遍历" tabindex="-1"><code>归并排序</code> 就是 二叉树的<code>后序遍历</code> <a class="header-anchor" href="#归并排序-就是-二叉树的后序遍历" aria-label="Permalink to &quot;`归并排序` 就是 二叉树的`后序遍历`&quot;">​</a></h3>',12),l=[t];function i(r,n,s,h,p,_){return o(),c("div",null,l)}const m=e(a,[["render",i]]);export{g as __pageData,m as default};
