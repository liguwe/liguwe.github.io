/**
 * @description 最大子数组和，前缀和思路
 * @param {number[]} nums
 * @return {number} 返回最大子数组和
 */
var maxSubArray = function (nums) {

    /*************************************************
     * ::::::::::::::::: 构造前缀和 ::::::::::::::::::
     ************************************************/
    let preSum = [0];
    /*************************************************
     * ::::① 注意 i 从 1 开始，因为前缀和数组的第一个元素是 0::::
     * ::::② i <= nums.length，因为前缀和数组的长度是 nums.length + 1::::
     ************************************************/
    for (let i = 1; i <= nums.length; i++) {
        preSum[i] = preSum[i - 1] + nums[i - 1];
    }

    /*************************************************
     * ::::当前的最大子数组和，初始化为最小值::::
     * ::::即 Number.MIN_VALUE 或者 初始化题设中的最小值即可::::
     ************************************************/
    let res = -10000 * 100000;

    /*************************************************
     * ::::当前位置之前的最小前缀和，初始化最大值 ::::
     ************************************************/
    let minPreSum = 10000 * 100000;

    // 最大子数组和 = 当前位置元素的前缀和 - 最小前缀和
    for (let i = 0; i < nums.length; i++) {
        // 更新最小前缀和
        minPreSum = Math.min(minPreSum, preSum[i]);

        //公式：最大子数组和 = 当前位置元素的前缀和 - 最小前缀和
        res = Math.max(res, preSum[i + 1] - minPreSum);
    }

    return res;

};
