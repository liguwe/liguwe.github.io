
#vue 


##  一、不做任何 diff 优化 的渲染

看个例子，由 `vnode1` 变成 `vnode2` ，如果按照 [[0032.vue3 的渲染器原理@Vue| 上文 vue渲染器]]   中的简易实现，即 `先卸载所有，再挂载所有`，那么：我们需要 `8 次 DOM 操作`

```javascript

const VNode1 = {
    type: 'div',
    children: [
        {type: 'p', children: '1'},
        {type: 'p', children: '2'},
        {type: 'p', children: '3'},
        {type: 'p', children: '4'}
    ]
}

const VNode2 = {
    type: 'div',
    children: [
        {type: 'p', children: '4'},
        {type: 'p', children: '2'},
        {type: 'p', children: '1'},
        {type: 'p', children: '3'}
    ]
}
```

如果，我们做 diff  算法，我们发现，上面的 vnode 只是 `文本内容`发生了变化，所以只需要更新文本节点即可，最终只需要 `4 次 DOM 操作`。

所以，对于 `这新旧两组节点`，我们以下优化策略：
- 比较新旧两组节点的个数，新组节点多，则说明有新的节点需要挂载，否则有旧的节点需要卸载。
- 另外，我们需要 `遍历长度较段的节点`，进行 patch，保证尽可能多的 patch，避免更多的 DOM 操作。

## 二、简单 Diff 算法：考虑 可复用 DOM ，减少 DOM 操作


还是看个例子，按照上面的优化策略，还是得 `8 次 DOM 操作` ，但是我们发现，其实每个节点的区别仅仅在于 `位置移动了`。所以我们需要考虑如何复用 DOM，而不是`销毁了重建`

```javascript
const vNode1 = {
    type: 'div',
    children: [
        {type: 'p', children: '4'},
        {type: 'div', children: '2'},
        {type: 'h1', children: '1'},
        {type: 'span', children: '3'}
    ]
}

const vNode2 = {
    type: 'div',
    children: [
        {type: 'div', children: '2'},
        {type: 'span', children: '3'},
        {type: 'p', children: '4'},
        {type: 'h1', children: '1'}
    ]
}

```

基于上，我们需要思考：

### 第一：如何找可复用的节点？

答案是唯一 `key` ,  最简单的方式，我们遍历（嵌套遍历）新旧节点，然后找到 `key 相同`的新旧节点，然后打补丁 `patch(oldNode , newNode)` ，换另外一种说明，即拿着一组节点，去旧节点组中查找，是否有可复用的节点，复用的依据是` key`  ，下面是代码描述：

```javascript
 // 遍历新的 children
  for (let i = 0; i < newChildren.length; i++) {
	const newVNode = newChildren[i]
	let j = 0
	// 遍历旧的 children
	for (j; j < oldChildren.length; j++) {
	  const oldVNode = oldChildren[j]
	  // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之
	  if (newVNode.key === oldVNode.key) {
		patch(oldVNode, newVNode, container)
		break // 这里需要 break
	  }
	}
  }
```

### 第二：如何判断节点是否需要移动？

这里直接给结论，初始化`最大索引值为 0`，拿着新的节点，尝试去旧的节点组去找具有相同` key` 值的，更新 `最大索引值`；如果后续后续查找过程中，在旧的的节点组中招到的索引 小于 这个 `最大索引值`，则需要移动。

代码描述如下图：

![image.png|705](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305271146769.png)

下面是具体代码：

```javascript
  const oldChildren = n1.children
  const newChildren = n2.children
  // 遍历新的 children
  for (let i = 0; i < newChildren.length; i++) {
	const newVNode = newChildren[i]
	let j = 0
	// 遍历旧的 children
	for (j; j < oldChildren.length; j++) {
	  const oldVNode = oldChildren[j]
	  // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之
	  if (newVNode.key === oldVNode.key) {
		patch(oldVNode, newVNode, container)
		if (j < lastIndex) {
		  // 需要移动
		} else {
		  // 更新 lastIndex
		  lastIndex = j
		}
		break // 这里需要 break
	  }
	}
  }
```


上面的 `patch 代码`，因为可以`复用DOM`，所以会在 `pathElement` 中把 `DOM 引用（ 即oldNode.el ）`直接给新的节点，达到复用的效果，如下代码：

```javascript
function patchElement(n1, n2) {
	const el = n2.el = n1.el
	// 。。。 其他代码
}
```


### 第三：如何移动可复用节点？

首先，移动节点，移动的是`真实的 DOM`，你想嘛，要复用DOM 节点嘛。所以，会调用 DOM  `insertBefore(el, anchor)`操作

如下图：

![image.png|775](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305271213777.png)

最终代码：

```javascript
      const oldChildren = n1.children
      const newChildren = n2.children
      let lastIndex = 0
      // 遍历新的 children
      for (let i = 0; i < newChildren.length; i++) {
        const newVNode = newChildren[i]
        let j = 0
        let find = false
        // 遍历旧的 children
        for (j; j < oldChildren.length; j++) {
          const oldVNode = oldChildren[j]
          // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之
          if (newVNode.key === oldVNode.key) {
            find = true
            patch(oldVNode, newVNode, container)
            if (j < lastIndex) {
              // 需要移动
              const prevVNode = newChildren[i - 1]
              if (prevVNode) {
                const anchor = prevVNode.el.nextSibling
                insert(newVNode.el, container, anchor)
              }
            } else {
              // 更新 lastIndex
              lastIndex = j
            }
            break // 这里需要 break
          }
        }
```

`insert` 依赖于原生 `insertBefore` 方法，如下：

```javascript
insert(el, parent, anchor = null) {
	parent.insertBefore(el, anchor)
},
```

### 第五、如何添加新节点

如下图：

![image.png|750](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305271220236.png)

直接看代码，注意解释部分：

![image.png|825](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305271226975.png)

具体代码部分：

```javascript
if (!find) {
	const prevVNode = newChildren[i - 1]
	let anchor = null
	if (prevVNode) {
		anchor = prevVNode.el.nextSibling // 下一个兄弟节点
	} else {
		anchor = container.firstChild // 是第一个元素
	}
	patch(null, newVNode, container, anchor)
}
```

### 第六、删除不存在的元素

![image.png|500](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305271235808.png)

这个时候，我们需要遍历 `旧的节点组`，代码如下：

```javascript

// 遍历旧的节点
for (let i = 0; i < oldChildren.length; i++) {
	const oldVNode = oldChildren[i]
	// 拿着旧 VNode 去新 children 中寻找相同的节点
	const has = newChildren.find(
		vnode => vnode.key === oldVNode.key
	)
	if (!has) {
		// 如果没有找到相同的节点，则移除
		unmount(oldVNode)
	}
}
```


## 三、双端 Diff 算法

### 1、先看看一个示例

如下图，如果使用前文所使用的的 简易 Diff 算法，那么需要移动 `两次 DOM 操作`

![image.png|475](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305281537713.png)

但其实，我只需要`移动一次DOM`即可，即 把 P3 移动 P1 后面 即可，如下图：

![image.png|650](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305281540264.png)

### 2、理想情况双端算法处理

具体双端算法流程图，参考 `fj`

https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=167-296&t=i3ztBjIOmSVuaLfT-4

部分代码如下：

```javascript
function patchKeyedChildren(n1, n2, container) {
	const oldChildren = n1.children
	const newChildren = n2.children
	let oldStartIdx = 0
	let oldEndIdx = oldChildren.length - 1
	let newStartIdx = 0
	let newEndIdx = newChildren.length - 1
	let oldStartVNode = oldChildren[oldStartIdx]
	let oldEndVNode = oldChildren[oldEndIdx]
	let newStartVNode = newChildren[newStartIdx]
	let newEndVNode = newChildren[newEndIdx]
	while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
		//  第1步：
		if (oldStartVNode.key === newStartVNode.key) {
			patch(oldStartVNode, newStartVNode, container)
			oldStartVNode = oldChildren[++oldStartIdx]
			newStartVNode = newChildren[++newStartIdx]
		//  第2步：	
		} else if (oldEndVNode.key === newEndVNode.key) {
			patch(oldEndVNode, newEndVNode, container)
			oldEndVNode = oldChildren[--oldEndIdx]
			newEndVNode = newChildren[--newEndIdx]
		//  第3步：	
		} else if (oldStartVNode.key === newEndVNode.key) {
			patch(oldStartVNode, newEndVNode, container)
			insert(oldStartVNode.el, container, newEndVNode.el.nextSibling)
			oldStartVNode = oldChildren[++oldStartIdx]
			newEndVNode = newChildren[--newEndIdx]
		//  第4步：
		} else if (oldEndVNode.key === newStartVNode.key) {
			// 步骤四：oldEndVNode 和 newStartVNode 比对
			patch(oldEndVNode, newStartVNode, container)
			insert(oldEndVNode.el, container, oldStartVNode.el)
			oldEndVNode = oldChildren[--oldEndIdx]
			newStartVNode = newChildren[++newStartIdx]
		}else{
			//********* 非理想情况下 *********
		}
	}
}
```

是的，双端，4 个指针，按照一定规则移动，但上面代码中 `else部分` 是干啥的？ 看下面图：

![image.png|700](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305281644663.png)

前 4 步骤都没法命中，所以才需要`在 else 里`处理。



### 3、非理想情况下双端算法

看流程图：

https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-371&t=i3ztBjIOmSVuaLfT-4

部分代码截图：

![image.png|650](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305281705144.png)

上面第 5 步，如果找不到可以复用的节点呢？ 说明需要`添加节点`了，见下面：

### 4、新增元素

![image.png|625](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305281713290.png)

https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-503&t=i3ztBjIOmSVuaLfT-4

### 5、移动元素

![image.png|725](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305281738976.png)

见流程图：

https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-542&t=i3ztBjIOmSVuaLfT-4

### 6、最后总结

相较于`简单 Diff 算法`，`双端Diff 算法`的优势在于，同样的更新场景，执行的 DOM 操作更少一点而已。


## 四、快速 Diff 算法 + 最长递增子序列

Vue3 是通过`双端对比`+`最长递增子序列算法`得出最小的更新消耗。下面我们先看看 `快速 Diff 算法`

### 1、相同的前置元素和后置元素

![image.png|475](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305300920890.png)



### 2、添加的节点的情况

https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-731&t=2Hh2yCqllM2zgzaD-4

### 3、删除节点的情况

https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-695&t=2Hh2yCqllM2zgzaD-4

### 4、更复杂的情况

https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-731&t=2Hh2yCqllM2zgzaD-4

### 最长递增子序列算法参考

[[0010.最长递增子序列+俄罗斯套娃信封问题@算法#最长递增子序列|最长递增子序列]] 

### 最后

`快速 Diff 算法`在实测中性能最优。它借鉴了`文本 Diff 中`的 `预处理思路`，

1. 先处理`新旧两组子节点`中相同的前置节点和相同的后置节点。 
2. 当前置节点和后置节点全部处理完毕后，如果无法简单地通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要`根据节点的索引关系，构造出一个最长递增子序列`。`最长递增子序列所指向的节点`即为`不需要移动的节点`。


---
<div class="liguwe-doc-footer">
            <p class="liguwe-doc-footer-update-time"><i>Last updated：2023.05.24</i></p>
            <div id="liguwe-comment"></div>
            <div class="liguwe-doc-footer-edit-link">
                <a href="https://www.yuque.com/liguwe/post/0033" target="_blank" class="liguwe-doc-footer-edit-link-a">View this page on Yuque（语雀）</a>
                <a href="https://github.com/liguwe/liguwe.github.io/issues/new?title=0033.Vue3 的 Diff 算法@Vue&labels=liguwe.site" target="_blank" class="liguwe-doc-footer-edit-link-a">Comment this page on GitHub Issues</a>
            </div>
        </div>