
# 0012.Vue 的响应式的系统设计原理
<Badge type="danger">前端框架/vue</Badge>

#前端框架/vue 


## 何为副作用函数？

如修改了全局变量等。

## 为何响应式数据？

如下代码，希望 `data.text` 值改变时，会自己执行 `effect函数` ， 那么`data 数据`就是`响应式的`。

```javascript
// 原始数据
const data = { text: 'hello world' }
function effect() {
  document.body.innerText = obj.text
}
effect()
```

## 响应式数据最简单的实现

借助 `Proxy` ， 每次`读取`时，将 effect 函数存储到`桶：bucket` 中，每次`set 时`，从`桶`中取出并执行，如下代码：

```javascript

// 存储副作用函数的桶
const bucket = new Set()

// 原始数据
const data = { text: 'hello world' }
// 对原始数据的代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 effect 添加到存储副作用函数的桶中
    bucket.add(effect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    bucket.forEach(fn => fn())
  }
})

function effect() {
  document.body.innerText = obj.text
}
effect()
```

但上面的方式缺点是`硬编码`了 `effect` 

## 解决 硬编码 `effect` 函数的问题

思路是，`effect(fn)` 传入一个函数，标识注册副作用函数 `fn` , 并使用全局变量 `activeEffect` 来存储 `当前激活的 effect 函数` 

```json
// 存储副作用函数的桶
const bucket = new Set()

// 原始数据
const data = { text: 'hello world' }
// 对原始数据的代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中
    bucket.add(activeEffect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    bucket.forEach(fn => fn())
  }
})


// 用一个全局变量存储当前激活的 effect 函数
let activeEffect
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

effect(() => {
  console.log('effect run')
  document.body.innerText = obj.text
})

setTimeout(() => {
  obj.text2 = 'hello vue3'
}, 1000)
```

但是，上面代码如果我们 设置不存在的属性时，如 `obj.noExist = 'hello '` , `传入的effect` 中的 `fn` 会**执行两次**

所以，`副作用函数`需要与`目标字段` 建立映射，所以我们需要重新设计数据结构


## 重新设计数据结构 - 解决设置不存在的属性时也执行问题

如下代码：

```javascript
// 用一个全局变量存储当前激活的 effect 函数
let activeEffect
function effect(fn) {
    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect
    activeEffect = fn
    // 执行副作用函数
    fn()
}

const obj = { text1: 'text1', text2: 'text2' };
const obj2 = { text1: 'text1', text2: 'text2' };

effect(function fn1() {
    console.log(obj.text1);
})

effect(function fn2() {
    console.log(obj.text2);
    console.log(obj.text1);
})

/*************************************************
 * :::: 以上代码的映射关系如下
 * obj
 *  text1: [fn1,fn2]
 *  text2: [fn2]
 ************************************************/

effect(function fn3() {
    console.log(obj.text1);
    console.log(obj.text2);
})
/*************************************************
 * :::: 以上代码的映射关系如下
 * obj
 *  text1: [fn3]
 *  text2: [fn3]
 ************************************************/

effect(function fn1() {
    console.log(obj.text1);
})

effect(function fn2() {
    console.log(obj2.text2);
	console.log(obj.text1);
})

/*************************************************
 * :::: 以上代码的映射关系如下
 * obj
 *   text1: [fn1,fn2] 
 * obj2
 *   text2: [fn2]
 ************************************************/
```

结构如下：

- `WeakMap` 
	- `key` 为 `obj` 或者  `obj1`  对象
	- `value` 为 `Map`
		- `key` 为 字段名，如 `text1` ,`text2` 
		- `value`为 `Set`  ，比如上面的 `fn1`  `fn2` 

如下图：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081112785.png)

### 为什么要使用 WeakMap？


```javascript
const weakMap = new WeakMap();
const map = new Map();

(function () {
    let w = {w: "w"};
    let m = {m: "m"};
    weakMap.set(w, 1);
    map.set(m, 2);
    console.log(weakMap);
    console.log(map);
    w = null;
    m = null;
})()

// 这 5s的时间，weakMap 会被回收，而 map 不会，因为 map 的 key 是强引用，不会被回收
// chrome performance 手动触发垃圾回收
setTimeout(() => {
    console.log(weakMap);
    console.log(map);
}, 5000);

```


手动触发垃圾回收机制：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081153881.png)

最终打印打印结果如下：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081151462.png)

所以，结论就是：使用 `WeakMap` 能够保证 `GC`，不会像 `Map` 那个强引用导致`内存溢出`


### 最终代码

**最终代码如下**：封装 `track(targe,key)` 和 `trigger(targe,key)`

```javascript
// 存储副作用函数的桶
const bucket = new WeakMap()
// 原始数据
const data = { text: 'hello world' }
// 对原始数据的代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中
    track(target, key)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    trigger(target, key)
  }
})

function track(target, key) {
  let depsMap = bucket.get(target)
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  let deps = depsMap.get(key)
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  deps.add(activeEffect)
}

function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  effects && effects.forEach(fn => fn())
}
// 用一个全局变量存储当前激活的 effect 函数
let activeEffect
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

effect(() => {
  console.log('effect run')
  document.body.innerText = obj.text
})

setTimeout(() => {
  trigger(data, 'text')
}, 1000)
```


> [!tip]
> 其实如何能够梳理清楚这个数据结构，那么就容易写出代码，所以也不用抠代码细节，真正需要自己使用即可！


## 分支切换问题

如下代码：

```javascript
effect(() => {
  console.log('effect run')
  document.body.innerText = obj.ok ? obj.text : 'not'
})
```

根据上面，我们知道关系如下：

- obj
	- ok
		- fn
	- text
		- fn

所以，当 `text` 值改变时，必然会导致 `fn` 重新执行 ，但其实当`ok` 为 `false` 时，无论 `text` 如何变化，我们不希望 `fn` 重新执行。如何解决呢？

解决方案是 **每次副作用函数执行之前，清除上一次建立的关系**。

重新设计结构，`effect.deps` 用来存储 `所有与该副作用函数相关的依赖集合` ，如下代码：

```javascript
// 用一个全局变量存储当前激活的 effect 函数
let activeEffect
function effect(fn) {
  const effectFn = () => {
    cleanup(effectFn)
    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect
    activeEffect = effectFn
    fn()
  }
  // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合
  effectFn.deps = []
  // 执行副作用函数
  effectFn()
}

// 每次都会清除
function cleanup(effectFn) {
  for (let i = 0; i < effectFn.deps.length; i++) {
    const deps = effectFn.deps[i]
    deps.delete(effectFn)
  }
  effectFn.deps.length = 0
}
```


下面看 `trigger` 函数：

```javascript
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key);
  // here ，这里出现无限循环
  effects && effects.forEach(effectFn => effectFn())
}
```

但是，上面的代码会出现无限循环，原因类似于下面的代码：

```javascript
const set = new Set([1])
set.forEach(item => {
  set.delete(1)
  set.add(1)
  console.log(999)
})
```

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081406196.png)

解决方案：**新的变量** `newSet`

```javascript
const set = new Set([1])
const newSet = new Set(set)
newSet.forEach(item => {
  set.delete(1)
  set.add(1)
  console.log(999)
})
```

所以最终 `trigger` 代码：创建`新的变量` `effectsToRun`

```javascript
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)

  const effectsToRun = new Set()
  effects && effects.forEach(effectFn => effectsToRun.add(effectFn))
  effectsToRun.forEach(effectFn => effectFn())
  // effects && effects.forEach(effectFn => effectFn())
}
```

## Effect 函数嵌套的场景

### 先说说为什么要支持嵌套

因为 `jsx` 天然需要支持嵌套，如下代码：

```javascript
const Foo = {
    render() {
        return h('div', 'foo')
    }
}

const Bar = {
    render() {
        return h(Foo, 'bar')
    }
}
```

### 现有 `effect` 函数不支持嵌套

如下代码：

```javascript
let temp1, temp2

effect(function effectFn1() {
  console.log('1')
  effect(function effectFn2() {
    console.log('2')
    temp2 = obj.bar
  })
  temp1 = obj.foo
})

// obj.foo之前的值为 true
setTimeout(() => {
    obj.foo = false
}, 5000);
```

我们修改 `obj.foo` , **预期是：**输出 `1 2 1` ,  因为 obj.foo 修改导致 `fn1` 的执行，打印 `1`，`fn2` 嵌套在 `fn1` 里，所以还会执行`fn2` 打印出 `2`，5s 后，值`obj.foo`改变了，导致 `fn1` 执行，打印出 `2`

但实际上是 `1 2 2` 

原因是：发生嵌套时，内层激活的 `activeEffect` 会覆盖`外层的副作用函数`，所以最终执行的都是`内层副作用函数`

### 解决思路：副作用函数栈 `efectStack`

如下代码：

```javascript
// 用一个全局变量存储当前激活的 effect 函数
let activeEffect
// effect 栈
const effectStack = []
function effect(fn) {
  const effectFn = () => {
    cleanup(effectFn)
    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect
    activeEffect = effectFn
    // 在调用副作用函数之前将当前副作用函数压栈
    effectStack.push(effectFn)
    fn()
    // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈
    // 并还原 activeEffect 为之前的值
    effectStack.pop()
    activeEffect = effectStack[effectStack.length - 1]
  }
  // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合
  effectFn.deps = []
  // 执行副作用函数
  effectFn()
}
```

## 新的问题：无限递归循环

如下代码，会引起 `栈溢出`

```javascript
effect(() => {
    obj.foo++;
})
```

因为  `obj.foo 同时读取和设置` ，从而导致无限递归循环。

因为读取和操作是在同一个副作用函数中，进行的。所以可以增加`守卫条件`： **trigger 触发的副作用函数和当前执行的副作用函数，是一个函数，则不执行。**

```javascript
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  const effectsToRun = new Set()
  effects && effects.forEach(effectFn => {
	// 守卫条件
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  effectsToRun.forEach(effectFn => effectFn())
}
```

## 响应式系统的调度

所谓`调度`，即 `trigger` 重新触发副作用函数时，能够决定执行的时机，次数等`自定义行为`。

### 例子 1

以下执行顺序是：`1 ，2 ，end...` 

```javascript
const data = {foo: 1};
const obj = new Proxy(data, {});

effect(() => {
    console.log(obj.foo);
})

obj.foo++;
console.log('end...');
// ::::顺序是：1 ，2 ，end... 
```

如果我们希望顺序变成了：`1 ，end... ，2`   呢？？？

**解法方法是**：给 `effect` 函数添加一个 `options` 参数

```javascript
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)

  const effectsToRun = new Set()
  effects && effects.forEach(effectFn => {
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  effectsToRun.forEach(effectFn => {
      // ::::新增代码::::
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      effectFn()
    }
  })
}
```

修改上面例子代码如下：

```javascript
const data = {foo: 1};
const obj = new Proxy(data, {});

effect(
    () => {
        console.log(obj.foo);
    },
    {
        scheduler: (fn) => {
            setTimeout(fn, 0);
        }
    }
);

obj.foo++;
console.log('end...');

// ::::顺序就可以变成 1 ，end... ，2
```

### 示例 2 

如下代码

```javascript
const data = {foo: 1};
const obj = new Proxy(data, {});

effect(
    () => {
        console.log(obj.foo);
    }
);

obj.foo++;
obj.foo++;
obj.foo++;
obj.foo++;

// ::::顺序： 1 2 3 4 5 
```

如果我只打印 `初始值` 和 `最终值`呢？其实就有点类似于 **React 中的 setState 多次或者 Vue 中的连续改变响应式数据。**

#### 微任务队列

所以，关键是 需要`实现一个微任务队列，并去重，并且如何保证一个微任务队列里，只执行一次`，如下代码：

```javascript
const jobQueue = new Set()
const p = Promise.resolve()
// 标识是否正在刷新微任务队列，
// 如果正在刷新，则不再执行 flushJob，所以一个事件循环中只会执行一次 flushJob
let isFlushing = false
// 利用 promise ，保证 flushJob 在一个事件循环中只执行一次
function flushJob() {
  if (isFlushing) return
  isFlushing = true;
  // 将一个函数添加到微任务队列中
  p.then(() => {
    jobQueue.forEach(job => job())
  }).finally(() => {
    isFlushing = false
  })
}

effect(() => {
  console.log(obj.foo)
}, {
  scheduler(fn) {
    // 使用 Set 来去重
    jobQueue.add(fn);
    // 刷新微任务队列
    flushJob()
  }
})
```

## 计算属性 `computed` 与 `lazy`


### 懒执行

以下代码是立即执行的，如何实现代码 `lazy 执行` 呢？如下代码：

```javascript
const data = {foo: 1};
const obj = new Proxy(data, {});
effect(
    () => {
        console.log(obj.foo); // ::::立即执行
    }
);
```

添加 `options.lazy = true`, 使得 `effect` 不会立即执行 ? 如下代码：

```javascript
effect(
    () => {
        console.log(obj.foo); // ::::不立即执行
    },
    // ::::options.lazy = true 时不立即执行
    {lazy: true}
);
```

改造 `effect函数` 代码如下：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091113904.png)

但是，上面的代码，仅仅能够`手动执行` ，如下代码：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091118724.png)

如果 `fn` 为 `getter函数`呢？ 如下：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091121697.png)

上面代码能否再抽象成 `computed` ?  这就引出了 `computed`

### `computed` 计算属性

- 计算属性的 `懒计算`，即 `只有读取时，才会计算`
- 另外，多次读取一个属性时，还需要做到 `缓存`，避免`多次计算`，通过脏变量 `dirty`来标识，类似于 Angular 的概念。
- 类似于 Vue ， 如果`计算属性发生变化会重新触发渲染` ， 但是如果一个计算属性依赖另外一个计算属性时，会发生 `effect 嵌套`，所以，每次读取计算属性时，需要`手动触发 trigger 追踪`

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091154769.png)

所以，上面的代码会建立响应联动关系如下：

- `computed(obj)`
	- `value`
		- `effectFn`


即，你就把  `对于computed嵌套，当做是两个副作用函数的嵌套来理解`，就对了！


> 最终代码见[[#参考]]  地址

> [!info]
> 真正还是需要看代码去，说真的，自己手写实现完整的功能，得实现多久啊！！，这就是业务代码和真正技术代码的区别吧！

> [!tip]
> 所以，**这里基本思路掌握即可，不用装牛角尖**，也不可能让你段时间内徒手写出来，需要的话就去自己看代码。

## `watch函数` 的实现原理

### 简单实现 

通过前面我们知道，副作用函数重新执行时，`可调度` ，所以 我们把调度里，加个`回调`，就能实现，如下代码：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091223151.png)

上面代码硬编码了 `source.foo` 的读取操作，更通用的解法：`递归读取对象的所有属性`

### 相对完善的实现

就想想如何使用 `watch` 函数的？ 所以，需要支持一下功能：

- watch 入参支持`三个`，
	- 想想是 哪三个？
	- `第一个`参数 支持 `getter 函数` 和 `对象`
	- `第二个`参数，回调函数里支持 `newVal` 和 `oldVal`
	- `第三个`自定义参数 `options`

下面是 `watch 函数`的代码
![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091242677.png)

> [!tip]
> 注意，上面代码**高亮的部分** ，另外 `flush` 的值 `pre` 和 `post` 代表**组件更新前和更新后**，后面会涉及到具体原理，这里不深究。

### 回调的第三个参数？ 

先看一个例子，如果 `watch` 一个 `obj 对象`，改变了就发请求，如下：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091258200.png)

所以，会存在`过期的副作用函数`，`第三个参数`就是解决这种`竞态问题`的 ，以下是代码实现：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091303363.png)

> 注意上面代码的 **高亮部分**

下面是 **使用实例**：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091304118.png)

所以，最终的效果如下：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091306983.png)

## 最后


> [!warning]
> 强调下，这一章很难啃的，但层层递进的思想比代码本身更重要，具体如何实现，代码最终如何编写实现，远远没有理解来龙去脉重要。**最终代码都有，多些思考与理解，装牛角尖意义不大**


## 参考

 - 《Vue.js设计与实现》
 - https://github.com/HcySunYang/code-for-vue-3-book


---
<div class="liguwe-doc-footer">
            <div class="liguwe-doc-footer-edit-link">
                <p class="liguwe-doc-footer-p">
                    <svg t="1687912573060" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1498">
                        <path d="M854.6 370.6c-9.9-39.4 9.9-102.2 73.4-124.4l-67.9-3.6s-25.7-90-143.6-98c-117.8-8.1-194.9-3-195-3 0.1 0 87.4 55.6 52.4 154.7-25.6 52.5-65.8 95.6-108.8 144.7-1.3 1.3-2.5 2.6-3.5 3.7C319.4 605 96 860 96 860c245.9 64.4 410.7-6.3 508.2-91.1 20.5-0.2 35.9-0.3 46.3-0.3 135.8 0 250.6-117.6 245.9-248.4-3.2-89.9-31.9-110.2-41.8-149.6z m-204.1 334c-10.6 0-26.2 0.1-46.8 0.3l-23.6 0.2-17.8 15.5c-47.1 41-104.4 71.5-171.4 87.6-52.5 12.6-110 16.2-172.7 9.6 18-20.5 36.5-41.6 55.4-63.1 92-104.6 173.8-197.5 236.9-268.5l1.4-1.4 1.3-1.5c4.1-4.6 20.6-23.3 24.7-28.1 9.7-11.1 17.3-19.9 24.5-28.6 30.7-36.7 52.2-67.8 69-102.2l1.6-3.3 1.2-3.4c13.7-38.8 15.4-76.9 6.2-112.8 22.5 0.7 46.5 1.9 71.7 3.6 33.3 2.3 55.5 12.9 71.1 29.2 5.8 6 10.2 12.5 13.4 18.7 1 2 1.7 3.6 2.3 5l5 17.7c-15.7 34.5-19.9 73.3-11.4 107.2 3 11.8 6.9 22.4 12.3 34.4 2.1 4.7 9.5 20.1 11 23.3 10.3 22.7 15.4 43 16.7 78.7 3.3 94.6-82.7 181.9-182 181.9z"
                              p-id="1499" ></path>
                    </svg>
                    <a href="https://www.yuque.com/liguwe/post/0012" target="_blank" class="liguwe-doc-footer-edit-link-a">
                        View this page on Yuque
                    </a>
                </p>
                <p class="liguwe-doc-footer-p">
                    <svg t="1687927073703" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1464"><path d="M512 96l480 832H32z" p-id="1465" ></path></svg>
                    <a href="https://liguwe.vercel.app/post/0012.html" target="_blank" class="liguwe-doc-footer-edit-link-a">
                        View this page on Vercel
                    </a>
                </p>
                <p class="liguwe-doc-footer-p">
                    <svg t="1687913054251" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5173"><path d="M853.333333 501.333333c-17.066667 0-32 14.933333-32 32v320c0 6.4-4.266667 10.666667-10.666666 10.666667H170.666667c-6.4 0-10.666667-4.266667-10.666667-10.666667V213.333333c0-6.4 4.266667-10.666667 10.666667-10.666666h320c17.066667 0 32-14.933333 32-32s-14.933333-32-32-32H170.666667c-40.533333 0-74.666667 34.133333-74.666667 74.666666v640c0 40.533333 34.133333 74.666667 74.666667 74.666667h640c40.533333 0 74.666667-34.133333 74.666666-74.666667V533.333333c0-17.066667-14.933333-32-32-32z"  p-id="5174"></path><path d="M405.333333 484.266667l-32 125.866666c-2.133333 10.666667 0 23.466667 8.533334 29.866667 6.4 6.4 14.933333 8.533333 23.466666 8.533333h8.533334l125.866666-32c6.4-2.133333 10.666667-4.266667 14.933334-8.533333l300.8-300.8c38.4-38.4 38.4-102.4 0-140.8-38.4-38.4-102.4-38.4-140.8 0L413.866667 469.333333c-4.266667 4.266667-6.4 8.533333-8.533334 14.933334z m59.733334 23.466666L761.6 213.333333c12.8-12.8 36.266667-12.8 49.066667 0 12.8 12.8 12.8 36.266667 0 49.066667L516.266667 558.933333l-66.133334 17.066667 14.933334-68.266667z"  p-id="5175"></path></svg>
                    <a href="https://github.com/liguwe/liguwe.github.io/blob/master/docs/0012.md" target="_blank" class="liguwe-doc-footer-edit-link-a">Edit this page on Github</a>
                </p>
                 <p class="liguwe-doc-footer-p">
                     <svg t="1687912510038" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                             p-id="2280">
                            <path d="M746.666667 106.666667a192 192 0 0 1 192 192v373.333333a192 192 0 0 1-192 192h-107.925334l-97.749333 90.496a42.666667 42.666667 0 0 1-57.984 0L385.28 864H277.333333a192 192 0 0 1-192-192V298.666667a192 192 0 0 1 192-192h469.333334z m0 64H277.333333a128 128 0 0 0-128 128v373.333333a128 128 0 0 0 128 128h107.925334a64 64 0 0 1 43.477333 17.045333L512 894.122667l83.264-77.077334a64 64 0 0 1 43.477333-17.045333H746.666667a128 128 0 0 0 128-128V298.666667a128 128 0 0 0-128-128zM512 426.666667a54.677333 54.677333 0 0 1 54.634667 54.698666A54.677333 54.677333 0 0 1 512 536.064a54.677333 54.677333 0 0 1-54.634667-54.698667A54.677333 54.677333 0 0 1 512 426.666667z m-196.693333 0a54.677333 54.677333 0 0 1 54.634666 54.698666 54.677333 54.677333 0 0 1-54.613333 54.698667 54.677333 54.677333 0 0 1-54.634667-54.698667A54.677333 54.677333 0 0 1 315.306667 426.666667z m393.386666 0a54.677333 54.677333 0 0 1 54.613334 54.698666 54.677333 54.677333 0 0 1-54.613334 54.698667 54.677333 54.677333 0 0 1-54.634666-54.698667A54.677333 54.677333 0 0 1 708.672 426.666667z"
                                   p-id="2281"></path>
                        </svg>
                     <a href="https://github.com/liguwe/liguwe.github.io/issues/new?title=0012.Vue%20%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86&labels=liguwe.site"
                       target="_blank" class="liguwe-doc-footer-edit-link-a">
                        Comment this page on GitHub Issues
                    </a>
                </p>
                 <p class="liguwe-doc-footer-p">
                     <svg t="1687912510038" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                             p-id="2280">
                            <path d="M746.666667 106.666667a192 192 0 0 1 192 192v373.333333a192 192 0 0 1-192 192h-107.925334l-97.749333 90.496a42.666667 42.666667 0 0 1-57.984 0L385.28 864H277.333333a192 192 0 0 1-192-192V298.666667a192 192 0 0 1 192-192h469.333334z m0 64H277.333333a128 128 0 0 0-128 128v373.333333a128 128 0 0 0 128 128h107.925334a64 64 0 0 1 43.477333 17.045333L512 894.122667l83.264-77.077334a64 64 0 0 1 43.477333-17.045333H746.666667a128 128 0 0 0 128-128V298.666667a128 128 0 0 0-128-128zM512 426.666667a54.677333 54.677333 0 0 1 54.634667 54.698666A54.677333 54.677333 0 0 1 512 536.064a54.677333 54.677333 0 0 1-54.634667-54.698667A54.677333 54.677333 0 0 1 512 426.666667z m-196.693333 0a54.677333 54.677333 0 0 1 54.634666 54.698666 54.677333 54.677333 0 0 1-54.613333 54.698667 54.677333 54.677333 0 0 1-54.634667-54.698667A54.677333 54.677333 0 0 1 315.306667 426.666667z m393.386666 0a54.677333 54.677333 0 0 1 54.613334 54.698666 54.677333 54.677333 0 0 1-54.613334 54.698667 54.677333 54.677333 0 0 1-54.634666-54.698667A54.677333 54.677333 0 0 1 708.672 426.666667z"
                                  p-id="2281"></path>
                        </svg>
                     <a href="https://github.com/liguwe/liguwe.github.io/discussions/new?category=general&labels=liguwe.site&title=0012.Vue%20%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"
                       target="_blank" class="liguwe-doc-footer-edit-link-a">
                        Discuss this page on GitHub Discussions
                    </a>
                </p>
            </div>
            <p class="liguwe-doc-footer-update-time"><i>Last updated：2023.03.25</i></p>
            <div id="liguwe-comment"></div>
        </div>