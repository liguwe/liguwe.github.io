
#vue 


前文讲了 [[0012.Vue 的响应式的系统设计原理@Vue]]  ，本文，主要讲解更复杂场景 ，比如

- 如何拦截 `for-in` ?
- 如何拦截 `Map WeakMap  Set  WeakSet` 等？ 

## 一、先看看 `Proxy` 与 `Reflect` 

### 基本操作

拦截对象的 `读 get 、取 set`   

```javascript
const obj = {foo: 1}

const p = new Proxy(obj, {
    get() {
        return obj.foo
    },
    set(target, key, value) {
        obj[key] = value
    }
})
```

拦截函数的`调用 apply`

```javascript
const fn = (name) => {
    console.log('我是：', name)
}

const p2 = new Proxy(fn, {
    apply(target, thisArg, argArray) {
        target.call(thisArg, ...argArray)
    }
})
```

### 复合操作

读取一个对象的方法，如 `obj.fn()` ， 分两步：
- 先 `get` 读取 `obj.fn`
- 然后`apply` 调用，`obj.fn()`

### Reflect

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304151627304.png)

> `Reflect` 与 `Proxy` 的 API  一一对应，比如 `get / set / apply` 等

`Reflect` 还接受`第三个参数`，如下：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304151634228.png)

前文 [[0012.Vue 的响应式的系统设计原理@Vue]] 的` Effect` 函数，如果对于下面的数据结构有问题，`无法正常收集响应信息`。这时候就需要用到 `Reflect 的第三个参数了`

```javascript
const obj = {
  foo: 1,
  get bar() {
     return this.foo
  }
}
```

> 具体解决方法，代码见 Demo 仓库

## 二、Javascript 对象 与 Proxy 对象

### 如何判断是 `普通对象` 还是`函数对象` 

JS 中一切都是对象，函数也是对象，那么如何区分呢？

- 对象真正语义由`内部方法`实现，即对对象进行某个操作时，`引擎内部`实际调用的方法，对用户是不可见的

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304151708966.png)

如上图，是 常规对象 的 `内部方法`，下面是`函数对象的内部方法`

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304151710430.png)

所以，根据是否部署 `[[Call]]`  方法，就可以判断是 `普通对象` 还是`函数对象` 

> https://262.ecma-international.org/#sec-ordinary-and-exotic-objects-behaviours


### `常规对象` 与 `异质对象`

ES 规范，JS 中有`两种对象`：
- `常规对象`
- `异质对象`： 如 Proxy 对象，如下图：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304151717703.png)

- `[[Call]]` 和 `[[construct]]` 两个内部方法只有被代理对象是函数和构造函数时才会调用
- 内部方法的`多态性` 即 普通对象 和 Proxy 都有 `[[Get]]`  ，但规范定义是完全不同的。

> https://262.ecma-international.org/#sec-proxy-object-internal-methods-and-internal-slots


### 示例：代理 `delete` 操作

所以根据以上可知，可通过**下面**的方式 `拦截删除属性操作` 

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304151748456.png)
``

> [!bug]
> 注意：需要删除被 `proxy` 的对象，才会拦截，如下图，下面的方式就不会
> **自己丢到坑里了，搞了一会，才发现都写错了**

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304151749441.png)

## 三、如何代理 Object

如何拦截对象的`一切读取操作`，比如

- 访问属性：`obj.foo`  ， `obj['foo']`
	- `Proxy get` 
- `in`操作符：`foo in obj`
	- 根据 ECMA-262中，in 操作符运算时的逻辑，通过 `Proxy has` 拦截
- 遍历：`for(const key in obj)`
	- 还是通过规范可知，使用` Proxy ownKeys 操作` 可拦截
- 删除某个属性： `delete p.foo`
	- 通过看规范可知，可通过拦截 `Proxy deleteProperty ` 拦截
- 等等。。。

所以，结论就是：首先需要`查阅规范`，找到可拦截的方法，另外一些`复合操作`，依赖于一些基本操作，我们需要分析，通过拦截`基本操作`，达到`间接拦截复合操作`的目的。


另外，比如 添加、删除属性时对 `for-in`  的`执行次数`有影响，需要定义 `const ITERATE_KEY = Symbol()`，即`遍历key` 与 副作用函数相关联，避免重复执行。


> [!info]
>  更多的参考代码，不展开了，真正需要的时候再说吧！


### 合理的触发响应

如下代码：期望改变 `p.foo` 时，触发 `effect` 函数

```javascript
const obj = {foo:0}
const p = reactive(obj);

effect(() => {
    console.log(p.foo);
})

p.foo = 1;
p.foo = 2;
p.foo = 3;

```

打印如下：
![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305171911771.png)


然而，`NaN === NaN` 永远为 `false` ，需要兼容。如下图：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305171910764.png)


最后，访问`原型链上的属性`，可能会导致副作用执行两次的问题，也需要解决。

```javascript
const obj = {foo: 0};
const proto = {bar: 1};

const child = reactive(obj);
const parent = reactive(proto);

Object.setPrototypeOf(child, parent);

effect(() => {
    console.log(child.bar);
})

child.bar = 2;
```

所以，代理对象是一个大工程，这里不展开了，以后真正有实际应用场景，再来看`源代码`。

## 四、深响应与浅响应 、深只读 与 浅只读


`深浅`是指：
- `浅`代表`只读或只响应`对象的`第一层`属性，
- `深`则相反，我们需要，我们需要再返回属性值，之前对值进行递归包装，包装成`响应式`的再返回。


如下图：修改嵌套内层的 `bar属性`，也应该触发副作用函数

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305171922254.png)

所以，我们需要再递归再返回属性值，如下图：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305171926950.png)



如下代码：

```javascript
import {createApp, reactive, effect,readonly} from 'vue'
const obj = readonly({ text1: 'text1', text2: 'text2' });
obj.text2 = 1; // [Vue warn] Set operation on key "text2" failed: target is readonly
```

执行会警告：如下图
![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305171931126.png)

再者，`只读数据`不应该和副作用函数`建立响应关系`。如何实现呢？


## 五、对于数组的代理

数组是`异质对象`，因为数组对象的 `[[DefineOwnproperty]]` 内部方法与常规对象不同。

- 通过`索引`直接设置新的元素，可能会`隐式`的改变数组的 `length` 值
- 修改 `length` 值，也可能会影响 `已有元素`
- `for-in`遍历对象与普通对象区别不大，可使用 `length` 作为追踪的 `key`
- 使用 `for-of` 时，会读取数组的 `Symbol.iterator` 的方法。
- 另外对于数组的查找方法：用户可能会对`代理数组对象`进行查找，当然也可能对`原始对象`进行查找，所以我们`重写了`数组的查找方法。

所以，首先，我需要知道 `读取` 和 `写入` 操作都有哪些？

对于数组所有可能的`读取操作`有哪些？
- `arr[0]`
- length
- for-in 
- for-of
- 不改变原数组的方法：如 some /find 、includes 等等

对于数组所有可能的`设置操作`有哪些？
- `arr[0]=1`
- `length=0`
- 栈方法：push pop等等，它还会`隐式`修改 `length`
- 改变原数组的方法：如 spice 、sort  、fill 等

然后，去查文档，看看每个操作后面的调用逻辑是什么？再有针对性的去跟踪建立响应。

为什么我们要重写` includes` 、 `indexOf` 和 `lastIndexof` 呢？
- 以 includes 为例，查阅语言规范，我们发现
	- 这个方法的执行流程中使用了`数组的对象属性的一面`去查找属性，所以 `this` 指向这个`对象`，所以 `reacttive(obj)` 每次都很返回一个新的对象，所以 this 指向肯定有问题。所以我们需要重写 `includes`, 如何重写呢，即 拦截` arr 对象`的 `includes 属性` ，及看 `includes` 是否存在于`arrayInstrumentations`中，如下代码截图

```javascript
const arrayInstrumentations = {}

;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {
  const originMethod = Array.prototype[method]
  arrayInstrumentations[method] = function(...args) {
    // this 是代理对象，先在代理对象中查找，将结果存储到 res 中
    let res = originMethod.apply(this, args)

    if (res === false) {
      // res 为 false 说明没找到，在通过 this.raw 拿到原始数组，再去原始数组中查找，并更新 res 值
      res = originMethod.apply(this.raw, args)
    }
    // 返回最终的结果
    return res
  }
})
```


下面看看为什么重写 栈方法：如 `push`，看下面示例：

> 你可以想想，语言规范里，调用 `push`  肯定有一步是修改 `length` 的


```javascript
const arr = reactive([]);
// ::::第一个 effect
effect(() => {
    arr.push(1); // 间接读取 length,所以会建立依赖
})
// ::::第二个 effect
effect(() => {
    arr.push(1); // 间接读取 length,还会间接修改 length, 然后就执行第 一 已经建立好的effect，然后就死循环了，导致栈溢出
})
```

上面的代码会`栈溢出` ，解决方案是：使用全局变量 `shouldTrack` 来禁止追踪，断开 length 属性 与 副作用函数的响应联系。

```javascript
let shouldTrack = true
;['push','unshift','pop'].forEach(method => {
  const originMethod = Array.prototype[method]
  arrayInstrumentations[method] = function(...args) {
    shouldTrack = false
    // 调用原始方法之前
    let res = originMethod.apply(this, args)
    // 调用原始方法之后，恢复，允许追踪
    shouldTrack = true
    return res;
  }
})
```

以下代码实现`不追踪`：

```javascript
function track(target, key) {
  if (!activeEffect || !shouldTrack) return
}
```

`pop 、 shift、unshift 、splice` 等方法类似。


## 六、对于 Set 和 Map 的代理


可以想想 `Set` 和  `Map` 对应的属性和方法有哪些？
- size clear keys  values()  entries()  等等

同样的你还是需要去查语言规范，比如 `size` 是一个访问器属性，语言规范里规范有 `this` 执行的步骤，所以直接通过代理对象访问，会导致报错，这时候你需要去兼容，如去拦截 `get()` ，然后`bind` 正确的 `this 值`



其实 `delete()` 也是同样的道理

很多思路类似，比如代理迭代器属性和方法，比如 `for in`  和 `foreach` ，又比如 需要去看看文档规范里 `entries keys 和 values` 是如何定义的


另外需要避免数据污染的问题，即把`响应式数据`设置到`原始数据`上的行为。我们可以通过响应式对象的 `row`属性来访问`原始对象`


OK，就到这儿吧，其实已经有一个很现成的库供我们使用了，如果某一天真正需要用到，或者需要仔细研究，那么去看看 `@vue/reactivity` 或者看看本书的附件源码吧


## 七、原始值的响应方案，比如 `Boolean String BigInt Symbol undefined null Number` 


原始值`按值传递`，所以需要`包裹` , 我们使用 `ref()` 来包裹。代码如下：

```javascript
function ref(val) {
	const wrapper = {
		value: val
	}
	// 定义一个不可枚举不可写的属性，用于标识他是一个 ref
	Object.defineProperty(wrapper, '__v_isRef', {
		value: true
	})
	return reactive(wrapper)
}

```

`ref` 还能解决`响应式丢失`的问题，关于`响应式丢失`，我们来看一个例子

```javascript

const obj = reactive({foo: 1, bar: 2});

// :::: 使用 ... 运算符
const newObj = {...obj}; 

effect(() => {
    console.log(newObj.foo); // newObj 没有任何响应能力，所以这里不会触发 effect
})

// :::: 很显然，这里不会触发 effect 
obj.foo = 2; 
```

有没有什么办法，即使使用 `newObj` 普通对象访问属性值，也会被收集响应呢？答案如下：

```javascript
const obj = reactive({foo: 1, bar: 2});
const newObj = {
    foo: {
        get value() {
            return obj.foo
        }
    },
    bar: {
        get value() {
            return bar.foo
        }
    }
}

effect(() => {
    // 这里会触发 get value() ，从而访问了 obj.foo ，从而触发收集依赖
    console.log(newObj.foo); 
})

obj.foo = 2;
```

所以封装两个函数 `toRef`  和 `toRefs` 

```javascript


function toRefs(obj) {
  const ret = {}
  for (const key in obj) {
    ret[key] = toRef(obj, key)
  }
  return ret
}

function toRef(obj, key) {
  const wrapper = {
    get value() {
      return obj[key]
    },
    set value(val) {
      obj[key] = val
    }
  }

  Object.defineProperty(wrapper, '__v_isRef', {
    value: true
  })

  return wrapper
}
```

这样，就能正确的触发收集了。

>  这下知道这个两个函数是干什么的了吧？以前都有一点懵逼


最后，我们说说 自动脱落 `ref` 的能力，啥意思呢？

比如模板代码，每次都需要加一个 `.value` ？

```html
<div>{{foo.value}}</div>
```


有啥办法解决吗？ 其实很简单，如下代码：

![image.png](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305182039262.png)

上面的代码，如上：
---
<div class="liguwe-doc-footer">
            <div class="liguwe-doc-footer-edit-link">
                <p class="liguwe-doc-footer-p">
                    <svg t="1687912573060" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1498">
                        <path d="M854.6 370.6c-9.9-39.4 9.9-102.2 73.4-124.4l-67.9-3.6s-25.7-90-143.6-98c-117.8-8.1-194.9-3-195-3 0.1 0 87.4 55.6 52.4 154.7-25.6 52.5-65.8 95.6-108.8 144.7-1.3 1.3-2.5 2.6-3.5 3.7C319.4 605 96 860 96 860c245.9 64.4 410.7-6.3 508.2-91.1 20.5-0.2 35.9-0.3 46.3-0.3 135.8 0 250.6-117.6 245.9-248.4-3.2-89.9-31.9-110.2-41.8-149.6z m-204.1 334c-10.6 0-26.2 0.1-46.8 0.3l-23.6 0.2-17.8 15.5c-47.1 41-104.4 71.5-171.4 87.6-52.5 12.6-110 16.2-172.7 9.6 18-20.5 36.5-41.6 55.4-63.1 92-104.6 173.8-197.5 236.9-268.5l1.4-1.4 1.3-1.5c4.1-4.6 20.6-23.3 24.7-28.1 9.7-11.1 17.3-19.9 24.5-28.6 30.7-36.7 52.2-67.8 69-102.2l1.6-3.3 1.2-3.4c13.7-38.8 15.4-76.9 6.2-112.8 22.5 0.7 46.5 1.9 71.7 3.6 33.3 2.3 55.5 12.9 71.1 29.2 5.8 6 10.2 12.5 13.4 18.7 1 2 1.7 3.6 2.3 5l5 17.7c-15.7 34.5-19.9 73.3-11.4 107.2 3 11.8 6.9 22.4 12.3 34.4 2.1 4.7 9.5 20.1 11 23.3 10.3 22.7 15.4 43 16.7 78.7 3.3 94.6-82.7 181.9-182 181.9z"
                              p-id="1499" fill="#10b981"></path>
                    </svg>
                    <a href="https://www.yuque.com/liguwe/post/0017" target="_blank" class="liguwe-doc-footer-edit-link-a">
                        View this page on Yuque
                    </a>
                </p>
                <p class="liguwe-doc-footer-p">
                    <svg t="1687913054251" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5173"><path d="M853.333333 501.333333c-17.066667 0-32 14.933333-32 32v320c0 6.4-4.266667 10.666667-10.666666 10.666667H170.666667c-6.4 0-10.666667-4.266667-10.666667-10.666667V213.333333c0-6.4 4.266667-10.666667 10.666667-10.666666h320c17.066667 0 32-14.933333 32-32s-14.933333-32-32-32H170.666667c-40.533333 0-74.666667 34.133333-74.666667 74.666666v640c0 40.533333 34.133333 74.666667 74.666667 74.666667h640c40.533333 0 74.666667-34.133333 74.666666-74.666667V533.333333c0-17.066667-14.933333-32-32-32z" fill="#10b981" p-id="5174"></path><path d="M405.333333 484.266667l-32 125.866666c-2.133333 10.666667 0 23.466667 8.533334 29.866667 6.4 6.4 14.933333 8.533333 23.466666 8.533333h8.533334l125.866666-32c6.4-2.133333 10.666667-4.266667 14.933334-8.533333l300.8-300.8c38.4-38.4 38.4-102.4 0-140.8-38.4-38.4-102.4-38.4-140.8 0L413.866667 469.333333c-4.266667 4.266667-6.4 8.533333-8.533334 14.933334z m59.733334 23.466666L761.6 213.333333c12.8-12.8 36.266667-12.8 49.066667 0 12.8 12.8 12.8 36.266667 0 49.066667L516.266667 558.933333l-66.133334 17.066667 14.933334-68.266667z" fill="#10b981" p-id="5175"></path></svg>
                    <a href="https://github.com/liguwe/liguwe.github.io/blob/master/docs/0017.md" target="_blank" class="liguwe-doc-footer-edit-link-a">Edit this page on Github</a>
                </p>
                 <p class="liguwe-doc-footer-p">
                     <svg t="1687912510038" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                             p-id="2280">
                            <path d="M746.666667 106.666667a192 192 0 0 1 192 192v373.333333a192 192 0 0 1-192 192h-107.925334l-97.749333 90.496a42.666667 42.666667 0 0 1-57.984 0L385.28 864H277.333333a192 192 0 0 1-192-192V298.666667a192 192 0 0 1 192-192h469.333334z m0 64H277.333333a128 128 0 0 0-128 128v373.333333a128 128 0 0 0 128 128h107.925334a64 64 0 0 1 43.477333 17.045333L512 894.122667l83.264-77.077334a64 64 0 0 1 43.477333-17.045333H746.666667a128 128 0 0 0 128-128V298.666667a128 128 0 0 0-128-128zM512 426.666667a54.677333 54.677333 0 0 1 54.634667 54.698666A54.677333 54.677333 0 0 1 512 536.064a54.677333 54.677333 0 0 1-54.634667-54.698667A54.677333 54.677333 0 0 1 512 426.666667z m-196.693333 0a54.677333 54.677333 0 0 1 54.634666 54.698666 54.677333 54.677333 0 0 1-54.613333 54.698667 54.677333 54.677333 0 0 1-54.634667-54.698667A54.677333 54.677333 0 0 1 315.306667 426.666667z m393.386666 0a54.677333 54.677333 0 0 1 54.613334 54.698666 54.677333 54.677333 0 0 1-54.613334 54.698667 54.677333 54.677333 0 0 1-54.634666-54.698667A54.677333 54.677333 0 0 1 708.672 426.666667z"
                                  fill="#10b981" p-id="2281"></path>
                        </svg>
                     <a href="https://github.com/liguwe/liguwe.github.io/issues/new?title=0017.Vue3 的非原始值响应式方案@Vue&labels=liguwe.site"
                       target="_blank" class="liguwe-doc-footer-edit-link-a">
                        Comment this page on GitHub Issues
                    </a>
                </p>
                 <p class="liguwe-doc-footer-p">
                     <svg t="1687912510038" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                             p-id="2280">
                            <path d="M746.666667 106.666667a192 192 0 0 1 192 192v373.333333a192 192 0 0 1-192 192h-107.925334l-97.749333 90.496a42.666667 42.666667 0 0 1-57.984 0L385.28 864H277.333333a192 192 0 0 1-192-192V298.666667a192 192 0 0 1 192-192h469.333334z m0 64H277.333333a128 128 0 0 0-128 128v373.333333a128 128 0 0 0 128 128h107.925334a64 64 0 0 1 43.477333 17.045333L512 894.122667l83.264-77.077334a64 64 0 0 1 43.477333-17.045333H746.666667a128 128 0 0 0 128-128V298.666667a128 128 0 0 0-128-128zM512 426.666667a54.677333 54.677333 0 0 1 54.634667 54.698666A54.677333 54.677333 0 0 1 512 536.064a54.677333 54.677333 0 0 1-54.634667-54.698667A54.677333 54.677333 0 0 1 512 426.666667z m-196.693333 0a54.677333 54.677333 0 0 1 54.634666 54.698666 54.677333 54.677333 0 0 1-54.613333 54.698667 54.677333 54.677333 0 0 1-54.634667-54.698667A54.677333 54.677333 0 0 1 315.306667 426.666667z m393.386666 0a54.677333 54.677333 0 0 1 54.613334 54.698666 54.677333 54.677333 0 0 1-54.613334 54.698667 54.677333 54.677333 0 0 1-54.634666-54.698667A54.677333 54.677333 0 0 1 708.672 426.666667z"
                                  fill="#10b981" p-id="2281"></path>
                        </svg>
                     <a href="https://github.com/liguwe/liguwe.github.io/discussions/new?category=general&labels=liguwe.site&title=0017.Vue3 的非原始值响应式方案@Vue"
                       target="_blank" class="liguwe-doc-footer-edit-link-a">
                        Discuss this page on GitHub Discussions
                    </a>
                </p>
            </div>
            <p class="liguwe-doc-footer-update-time"><i>Last updated：2023.04.15</i></p>
            <div id="liguwe-comment"></div>
        </div>