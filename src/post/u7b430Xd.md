
# vite 中如何使用 Module Federation（模块联邦）


在 Vite 中，我们可以使用 `@originjs/vite-plugin-federation` 插件来实现模块联邦功能。以下是详细的使用步骤和示例：


## 目录
<!-- toc -->
 ## 1. 基本配置示例 

### 1.1. 主应用（Host）配置

```typescript hl:10,15
// vite.config.ts
import { defineConfig } from 'vite'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig({
  plugins: [
    federation({
      name: 'host-app',
      remotes: {
        remoteApp: {
          external: 'http://localhost:5001/assets/remoteEntry.js',
          format: 'esm'
        }
      },
      shared: ['vue', 'pinia'] // 共享依赖
    })
  ]
})
```

### 1.2. 远程应用（Remote）配置

```typescript hl:10
// vite.config.ts
import { defineConfig } from 'vite'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig({
  plugins: [
    federation({
      name: 'remote-app',
      filename: 'remoteEntry.js',
      exposes: {
        './Button': './src/components/Button.vue',
        './Header': './src/components/Header.vue'
      },
      shared: ['vue', 'pinia']
    })
  ],
  build: {
    target: 'esnext'
  }
})
```

## 2. 使用远程组件

```vue hl:15
<!-- 主应用中使用远程组件 -->
<template>
  <div>
    <h1>Host Application</h1>
    <Suspense>
      <RemoteButton />
    </Suspense>
  </div>
</template>

<script setup>
import { defineAsyncComponent } from 'vue'

const RemoteButton = defineAsyncComponent(() => 
  import('remoteApp/Button')
)
</script>
```

## 3. 带版本控制的共享依赖

```typescript hl:15
// vite.config.ts
export default defineConfig({
  plugins: [
    federation({
      name: 'host-app',
      remotes: {
        remoteApp: 'http://localhost:5001/assets/remoteEntry.js'
      },
      shared: {
        vue: { 
          requiredVersion: '^3.2.0',
          singleton: true 
        },
        'vue-router': {
          requiredVersion: '^4.0.0',
          singleton: true
        }
      }
    })
  ]
})
```

## 4. 动态远程加载

```typescript hl:8
// vite.config.ts
export default defineConfig({
  plugins: [
    federation({
      name: 'host-app',
      remotes: {
        remoteApp: {
          external: `Promise.resolve('http://localhost:5001/assets/remoteEntry.js')`,
          format: 'esm'
        }
      }
    })
  ]
})
```

## 5. 开发模式配置

```typescript
// vite.config.ts
export default defineConfig({
  plugins: [
    federation({
      name: 'remote-app',
      filename: 'remoteEntry.js',
      exposes: {
        './components': './src/components/index.ts'
      },
      shared: ['vue']
    })
  ],
  build: {
    target: 'esnext',
    minify: false,
    cssCodeSplit: false,
    sourcemap: true
  }
})
```

## 6. 错误处理和降级策略

下面是一个包装后的 `RemoteComponent` 组件

```vue
<template>
  <Suspense>
    <template `#default>`
      <RemoteComponent />
    </template>
    <template `#fallback>`
      <div>Loading remote component...</div>
    </template>
  </Suspense>
</template>

<script setup>
import { defineAsyncComponent, h } from 'vue'

const RemoteComponent = defineAsyncComponent({
  loader: () => import('remoteApp/Component'),
  loadingComponent: () => h('div', 'Loading...'),
  errorComponent: () => h('div', 'Failed to load component'),
  delay: 200,
  timeout: 3000
})
</script>
```

## 7. 示例：如何在 Vite 的 Module Federation 中共享 Pinia 状态

### 7.1. 首先需要在`主应用和远程应用`中都配置 Pinia 作为共享依赖

```typescript
// vite.config.ts (主应用和远程应用都需要配置)
import { defineConfig } from 'vite'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig({
  plugins: [
    federation({
      // ... 其他配置
      shared: {
        vue: {
          singleton: true,
          requiredVersion: '^3.0.0'
        },
        pinia: {
          singleton: true,
          requiredVersion: '^2.0.0'
        }
      }
    })
  ]
})
```

创建共享 Store

### 7.2. `远程应用`中定义 Store ，并暴露 Store

#### 7.2.1. 定义 Store 

```typescript
// remote-app/src/stores/counter.ts
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
    message: 'Hello from Remote App'
  }),
  
  actions: {
    increment() {
      this.count++
    },
    decrement() {
      this.count--
    },
    setMessage(msg: string) {
      this.message = msg
    }
  },
  
  getters: {
    doubleCount(): number {
      return this.count * 2
    }
  }
})

// 导出 store 定义
export type CounterStore = ReturnType<typeof useCounterStore>
```

#### 7.2.2. 暴露 Store

```typescript
// remote-app/src/stores/index.ts
export { useCounterStore } from './counter'

// vite.config.ts (远程应用)
export default defineConfig({
  plugins: [
    federation({
      name: 'remote-app',
      filename: 'remoteEntry.js',
      exposes: {
        './stores': './src/stores/index.ts'
      },
      shared: {
        vue: { singleton: true },
        pinia: { singleton: true }
      }
    })
  ]
})
```

### 7.3. 主应用创建 Pinia 实例，并使用远程 Store

#### 7.3.1. 主应用中创建 Pinia 实例

```typescript
// host-app/src/main.ts
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.mount('#app')
```

#### 7.3.2. 主应用中使用远程 Store

```typescript hl:17
// host-app/src/components/Counter.vue
<template>
  <div>
    <h2>Counter from Remote Store</h2>
    <p>Count: {{ counter.count }}</p>
    <p>Double Count: {{ counter.doubleCount }}</p>
    <p>Message: {{ counter.message }}</p>
    
    <button @click="counter.increment()">Increment</button>
    <button @click="counter.decrement()">Decrement</button>
    <button @click="updateMessage">Update Message</button>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue'
import { useCounterStore } from 'remoteApp/stores'

const counter = useCounterStore()

const updateMessage = () => {
  counter.setMessage('Updated from Host App')
}

onMounted(() => {
  // 初始化操作
  console.log('Store mounted in host app')
})
</script>
```

#### 7.3.3. 在主应用中扩展远程 Store

```typescript
// host-app/src/stores/enhancedCounter.ts
import { defineStore } from 'pinia'
import { useCounterStore } from 'remoteApp/stores'

export const useEnhancedCounterStore = defineStore('enhancedCounter', {
  state: () => ({
    localData: 'Host App Data'
  }),
  
  actions: {
    async complexAction() {
      const remoteCounter = useCounterStore()
      remoteCounter.increment()
      this.localData = `Updated after remote count: ${remoteCounter.count}`
    }
  },
  
  getters: {
    combinedInfo(): string {
      const remoteCounter = useCounterStore()
      return `${this.localData} - Remote Count: ${remoteCounter.count}`
    }
  }
})
```

## 8. 注意事项

- 确保将构建目标设置为 '`esnext`'，以支持动态导入
- 在生产环境中考虑启用代码分割和压缩
- 开发时建议禁用代码压缩，便于调试，并启动 sourcemap
- 使用 `singleton` 模式避免多个版本共存
- 明确指定共享依赖的版本要求
- 实现合适的加载状态和错误提示及降级方案

