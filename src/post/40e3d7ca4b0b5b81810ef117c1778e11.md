
# Vue3中 Teleport 组件的实现原理


`#vue` 

简单说就是，蒙层 `z-index` 的问题，所以必须渲染到 `body` 或者挂载到父元素上才行，vue3 本身提供内部组件来支持这个功能



## 目录
<!-- toc -->
 ## 实现渲染逻辑分离 
将 Teleport 组件的渲染逻辑从渲染器中分离出来，这么做有两点好处：

- 可以**避免渲染器逻辑代码“膨胀”**； 
- **方便TreeShaking**：当用户没有使用 Teleport 组件时，由于 Teleport 的渲染逻辑被分离，因此可以利用 TreeShaking 机制在最终的 bundle 中删除 Teleport 相关的代码，使得最终构建包的体积变小

下面是 patch 函数：
![](https://832-1310531898.cos.ap-beijing.myqcloud.com/157ea664c2294a84c81ee0dba0120952.png)


## 以下面模板为示例
![](https://832-1310531898.cos.ap-beijing.myqcloud.com/43dac0ddd96491945eff4ff8a1f2770c.png)
所以具体对应的 vdom 如下：
![](https://832-1310531898.cos.ap-beijing.myqcloud.com/f25fb6a62f4fc44e773d798c7cc4227b.png)


## 最终代码
```javascript
const Teleport = {
  __isTeleport: true,
  process(n1, n2, container, anchor, internals) {
    const { patch, patchChildren, move } = internals
    if (!n1) {
      // 挂载
        // :::: 使用 to属性 去查找 DOM 节点
      const target = typeof n2.props.to === 'string'
        ? document.querySelector(n2.props.to)
        : n2.props.to
      n2.children.forEach(c => patch(null, c, target, anchor))
    } else {
      // 更新
      patchChildren(n1, n2, container)
      if (n2.props.to !== n1.props.to) {
          // :::: 使用 to属性 去查找 DOM 节点
        const newTarget = typeof n2.props.to === 'string'
          ? document.querySelector(n2.props.to)
          : n2.props.to
        n2.children.forEach(c => move(c, newTarget))
      }
    }
  }
}
```


## 最后
看看 `Teleport` 单词含义：
v. 心灵运输（物体、人）；远距离传送
n. 通信卫星；心灵传输

**即，Teleport组件 将模板渲染到其他节点下，即跨越 DOM 层级渲染**
