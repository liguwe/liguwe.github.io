
# 理解大语言模型

`#2026/01/01` `#ai` 

> 一份从零开始构建LLM的计划：本书讲通过代码逐步实现一个基于 Transformer 架构的类 ChatGPT LLM，以此深入理解LLM。

**本书的目标：** 我们不是要调用 API，而是要**从零开始写代码**，构建一个类似于 ChatGPT 的 LLM，虽然规模会小一些，但原理完全一样。


## 目录
<!-- toc -->
 ## 什么是 LLM 

核心定义：
- 大语言模型（LLM）本质上是一个**深度神经网络**。
- 它的核心工作非常单纯：**预测文本序列中的下一个词**。
	-  虽然这个任务听起来很简单（Next-word prediction），但当模型的规模变得非常“大”——拥有数百亿甚至数千亿个`参数`，并且在海量数据上训练后，它就涌现出了理解、生成和解释人类语言的惊人能力。

---

- LLM 是一种用于`理解、生成和响应`类似`人类语言文本`的`神经网络`。
	- 属于 **深度神经网络** （deep neural network），通过大规模文本数据训练而成
- LLM 采用了一种名为 `Transformer 的架构`
	- 这种架构允许模型在进行预测时有选择地关注输入文本的不同部分，从而使得它们特别擅长`应对人类语言的细微差别和复杂性`。
- 生成式人工智能
	- 由于LLM能够 **生成** 文本，因此它们通常也被归类为 **生成式人工智能** （generative artificial intelligence，简称 generative AI 或 GenAI）。
- 人工智能
	- 是一个囊括机器学习、深度学习等众多分支的领域，旨在开发能够执行需要人类智能水平的任务（包括语言理解、模式识别、决策制定等）的机器。

![{%}|552](https://www.ituring.com.cn/figures/2025/LargeLanguageModel/001.jpg)

- LLM 是`深度学习`技术的`具体应用`，能够处理和生成类似人类语言的文本；
- `深度学习`是`机器学习`的一个分支，主要使用`多层神经网络`；
- 机器学习和深度学习致力于开发算法，使计算机能够从数据中学习，并执行需要人类智能水平的任务
- 深度学习是机器学习的一个分支，它主要利用 `3 层及以上`的神经网络（深度神经网络）来建模数据中的复杂模式和抽象特征。
- 与深度学习不同，`传统的机器学习`往往需要人工进行特征提取。这意味着`人类专家`需要为模型识别和挑选出最相关的特征。

为什么叫“大”模型？
- **数据集大：** 
	- 训练数据几乎涵盖了互联网上所有公开的文本。
- **参数量大：** 
	- 相比传统算法可能只有几个参数，LLM 有数十亿个参数。这些参数就是`矩阵中的权重`，在训练中不断调整。

## LLM 能做什么？

想象大模型都能干什么就行

![{%}|576](https://www.ituring.com.cn/figures/2025/LargeLanguageModel/002.jpg)

## 为什么要自己构建LLM？

- 从零开始构建LLM不仅是一次深入了解模型机制和局限性的绝佳机会
- 还为我们提供了预训练和微调`开源 LLM`，使其适应特定领域的数据集或任务的必要知识。

> **注意**： 如今大多数LLM是使用 `PyTorch` 深度学习库实现的，我们也将使用该库

## 构建和使用LLM的各个阶段：预训练与微调

LLM的构建通常包括 **预训练** （pre-training）和 **微调** （fine-tuning）两个阶段。
- “预训练”中的“`预`”表明它是模型训练的初始阶段，此时模型会在`大规模、多样化的数据集`上进行训练，以形成`全面的语言理解能力`。
- 以预训练模型为基础，`微调阶段`会在规模较小的特定任务或领域数据集上对模型进行针对性训练，以进一步提升其特定能力。

![{%}|816](https://www.ituring.com.cn/figures/2025/LargeLanguageModel/003.jpg)

> **图：LLM的预训练目标是在大量无标注的文本语料库（原始文本）上进行下一单词预测。预训练完成后，可以使用较小的带标注的数据集对LLM进行微调**

```
大语言模型（LLM）训练流程  
├── 第一阶段：预训练（自监督学习）  
│   ├── 特点  
│   │   ├── 使用大量无标注的原始文本数据  
│   │   ├── 文本数据特点：普通文本，无额外标注  
│   │   └── 数据预处理：过滤格式字符、删除未知语言文档  
│   │  
│   ├── 与传统机器学习的关键区别  
│   │   ├── 传统模型：需要标签信息  
│   │   └── LLM预训练：自监督学习，模型自生成标签  
│   │  
│   └── 典型任务：文本补全  
│       ├── 示例模型：GPT-3  
│       └── 能力：少样本学习  
│  
├── 第二阶段：微调（有监督学习）  
│   ├── 微调方法一：指令微调（Instruction Fine-tuning）  
│   │   └── 数据特点：指令-答案对  
│   │       - 例：原文-正确翻译文本  
│   │  
│   └── 微调方法二：分类任务微调（Classification Fine-tuning）  
│       └── 数据特点：文本-类别标签  
│           - 例：邮件-"垃圾/非垃圾"标签  
│  
└── 训练目标  
    ├── 构建基础模型（Foundation Model）  
    └── 提升模型在特定任务上的性能  
```

### 预训练 (Pre-training) → 打造“基础模型” （自监督学习）

- **做什么：** 
	- 让模型在海量的、**无标签**的文本（原始文本）上通过“预测下一个词”来学习。
- **数据：
	- ** 维基百科、书籍、网页代码等。不需要人工打标签（Self-supervised learning，自监督学习），因为文本本身就是答案。
- **产出：
	- ** 得到一个**基础模型 (Foundation Model)**（例如 GPT-3）。
- **能力：
	- 这时候的模型“博学”但“不懂规矩”。它能把句子补全，但可能不知道如何像助手一样回答问题。

### 微调 (Fine-tuning) → 专业化训练（有监督学习）

- **做什么：** 
	- 在较小的、**有标签**的数据集上进一步训练，让模型适应特定任务。
- **数据：** 
	- 比如“指令-答案”对（Instruction-Answer pairs）。
- **分类：**
    1. **指令微调 (Instruction Fine-tuning)：** 
        - 让模型学会听懂人话，比如“把这段代码翻译成 Python”。
        - ChatGPT 就是 GPT-3 经过指令微调后的产物,。
    2. **分类微调 (Classification Fine-tuning)：** 
        - 让模型专门做判断，比如判断邮件是不是垃圾邮件。

## Transformer 架构介绍

大部分的现代LLM基于 Transformer 架构，这是一种`深度神经网络架构`，该架构是在谷歌于 `2017 年`发表的论文“Attention Is All You Need” 中首次提出的。

### 编码器与解码器

`Transformer` 最初是为机器翻译任务（比如将英文翻译成德语和法语）开发的。Transformer 架构的一个简化版本如图 1-4 所示。

![{%}|1032](https://www.ituring.com.cn/figures/2025/LargeLanguageModel/004.jpg)

原始 Transformer 架构的简化描述，这是一种用于机器翻译的深度学习模型。Transformer 由两部分组成：
- 一个是编码器，用于处理输入文本并生成`文本嵌入`
	- `文本嵌入`是一种能够在不同维度中捕获许多不同因素的数值表示
- 另一个是解码器，用于使用这些`文本嵌入`逐词生成翻译后的文本。
	- 请注意，图中展示的是翻译过程的最后阶段，此时解码器根据原始输入文本（“This is an example”）和部分翻译的句子（“Das ist ein”），生成最后一个单词（“Beispiel”）以完成翻译

总结：
1. **编码器 (Encoder)：** 
	- 负责“读”。把输入的文本（比如英文）吃进去，理解上下文，压缩成向量。
2. **解码器 (Decoder)：** 
	- 负责“写”。根据编码器的信息，逐个字生成翻译后的文本（比如德文）。

以翻译任务为例，编码器将源语言的文本编码成向量，解码器则解码这些向量以生成目标语言的文本。编码器和解码器都是由`多层`组成，这些层通过`自注意力机制`连接。

### 自注意机制

Transformer 和LLM的一大关键组件是 **自注意力机制** （self-attention mechanism），它允许模型衡量序列中不同单词或词元之间的`相对重要性`。

比如处理“苹果”时，模型能根据上下文判断它是指“水果”还是“手机公司”。这种机制让模型能捕捉长距离的依赖关系。

这一机制使得模型能够捕捉到输入数据中长距离的依赖和上下文关系，从而提升其生成连贯且上下文相关的输出的能力。

为了适应不同类型的下游任务，Transformer 的后续变体，如 **BERT** （Bidirectional Encoder Representations from Transformer， **双向编码预训练 Transformer** ）和各种 **GPT** （Generative Pretrained Transformer， **生成式预训练 Transformer** ）模型，都基于这一理念构建

### Transformer 的两大流派

 随着发展，Transformer 分化出了两种主要变体：

1. **BERT (Encoder-only)：** 只用编码器。
    - 专长：
        - 它是“完形填空”高手（Masked word prediction）。
        - 擅长分类任务（如情感分析），因为它能同时看到上下文。
2. **GPT (Decoder-only)：** 只用解码器。
    - 专长：
        - 它是“接龙”高手（Next-word prediction）。擅长生成文本。

BERT 基于原始 Transformer 的编码器模块构建，其训练方法与 GPT 不同。
- GPT 主要用于生成任务，
- 而 BERT 及其变体专注于 **掩码预测** （masked word prediction），即`预测给定句子中被掩码的词`，如图 1-5 所示。这种独特的训练策略使 BERT 在情感预测、文档分类等文本分类任务中具有优势。例如，截至本书撰写时，X（以前的 Twitter）在检测有害内容时使用的是 BERT。

![{%}|848](https://www.ituring.com.cn/figures/2025/LargeLanguageModel/005.jpg)

**图 1-5　Transformer 编码器和解码器的可视化展示。
- 左侧的编码器部分展示了专注于掩码预测的类 BERT LLM，主要用于文本分类等任务。
- 右侧的解码器部分展示了类 GPT LLM，主要用于生成任务和生成文本序列

GPT 则侧重于原始 Transformer 架构的解码器部分，主要用于处理生成文本的任务，包括机器翻译、文本摘要、小说写作、代码编写等。

GPT 模型主要被设计和训练用于 **文本补全** （text completion）任务，但它们表现出了出色的可扩展性。这些模型擅长执行零样本学习任务和少样本学习任务。

- **零样本学习** （zero-shot learning）
	- 是指在没有任何特定示例的情况下，泛化到从未见过的任务，
- 而 **少样本学习** （few-shot learning）
	- 是指从用户提供的少量示例中进行学习，如图 1-6 所示。

![{%}|1064](https://www.ituring.com.cn/figures/2025/LargeLanguageModel/006.jpg)

**图 1-6　除了文本补全，类 GPT LLM还可以根据输入执行各种任务，而无须重新训练、微调或针对特定任务更改模型架构。有时，在输入中提供目标示例会很有帮助，这被称为“少样本设置”。然而，类 GPT LLM也能够在没有特定示例的情况下执行任务，这被称为“零样本设置”**

## 利用大型数据集

预训练的数据量是巨大的。以 GPT-3 为例，它看了大约 **3000 亿个 Token**（词元）。

- **数据源：** 爬取的网页（CommonCrawl）、高质量图书、维基百科等。
- **Token (词元)：** 模型读写的单位，不完全等于单词，包括单词、标点甚至空格。
- **计算成本：** 预训练一次 GPT-3 的云计算成本约为 460 万美元。

好消息是：
- 我们不需要每次都花几百万美元。我们可以用小数据集学习原理，然后**加载开源的预训练权重**（比如 OpenAI 或 Meta 发布的），跳过昂贵的预训练步骤。

主流的 GPT、BERT 等模型所使用的训练数据集涵盖了多样而全面的文本语料库。这些语料库包含数十亿词汇，涉及广泛的主题，囊括自然语言与计算机语言。

**表 1-1　GPT-3 LLM的预训练数据集**

| 数据集名称            | 数据集描述       | 词元数量   | 训练数据中的比例 | 存储空间   |
| ---------------- | ----------- | ------ | -------- | ------ |
| CommonCrawl（过滤后） | 网络抓取数据      | 4100 亿 | 60%      | 570 GB |
| WebText2         | 网络抓取数据      | 190 亿  | 22%      |        |
| Books1           | 基于互联网的图书语料库 | 120 亿  | 8%       |        |
| Books2           | 基于互联网的图书语料库 | 550 亿  | 8%       |        |
| Wikipedia        | 高质量文本       | 30 亿   | 3%       |        |

表 1-1 展示了各种数据集的词元数量。 **词元** （token）是模型读取文本的基本单位。

GPT-3 等模型的后续版本（如 Meta 的 Llama），已经扩展了它们的训练范围，涵盖了包括 Arxiv 研究论文（92 GB）和 `StackExchange 上的代码问答`（78 GB）在内的更多数据源。

## 深入剖析 GPT 架构

GPT (Generative Pre-trained Transformer)** 是目前最主流的生成式模型架构。
- **架构特点：** 
- **工作方式：自回归 (Autoregressive)**。
    - 也就是“单向”处理（从左到右）。它把上一次生成的输出，作为下一次预测的输入，就像贪吃蛇一样不断变长，直到生成完整的句子。
- **涌现能力 (Emergence)：**
    - GPT 只是被训练来预测下一个词，但当模型足够大、数据足够多时，它突然“学会”了翻译、写代码、做数学题。这些能力不是显式编程进去的，而是自然涌现的。

![{%}|720](https://www.ituring.com.cn/figures/2025/LargeLanguageModel/008.jpg)

- 原始的 Transformer 模型将编码器模块和解码器模块重复了 6 次，
-  GPT-3 总共有 `96 层` Transformer 和 `1750 亿`个参数。

## 构建LLM

![{%}|712](https://www.ituring.com.cn/figures/2025/LargeLanguageModel/009.jpg)

1. **第一阶段：搭建架构**
    - 处理数据（分词、Embedding）。
    - 实现核心的**注意力机制 (Attention)**。
    - 搭建 GPT 的骨架代码。
2. **第二阶段：预训练 (Pre-training)**
    - 编写训练循环。
    - 让模型在无标签文本上学习“预测下一个词”。
    - 注：为了教学，我们会用小数据集，同时也会教你如何加载现成的商业级预训练权重。
3. **第三阶段：微调 (Fine-tuning)**
    - 这是让模型变得好用的关键。
    - 我们将模型微调成一个**文本分类器**。
    - 我们将模型微调成一个能听懂指令的**个人助手**。

## 小结
