
# AVL 树和红黑树 →  都是 BST

`#树` `#数据结构` 


## 目录
<!-- toc -->
 ## 1. AVL 树 
 
### 1.1. 定义
 
- 既是二叉搜索树，也是平衡二叉树
- 对每个节点，其左右子树的高度差不超过 1
- 使用高度或平衡因子来维持平衡

### 1.2. 使用场景

- 组织和存储大型数据，适用于**高频查找、低频增删**的场景
- 用于构建数据库中的**索引**系统
- 文件系统
- 适用于读操作（查找）频繁的场景
	- 对查询性能要求极高的情况
	- 数据库索引
	- 需要保证最坏情况下性能的应用
- 某些数**据库系统的索引**实现
- 需要**频繁查找但较少插入/删除的内存数据集**

## 2. 红黑树

### 2.1. 定义

- 也是一种**自平衡二叉搜索树**
- 每个节点都有颜色属性，要么红色要么黑色
- 通过节点颜色和一系列规则来保持平衡：
    1. 根节点是黑色
    2. 所有叶子节点（NIL）是黑色
    3. 红色节点的子节点必须是黑色
    4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

### 2.2. 使用场景

- 适用于读写操作（查找、插入、删除）都**较为频繁**的场景
- 对插入和删除操作的性能要求较高
- 需要在性能和内存使用之间取得平衡的情况

具体应用例子：
- Java 中的 TreeMap 和 TreeSet
- C++ STL 中的 map 和 set
- Linux 内核中的完全公平调度器（CFS）
- 各种中等规模的数据集合管理

## 3. 总结

总的来说
- 如果你的应用更注重查询速度且插入/删除操作相对较少，可以选择 **AVL 树**。
- 如果你需要处理频繁的插入和删除操作，同时还要保持不错的查询性能，那么**红黑树**可能是更好的选择。
- AVL树提供了更严格的平衡，适合读操作频繁的场景。
- 红黑树提供了更好的写操作性能，适合读写都很频繁的场景。
- 在实际应用中，红黑树因其在插入和删除操作上的效率优势，以及内存占用较小的特点，往往被更广泛地使用。