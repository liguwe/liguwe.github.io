
# 并查集原理



## 目录
<!-- toc -->
 ## 名词解释 

![图片&文件](./files/20241120-11.png)

- 10 个 `连通分量`
	- 因为它们自成一派，没有和其他节点相连

![图片&文件](./files/20241120-12.png)

- 图结构中的节点 `0,1,2` 之间就有了连接关系，它们三个节点共同构成了一个`连通分量`，我们可以说这三个节点是`连通`的。
- 这个图结构中的`连通分量`的数量从 **10** 减少到了 **8**
	- 因为连接操作将多个连通分量合并成了一个

给你输入一个图结构
- 进行若干次`「连接操作」`
- 可能会查询任意两个节点`是否「连通」`
- 或者查询当前图中有`多少个「连通分量」`


## 并查集（Union Find）结构

```java
class UF {
    // 初始化并查集，包含 n 个节点，时间复杂度 O(n)
    public UF(int n);

    // 连接节点 p 和节点 q，时间复杂度 O(1)
    public void union(int p, int q);

    // 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内），时间复杂度 O(1)
    public boolean connected(int p, int q);

    // 查询当前的连通分量数量，时间复杂度 O(1)
    public int count();
}
```

## 并查集的原理

并查集本质上还是**树结构的延伸**

如果我们想办法把同一个连通分量的节点都放到同一棵树中，把这棵树的**根节点作为这个连通分量的代表**，那么我们就可以高效实现上面的操作了。

并查集底层其实是一片==森林==，这片森林由很多多叉树组成，每棵树代表一个连通分量
- `connected(p, q)`：**是否联通**
	- 只需要判断 `p` 和 `q` 所在的多叉树的根节点
	- 若相同，则 `p` 和 `q` 在同一棵树中，即连通，否则不连通
- `count()`：
	- 只需要统计一下==总共有多少棵树==，即可得到**连通分量的数量**。
- `union(p, q)`：连接两个点
	-  `p` 所在树的==根节点==  →    `q` 所在树的**根节点**



并查集中每个节点其实不在乎自己的子节点是谁，**只在乎自己的根节点是谁**，所以节点类型为

```java
class UFNode {
    // 节点 id 编号
    int id;
    // 指向父节点的指针
    UFNode parent;
}
```

对于任意一个节点，我们都可以顺着 `parent` 指针一路找到它的根节点，如下代码

```java hl:16
// 连接节点 p 和节点 q
void union(UFNode p, UFNode q) {
    // 找到节点 p 和节点 q 的根节点
    // 将 p 所在的整棵树接到 q 所在的整棵树下面
    return find(p).parent = find(q);
}

// 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内）
boolean connected(UFNode p, UFNode q) {
    return find(p).id == find(q).id;
}

// 查询节点 node 的根节点，时间复杂度取决于树的高度
UFNode find(UFNode node) {
    while (node.parent != null) {
        node = node.parent;
    }
    return node;
}
```


`union` 和 `connected` 方法的时间复杂度都依赖 `find` 方法，而 `find` 方法的时间复杂度**取决于树的高度**。
- 所以并查集算法最终的目标，就是要尽可能**降低树的高度，如果能保持树高为常数**，那么上述方法的复杂度就都是 `O(1)` 了




