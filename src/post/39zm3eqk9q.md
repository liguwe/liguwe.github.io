
# Jupyter、.ipynb、Jupyter Notebook、JupyterLab、uv run 等的概念

`#2026/01/02`


## 目录
<!-- toc -->
 ## 1. 定义 

- **Jupyter**（通常指 Jupyter Notebook 或 JupyterLab）是数据科学和 AI 开发领域的“**实验室**”。
- 你可以把它理解为一个**增强版的 Web 交互式 REPL**。
	- 它不仅仅能运行代码，还能将代码、运行结果（如图像、表格）、数学公式和 Markdown 文档完美融合在一个文件（`.ipynb`）中。

## 2. 为什么 AI 开发离不开它？

### 2.1. 基于“单元格”（Cells）的运行模式

不同于传统的 `.py` 脚本必须从头运行到尾，Jupyter 将代码拆分成一个个独立的单元格。
- **状态保留**：
	- 你在第一个`单元格`定义了一个加载大模型的变量，运行后它会一直驻留在内存里。
- **局部调试**：
	- 你可以只修改和运行第二个单元格的绘图代码，而不需要重新加载耗时几分钟的模型。

### 2.2. 即时可视化

在 Web 开发中，你可能需要启动服务、打开浏览器查看 UI。  
在 Jupyter 中，数据处理后的图表、模型生成的文本直接显示在代码下方。这对于观察 LLM 的 Tokenization 过程或 Loss 曲线非常直观。

### 2.3. 文档与代码合一

正如你现在阅读的 Sebastian Raschka 的书，他的 GitHub 仓库里全是 `.ipynb` 文件。这种格式能让他一边写深入浅出的原理解释（Markdown），一边放上可以直接执行的代码片段。

---

## 3. 📊 Jupyter vs 传统 IDE（如 VS Code/PyCharm）

| **特性**   | **Jupyter (Notebook)** | **传统 IDE (Script)** |
| -------- | ---------------------- | ------------------- |
| **执行流程** | 碎片化、交互式（适合实验）          | 线性执行（适合工程化部署）       |
| **内存状态** | 运行后变量常驻内存              | 程序运行完即释放            |
| **输出展示** | 原位显示图表、多媒体内容           | 命令行输出或弹窗            |
| **核心用途** | 数据探索、模型训练、写教程          | 软件开发、系统构建           |

---

## 4. 🚀 环境相关

既然你已经在搭建 Sebastian Raschka 的环境，Jupyter 是必不可少的。

### 4.1. 安装

在你激活的 `uv` 环境中，安装 JupyterLab：

```
uv pip install jupyterlab
```

### 4.2. 启动

使用 `uv` 运行命令，它会自动在你默认浏览器打开一个交互界面：

Bash

```
uv run jupyter lab
```

## 5. VS Code 里安装 "Jupyter" 扩展

你会发现 VS Code 对 Jupyter 的支持非常好。你不需要在浏览器运行，直接在 VS Code 里安装 "Jupyter" 扩展，就可以像编辑普通代码一样打开 `.ipynb 文件`，同时还能享受 Copilot 的强力辅助

---

## 6. `.ipynb` 到底是什么？

如果你用文本编辑器（如 Sublime 或 VS Code 的文本模式）打开一个 `.ipynb` 文件，你会发现它本质上是一个 **JSON 文件**。

它里面记录了：
- **所有的代码块（Cells）**。
- **所有的渲染文本（Markdown）**。
- **上一次运行的输出结果**（包括报错信息、打印的文本、甚至是图片的二进制数据）。

## 7. 为什么不直接写 `.py`？（AI 开发的特殊性）

在传统的 Web 开发中，代码改了直接热重载（Hot Reload）就行。但在 **大模型开发** 中，有一个非常头疼的问题：**内存挂载**。

### 7.1. 场景对比：

- 如果你写 .py：
	- 每次你修改一行绘图的代码，你都必须重新运行整个脚本。这意味着你需要重新加载几 GB 的模型权重、重新处理一遍数据集。在 M4 芯片上虽然快，但每次等 10-30 秒也会打断思路。
- 如果你写 .ipynb：
	- 你可以把“加载模型”放在第一个单元格，“数据处理”放在第二个。当你修改第三个单元格的绘图逻辑时，模型依然驻留在内存里，点击运行，结果秒出。

**结论：** `.ipynb` 的核心价值在于**保留内存状态**，它是为了“`探索`”和“`调试`”而生的。

## 8. 全栈工程师的最佳实践：混合模式

既然你习惯了编辑器（VS Code），我建议你**不需要**切换到浏览器去用 Jupyter。

### 8.1. 方案 A：在 VS Code 里直接用 Notebook（推荐）

VS Code 内置了完美的 Notebook 支持。

1. 直接打开书中的 `.ipynb` 文件。
2. VS Code 会用类似 Notebook 的 UI 显示它。
3. **好处**：你可以享受 Copilot、代码跳转、以及你熟悉的快捷键，同时拥有“分块运行”的能力。

### 8.2. 方案 B：使用 Python 交互式窗口（Interactive Window）

如果你坚持写 `.py` 文件，但又想要 Notebook 的功能，可以在 `.py` 文件里使用特殊的注释 `#%%`：

```python
`#%%` 加载模型（运行后模型会留在内存）
import torch
model = load_model() 

`#%%` 测试模型（改这里不需要重新加载模型）
output = model("Hello")
print(output)
```

VS Code 会识别 `#%%` 并允许你逐块发送到右侧的交互窗口运行。

## 9. 什么时候该把代码转成 `.py`？

当你的实验结束，代码逻辑已经定型，需要进行以下操作时，请务必转成 `.py`：

1. **版本控制**：`.ipynb` 的 JSON 格式在 Git 里的 `diff` 简直是灾难。
2. **自动化训练**：在服务器上跑长时间的预训练任务。
3. **模块化调用**：当你想封装一个 `tokenizer.py` 给其他服务调用时。

---

## 10. 🛠️ 给你的建议

作为正在读这本书的你：

1. **阅读阶段**：
	- 直接使用 VS Code 打开书中的 `.ipynb`。因为作者 Sebastian 在里面写了大量的原理解释，这比单看代码注释要清晰得多。
2. **练习阶段**：
	- 你可以自己建一个 `playground.ipynb` 来随手测试。
3. **重构阶段**：
	- 当你学完第二章，尝试自己写一个 `data_loader.py`。

## 11. Jupyter Notebook 和 JupyterLab 的区别

简单来说：**Jupyter Notebook 是“文档格式”和“单一编辑器”的代称，而 JupyterLab 是承载它的“下一代集成开发环境（IDE）”。**

作为全栈工程师，你可以把它们的关系类比为：

- **Notebook (.ipynb)**：好比是 **HTML 文件**（底层格式）。
- **Jupyter Notebook (Classic)**：好比是 **Notepad**（只能打开一个文件的简单编辑器）。
- **JupyterLab**：好比是 **VS Code**（可以开多个标签页、有终端、有文件管理器的完整工作站）。

### 11.1. 核心区别：工具 vs 平台

|**特性**|**Jupyter Notebook (经典版)**|**JupyterLab (现代版)**|
|---|---|---|
|**定位**|简单的 Web 页面，一次只能开一个 Notebook|模块化的 IDE，可以在一个窗口管理整个项目|
|**界面**|标签页式（每个文件占一个浏览器标签）|窗口式（类似 IDE，左侧文件树，右侧多页签）|
|**功能集成**|仅限运行代码块|集成终端、Markdown 预览、CSV/图片查看器|
|**扩展性**|插件系统较老且难以管理|拥有非常现代化的扩展系统|

### 11.2. 它们如何协作？

1. **底层文件通用**：无论你用哪一个，操作的都是 `.ipynb` 文件（JSON 格式）。
2. **共用内核（Kernel）**：它们都连接到同一个后台 Python 进程。
3. **官方现状**：Jupyter 官方团队目前已经将开发重心完全转向 **JupyterLab**，它被定位为前者的接班人。

### 11.3. 对全栈工程师来说，JupyterLab 强在哪里？

JupyterLab 的多任务处理能力能让你非常爽：

- **多窗口分屏**：
	- 你可以左边开着 `chapter2.ipynb`（看原理），右边开一个 `playground.ipynb`（自己练手），底部再开一个终端（运行 `pip` 或 `git` 命令）。
- **更好的文件管理**：
	- 左侧有类似 VS Code 的目录树，可以直接拖拽文件。
- **实时 Markdown 预览**：
	- 写文档时可以像编辑器一样实时看到效果。

### 11.4. 关键点：你在 VS Code 里用的是什么？

由于你习惯使用 VS Code，你其实已经**跳过**了这两个工具的纠结。
- 当你在 VS Code 里打开 `.ipynb` 时，VS Code 使用的是它**自己开发的 UI** 来渲染 Notebook。
- 它既不是 JupyterLab 官网那个界面，也不是经典 Notebook 的界面，但功能上涵盖了两者，且完美集成了 VS Code 的插件生态。

### 11.5. 💡 总结与建议

- **如果你想在浏览器里玩**：
	- 直接选 **JupyterLab**。安装命令是 `uv pip install jupyterlab`，启动命令是 `uv run jupyter lab`。
- **如果你想效率最高**：留在 **VS Code**。
    - 你会发现 VS Code 处理 `.ipynb` 比浏览器更流畅。
    - 你可以直接把代码从 `.ipynb` 复制到旁边的 `.py` 文件，或者利用 VS Code 的“交互式窗口”功能。

## 12. `uv run jupyter lab` 和 `jupyter notebook` 这两个启动的命令有什么区别？

由于你使用的是 `uv`，这两个命令不仅启动了界面，还确保了 Jupyter 运行在你当前项目定义的`虚拟环境`中。

### 12.1. 核心区别：IDE 与 单文档

|**特性**|**uv run jupyter lab**|**uv run jupyter notebook**|
|---|---|---|
|**界面定位**|**下一代 IDE（集成开发环境）**|**经典单文档编辑器**|
|**窗口管理**|支持在一个浏览器页签中**分屏、多签**|一个浏览器页签只能打开一个文件|
|**集成工具**|内置终端、文件浏览器、图片查看器|功能单一，专注于代码块运行|
|**推荐人群**|需要同时处理多个脚本、模型、数据的工程师|只需要临时运行一个演示文档的人|

---

### 12.2. `uv run` 在这里的关键作用

不管你后面接的是 `lab` 还是 `notebook`，前缀 `uv run` 对你这个全栈工程师来说非常重要：
- **内核自动匹配**：
	- 它会自动将你的 Python 虚拟环境（`.venv`）注册为 Jupyter 的 **Kernel**。
- **无需重复安装**：
	- 只要你的 `pyproject.toml` 或 `requirements.txt` 里有这些包，`uv run` 就能确保 Jupyter 找得到它们。
- **依赖隔离**：
	- 它不会去污染你 Mac Pro M4 的全局 Python 环境，一切都留在项目目录里。

### 12.3. 对于复刻 Sebastian 代码的你，该选哪个？

既然你现在正在通过**手敲（复刻）**的方式学习，我强烈建议使用：

> **`uv run jupyter lab`**

**原因如下：**
1. **左侧文件树**：你可以一边看着 `data/` 目录里的 `.txt` 文件，一边在 `src/` 里敲代码。
2. **分屏对照**：你可以在 JupyterLab 里左右分栏，左边打开作者的 `ch02.ipynb` 作为参考，右边打开你自己新建的 `my_ch02.ipynb` 手敲。
3. **集成终端**：你可以直接在界面下方的终端里运行 `git status` 或者 `uv pip install`，不需要切换窗口。

---

### 12.4. 💡 进阶：如果你已经在 VS Code 里装了插件

如果你已经安装了前面提到的 **VS Code Jupyter 插件**，你其实**根本不需要**运行这两个命令。

1. 直接在 VS Code 里点击 `.ipynb` 文件。
2. VS Code 会自动询问你使用哪个内核，你选择 `.venv` 下的 Python。
3. **结果**：你获得了一个比 JupyterLab 更快、更符合全栈开发习惯的界面。

## 13. 现在专业选手，使用 vscode 还是使用jupyter lab？

这是一个非常深刻的问题。作为一名**全栈工程师**，你会发现 AI 领域的“专业选手”其实分为两派，但趋势已经非常明显。

**直接给结论**：**现在的“专业选手”（尤其是具备工程背景的机器学习工程师）绝大多数已经全面转向 VS Code（配合 Jupyter 插件）。**

---

### 13.1. 为什么“工程派”专业选手首选 VS Code？

在全栈开发和大模型实战中，代码最终是要跑在生产环境的。VS Code 实现了从“实验室”到“工厂”的无缝切换。

- 混合开发能力（Hybrid Workflow）：
	- 是专业选手最看重的。你可以左边开着 .ipynb 做实验（测试分词逻辑），右边开着 .py 写正式的类（封装 Tokenizer）。
	- 在 VS Code 里，这两个文件共享同一个内核，你可以无缝复制代码。
- 极致的 AI 辅助：
	- 在 VS Code 里，你可以使用 GitHub Copilot 或 Cline (Claude Dev)。当你手敲 GPTDatasetV1 遇到逻辑问题时，AI 可以直接读取你的整个项目上下文提供建议。
	- Jupyter Lab 的插件系统在这方面远逊于 VS Code。
- 调试能力（Debugging）：
	-   Jupyter Lab 的调试器相对简陋。而在 VS Code 中，你可以像调试 Node.js 或 Go 一样，在 Python 代码里打断点、查看变量堆栈、单步执行。
	- 这对理解复杂的滑动窗口切片逻辑非常有帮助。
- 版本控制（Git）：
	-   对于专业选手，代码不在 Git 里等于没写。VS Code 有极致的 Git 集成，配合 nbdime 等工具，可以处理原本很难对比的 .ipynb 文件差异。

---

### 13.2. 谁还在坚持使用 Jupyter Lab？

Jupyter Lab 并没有消失，它在以下场景依然是“专业选手”的选择：
- **纯科研/学术界**：很多论文作者、数学家更喜欢纯粹的、无干扰的文档环境。
- **展示与协作**：如果你在做一个演示，或者需要利用一些复杂的交互式微调插件（ipywidgets），Jupyter Lab 的 Web 端渲染有时更稳定。
- **远程重设备环境**：在一些超大规模算力集群上，管理员可能只开放了网页端的 Jupyter 接口。

---

### 13.3. 对你（Macbook Pro M4 用户）的终极建议

既然你习惯了 Obsidian 的 Markdown 风格，追求手感，且拥有 M4 这种顶级生产力工具，你的最佳组合应该是：**VS Code + Python 交互式窗口（Interactive Window）**。

#### 13.3.1. 为什么这是“大神级”操作？

你不需要新建 `.ipynb` 文件，而是直接新建一个普通的 `.py` 文件，然后利用 `#%%` 注释：
1. **手感一流**：
	- 你在写真正的 `.py` 代码，这符合你全栈工程师的本能。
2. **分块运行**：
	- 点击代码上方的 "Run Cell"，结果会像 Notebook 一样弹出在右侧。
3. **直接复用**：
	- 当你手敲完第二章的所有逻辑，你的代码直接就是一个可以直接被 `import` 的模块，不需要从 Notebook 里导出。
