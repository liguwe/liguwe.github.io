{"8662e1ce-a25e-54f1-aece-1e4b0ef95f05":"\n# 📚 832 之书\n\n\n> 个人博客&播客、知识库、电子书、开源作品合集\n\n## 📆 832 Monthly\n\n> 详见《第一部分 博客》内容 \n\n## 📝 博客\n\n> 详见《第一部分 博客》内容 \n\n## 📕 大前端知识体系\n\n> 详见《第四部分 前端》\n\n结合以往的笔记，利用 GPT 工具，梳理个人所知道的关于大前端的一切，体系化大前端技术知识\n\n## 📗 数据结构、算法、LeetCode\n\n结合以往数据结构与算法笔记和 LeetCode 刷题笔记，利用 GPT 工具，体系化数据结构与算法知识 \n\n## 🧠 通往 AGI 之路\n\n如何使用 AGI 来武装自己，建立 AGI 知识体系\n\n## ☯️ 技术管理之路\n \n沉淀各类研发管理知识及经验，建立研发管理知识体系\n\n## 📺 计算机科学\n\n整合以往学过的计算机相关的所有知识，体系化计算机科学知识\n\n## 🔌 Deeptest\n\n免费开源的端到端 API 设计、调试、测试和管理平台，详见 [Deeptest](https://github.com/deeptest-com/deeptest)\n\n","179c256c-8995-5920-bd91-354ca9525ba9":"\n# 前言\n\n\n> **提示：**另外您也可以在 [语雀](https://www.yuque.com/liguwe/fe) 中阅读本书，阅读体验更佳！\n\n这不是一本入门的书，写这书的**主要目的**是沉淀构建自己的前端知识体系，主要受众是我自己。\n\n前端十年，正赶上了 AGI 时代，和 AGI 好好探讨前端知识，故此书会以问答的形式展开！\n\n> AGI 时代学习和教育的方式将被颠覆 ! \n\n","cbbd6714-90d8-5fdd-b1d9-752f7703954b":"\n# 更新日志\n\n\n## 2024.07.17 周三\n- [ ] 将现代 Web 技术概述、 HTML、CSS 三个章节改成问答的形式\n\n## 2024.07.16 周二\n\n- [x] 发现还是需要聚焦一些，借助 AI，通过问答的方式展开此书\n- [x] 也得益于播客的一些启发，想通过 AI 的方式展开此书\n\n## 2024.07.14 周天\n\n- [ ] ~~HTML 章节完成~~\n- [ ] ~~CSS 章节完成~~\n- [ ] ~~Javascript 章节完成~~\n- [ ] ~~Typescript 章节完成~~\n- [ ] ~~整合之前整理的面试题笔记~~\n\n## 2024.07.12 周五\n\n- [ ] ~~Javascript 大纲整理好~~\n\n## 2024.07.11 周四\n\n- [x] 添加 HTML 章节\n- [x] 添加 CSS 章节\n\n## 2024.07.10 周三\n\n- [x] 添加现代 Web 技术概述章节\n\n## 2024.07.07 周天\n\n- [x] 书籍目录大纲梳理\n- [x] 搭建电子书站点、流水线完成\n\n","a5e5bfd4-aad5-516a-ad20-37b28a4130a5":"\n# 说明\n\n\n点到hello","679808e4-a3f4-5946-b5e0-628526b96e80":"\n# 前言\n\n\n\n前言说明\n\n","bf9d6637-f383-54e8-be49-6f4c1693f2ca":"\n# JAMstack 架构概述\n\n\n##  定义\nJAMstack 是一种现代 Web 开发架构，强调使用 JavaScript、API 和 Markup（标记）来构建高性能和高安全性的 Web 应用。\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ff6bf70189d55690f74889441c4f9ca2.png)\n\n## 产生背景\n**传统的网站架构 ： 无论如何都需要一个实时的在线服务，它在处理这些不怎么变动的内容时，很鸡肋：计算量很小，但是依旧需要大量后端和运维人员维护网站的安全性、稳定性、可伸缩性……**\n\n## JAMstack 的核心概念\n\n### JavaScript\n\n- 用于处理前端逻辑和交互。可以使用各种 JavaScript 框架和库，如 React、Vue.js、Angular 等。\n- JavaScript 代码通常在客户端执行，减少了服务器负担。\n\n### API\n\n- 通过 API 调用来获取动态数据和执行服务器端操作。\n- 可以使用第三方服务（如 Auth0、Stripe、Firebase等）或 自建的 API（如 RESTful API、GraphQL）。\n- API 通常是无状态的，提供了良好的可扩展性和灵活性。\n\n### Markup（标记）\n\n- 使用静态站点生成器（如 Gatsby、Next.js、Hugo、vitepress 等）预生成 HTML 页面。\n- 这些页面在构建时生成，可以直接部署到 CDN，提高加载速度和性能。\n\n## JAMstack 的优势\n\n### 高性能\n\n   - 预生成的静态页面可以通过 CDN 快速分发，减少了服务器响应时间。\n   - 静态资源通常比动态内容加载更快，提高了用户体验。\n\n### 高安全性\n\n   - 减少了服务器端代码的执行，降低了攻击面。\n   - 静态文件不容易受到传统的服务器攻击（如 SQL 注入）。\n\n### 可扩展性\n\n   - 静态站点可以轻松扩展，通过增加新的静态文件和 API 调用来实现更多功能。\n   - API 调用可以根据需要进行扩展和修改，而不影响前端代码。\n\n### 开发效率：\n\n   - 开发者可以专注于前端代码和用户体验，而不需要处理复杂的服务器端逻辑。\n   - 使用现代前端框架和工具链，提高了开发效率和代码质量。\n\n## JAMstack 的劣势\n**业务场景非常狭小，只能用于内容更新不大频繁的 CMS 站点**。国外也有无头电商（Headless Commerce）的商业实践，但是前景并不明朗。\n\n## 常见的 JAMstack 工具和框架\n\n### 静态站点生成器\n\n- **Gatsby**：基于 React 的静态站点生成器，支持 GraphQL 数据查询。\n- **Next.js**：提供静态生成和服务器端渲染（SSR）的混合模式，适用于复杂的 Web 应用。\n- **Hugo**：一个快速、灵活的静态站点生成器，使用 `Go 语言`编写。\n- Jekyll\n- Nuxt.js\n   - 基于Vue.js的框架，支持静态生成和服务器端渲染（SSR）。\n   - 适用于构建复杂的Vue.js应用。\n\n### API 服务\n\n- **Headless CMS**：如 Contentful、Sanity、Strapi，提供内容管理和 API 接口。\n- **服务器端功能**：如 AWS Lambda、Netlify Functions，用于实现无服务器计算。\n   - **正常云服务厂商都有提供，比如用过腾讯云提供serverless服务**\n- **第三方 API**：如 Auth0（身份验证）、Stripe（支付）、Algolia（搜索）。\n\n### 部署和托管：\n\n- **Netlify**：提供静态站点托管、无服务器函数和持续集成（CI/CD）服务。\n- **Vercel**：支持` Next.js` 和其他静态站点的托管，提供无服务器函数和自动部署。\n- **GitHub Pages**：适用于简单的静态站点托管，集成了 GitHub 仓库。\n- **正常云服务产商都有提供这个能力，比如 Amazon、阿里云、腾讯云等**\n\n## JAMstack 的工作流程\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/20b4de6008f7cfc8c07f1d11772e1573.png)\n\n> 其实很类似 [https://elog.1874.cool/notion/vy55q9xwlqlsfrvk](https://elog.1874.cool/notion/vy55q9xwlqlsfrvk) 的思路\n\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/fd45c197b1ed7399ddf97db551d64af0.png)\n\n### 开发阶段\n\n- 使用静态站点生成器（如 Gatsby、Next.js）编写前端代码和模板。\n- **通过 API 获取动态数据，并将其嵌入到静态页面中**。\n- 使用 JavaScript 实现前端交互和动态功能。\n\n### 构建阶段\n\n- 运行构建工具，生成静态 HTML、CSS 和 JavaScript 文件。\n- 预生成的页面文件可以直接部署到 CDN 或静态托管服务。\n\n### 部署阶段\n\n- 将静态文件上传到托管平台（如 Netlify、Vercel）。\n- 配置 CDN 分发，确保全球用户都能快速访问。\n\n### 运行时\n\n- 用户访问网站时，CDN 会提供预生成的静态页面，确保快速加载。\n- 前端 JavaScript 代码在浏览器中执行，调用 API 获取和更新数据。\n- 无服务器函数处理特定的服务器端任务，如表单提交、身份验证等。\n\n## 使用 JAMstack 的场景\n\n### 博客和内容网站\n\n   - 使用 Headless CMS 管理内容，通过静态站点生成器生成 HTML 页面。\n   - 预生成的页面通过 CDN 分发，提供快速的阅读体验。\n\n### 电商网站\n\n   - 产品信息和库存通过 API 获取，前端使用 JavaScript 实现购物车和结账功能。\n   - 静态页面展示产品列表和详情，提高页面加载速度。\n\n### 企业官网\n\n   - 静态页面展示公司信息、服务和案例，减少服务器负担。\n   - 表单提交和用户交互通过无服务器函数处理。\n\n## 总结\nJAMstack 通过将 JavaScript、API 和 Markup 结合起来，提供了一种高效、安全和可扩展的 Web 开发架构。它适用于各种类型的 Web 应用，从简单的博客到复杂的电商网站。通过使用现代工具和框架，开发者可以快速构建和部署高性能的 Web 应用，提供卓越的用户体验。\n","009e8dcb-769b-5ac4-a8ea-c4e753cf9100":"\n# Web 技术新兴技术和标准\n\n\n现代 Web 技术中，新兴技术和标准正在推动 Web 开发领域的创新和进步。以下是一些主要的新兴技术和标准的详细介绍：\n\n## WebAssembly (Wasm)\n\n### 定义\nWebAssembly 是一种新的二进制指令格式，设计用于浏览器中的高性能执行。它是一种低级、类似于汇编语言的格式，可以与 JavaScript 一起使用。\n\n### 特点\n\n- **高性能**：接近原生代码的执行速度，适用于需要高计算性能的应用。\n- **跨平台**：在不同的操作系统和设备上运行一致。\n- **语言无关**：支持多种编程语言，如 C、C++、Rust 等。\n\n### 应用场景\n\n- **游戏开发**：高性能的图形渲染和计算。\n- **图像和视频处理**：实时的图像编辑和视频编码。\n- **科学计算**：复杂的数学运算和模拟。\n\n## WebXR\n\n### 定义\nWebXR 是一种用于构建虚拟现实（VR）和增强现实（AR）体验的标准 API。它是 WebVR 的扩展，提供了更广泛的功能和更好的性能。\n\n### 特点\n\n- **跨设备支持**：支持多种 VR 和 AR 设备，如 Oculus Rift、HTC Vive、Microsoft HoloLens 等。\n- **高性能**：优化了渲染和交互的性能，提供沉浸式体验。\n- **易于集成**：与现有的 Web 技术（如 WebGL）无缝集成。\n\n### 应用场景\n\n- **游戏和娱乐**：沉浸式游戏和虚拟旅游。\n- **教育和培训**：虚拟实验室和模拟训练。\n- **电商和营销**：虚拟试衣间和产品展示。\n\n## 机器学习和 AI \n\n### TensorFlow.js 和 ml5.js\n\n- **TensorFlow.js**：一个用于在浏览器中运行机器学习模型的库。支持训练和推理，允许开发者直接在客户端进行机器学习操作。\n- **ml5.js**：基于 TensorFlow.js 的高级库，提供了简单易用的 API，用于实现常见的机器学习任务。\n\n### 特点\n\n- **实时处理**：在浏览器中实时运行机器学习模型，无需服务器端处理。`** ===> 端侧模型**`\n- **隐私保护**：数据在本地处理，减少了隐私泄露的风险。\n- **易于使用**：提供了丰富的预训练模型和简化的 API，降低了机器学习的入门门槛。\n\n### 应用场景\n\n- **图像识别**：实时的图像分类和对象检测。\n- **自然语言处理**：文本分类、情感分析和翻译。\n- **推荐系统**：个性化推荐和内容过滤。\n\n## HTTP/3\n\n### 定义\nHTTP/3 是 HTTP 协议的最新版本，基于 QUIC 协议（Quick UDP Internet Connections）。它旨在提高 Web 的传输效率和可靠性。\n\n### 特点\n\n- **基于 UDP**：使用 `UDP` 代替 TCP，减少了连接建立的延迟。\n- **多路复用**：在一个连接中同时传输多个数据流，避免了“队头阻塞”问题。\n- **内置加密**：默认使用 TLS 1.3 提供安全传输。\n\n### 优势\n\n- **更快的连接建立**：减少了握手时间，提高了页面加载速度。\n- **更好的性能**：在高延迟和丢包环境下表现更好。\n- **增强的安全性**：内置加密提供了更强的安全保障。\n\n> HTTP 章节会展开聊\n\n## WebRTC\n\n### 定义\nWebRTC（Web Real-Time Communication）是一个支持浏览器和移动应用进行实时通信的开源项目。它**允许音频、视频和数据的直接传输，无需中介服务器。**\n\n### 特点\n\n- **点对点通信**：**直接在客户端之间传输数据，减少了延迟**。\n- **跨平台支持**：在不同浏览器和设备上运行一致。\n- **高质量传输**：支持高质量的音频和视频传输。\n\n### 应用场景\n\n- **视频会议**：实时的视频通话和会议。\n- **在线教育**：实时的教学和互动。\n- **游戏和娱乐**：实时的多人游戏和互动体验。\n\n## Progressive Web Apps (PWA)\n\n### 定义\n渐进式 Web 应用（PWA）是一种结合了 Web 和本地应用优点的新型应用形式。PWA 使用现代 Web 技术提供类似本地应用的用户体验。\n\n### 特点\n\n- **离线访问**：通过 `**Service Worker**` 实现离线缓存。\n- **推送通知**：支持推送通知，保持用户互动。\n- **安装到主屏幕**：用户可以将 PWA 安装到主屏幕，像本地应用一样使用。\n\n### 优势\n\n- **跨平台**：在不同操作系统和设备上运行一致。\n- **无需安装**：用户通过浏览器访问，无需下载和安装。\n- **自动更新**：应用更新自动推送到用户，无需手动操作。\n\n## JAM stack 架构\n> 下文有详细介绍\n\n### 定义\nJAM 代表 JavaScript、APIs、Markup。\n\n- JavaScript 是网络应用程序使用的编程语言\n- API（应用程序编程接口）是一种从别人的程序或应用程序中请求数据的方式\n- Markup 是向浏览器提供格式化指示的代码（HTML 和 CSS）。\n\nJAMstack 是一种现代 Web 开发架构，强调客户端 JavaScript、可重用 API 和预构建标记（Markup）。它旨在提高 Web 应用的性能、安全性和可扩展性。\n\n### 特点\n\n- **静态生成**：使用静态站点生成器（如 Gatsby、Next.js）预构建页面，提高加载速度。\n- **无服务器**：通过 API 调用实现动态功能，减少服务器管理。\n- **分离关注点**：前端和后端分离，前端通过 API 获取数据。\n\n### 优势\n\n- **高性能**：静态页面加载速度快，用户体验好。\n   - 因为：**JAMstack 应用程序中的几乎所有内容都由从 CDN 提供的静态 HTML 文件组成**\n- **高安全性**：减少了服务器攻击面，提高了安全性。\n- **易于扩展**：通过 API 扩展功能，灵活性高。\n   - 由于 JAMstack 前端速度快且后端轻量化，因此 JAMstack 应用程序通常具有极强的可扩展性。\n\n这些新兴技术和标准正在推动 Web 开发的不断进步，提供了更高的性能、更好的用户体验和更强的开发灵活性。了解和掌握这些技术对于现代 Web 开发者来说至关重要。\n","69ec52e4-d0d7-5368-bf90-36cee232421d":"\n# Web 技术有哪些？\n\n`**Web 技术**`是用于创建和维护 Web 应用、网站和 Web 服务的一组技术和标准。以下是一些主要的 Web 技术及其相关概念：\n\n# 前端技术\n前端技术主要用于构建用户界面和用户体验，涉及到网页的结构、样式和交互功能。\n\n1. **HTML (HyperText Markup Language)**：\n   - 用于定义网页的结构和内容。\n   - HTML 标签用于标记文本、图像、链接等元素。\n2. **CSS (Cascading Style Sheets)**：\n   - 用于控制网页的外观和布局。\n   - 通过样式规则定义元素的颜色、字体、排版等。\n3. **JavaScript**：\n   - 一种脚本语言，用于实现网页的动态功能和交互效果。\n   - 可以操作 HTML 和 CSS，实现动画、表单验证、动态内容加载等功能。\n4. **前端框架和库**：\n   - **React**：由 Facebook 开发的 JavaScript 库，用于构建用户界面。\n   - **Angular**：由 Google 开发的前端框架，用于构建复杂的单页应用。\n   - **Vue.js**：一个渐进式 JavaScript 框架，易于集成和使用。\n5. **AJAX (Asynchronous JavaScript and XML)**：\n   - 用于在不重新加载整个页面的情况下与服务器进行异步数据交换。\n   - 常用于动态内容更新和后台数据加载。\n\n> 后面章节都会展开\n\n\n# 后端技术\n后端技术主要用于处理业务逻辑、数据存储和服务器端的操作。\n\n1. **服务器端编程语言**：\n   - **Node.js**：基于 JavaScript 的服务器端运行环境，适用于构建高性能网络应用。\n   - **Python**：常用于 Web 开发的语言，框架如 Django 和 Flask。\n   - **Ruby**：用于 Web 开发的语言，框架如 Ruby on Rails。\n   - **PHP**：广泛应用于 Web 开发的语言，特别是内容管理系统（如 WordPress）。\n   - Java\n   - Golang \n   - 等\n2. **数据库**：\n   - **关系型数据库**：如 MySQL、PostgreSQL，使用 SQL 进行数据查询和操作。\n   - **NoSQL 数据库**：如 MongoDB、Cassandra，适用于处理大规模和非结构化数据。\n3. **Web 框架**：\n   - 提供结构化的开发环境和工具，简化 Web 应用的开发过程。\n   - 常见的框架如 Express (Node.js)、Django (Python)、Rails (Ruby)。\n4. **API (Application Programming Interface)**：\n   - 用于客户端和服务器之间的数据交换。\n   - 常见的 API 形式有 RESTful API 和 GraphQL。\n\n# 协议和标准\n\n1. **HTTP/HTTPS (HyperText Transfer Protocol / Secure)**：\n   - 用于在浏览器和服务器之间传输数据。\n   - HTTPS 是 HTTP 的安全版本，使用 SSL/TLS 加密数据传输。\n2. **WebSocket**：\n   - 一种全双工通信协议，允许客户端和服务器之间的实时数据交换。\n   - 常用于实时聊天、在线游戏等应用。\n3. **REST (Representational State Transfer)**：\n   - 一种架构风格，用于设计网络应用的 API。\n   - 基于 HTTP 协议，使用标准的 HTTP 方法（如 GET、POST、PUT、DELETE）。\n4. **GraphQL**：\n   - 由 Facebook 开发的一种查询语言，用于 API 数据查询。\n   - 允许客户端指定所需的数据结构，减少冗余数据传输。\n\n# 开发工具套件和环境\n\n1. **版本控制系统**：\n   - **Git**：用于跟踪代码变更和协作开发的版本控制系统。\n   - **GitHub/GitLab**：基于 Git 的代码托管平台，提供协作和项目管理工具。\n2. **集成开发环境（IDE）和代码编辑器**：\n   - **Visual Studio Code**：流行的代码编辑器，支持多种编程语言和扩展。\n   - **WebStorm**：专为 Web 开发设计的 IDE，提供强大的代码编辑和调试功能。\n3. **构建工具和包管理器**：\n   - **Webpack**：用于打包 JavaScript 模块和资源的构建工具。\n   - **npm/yarn**：JavaScript 包管理器，用于管理项目依赖。\n\n综上所述，Web 技术涵盖了从前端到后端、从协议到工具的广泛领域，支持构建功能丰富、性能优异的 Web 应用。\n","354a8979-3b17-5390-9913-9d16653f6c72":"\n# 什么是 Web 应用（Web Application）？\n\n\n是一种通过 `web 浏览器`访问的应用程序。它利用 `Web 技术`和标准来执行任务，通常包括与用户交互、数据处理和存储等功能，用户可以通过浏览器访问，无需下载或安装。它通常采用`客户端（浏览器）-服务器架构（即B/S架构）`，客户端是用户的浏览器，服务器是提供应用逻辑和数据存储的远程计算机。\n\n**特点：**\n\n- 浏览器访问，无需额外下载或安装软件\n- 动态内容：根据用户输入可显示不同内容\n- 交互性：javascript 来支持\n- 跨平台：因为浏览器而跨平台，支持不同操作系统和设备（如 PC、手机、平板）\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/34cffa574854ba3eac6cd1e59a715885.png)\n","f016526f-a9b4-5d12-aaed-bd75dc907d9e":"\n# 什么是万维网（World Wide Web）？\n\n\n- 一般称其为 `WWW`、`W3` 或 `the Web` 或 `Web` \n- 是一个基于`**超文本和多媒体技术**`的全球信息空间。它允许用户通过互联网访问和共享文本、图像、视频和其他形式的信息\n- 它经历以下三个阶段\n   - Web 1.0：早期的静态网页，主要用于信息展示。\n   - Web 2.0：引入用户生成内容和交互功能，如博客、社交媒体、维基等。\n   - Web 3.0：也称为语义网，旨在通过机器学习和人工智能提高信息的关联性和可用性\n\n> Web 与互联网不一样：Web 是建立在互联网之上的许多应用程序之一\n\n","ef7de748-a0ce-5966-b213-329e33d4a31c":"\n# 什么是互联网？\n\n\n- 解释一：互联网（Internet）是一个全球性的计算机网络系统，通过一系列`**标准化的通信协议（如 TCP/IP）**`将世界各地的计算设备连接在一起。它允许用户在全球范围内共享和访问信息、资源和服务。\n- 解释二：互联网是一个通过`**标准化通信协议**`将全球计算设备连接在一起的网络系统，具有信息共享、电子邮件、在线搜索、社交媒体、电子商务和云计算等多种功能\n","b2eda488-9981-59a5-8458-eff5d15ed64f":"\n# 前端技术关键词\n\n> 以下是一些`**相对不过时的前端技术关键词**`及其简要介绍\n\n## React 和 React Hooks\n\n- **React**：一个由 Facebook 开发的用于构建用户界面的 JavaScript 库。它的虚拟 DOM 和组件化设计使其非常受欢迎。\n- **React Hooks**：React 16.8 引入的一组新特性，允许在函数组件中使用状态和其他 React 特性，如 `useState`、`useEffect` 等。\n\n## Vue 3\n\n- **Vue.js**：一个用于构建用户界面的渐进式 JavaScript 框架。Vue 3 引入了 Composition API、性能改进和更好的 TypeScript 支持。\n\n## Svelte 和 SvelteKit\n\n- `**Svelte**`：一个新的前端框架，与传统框架不同，**Svelte 在编译时将组件转换为高效的命令式代码，而不是在运行时解释代码**。\n   - Svelte 是一种全新的构建用户界面的方法。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建应用程序的编译阶段来处理。\n   - Svelte 在 `构建/编译阶段` 将你的应用程序转换为理想的 JavaScript 应用，而不是在`运行阶段` 解释应用程序的代码。这意味着你不需要为框架所消耗的性能付出成本，并且在应用程序首次加载时没有额外损失。\n- `**SvelteKit**`：一个用于构建 Svelte 应用的全栈框架，支持服务器端渲染、静态站点生成等功能。\n\n## Next.js 和 Nuxt.js\n\n- **Next.js**：一个基于 `React` 的框架，支持服务器端渲染（SSR）、静态站点生成（SSG）和增量静态再生（ISR）。\n- **Nuxt.js**：一个基于 `Vue.js` 的框架，提供类似的功能，如 SSR 和 SSG。\n\n## JAMstack\n\n- **JAMstack**：一种现代 Web 开发架构，强调使用 JavaScript、API 和 Markup。常用工具包括静态站点生成器（如 Gatsby、Next.js）和无服务器函数（如 Netlify Functions）。\n\n> 前文提到过\n\n## WebAssembly (Wasm)\n\n- **WebAssembly**：一种新的二进制指令格式，设计用于在浏览器中实现高性能应用。它允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，并在浏览器中运行。\n\n## TypeScript\n\n- **TypeScript**：微软开发的一种 JavaScript 的超集，增加了类型检查和其他特性。TypeScript 近年来在前端开发中变得非常流行，尤其是在大型项目中。\n\n## GraphQL\n\n- **GraphQL**：由 Facebook 开发的一种用于 API 的查询语言，允许客户端指定所需的数据结构。与传统的 REST API 相比，GraphQL 提供了更高效的数据获取方式。\n\n## Tailwind CSS\n\n- **Tailwind CSS**：一个实用优先的 CSS 框架，允许开发者直接在 HTML 中使用类名来应用样式。它的灵活性和可定制性使其在前端开发中越来越受欢迎。\n\n> 有点类似于之前的 `bootstrap`\n\n## Headless CMS\n\n- **Headless CMS**：一种内容管理系统，只提供内容管理的后台，通过 API 提供内容，而不负责前端展示。常见的 Headless CMS 有 Contentful、Strapi 和 Sanity。\n\n## Progressive Web Apps (PWA)\n\n- **PWA**：渐进式 Web 应用，通过使用现代 Web 技术（如 `Service Worker` 和 `Web App Manifest`）提供类似本地应用的体验，包括`离线访问`和`推送通知`\n\n## 微前端：Micro Frontends \n\n- **Micro Frontends**：一种将前端应用拆分为多个小型、独立的模块的架构，每个模块可以独立开发、部署和运行。\n\n## Web Components\n\n- **Web Components**：一组标准技术，允许开发者创建可重用的自定义 HTML 元素。包括 Custom Elements、Shadow DOM 和 HTML Templates。\n\n## Server-side Rendering (SSR) 和 Static Site Generation (SSG)\n\n- **SSR** 和 **SSG**：通过在服务器端生成 HTML，提高了页面加载速度和 SEO 性能。Next.js 和 Nuxt.js 都支持这些功能。\n\n## Modern Build Tools\n\n- **Webpack**、**Rollup**、**Parcel** 和 **Vite**：现代 JavaScript 构建工具，提供代码打包、模块化和性能优化等功能。\n\n## WebRTC\n\n- **WebRTC**：一种支持浏览器和移动应用进行实时通信（如视频、音频、数据传输）的技术。它使得开发者可以构建视频会议、实时聊天和 P2P 文件共享等应用。\n\n## WebSockets\n\n- **WebSockets**：一种在客户端和服务器之间建立持久连接的协议，允许双向通信。适用于实时应用，如在线游戏、实时聊天和实时更新的仪表盘。\n\n## Service Workers\n\n- **Service Workers**：一种在后台运行的脚本，能够拦截和处理网络请求，提供离线支持、缓存管理和推送通知等功能，是 PWA 的核心技术之一。\n\n## Single Page Applications (SPA)\n\n- **SPA**：单页应用，通过动态加载内容和更新 URL 实现不重新加载整个页面的用户体验。常用框架包括 React、Vue.js 和 Angular。\n\n## Microservices Architecture：微服务架构\n\n- **Microservices**：将应用拆分为一组小的、独立部署的服务，每个服务负责特定的业务功能。前端可以通过 API 网关或服务编排与这些微服务进行交互。\n\n## APIs and Backend for Frontend (BFF)\n\n- **BFF**：一种设计模式，为每个前端应用（如 Web、移动）创建专门的后端服务，优化 API 调用和数据处理。\n\n## 状态管理库：State Management Libraries\n用于数据流管理的！\n\n- **Redux**：一个流行的 JavaScript 状态管理库，常与 React 一起使用。\n- **MobX**：另一种状态管理库，基于响应式编程，适用于需要更灵活状态管理的应用。\n- **Recoil**：Facebook 开发的状态管理库，专为 React 设计，提供更好的性能和开发体验。\n- vuex\n- pinia\n- umi/dva\n\n## Component Libraries and Design Systems：组件库&设计系统\n\n- **Material-UI**：基于 Google 的 Material Design 规范的 React 组件库。\n- **Ant Design**：一个企业级的 UI 设计语言和 React 组件库。\n- **Chakra UI**：一个简单、模块化且可访问的 React 组件库。\n\n## Serverless Architecture\n\n- **Serverless**：一种云计算模型，开发者只需编写代码而无需管理服务器。常用的服务包括 AWS Lambda、Azure Functions 和 Google Cloud Functions。\n- 国内各个云商也都有提供\n\n## Static Site Generators (SSG)\n\n- **Gatsby**：基于 React 的静态站点生成器，支持 GraphQL 数据层。\n- **Hugo**：一个用 Go 语言编写的静态站点生成器，构建速度非常快。\n- **Eleventy**：一个简单灵活的静态站点生成器，支持多种模板语言。\n\n## CSS-in-JS\n\n- **Styled Components**：一种将 CSS 直接写在 JavaScript 中的技术，提供组件级的样式隔离。\n- **Emotion**：一个高性能的 CSS-in-JS 库，支持标签模板和对象样式。\n\n## Modern CSS Features\n\n- **CSS Grid**：一种用于创建二维布局的 CSS 布局系统。\n- **CSS Variables**：也称为自定义属性，允许定义可重用的值。\n- **Flexbox**：一种用于创建一维布局的 CSS 布局系统。\n\n## Web Animations API\n\n- **Web Animations API**：一种用于在 Web 上创建高性能动画的 API，提供了对动画的精细控制。\n\n## Web Components \n\n- **LitElement**：一个用于构建 Web Components 的轻量级库，简化了自定义元素的创建。\n- **Stencil**：一个用于构建高性能 Web Components 的编译器，支持 TypeScript 和 JSX。\n\n## Testing Frameworks and Tools\n\n- **Jest**：一个由 Facebook 开发的 JavaScript 测试框架，支持快照测试和并行测试。\n- **Cypress**：一个用于端到端测试的现代 JavaScript 测试框架，提供了直观的 API 和强大的调试功能。\n- **Playwright**：一个用于端到端测试的工具，由 Microsoft 开发，支持多种浏览器。\n\n## Web Vitals\n\n- **Web Vitals**：一组由 Google 定义的指标，用于衡量和优化 Web 性能，包括 Largest Contentful Paint (LCP)、First Input Delay (FID) 和 Cumulative Layout Shift (CLS)。\n\n## 边缘计算：Edge Computing\n\n- **Edge Computing**：一种在`**靠近数据源的地方**`进行计算和数据处理的技术，减少了延迟，提高了性能。常见的服务包括 Cloudflare Workers 和 AWS Lambda@Edge。\n\n## Low-Code/No-Code Platforms\n\n- **Low-Code/No-Code**：一种通过图形化界面和拖放组件来构建应用的开发方式，降低了开发门槛。常见平台包括 OutSystems、Mendix 和 Webflow。\n\n## Remote Procedure Calls (RPC)\n\n- RPC：通过网络调用远程服务的方法，常见实现有 `gRPC`，适用于高性能的前后端通信。\n\n## Module Federation：模块联邦\nModule Federation：Webpack 5 的新特性，支持在不同应用之间动态加载模块，适用于微前端架构。\n\n## 增量静态再生（Incremental Static Regeneration, ISR）\n增量静态再生（Incremental Static Regeneration, ISR）是 Next.js 提供的一种功能，结合了静态站点生成（Static Site Generation, SSG）和服务器端渲染（Server-Side Rendering, SSR）的优点。它允许开发者在构建时生成静态页面，并在运行时按需更新这些页面，从而实现高性能和最新数据的平衡。\n\n> 随着技术的不断发展，前端开发领域将继续涌现出更多的东西\n\n## Storybook\n\n- 介绍：用于开发和测试UI组件的工具。\n- 特点：独立环境、组件文档、交互测试。\n\n## 参考\n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [web 入门 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web)\n- [Web 和 Web 标准 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/The_web_and_web_standards)\n- [万维网 - MDN Web 文档术语表：Web 相关术语的定义 | MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/World_Wide_Web)\n- [万维网是如何工作的 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/How_the_Web_works)\n- [什么是 JAMstack？](https://www.cloudflare.com/zh-cn/learning/performance/what-is-jamstack/)\n- [什么是JAMStack前端架构](https://juejin.cn/post/6999897855695683614)\n- [前端知识图谱](https://f2e.tech/mindmap?)\n\n","2dacd803-f201-58b7-b2a8-4c6d14dc9f9a":"\n# 现代 Web 技术有哪些变化和趋势？\n\n\n现代 Web 技术正在不断发展，以适应用户需求和技术进步。以下是一些主要的变化和趋势：\n\n# 前端技术的演变\n\n1. **单页应用（SPA）**：\n   - 单页应用通过动态加载内容，使用户体验更加流畅。常用框架有 React、Angular 和 Vue.js。\n   - 使用`**虚拟 DOM 技术**`，提高了性能和响应速度。\n2. **渐进式 Web 应用（PWA）**：\n   - **PWA** 结合了 Web 应用和本地应用的优点，提供离线访问、推送通知和安装到主屏幕等功能，使 Web 应用具有更好的性能和用户体验。\n   - 通过` Service Worker` 实现离线缓存和后台同步。\n3. **Web 组件**：\n   - Web 组件是一种封装 HTML、CSS 和 JavaScript 的技术，允许开发者创建`**可重用的自定义元素**`。\n   - 标准技术包括 `Custom Elements`、`Shadow DOM` 和 `HTML Templates`。\n4. **CSS-in-JS**：\n   - 将 CSS 样式直接写在 JavaScript 中，方便样式的动态生成和管理。\n   - 常用库有 `styled-components` 和 `Emotion`。\n\n# 后端技术的演变\n\n1. **无服务器架构（Serverless Architecture）**：\n   - 开发者可以将代码部署到云服务提供商（如 AWS Lambda、Azure Functions），无需管理服务器。\n   - 按需收费，自动扩展，适合事件驱动的应用程序。\n2. **微服务架构**：\n   - 将大型应用拆分为多个小型、独立的服务，每个服务负责单一功能。\n   - 提高了应用的可扩展性和维护性，常用技术包括 Docker 和 Kubernetes。\n3. **GraphQL**：\n   - 由 Facebook 开发的一种查询语言，允许客户端指定所需的数据结构。\n   - 减少了冗余数据传输，提高了数据获取的灵活性和效率。\n\n# DevOps 和 CI/CD\n\n1. **持续集成和持续部署（CI/CD）**：\n   - 自动化代码测试、构建和部署流程，提高了开发效率和代码质量。\n   - 常用工具有` Jenkins`、`GitHub Actions`、`GitLab CI/CD`。\n2. **容器化和编排**：\n   - 使用 Docker 将应用打包成独立的容器，确保在不同环境中的一致性。\n   - 使用 `Kubernetes` 管理和编排容器，提供自动扩展、负载均衡和故障恢复。\n\n# 安全和性能优化\n\n1. **内容安全策略（CSP）**：\n   - 通过设置 HTTP 头，防止跨站脚本攻击（XSS）和数据注入攻击。\n   - 限制资源加载的来源，提高应用的安全性。\n2. **HTTP/2 和 HTTP/3**：\n   - HTTP/2 提供多路复用、头部压缩和服务器推送，显著提高了 Web 性能。\n   - HTTP/3 基于 `QUIC 协议`，进一步减少了延迟和提高了传输效率。\n3. **Web 性能优化**：\n   - 使用懒加载（Lazy Loading）和代码分割（Code Splitting）减少初始加载时间。\n   - 通过使用 CDN（内容分发网络）加速资源传输。\n\n# 新兴技术和标准\n\n1. **WebAssembly (Wasm)**：\n   - 一种新的二进制指令格式，允许开发者用 C、C++、Rust 等语言编写高性能的 Web 应用。\n   - 提高了 Web 应用的计算性能，适用于游戏、图像处理等高性能需求的应用。\n2. **WebXR**：\n   - 用于构建虚拟现实（VR）和增强现实（AR）应用的标准 API。\n   - 提供了在 Web 浏览器中体验沉浸式内容的能力。\n3. **机器学习和 AI**：\n   - `TensorFlow.js` 和 `ml5.js` 等库使得在浏览器中进行机器学习和人工智能应用成为可能。\n   - 实现图像识别、自然语言处理等功能，增强用户体验。\n\n> 下文还有详细介绍\n\n\n# 用户体验和设计\n\n1. **响应式设计**：\n   - 使用媒体查询和弹性布局，使网页在不同设备上都有良好的显示效果。\n   - 提高了移动设备用户的体验。\n2. **无障碍设计**：\n   - 确保 Web 应用对所有用户，包括残障人士，都具有可访问性。\n   - 遵循 WAI-ARIA 标准，提供语义化的 HTML 标签和辅助功能。\n\n综上所述，现代 Web 技术在前端、后端、DevOps、安全、性能优化、新兴技术和用户体验等方面都发生了显著变化。这些技术的进步不仅提升了 Web 应用的功能和性能，还大大改善了开发者的工作流程和用户的使用体验。\n","e5ca3e53-adb6-5ebf-9422-93c4aad3a96e":"\n# 现代 Web 技术概述\n\n现代 web 技术概述\n","d59b94d5-8cf0-5b26-bada-e0d1dd01703f":"\n# HTML 标签与 HTML 属性\n\n\n# 说说 `<meta>` 标签的用处？\n使用 `<meta>` 标记 Metadata \n> 更多参考：[https://web.dev/learn/html/metadata?hl=zh-cn](https://web.dev/learn/html/metadata?hl=zh-cn)\n\n\n# 标签语义化是什么意思？\n每个标签都有语义，需要注意使用场景，比如下图：\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/acc28644f26ef7363764d208cbc08ba3.png)\n\n# 列举一些不常用但特别有用的标签\n\n## abbr：缩写 abbreviation\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/dd23fcc1f51d799987d70f160ed51031.png)\n\n## 展示计算机代码\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3949d49f5800384366ecff6d88bc091b.png)\n\n> 所以不只有`pre/code` ，但其他确实不太常用\n\n\n\n## 对话框\n```html\n<dialog open>\n  <p>Greetings, one and all!</p>\n  <form method=\"dialog\">\n    <button>OK</button>\n  </form>\n</dialog>\n```\n\n## 其他：HTML 元素，多看 MDN\n\n> **这里只是强调您可能还有很多标签元素没有使用过，建议多多参考文档**\n\n\n> 更多参考： [<a>：锚元素 - HTML（超文本标记语言） | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a) \n\n\n\n# 说说HTML 属性有哪些类型？\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e5d1702720265eaec8f3a3af0dce9349.png)\n\n又分`布尔属性`、`枚举属性`、`全局属性`及`自定义属性`，可见下面代码示例\n```html\n<input required>\n<section id=\"reg\"/>\n<blockquote data-machine-learning=\"workshop\"></blockquote>\n```\n\n> 更多可参考：[网页元素的属性](https://wangdoc.com/html/attribute)\n\n\n# 列举多媒体嵌入相关的标签\n\n- 常见标签为`<img> 、<video> 、<audio>、、<iframe>、<embed> 、 <object>、<track>、<param>`\n   - 可插入如图片、视频、音频、网页、字幕\n- `<embed>` 和 `<object>` : 可嵌入各类资源，如音频、视频、pdf 文件等\n\n> 更多参考：\n> - [多媒体与嵌入 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding)\n> - [多媒体标签](https://wangdoc.com/html/multimedia#embed)\n\n\n","5e26f455-db82-5500-a6a5-132904ae7b95":"\n# HTML 概述\n\n\n# 什么是 HTML？\n- HTML 的全名是“超文本标记语言”（HyperText Markup Language），可以说有了它，才有互联网的**内容**。\n- 它是用于构建网页的基本语言，用于定义网页的结构和内容\n- 任何网站的请求，第一个请求回来的资源就是`.html` 文件。\n\n# HTML 元素基本格式\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/5807dd04c7c94cbf0070e1ea5ec7d024.png)\n\n# HTML 基本结构\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>页面标题</title>\n  </head>\n  <body>\n    <h1>欢迎</h1>\n    <p>这是一个段落。</p>\n  </body>\n</html>\n```\n\n","1db74294-ed13-5bc5-886d-37e6c490333b":"\n# HTML 模板语言\n\n\nHTML 模板语言是一种用于生成动态 HTML 内容的工具，通常用于 Web 开发中以简化和自动化 HTML 代码的生成，比如\n\n- `Handlebars.js` ，适用于前端和后端渲染\n- `Nunjucks`，适用于前端和后端渲染\n- `pug/ejs` ，适用于 nodejs\n- 还有 \n   - php：`smarty `\n   - java：`jsp / Velocity`\n","daa0da12-8db8-55a1-9758-825b2d328309":"\n# HTML 篇\n\n\n\n# 参考\n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [web.dev](https://web.dev/learn/html/welcome?continue=https%3A%2F%2Fweb.dev%2Flearn%2Fhtml&hl=zh-cn#article-https://web.dev/learn/html/welcome&hl=zh-cn)\n- [HTML 语言简介](https://wangdoc.com/html/intro#%E6%A0%87%E7%AD%BE)\n- [HTML 简介 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML)\n- [https://whatwg-cn.github.io/html/](https://whatwg-cn.github.io/html/)\n- [https://whatwg.org/?locale=zh_CN](https://whatwg.org/?locale=zh_CN)\n- [https://html.spec.whatwg.org/?locale=zh_CN](https://html.spec.whatwg.org/?locale=zh_CN)\n- [ARIA - 无障碍 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/ARIA)\n","ea000c2e-9a7b-5752-8c14-43755c8ea93e":"\n# 什么是 Web Components？\n\n\nWeb 组件标准由三部分组成：[HTML 模板](https://developer.mozilla.org/docs/Web/Web_Components/Using_templates_and_slots)、[自定义元素](https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements) 和 [Shadow DOM](https://developer.mozilla.org/docs/Web/Web_Components/Using_shadow_DOM)\n\n> 更多参考：[Web Component - Web API | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components)\n> 后面会有独立章节单独讲这块\n\n\n","50b74831-78e0-5f08-9182-5dd8ef9167e3":"\n# 列举一些HTML 技术关键词\n\n\n# 列举一些HTML 技术关键词（Sonnet）\n关于HTML技术，以下是一些关键词和概念：\n\n1. 语义化标签：如header, nav, main, article, section, aside, footer等\n2. 表单元素：input, select, textarea, button等\n3. 多媒体标签：audio, video, canvas, svg\n4. 元数据：meta标签，用于定义页面的各种元数据\n5. 响应式设计：使用viewport meta标签和媒体查询\n6. 无障碍性（Accessibility）：使用aria属性，alt文本等\n7. 结构化数据：使用microdata, RDFa, JSON-LD等\n8. 离线Web应用：使用manifest文件（现在更多使用Service Workers）\n9. 本地存储：localStorage, sessionStorage\n10. **拖放API：drag and drop**\n11. 地理定位：Geolocation API\n12. Web Workers：用于在后台运行脚本\n13. WebSockets：用于实时双向通信\n14. 跨文档消息传递：postMessage API\n15. 内容安全策略（CSP）：用于防止XSS攻击\n16. 自定义数据属性：data-*属性\n17. 模板：template标签\n18. **图片响应式：srcset和sizes属性**\n19. 延迟加载：使用loading=\"lazy\"属性\n20. 表单验证：使用pattern, required等属性\n21. 输入类型：如date, time, email, url等\n22. 字符编码：使用UTF-8\n23. DOCTYPE声明：\n24. 语言声明：lang属性\n25. 链接关系：rel属性，如stylesheet, icon等\n26. 跨域资源共享（CORS）：通过HTTP头部控制\n27. 内容可编辑：contenteditable属性\n28. 自动完成：autocomplete属性\n29. 页面可见性API：用于检测页面是否可见\n30. 历史API：用于操作浏览历史\n\n这些关键词涵盖了HTML的基本结构、新特性、API以及与Web开发相关的重要概念。它们反映了现代HTML的功能和最佳实践。\n\n\n# 列举一些HTML 技术关键词（GPT-4o）\n关于HTML技术的关键词，可以涵盖HTML的基础知识、标签、属性、功能以及相关的技术和概念。以下是一些重要的HTML技术关键词：\n\n## 基础知识\n\n- **HTML (HyperText Markup Language)**: 超文本标记语言\n- **DOCTYPE**: 文档类型声明\n- **元素 (Element)**: HTML的基本构建块\n- **标签 (Tag)**: 用于定义HTML元素的标记\n- **属性 (Attribute)**: 提供元素的附加信息\n\n## 常用标签\n\n- `<html>`: 定义HTML文档的根元素\n- `<head>`: 包含文档的元数据\n- `<title>`: 定义文档的标题\n- `<meta>`: 提供文档的元数据\n- `<link>`: 链接外部资源\n- `<script>`: 嵌入或引用JavaScript代码\n- `<style>`: 嵌入CSS样式\n- `<body>`: 定义文档的主体内容\n- `<header>`: 定义页面或节的头部\n- `<footer>`: 定义页面或节的尾部\n- `<nav>`: 定义导航链接\n- `<main>`: 定义文档的主要内容\n- `<section>`: 定义文档的节\n- `<article>`: 定义独立的内容块\n- `<aside>`: 定义侧边栏内容\n- `<h1>`** 到 **`<h6>`: 定义标题\n- `<p>`: 定义段落\n- `<a>`: 定义超链接\n- `<img>`: 定义图像\n- `<ul>`: 定义无序列表\n- `<ol>`: 定义有序列表\n- `<li>`: 定义列表项\n- `<table>`: 定义表格\n- `<tr>`: 定义表格行\n- `<td>`: 定义表格单元\n- `<th>`: 定义表格头单元\n- `<form>`: 定义表单\n- `<input>`: 定义输入控件\n- `<button>`: 定义按钮\n- `<textarea>`: 定义多行文本输入控件\n- `<select>`: 定义下拉列表\n- `<option>`: 定义下拉列表中的选项\n- `<label>`: 定义表单控件的标签\n- `<div>`: 定义文档中的分区或区域\n- `<span>`: 定义文档中的行内元素\n\n## 表单和输入类型\n\n- `<input>`** 类型**: `**text, password, email, url, number, date, time, checkbox, radio, file, submit, reset, button, hidden, color, range, search, tel**`\n- **表单验证属性**:** **`**required, pattern, min, max, minlength, maxlength, step**`\n\n## 多媒体标签\n\n- `<audio>`: 定义音频内容\n- `<video>`: 定义视频内容\n- `<source>`: 定义多媒体资源\n- `<track>`: 定义视频和音频的文本轨道\n\n## 图形和绘图\n\n- `<canvas>`: 用于绘制图形\n   - 2d\n   - 3d\n- **SVG (Scalable Vector Graphics)**: 可缩放矢量图形\n\n## 响应式设计\n\n- `<meta name=\"viewport\">`: 定义视口属性\n- **媒体查询 (Media Queries)**: 用于响应式设计的CSS技术\n\n## 本地存储\n\n- **localStorage**: 本地存储数据\n- **sessionStorage**: 会话存储数据\n\n## Web Components\n\n- **自定义元素 (Custom Elements)**: 创建自定义HTML标签\n- **Shadow DOM**: 隐藏DOM树\n- **HTML模板 (HTML Templates)**: 定义可重用的HTML片段\n\n## 语义化和可访问性\n\n- **语义化标签**: `<header>`, `<footer>`, `<nav>`, `<main>`, `<section>`, `<article>`, `<aside>`\n- **ARIA (Accessible Rich Internet Applications)**: 增强可访问性的属性\n\n## 安全和性能\n\n- **内容安全策略 (CSP)**: 防止XSS攻击\n- **懒加载 (Lazy Loading)**: 延迟加载图像和其他资源\n- **预加载 (Preloading)**: 提前加载关键资源\n\n## 其他相关技术\n\n- **HTML5**: HTML的最新版本\n- **CSS (Cascading Style Sheets)**: 层叠样式表，用于样式和布局\n- **JavaScript**: 用于交互和动态内容的编程语言\n- **DOM (Document Object Model)**: 文档对象模型\n- **SEO (Search Engine Optimization)**: 搜索引擎优化\n\n这些关键词涵盖了HTML技术的各个方面，从基础知识到高级功能，帮助开发者更好地理解和使用HTML来构建现代Web应用。\n","ae0db591-7667-5190-be49-22d9953a5012":"\n# 如何判断你自己对 HTML 标签了解是否全面？\n\n\n你可以通过下面的清单来检测自己对于 HTML 标签的了解是否全面\n\n- HTML 简介\n- HTML 的标准规范有哪些？\n- URL ：通过 a 标签，构建了互联网\n- 标签语义\n- 全局属性：比如 `spellcheck/translate` 是做什么用的？\n   - 拼写和翻译\n- HTML的字符实体表示方法：为什么？\n   - 网页使用 utf-8 ，那么类似于`<p>` 中的 `<` 如何表示呢？\n- `a 标签`\n   - 它的下面这些属性都是干嘛的？\n      - [href](https://wangdoc.com/html/a#href)\n      - [hreflang](https://wangdoc.com/html/a#hreflang)\n      - [title](https://wangdoc.com/html/a#title)\n      - [target](https://wangdoc.com/html/a#target)\n      - [rel](https://wangdoc.com/html/a#rel)\n      - [referrerpolicy](https://wangdoc.com/html/a#referrerpolicy)\n      - [ping](https://wangdoc.com/html/a#ping)：用于打点\n      - [type](https://wangdoc.com/html/a#type)\n      - [download](https://wangdoc.com/html/a#download) ：用于下载\n   - 发邮件：调用邮件客户端\n   - 打电话：H5\n- link 标签\n   - rel：全称 `relationship`\n      - 预加载相关：preload / prefetch /dns-prefetch / prerender / preconnect\n      - 其他：比如 icon / stylessheet 等\n   - media：媒体查询\n   - crossorigin ：跨域访问相关\n   - manifest：文件清单\n   - 更多参考 [<link>](https://wangdoc.com/html/link#hreflang-%E5%B1%9E%E6%80%A7)\n- `<script> 、<noscript>`\n   - type \n   - async/defer\n   - crossorigin\n   - integrity：哈希防篡改\n   - nonce：密码随机值，配合服务器，只有白名单才执行\n- iframe\n   - `sandbox`：沙盒权限属性，比如是否允许提交表单、是否允许提示框等等\n   - `importance`：下载优先级\n   - `loading`: auto/lazy/eager \n- `table` 相关标签都有哪些\n   - 如何合并单元格？\n- `details/summary/dialog 标签`是干什么用的\n- form\n   - input type 有哪些？\n   - 每种 type 有不同的属性：比如 min/pattern/autocomplete ...\n   - 更多参考：[表单标签](https://wangdoc.com/html/form#meter)\n\n> 下文中只列举了部分标签，全部类型更多见底部的参考\n\n\n","596f3559-5bb1-5833-9721-099e47d0c95a":"\n# 展开说说响应式图片\n\n\n图片响应式设计是现代Web开发中一个重要的概念，旨在根据不同设备和屏幕尺寸提供适合的图片资源，以提高页面加载速度和用户体验。以下是关于图片响应式设计的详细说明：\n\n## 背景和重要性\n随着移动设备的普及，用户访问网站的设备种类和屏幕尺寸变得多样化。传统的固定尺寸图片在不同设备上可能会导致加载时间过长或显示效果不佳。响应式图片技术通过提供不同尺寸和分辨率的图片，确保在各种设备上都能获得最佳的显示效果和性能。\n\n## 基本概念\n\n- **响应式图片**: 根据设备特性（如屏幕尺寸、分辨率等）动态选择和加载合适的图片。\n- **视口（Viewport）**: 用户设备的可视区域。\n- **DPR（Device Pixel Ratio）**: 设备像素比，表示设备物理像素与CSS像素的比例。\n\n## 实现方法\n\n\n### 使用 `srcset` 和 `sizes` 属性\n`srcset` 和 `sizes` 属性是HTML5中引入的，用于指定不同分辨率和尺寸的图片资源。\n```html\n<img src=\"small.jpg\" \n     srcset=\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\" \n     sizes=\"(max-width: 600px) 480px, (max-width: 1200px) 800px, 100vw\" \n     alt=\"Responsive Image\">\n```\n\n- `**srcset**`**: 定义一组图片资源及其对应的宽度描述符（如500w表示500像素宽）。**\n- `**sizes**`**: 定义图片在不同视口宽度下的显示尺寸（如**`**(max-width: 600px) 480px**`**表示视口宽度小于600px时图片宽度为480px）。**\n\n浏览器会根据视口大小和设备像素比自动选择最合适的图片进行加载。\n\n### 使用 `<picture>` 元素\n`<picture>` 元素提供了更强大的响应式图片支持，可以根据不同的媒体条件加载不同的图片资源。\n```html\n<picture>\n  <source media=\"(max-width: 600px)\" srcset=\"small.jpg\">\n  <source media=\"(max-width: 1200px)\" srcset=\"medium.jpg\">\n  <img src=\"large.jpg\" alt=\"Responsive Image\">\n</picture>\n\n```\n\n- `<source>`: 定义不同的媒体条件和对应的图片资源。\n- `<img>`: 定义默认图片，当所有媒体条件都不满足时加载。\n\n## 示例\n\n### 使用 `srcset` 和 `sizes`\n```html\n<img src=\"images/default.jpg\"\n     srcset=\"images/small.jpg 480w, images/medium.jpg 800w, images/large.jpg 1200w\"\n     sizes=\"(max-width: 600px) 480px, (max-width: 1200px) 800px, 100vw\"\n     alt=\"Example of responsive image\">\n```\n\n### 使用 `<picture>` 元素\n```html\n<picture>\n  <source media=\"(max-width: 600px)\" srcset=\"images/small.jpg\">\n  <source media=\"(max-width: 1200px)\" srcset=\"images/medium.jpg\">\n  <img src=\"images/large.jpg\" alt=\"Example of responsive image\">\n</picture>\n\n```\n\n## 优势\n\n- **提高性能**: 通过加载适合的图片资源，减少不必要的带宽消耗，提高页面加载速度。\n- **优化用户体验**: 确保在不同设备上都能获得最佳的图片显示效果。\n- **SEO友好**: 提供合适的图片资源，有助于搜索引擎优化。\n\n## 注意事项\n\n- **图片格式**: 使用现代`图片格式（如WebP）`可以进一步优化图片加载性能。\n- **缓存策略**: 合理设置图片的缓存策略，减少重复加载。\n- **测试和优化**: 在不同设备和浏览器上测试响应式图片效果，确保兼容性和性能。\n\n## 工具和资源\n\n- **图片生成工具**: 使用工具（如ImageMagick）批量生成不同尺寸和分辨率的图片。\n- **在线服务**: 使用在线服务（如Cloudinary）自动生成和管理响应式图片资源。\n- **浏览器开发者工具**: 使用浏览器开发者工具测试和调试响应式图片效果。\n\n通过合理使用响应式图片技术，可以显著提升Web应用的性能和用户体验，适应现代Web开发的需求。\n","9c666db4-8cc9-5e83-852f-eae2e4048160":"\n# 说说 HTML 标准规范都有哪些？\n\n- **WHATWG** 全称是 `Web Hypertext Application Technology Working Group`，即 `**Web 超文本应用技术工作组**`\n- WHATWG HTML 规范：定义了 HTML 的语法和行为，涵盖了网页开发的**所有**方面，确保网页在不同浏览器中的一致性。\n- ARIA（Accessible Rich Internet Applications 规范：专注于增强网页的无障碍性，使得辅助技术用户能够更好地访问和操作网页内容\n   - 主要定义了一组属性，比如如 role、aria-label、aria-hidden、aria-live 等，用于增强现有 HTML 元素的语义信息。\n","af968b8a-1555-5e85-84e2-943ee137b06d":"\n# 请列举你认为最重要 HTML 技术清单？\n\n\n以下是一些最重要的HTML技术清单，这些技术和概念对于现代Web开发至关重要：\n\n## **HTML5**\n\n- **介绍**：HTML的最新版本，提供了许多新特性和API。\n- **特点**：语义化标签、新的表单控件、多媒体支持（audio、video）、本地存储（localStorage、sessionStorage）。\n\n## **语义化标签**\n\n- **介绍**：使用具有明确含义的标签来构建页面结构。\n- **特点**：提高可读性和可维护性、增强SEO、改善无障碍访问。\n- **示例**：`<header>`, `<footer>`, `<article>`, `<section>`, `<nav>`, `<aside>`。\n\n## **表单元素和验证**\n\n- **介绍**：HTML5引入了许多新的表单控件和属性，简化了表单的创建和验证。\n- **特点**：新的输入类型（如`email`, `url`, `date`）、表单验证属性（如`required`, `pattern`）、增强的用户体验。\n\n## **多媒体元素**\n\n- **介绍**：HTML5引入了原生的多媒体支持。\n- **特点**：`<audio>`和`<video>`标签，支持嵌入音频和视频内容，无需第三方插件。\n\n## **Canvas**\n\n- **介绍**：用于绘制2D图形的HTML元素。\n- **特点**：通过JavaScript绘制图形、动画和游戏。\n\n## **SVG**\n\n- **介绍**：可缩放矢量图形，基于XML的图像格式。\n- **特点**：高质量的图形、可交互、可动画化、支持CSS样式。\n\n## **本地存储**\n\n- **介绍**：HTML5提供了两种本地存储机制：localStorage和sessionStorage。\n- **特点**：持久化存储（localStorage）、会话存储（sessionStorage）、简化客户端数据管理。\n\n## **离线支持**\n\n- **介绍**：通过`<manifest>`文件和`Service Workers`实现离线支持。\n- **特点**：离线访问、缓存资源、提高应用的可靠性。\n\n## **Web Workers**\n\n- **介绍**：在后台线程中运行JavaScript代码，避免阻塞主线程。\n- **特点**：并行处理、提高性能、增强用户体验。\n\n## **ARIA（Accessible Rich Internet Applications）**\n\n- **介绍**：一组属性，用于增强Web内容的可访问性。\n- **特点**：改善无障碍访问、提高屏幕阅读器支持、增强用户体验。\n\n## **自定义数据属性**\n\n- **介绍**：使用`data-*`属性在HTML元素中存储自定义数据。\n- **特点**：灵活的数据存储、简化JavaScript交互。\n\n## **模板元素**\n\n- **介绍**：`<template>`标签，用于定义可重用的HTML片段。\n- **特点**：延迟渲染、提高性能、增强代码复用性。\n\n## **Shadow DOM**\n\n- **介绍**：Web Components 的一部分，用于封装元素的内部结构和样式。\n- **特点**：样式隔离、避免样式冲突、提高组件化开发。\n\n## **自定义元素**\n\n- **介绍**：Web Components 的一部分，允许创建自定义的HTML标签。\n- **特点**：增强HTML的可扩展性、提高代码复用性、与框架无关。\n\n## **响应式设计**\n\n- **介绍**：使用HTML和CSS技术创建适应不同设备和屏幕尺寸的页面。\n- **特点**：媒体查询、弹性布局、视口设置。\n\n## **微数据（Microdata）**\n\n- **介绍**：一种嵌入HTML的结构化数据的方式。\n- **目的: **为HTML元素添加机器可读的标签,描述其含义\n- **组成:** 主要由 itemscope, itemtype, 和 itemprop 属性组成。\n   - itemscope: 创建一个新的项目,表示其中包含的标记描述了一个特定的项目。\n   - itemtype: 指定项目的类型,通常是一个URL,指向一个词汇表或架构。\n   - itemprop: 定义项目的属性\n- **特点**：增强SEO、提高搜索引擎理解页面内容的能力。\n- 常用词汇表：Schema.org，最广泛使用的结构化数据词汇表,由主要搜索引擎共同支持。\n\n```html\n<div itemscope itemtype=\"http://schema.org/Person\">  \n  <span itemprop=\"name\">John Doe</span>  \n  <span itemprop=\"jobTitle\">Software Developer</span>  \n  <a href=\"mailto:john@example.com\" itemprop=\"email\">john@example.com</a>  \n</div>  \n\n```\n\n\n## **内容安全策略（CSP）**\n\n- **介绍**：一种Web安全策略，用于防止跨站脚本攻击（XSS）等安全威胁。\n- **特点**：定义允许加载的资源、提高安全性、减少攻击面。\n\n内容安全策略（`Content Security Policy`，简称CSP）是一种重要的Web安全机制，用于防止跨站脚本攻击（XSS）、数据注入等攻击。让我详细解释一下CSP\n\n### 基本概念\nCSP是一种由服务器声明的安全策略，它告诉浏览器哪些资源可以被加载和执行。\n\n### 主要目标\n\n- 防止XSS攻击\n- 减少数据注入风险\n- 报告违规行为\n- 强制使用HTTPS\n\n### 工作原理\nCSP通过`**HTTP头部 或 meta标签**`来实现，指定允许加载的资源的来源。\n\n### 实现方式\n\n#### HTTP头部方式：\n```\nContent-Security-Policy: directive1 source1 source2; directive2 source3 source4\n```\n\n#### Meta标签方式：\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"directive1 source1 source2; directive2 source3 source4\">\n```\n\n### 常用指令\n\n- `default-src`: 默认加载策略\n- `script-src`: JavaScript来源\n- `style-src`: CSS样式来源\n- `img-src`: 图片来源\n- `connect-src`: AJAX、WebSocket等连接来源\n- `font-src`: 字体文件来源\n- `object-src`: 插件来源（如Flash）\n- `media-src`: 音视频来源\n- `frame-src`: iframe来源\n\n> **即规定了所有可能加载资源的来源要求**\n\n\n### 示例\n```\nContent-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com; img-src *\n```\n这个策略允许：\n\n- 默认只加载同源资源\n- 脚本只能从自身域名和trusted.cdn.com加载\n- 图片可以从任何源加载\n\n### 报告模式\n可以使用`Content-Security-Policy-Report-Only`头部来测试策略，不实际阻止资源，只报告违规。\n\n### 违规报告\n可以通过`report-uri`指令指定违规报告的接收地址。\n\n### 优势\n\n- 大幅降低XSS风险\n- 控制资源加载，提高安全性\n- 强制使用HTTPS，保护数据传输\n- 提供违规报告，便于监控和调试\n\n### 挑战和注意事项\n\n- 可能影响第三方脚本和插件的使用\n- 需要仔细配置以避免破坏网站功能\n- 旧版浏览器可能不支持\n\n### 最佳实践\n\n- 从严格策略开始，逐步放宽\n- 使用报告模式进行测试\n- 定期审查和更新策略\n- 结合其他安全措施使用（如HTTPS、安全Cookie等）\n\n### 与其他安全措施的结合\n\n- HSTS (HTTP Strict Transport Security)\n- X-Frame-Options\n- X-XSS-Protection\n\n### 未来发展\n\n- 更细粒度的控制\n- 更好的浏览器支持\n- 与新兴Web技术的集成\n\n内容安全策略是现代Web安全的重要组成部分。它提供了一种强大的方式来控制资源加载，大大提高了网站抵御各种攻击的能力。然而，实施CSP需要仔细规划和测试，以确保既提高安全性，又不影响网站的正常功能。\n\n## **Web Components**\n\n- **介绍**：一组Web平台API，用于创建可复用的自定义元素。\n- **特点**：组件化开发、样式和功能封装、与框架无关。\n\n## **媒体查询**\n\n- **介绍**：用于在不同设备和屏幕尺寸上应用不同的CSS样式。\n- **特点**：响应式设计、提高用户体验、适应多种设备。\n","54e3516b-4087-57f6-8d2f-2fa8de15db15":"\n# CSS 篇\n\n\n\n> CSS 完全可以写一大本书了，这里只列举一些相对前沿或我认为比较重要的知识点\n\n## 参考\n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [https://www.w3.org/Style/CSS/#specs](https://www.w3.org/Style/CSS/#specs)\n- [CSS：层叠样式表 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS)\n- [https://web.dev/learn/css/color?hl=zh-cn](https://web.dev/learn/css/color?hl=zh-cn)\n\n## 推荐书籍\n\n- 《CSS 揭秘》\n\n","4191fef0-f302-5d63-b841-8db9227c9578":"\n# CSS  开启 GPU 硬件加速的原理\n\n\n##  原理\n\n### 核心原理\nGPU 硬件加速的`核心原理`在于将特定的渲染任务从 CPU 移交给 GPU 进行处理。GPU 擅长处理大规模的并行任务，这对于动画、变换和其他复杂的视觉效果来说尤其有效。通过 GPU 硬件加速，可以大幅提升这些任务的执行效率和渲染速度。\n\n### 从浏览器的渲染过程分析原理\nCSS 开启 GPU 硬件加速的原理主要涉及浏览器的渲染过程和`图层（Layer`）的概念。让我们深入了解这个过程：\n浏览器渲染页面通常遵循以下步骤：\n\n- 解析 HTML 构建 DOM 树\n- 解析 CSS 构建 CSSOM 树\n- 将 DOM 和 CSSOM 合并成渲染树\n- 布局（Layout）：计算元素的位置和大小\n- 绘制（Paint）：将元素绘制到屏幕上\n- 合成（Composite）：将`不同的图层`合并到一起\n\n#### 图层（Layer） \n**浏览器会将页面分成多个图层**。默认情况下，普通元素都在同一个图层中。但某些`特定的 CSS 属性`可以让元素提升为单独的图层。\n\n当一个元素被提升为单独的`图层`时，它的渲染会被委托给 GPU 处理。GPU 擅长处理纹理和图形，能够高效地处理图层的变换、缩放、旋转等操作。这样就能够 `**GPU 硬件加速**`\n\n\n#### 以 `transform: translate3d(0,0,0)` 为例：\n\n- 这个看似无用的 3D 变换会强制浏览器为该元素创建一个`新的图层`。\n- 新图层会被送到 GPU 处理。\n- GPU 可以高效地处理这个图层的后续变换，`无需重新布局或重绘`整个页面。\n\n#### 内部工作机制\n\n- 当元素被提升为独立图层后，它会被存储为纹理在 GPU 中。\n- GPU 可以直接操作这个纹理，进行位置移动、缩放、旋转等操作，无需 CPU 参与\n- 这大大减少了 CPU 的工作负担，提高了动画的流畅度。\n\n\n## CSS 触发 GPU 加速的属性\n以下是一些可以触发 GPU 硬件加速的 CSS 属性，告诉浏览器在最开始就把`**该元素放到新图层渲染**`。\n\n### transform\n应用二维或三维变换，如 `transform: translate3d(0, 0, 0);`\n> 注意：其实`二维`也行\n\n\n\n### opacity：改变元素的透明度\n\n### filter：应用图像处理效果\n`filter` 属性用于应用各种图形处理效果（例如模糊、亮度、对比度等），这些效果通常也会使用 GPU 加速来提高性能。\n```css\n.element {\n  filter: blur(5px);\n}\n```\n\n### will-change\n显式声明某些属性将发生变化，从而让浏览器提前优化这些元素\n\n\n### CSS 动画和过渡（`transition` 或 `animation`）\n\n`will-change` 属性让开发者可以显式地告诉浏览器哪些属性将会变化，从而让浏览器提前优化这些元素。\n```css\n.element {\n  will-change: transform, opacity;\n}\n```\n\n\n## 优势\n\n- 减少重绘：图层的变化不会影响其他图层，减少了不必要的`重绘`。\n- 提高性能：GPU 并行处理能力强，适合处理图形任务。\n- 流畅动画：减少了 CPU 的参与，使动画更加流畅。\n\n## 注意事项\n\n- 过度使用可能导致内存占用增加。\n- 不是所有设备都有强大的 GPU，过度依赖可能在低端设备上适得其反。\n- 不同浏览器的实现可能有差异。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/61f5c262db0860b921ca61e0479d99d2.png)\n\n","f7ae07e4-6858-5ea9-bec9-08c212c479c3":"\n# CSS Houdini\n\n\n- **描述**：一组低级 API，允许开发者扩展 CSS 的功能。\n- **特点**：可以创建自定义的 CSS 属性、值和渲染逻辑。\n- **示例**：使用 Houdini Paint API 创建自定义背景图案。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/fbc8c2fd3e2020705eca7a56269f9619.png)\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/66aa45d5394512e154f5316bb589f85f.png)\n\n","413a98f2-8051-5710-82de-43d0c43dcd57":"\n# CSS 处理器\n\n\n- PostCSS\n- Sass/SCSS\n- Less\n- Stylus\n","171b1097-d982-5a31-9a0b-e93a968a9a0f":"\n# CSS 定位\n\n\n\n# 定位\n\n- 静态定位（Static Positioning）\n- 相对定位（Relative Positioning）\n- 绝对定位（Absolute Positioning）\n- 固定定位（Fixed Positioning）\n- 粘性定位（Sticky Positioning）\n","9620482a-7567-534a-832c-fbbfa02110f8":"\n# CSS 定位或布局相关的参考坐标系都有哪些？\n\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/c792c133990e2818a06482c7117b141c.png)\n\n> 这里可以对应 JS 获取某个元素的各种位置信息：比如 clientX pageX 、width 、offesetLeft 等等等等\n> \n\nCSS 中的“参考坐标系”或“参考系”是指为定位、对齐或变换 CSS 元素而使用的坐标系。理解不同的参考系对于掌握 CSS 布局和定位非常重要。以下是一些常见的参考坐标系及其使用方法：\n\n## **文档坐标系**\n文档坐标系是整个 HTML 文档的坐标系，所有位置和尺寸都是相对于文档的起点（通常是左上角）来指定的。\n\n- **元素的宽度和高度**：以整个文档为参考系。\n- **滚动位置**：以整个文档为基准的滚动。\n\n> - `块级元素`独占一行,`内联元素`在一行内排列\n\n\n## **视口坐标系**\n视口坐标系是指`浏览器窗口或视口`的坐标系。\n\n- **百分比宽度和高度**：如`width: 100vw`表示宽度为 100% 视口宽度。\n- **固定定位**：`position: fixed;` 会以视口为参考系来定位元素。\n\n## **包含块（Containing Block）**\n`包含块`是一个元素在正常流或其他指定布局上下文中的直接父块或祖先块，用于确定其坐标和大小。\n\n- **相对定位**：`position: relative;` 会以包含块为参考来定位元素。\n- **绝对定位**：`position: absolute;` 会以最近的非静态定位的祖先元素（包含块）为参考。\n\n## **边框框（Border Box）**\n边框框是包含元素的内容、内边距和边框的区域。\n\n- **盒模型**：用于计算元素的总计宽度和高度。\n\n## **内边距框（Padding Box）**\n内边距框是包含元素内容和内边距的区域。\n\n- **背景和边框**：默认情况下，`**背景和边框**`会扩展到内边距框之外。\n\n## **内容框（Content Box）**\n内容框是仅包含元素内容的区域，不包括内边距、边框和外边距。\n\n- **内容尺寸**：通过`box-sizing`属性可以设置为以`**内容框或边框框**`来计算元素尺寸（默认是`content-box`）。\n\n## **变换参考系（Transform Reference）**\n当你对元素应用 CSS 变换（比如`transform`属性）时，使用的是变换参考系。\n\n- **变换中心点**：默认情况下，变换中心点为元素的中心。\n- 创建一个新的坐标系,不影响其他元素\n- 变换后的元素成为其子元素的`包含块`\n\n```css\n.transform {  \n  transform: rotate(45deg) translateX(100px);  \n}\n```\n\n## 表格布局\n\n- display: `table 和 table-cell`\n- 模拟表格的布局结构\n\n\n## Flex 布局、 Grid 布局、CSS 多列布局（Multi-Column Layout）\n这些布局模型创建了自己的坐标系:\n\n- Flexbox 坐标系: 主轴(main axis)和交叉轴(cross axis)\n- Grid 坐标系:  行和列定义的`网格坐标系`\n- Multi-Column Layout：用于将文本分为多列\n\n## 示例\n下面示例展示了几种不同的坐标系的使用：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CSS Reference Coordinate Systems</title>\n\n    <style>\n        .relative-container {\n            position: relative;\n            width: 300px;\n            height: 300px;\n            background-color: lightgray;\n            margin: 50px; /* 文档坐标系 */\n        }\n\n        .relative-child {\n            position: absolute;\n            top: 10px; /* 包含块参考系 */\n            left: 10px;\n            width: 100px;\n            height: 100px;\n            background-color: lightcoral;\n        }\n\n        .fixed-element {\n            position: fixed;\n            top: 20px; /* 视口坐标系 */\n            right: 20px;\n            width: 100px;\n            height: 100px;\n            background-color: lightblue;\n        }\n\n        .transform-element {\n            width: 100px;\n            height: 100px;\n            background-color: lightgreen;\n            margin: 50px;\n            transform: rotate(45deg); /* 变换参考系 */\n        }\n    </style>\n\n</head>\n\n<body>\n    <div class=\"fixed-element\">Fixed</div>\n\n    <div class=\"relative-container\">\n        <div class=\"relative-child\">Absolute</div>\n\n    </div>\n\n    <div class=\"transform-element\">Transform</div>\n\n</body>\n\n</html>\n\n```\n\n\n## 关键点：\n\n1. **文档坐标系**：用于整体文档的布局和滚动。\n2. **视口坐标系**：用于固定定位和视口相对尺寸。\n3. **包含块**：用于`相对和绝对`定位。\n4. **边框框、内边距框和内容框**：用于`盒模型`计算。\n5. **变换参考系**：用于应用 CSS 变换。\n\n这些参考坐标系在实际布局和定位中常常结合使用，因此理解它们如何协同工作是掌握 CSS 布局的关键。\n\n","76a9c1b1-4833-551c-ab05-459a50abd8c8":"\n# CSS 布局\n\n\n# 布局\n- CSS Grid Layout：二维布局系统\n- CSS Flexbox：维布局模型\n- 多列布局：column-count、column-gap 等\n- 浮动布局\n","d219a83e-8a12-50f5-bd8d-f65300b00d64":"\n# CSS 性能优化有哪些思路？\n\n\n在进行 CSS 性能优化时，有许多注意事项和最佳实践可以帮助提高网页的加载速度和渲染性能。以下是一些关键的性能优化技巧：\n\n## 1. 减少 CSS 文件的大小\n\n- **压缩 CSS 文件**：使用工具（如 CSSNano、csso）压缩 CSS 文件，去除空格、注释和不必要的字符。\n- **移除未使用的 CSS**：使用工具（如 PurifyCSS、PurgeCSS）检测并移除未使用的 CSS 规则。\n\n## 2. 优化选择器\n\n- **避免过于具体的选择器**：复杂的选择器（如后代选择器）会增加浏览器的匹配时间。尽量使用简单的选择器。\n- **避免使用通配符选择器**：如 `*` 选择器会匹配所有元素，性能较差。\n- **减少嵌套层级**：过深的嵌套会增加选择器的复杂度，影响性能。\n\n## 3. 使用高效的布局技术\n\n- **优先使用 Flexbox 和 Grid 布局**：这些布局模型在现代浏览器中性能较好，且代码简洁易维护。\n- **避免使用浮动布局**：浮动布局需要更多的清理和处理，影响性能。\n\n## 4. 减少重排和重绘\n\n- **避免频繁修改样式**：频繁修改样式会导致重排和重绘，影响性能。尽量批量修改样式。\n- **使用 **`class`** 切换而不是直接修改样式**：通过切换 `class` 来改变样式，而不是直接修改元素的 `style` 属性。\n- **避免使用 JavaScript 修改样式**：尽量使用 CSS 过渡和动画，而不是通过 JavaScript 修改样式。\n\n## 5. 使用硬件加速\n\n- **启用 GPU 加速**：使用 `transform`、`opacity` 和 `will-change` 属性来启用 GPU 加速，减少 CPU 负载。\n```css\n.element {\n  will-change: transform, opacity;\n}\n```\n\n## 6. 延迟加载和异步加载\n\n- **异步加载 CSS**：使用 `media` 属性和 `onload` 事件异步加载非关键 CSS。\n```html\n<link rel=\"stylesheet\" href=\"non-critical.css\" media=\"print\" onload=\"this.media='all'\">\n<noscript><link rel=\"stylesheet\" href=\"non-critical.css\"></noscript>\n\n```\n\n> 打印的样式肯定需要后置\n\n## 7. 使用 CSS 预处理器和后处理器\n\n- **使用预处理器（如 Sass、Less）**：预处理器可以帮助组织和优化 CSS 代码，提高可维护性。\n- **使用后处理器（如 PostCSS）**：后处理器可以自动添加浏览器前缀、压缩 CSS 等。\n\n## 8. 优化字体加载\n\n- **使用字体显示策略**：使用 `font-display` 属性优化字体加载体验。\n```css\n@font-face {\n  font-family: 'MyFont';\n  src: url('myfont.woff2') format('woff2');\n  font-display: swap;\n}\n```\n\n- **只加载必要的字体**：避免加载过多的字体变体和字符集。\n\n## 9. 代码分割和按需加载\n\n- **按需加载 CSS**：将不同页面的样式分割成不同的 CSS 文件，按需加载。\n\n## 10. 使用现代 CSS 特性\n\n- **使用 CSS 变量**：CSS 变量可以减少重复代码，提高可维护性和性能。\n```css\n:root {\n  --primary-color: #3498db;\n}\n\n.element {\n  color: var(--primary-color);\n}\n```\n\n- **使用现代布局和功能**：如 CSS Grid、Flexbox、`clamp()`、`min()`、`max()` 等，减少依赖 JavaScript 实现复杂布局和功能。\n\n## 11. 提前加载关键 CSS\n\n- **内联关键 CSS**：将关键 CSS 内联到 HTML 中，减少初始渲染时间。\n```html\n<style>\n  /* 关键 CSS */\n  body {\n    font-family: 'Arial', sans-serif;\n  }\n</style>\n\n```\n\n## 12. 使用内容分发网络 (CDN)\n\n- **使用 CDN 提供 CSS**：使用 CDN 提供的 CSS 文件，可以加速文件加载。\n","14b33967-8922-55fa-984d-533bdd18794e":"\n# CSS 是什么？\n\n即为 HTML 添加样式\n","e36e272e-7968-5768-a7de-f164ac50190c":"\n# CSS 滚动自动吸附效果与吸顶效果的区别？\n\n\n## CSS 滚动自动吸附效果如何实现？\n`**CSS Scroll Snap**` 用于创建更流畅、更控制的滚动体验，确保滚动容器滚动到`预定义`的位置，使用户可以`精确地滚动到相邻的部分`\n\n- **描述**：提供了一种控制滚动行为的方式，使滚动条在指定位置停止。\n- **特点**：适用于创建滑动视图和画廊。\n- **示例**：\n```css\n.container {\n  scroll-snap-type: x mandatory;\n}\n.item {\n  scroll-snap-align: center;\n}\n```\n\n可以理解为幻灯片的效果，或者画廊滚动的效果，具体效果可参考：[https://codepen.io/chriscoyier/full/pMRgwW](https://codepen.io/chriscoyier/full/pMRgwW)\n\n具体 CSS Scroll Snap 属性包括如下：\n\n- [scroll-snap-type](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type)\n- [scroll-padding](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding)\n   - [scroll-padding-top](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-top)\n   - [scroll-padding-right](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-right)\n   - [scroll-padding-bottom](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-bottom)\n   - [scroll-padding-left](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-left)\n   - [scroll-padding-inline](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline)\n   - [scroll-padding-inline-start](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline-start)\n   - [scroll-padding-inline-end](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline-end)\n   - [scroll-padding-block](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block)\n   - [scroll-padding-block-start](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block-start)\n   - [scroll-padding-block-end](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block-end)\n\n> 如何使用具体参考上面的链接即可\n\n## 上面说的 css 的`自动吸附效果`和`吸顶`有什么区别吗？\n\n- `position: sticky` 主要用于使元素在滚动时`粘性`地保持在其父元素的某个位置。\n- `CSS Scroll Snap` 主要用于创建更流畅和可控制的滚动体验，通过自动捕捉和对齐滚动点来提升用户体验。\n","4582625b-d738-5c4f-8368-4d9077a76dc0":"\n# CSS 的计算属性都有哪些？\n\n\n在 CSS 中，计算属性（也称为计算值）是指那些可以通过数学运算、函数或其他方式动态计算的属性值。\n\n### 1. `calc()`\n`calc()` 函数允许你在 CSS 属性中进行基本的数学运算（加、减、乘、除）。\n```css\n.element {\n  width: calc(100% - 50px);\n  height: calc(50vh + 20px);\n  margin: calc(10px * 2);\n}\n```\n\n### 2. `var()`\n`var()` 函数用于引用 CSS 变量。这些变量可以包含计算值。\n```css\n:root {\n  --base-size: 10px;\n}\n\n.element {\n  padding: calc(var(--base-size) * 2);\n}\n```\n\n### 3. `min()`, `max()`, `clamp()`\n这些函数允许你在多个值之间进行选择。\n\n- `min()` 返回最小值。\n- `max()` 返回最大值。\n- `clamp()` 返回一个在指定范围内的值。\n```css\n.element {\n  width: min(50vw, 500px); /* 取 50vw 和 500px 中的最小值 */\n  height: max(100px, 10vh); /* 取 100px 和 10vh 中的最大值 */\n  font-size: clamp(1rem, 2vw, 3rem); /* 字体大小在 1rem 到 3rem 之间，取 2vw */\n}\n```\n\n### 4. `attr()`\n`attr()` 函数允许你在 CSS 中使用 HTML 属性的值。虽然这个函数的支持仍然有限，但它可以用于一些简单的场景。\n```css\n.element::before {\n  content: attr(data-content);\n}\n```\n\n### 5. `env()`\n`env()` 函数用于访问环境变量，例如安全区域（safe area）内边距。\n```css\n.element {\n  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);\n}\n```\n\n### 6. `url()`\n`url()` 函数用于引用外部资源，例如图像、字体等。\n```css\n.element {\n  background-image: url('path/to/image.jpg');\n}\n```\n\n### 7. `rgba()`, `hsla()`\n这些函数用于定义颜色，可以包含计算值。\n```css\n.element {\n  background-color: rgba(255, 0, 0, 0.5); /* 半透明的红色 */\n  color: hsla(120, 100%, 50%, 0.3); /* 半透明的绿色 */\n}\n```\n\n### 8. `repeat()`\n`repeat()` 函数用于在 CSS Grid 布局中重复轨道定义。\n```css\n.grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr); /* 三列，每列平分 */\n}\n```\n\n### 9. `fit-content()`\n`fit-content()` 函数用于定义一个自适应内容的大小。\n```css\n.element {\n  width: fit-content(200px); /* 根据内容自适应宽度，不超过 200px */\n}\n```\n\n### 10. `rotate()`, `scale()`, `translate()`, `skew()`\n这些变换函数用于定义元素的变换效果。\n```css\n.element {\n  transform: rotate(45deg) scale(1.5) translate(10px, 20px);\n}\n```\n\n### 11. `cubic-bezier()`, `steps()`\n这些函数用于定义动画的时间函数。\n```css\n.element {\n  transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);\n  animation-timing-function: steps(4, end);\n}\n```\n\n\n### 12. `conic-gradient()`\n`conic-gradient()` 函数用于创建圆锥渐变。\n```css\n.element {\n  background: conic-gradient(from 0deg at 50% 50%, red, yellow, green, blue);\n}\n```\n\n### 13. `linear-gradient()`\n`linear-gradient()` 函数用于创建线性渐变。\n```css\n.element {\n  background: linear-gradient(to right, red, yellow, green);\n}\n```\n\n### 14. `radial-gradient()`\n`radial-gradient()` 函数用于创建径向渐变。\n```css\n.element {\n  background: radial-gradient(circle, red, yellow, green);\n}\n```\n\n### 15. `repeating-linear-gradient()`\n`repeating-linear-gradient()` 函数用于创建重复的线性渐变。\n```css\n.element {\n  background: repeating-linear-gradient(45deg, red, yellow 10%, green 20%);\n}\n```\n\n### 16. `repeating-radial-gradient()`\n`repeating-radial-gradient()` 函数用于创建重复的径向渐变。\n```css\n.element {\n  background: repeating-radial-gradient(circle, red, yellow 10%, green 20%);\n}\n```\n\n### 17. `hsl()`, `hsla()`\n`hsl()` 和 `hsla()` 函数用于定义 HSL 颜色值，可以包含计算值。\n```css\n.element {\n  color: hsl(120, 100%, 50%);\n  background-color: hsla(240, 100%, 50%, 0.5);\n}\n```\n\n### 18. `rotateX()`, `rotateY()`, `rotateZ()`\n这些 3D 变换函数用于定义元素的旋转效果。\n```css\n.element {\n  transform: rotateX(45deg) rotateY(30deg) rotateZ(60deg);\n}\n```\n\n### 19. `scaleX()`, `scaleY()`, `scaleZ()`\n这些 3D 变换函数用于定义元素的缩放效果。\n```css\n.element {\n  transform: scaleX(1.2) scaleY(0.8) scaleZ(1.5);\n}\n```\n\n### 20. `translateX()`, `translateY()`, `translateZ()`\n这些 3D 变换函数用于定义元素的平移效果。\n```css\n.element {\n  transform: translateX(10px) translateY(20px) translateZ(30px);\n}\n```\n\n### 21. `skewX()`, `skewY()`\n这些变换函数用于定义元素的倾斜效果。\n```css\n.element {\n  transform: skewX(30deg) skewY(20deg);\n}\n```\n\n### 22. `matrix()`, `matrix3d()`\n这些函数用于定义 2D 和 3D 变换矩阵。\n```css\n.element {\n  transform: matrix(1, 0, 0, 1, 50, 100); /* 2D 变换矩阵 */\n  transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 50, 100, 0, 1); /* 3D 变换矩阵 */\n}\n```\n\n### 23. `perspective()`\n`perspective()` 函数用于定义 3D 透视效果。\n```css\n.element {\n  transform: perspective(500px) rotateY(45deg);\n}\n```\n\n### 24. `path()`\n`path()` 函数用于定义一个路径，常用于 `clip-path` 属性。\n```css\n.element {\n  clip-path: path('M10 10 H 90 V 90 H 10 L 10 10');\n}\n```\n\n### 25. `circle()`, `ellipse()`, `inset()`, `polygon()`\n这些函数用于定义裁剪路径（clip path）。\n```css\n.element {\n  clip-path: circle(50% at 50% 50%);\n  clip-path: ellipse(50% 50% at 50% 50%);\n  clip-path: inset(10% 20% 30% 40%);\n  clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);\n}\n```\n\n### 26. `counter()`, `counters()`\n这些函数用于生成计数器内容。\n```css\nol {\n  counter-reset: section;\n}\n\nli::before {\n  counter-increment: section;\n  content: counter(section) \". \";\n}\n```\n\n### 27. `rotate3d()`\n`rotate3d()` 函数用于定义沿着任意轴的 3D 旋转。\n```css\n.element {\n  transform: rotate3d(1, 1, 0, 45deg);\n}\n```\n\n### 28. `translate3d()`\n`translate3d()` 函数用于定义 3D 平移。\n```css\n.element {\n  transform: translate3d(10px, 20px, 30px);\n}\n```\n\n","fc433cff-e82d-5e8b-a5c8-c79bff56c3a3":"\n# Tailland CSS 的使用\n\n- HTML 膨胀、可维护性\n","dd808c96-df67-5827-bb29-81f628134558":"\n# css 选择器的优先级\n\n\n\n## 特异性（Specificity） ：优先级\nCSS 选择器的优先级由四个数值组成，用来计算选择器的`**特异性（Specificity）**`。这些数值从高到低分别是：\n\n1. 内联样式：如果样式是通过元素的 `style` 属性内联定义的，例如 `<div style=\"color: red;\"></div>`。\n   1. 特异性（Specificity）：1000\n2. ID 选择器：例如 `#id`\n   1. 特异性（Specificity）：100\n3. 类选择器、属性选择器和`**伪类选择器**`：例如 `.class`、`[type=\"text\"]`、`:hover`\n   1. 特异性（Specificity）：10\n4. 元素选择器 和`**伪元素**`选择器：例如 `div`、`p`、`::before`\n   1. 特异性（Specificity）：1\n5. 通配符选择器（*）\n   1. 特异性（Specificity）：0\n\n> **特异性（Specificity） 即 优先级**\n\n## 示例\n\n1. `style=\"color: red;\"` 内联样式，特异性值为 `1000`\n2. `#idSelector` ID 选择器，特异性值为 `100`\n3. `.classSelector` 类选择器，特异性值为 `10`\n4. `[type=\"text\"]` 属性选择器，特异性值为 `10`\n5. `:hover` 伪类选择器，特异性值为 `10`\n6. `div` 元素选择器，特异性值为 `1`\n\n## `important`\n\n1. `!important` 提升声明的优先级，覆盖任何通常的权重计算。\n2. 任意规则使用 `!important`，该规则将优先权。\n3. 多个 `!important`之间情况，优先级基于特异性。\n\n## 总结\n\n1. `!important` 声明\n2. 内联样式（style 属性）\n3. ID 选择器（#id）\n4. 类选择器（.class）、属性选择器（[attr]）和 `伪类（:hover 等）`\n5. 元素选择器（div, p 等）和 `伪元素（::before, ::after 等`）\n6. 通配符选择器（*）\n\n> 是有一个很详细的计算公式的，CSS 引擎会严格计算具体的值\n\n## \n\n","6bae1b79-1024-5d7f-8223-af266ffe0333":"\n# 如何使用 CSS 变量？\n\n\nCSS 变量**使用 **`**--**`** 作为前缀来定义**，并且通常定义**在 **`**:root**`** 选择器中**，以便在整个文档中全局可用。\n\n```css\n:root {\n  --main-color: #3498db;\n  --padding-size: 10px;\n  --font-size: 16px;\n}\n```\n\nCSS 变量可以存储任何合法的 CSS 值，包括颜色、长度、百分比、字符串等\n\n## 使用 CSS 变量\n\n使用 `var()` 函数来引用 CSS 变量。\n```css\n.element {\n  color: var(--main-color);\n  padding: var(--padding-size);\n  font-size: var(--font-size);\n}\n```\n\n## 变量的作用域\nCSS 变量的作用域可以是全局的（定义在 `:root` 中）或局部的（定义在特定选择器中）。\n\n### 全局变量\n定义在 `:root` 中的变量可以在整个文档中使用。\n```css\n:root {\n  --global-color: #3498db;\n}\n.element {\n  color: var(--global-color);\n}\n```\n\n### 局部变量\n定义在特定选择器中的变量只能在该选择器及其子元素中使用。\n```css\n.container {\n  --local-color: #e74c3c;\n}\n.element {\n  color: var(--local-color); /* 仅在 .container 内部有效 */\n}\n```\n\n## 变量的默认值\n`var()` 函数可以接受一个可选的`第二个参数`作为默认值，当变量未定义时使用该默认值。\n```css\n.element {\n  color: var(--undefined-color, #2ecc71); /* 如果 --undefined-color 未定义，则使用 #2ecc71 */\n}\n```\n\n## 嵌套变量\nCSS 变量可以嵌套使用，即一个变量的值可以引用另一个变量。\n```css\n:root {\n  --primary-color: #3498db;\n  --secondary-color: var(--primary-color);\n}\n.element {\n  color: var(--secondary-color); /* 等同于 #3498db */\n}\n```\n\n## 变量的计算\nCSS 变量可以与其他 CSS 属性值一起使用，并且可以参与计算。\n```css\n:root {\n  --base-padding: 10px;\n}\n.element {\n  padding: calc(var(--base-padding) * 2); /* 等同于 20px */\n}\n```\n\n## 动态更新变量\nCSS 变量的值可以通过 JavaScript 动态更新，从而实现动态样式更改。\n```html\n<style>\n  :root {\n    --dynamic-color: #3498db;\n  }\n  .element {\n    color: var(--dynamic-color);\n  }\n</style>\n\n<div class=\"element\">Hello World</div>\n\n<script>\n  document.documentElement.style.setProperty('--dynamic-color', '#e74c3c');\n</script>\n\n```\n\n## 变量的继承\nCSS 变量遵循 CSS 的继承规则，子元素可以继承父元素定义的变量。\n```css\n.parent {\n  --inherited-color: #3498db;\n}\n.child {\n  color: var(--inherited-color); /* 继承自 .parent */\n}\n```\n\n## 变量的类型\nCSS 变量可以存储任何合法的 CSS 值，包括颜色、长度、百分比、字符串等。\n```css\n:root {\n  --color: #3498db;\n  --padding: 10px;\n  --font: 'Arial, sans-serif';\n}\n.element {\n  color: var(--color);\n  padding: var(--padding);\n  font-family: var(--font);\n}\n```\n\n## CSS @property\n\n- **描述**：用于注册自定义属性，并定义其初始值和继承行为。\n- **特点**：增强了 CSS 变量的功能。\n- **示例**：\n```css\n@property --main-color {\n  syntax: '<color>';\n  initial-value: #3498db;\n  inherits: true;\n}\n```\n\n> 源于 GPT 4.0 ，总结得很好！\n\n","031ac4b4-ea19-56e3-816a-3f7c674293c6":"\n# 媒体查询\n\n\n- min-width,\n- max-width\n- orientation\n- @container\n\n## `Container` Queries \n\n- **描述**：允许根据容器的尺寸而不是视口尺寸来应用样式。\n- **特点**：**更灵活的响应式设计，更灵活的媒体查询**\n- **示例**：\n```css\n@container (min-width: 500px) {\n  .element {\n    background-color: blue;\n  }\n}\n```\n\n","cee4ed35-8b2c-53ee-be11-da54f2b8afa3":"\n# 说一说盒模型\n\n看下面两张图即可\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3193f0e277d0e85d83a2451b624006f3.png)\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3514efe3929b598730be168652a3e627.png)\n\n","bc8eeddd-8083-5342-b457-1bd1e2931b24":"\n# 说说BFC与外边距重叠\n\n\n## 定义\n`BFC（Block Formatting Context，块级格式化上下文）`是 CSS 中一个重要的概念，它是页面布局中的一个独立渲染区域，决定了元素如何定位及与其他元素之间的关系。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/54562a17d3dbd31f0f89a9e125bfe2c3.png)\n\n## BFC 的特性\n\n1. **内部的盒子会在垂直方向，一个接一个地放置。**\n2. **盒子垂直方向上的距离由 **`margin`** 决定。相邻块级元素的外边距会发生折叠。**\n3. **BFC 的区域不会与浮动元素的盒子重叠。**\n4. **BFC 是一个隔离的独立容器，容器内部的元素不会影响外部的元素。**\n\n## 创建 BFC 的方式\n以下 CSS 属性会触发创建 BFC：\n\n1. 设置 `float` 不为 `none` 的元素；\n2. 设置 `position` 为 `absolute` 或 `fixed` 的元素；\n3. 设置 `display` 为 `inline-block`, `table-cell`, `table-caption`, `flex`, 或 `grid` 的元素；\n4. 设置 `overflow` 不为 `visible` 的元素。\n\n示例：\n```css\n.bfc {\n  overflow: hidden;  /* 触发 BFC */\n}\n```\n\n## 外边距重叠（Margin Collapsing）\n外边距重叠是指`**当两个上下相邻的块级元素的垂直外边距相遇时，它们会合并为一个外边距**`，其高度为最大的那个外边距值，而不是两者之和。\n\n### 兄弟元素的边界重叠 &  父子元素的边界重叠\n![A792D720-3B01-4A74-B5BD-7DC9028EFE9D.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e34a6a6d31a5c93b4d342ec4a57f596b.png)\n\n### 外边距重叠的规则\n\n- 同正，较大值 \n- 同负，绝对值最大值\n- 一正一负：相加\n\n## 使用 BFC 防止外边距重叠\n\n- 解决方案：即去触发`BFC`即可，如`BFC` 不会与 `float` 元素发生重叠。\n\n![240B4A71-C78E-47B2-A432-BF18ACC1134C.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/c4f97a2d27026987eb2967c1a6d48207.png)\n\n![E87FF6E8-F4A6-458C-B71C-9D230BAC5BB1.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ff8df8522e39084cec5d64669309ac23.png)\n\n","b2ce585a-2f0c-5568-8df9-ebedeb943716":"\n# 说说回流和重绘\n\n\n## 先看定义\n- `回流（或重排）`：布局引擎会根据各种样式计算每个盒子在页面上的`大小与位置`\n   - 重排（也称为回流）是浏览器重新计算页面中`**元素位置和几何形状**`的过程\n- `重绘`：当计算好盒模型的`位置、大小及其他属性`后，浏览器根据每个盒子特性进行绘制\n- `重绘`不一定导致`重排`，但`重排`一定会导致`重绘`  ，如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/0e89990a6d49095e5a717c3af1edeb53.png)\n\n## 导致`回流`的场景\n\n- 页面`首次渲染`\n- 浏览器`窗口大小`发生改变\n- 元素`尺寸或位置`发生改变\n- 元素内容变化（`文字数量`或`图片大小`等等）\n- 元素`字体大小`变化\n- `添加或者删除`可见的DOM元素\n- 激活CSS伪类（例如：`:hover`）\n- `calc()` 本身不会引起 `回流`，但是因为需要重新计算布局的属性，比如父元素的宽度改变了，那必然会导致子元素的一个 `回流`\n- `查询某些属性`或`调用某些方法`\n   - `dom.style.width/height` ，只能取`行内样式的宽和高`，`style` 中 `link` 外链取不到。可写，修改时会导致`重排`\n   - `window.getComputedStyle(dom).width/height`，指定`第二参数`指定一个要匹配的伪元素的字符串。必须对普通元素省略（`或null`） ，\n      - 读取的样式是`最终样式`，包括了内联样式、嵌入样式和外部样式\n      - 比如`getComputedStyle(h3, '::after').content` \n      - 会导致`回流` 因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），为求一个`“即时性”`和`“准确性”`。\n   - `dom.getBoundingClientRect().width/height 、top/left/right/bottom`  得到`渲染后的宽和高`，及`相对于视窗的上下左右`的距离\n   - 获取`布局信息`时，会导致`重排`。相关的方法属性如 `offsetTop`   `getComputedStyle` 等\n   - `scrollIntoView()`、`scrollIntoViewIfNeeded()` 、 `scrollTo()` 滚动时，会导致`重排`\n\n>  总之， `查询某些属性`或`调用某些方法` 是否会导致重排，关键需要看  `只读了` ，还是有`写入`操作\n\n>  另外一些容易被忽略的操作：如 getComputedStyle，  offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 这些属性有一个共性，就是需要通过`**即时计算**`得到。因此浏览器为了获取这些值，也会进行`回流`\n\n## opacity、display 和 visibility\n\n- 修改 `opacity` 和 `visibility` 属性通常只会触发`重绘`，而不会触发`回流`\n- 而修改 `display` 属性则可能会触发`回流和重绘`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/d416ea83c9a78c5f5445f7568c9de8ba.png)\n\n> - `**opacity**`** 为 0 ，可以点击**\n> - visibility 为 hidden时，不能点击\n\n## 修改  `left` 和 `right` 的影响\n\n### 对于绝对定位 (`position: absolute`) 和 固定定位 (`position: fixed`)的元素\n\n> **结论： 对于脱离文档流的元素：一般不会引起文档流的重排，但会导致该元素的重绘。**\n\n- 这些元素脱离正常文档流，它们的布局不再影响和被其他元素影响\n- 对于脱离文档流的元素（如`position: absolute`或`position: fixed`），修改`left`和`right`属性通常直接影响该元素本身的位置，而不会影响到其他元素的布局，因此**不会引起整体布局的重排**。\n- 然而，依然会 **导致该元素的重绘（repaint），但不涉及到重排（reflow）**\n\n### 对于对于未脱离文档流的元素（如`position: relative`）\n\n- 可能会导致该元素及其子元素的重排\n- 元素本身改变了，自然有可能导致整个文档的重排\n\n### 对于 `position: sticky` 的元素\n\n#### `position: sticky` 的特性\n\n- 当元素在容器视口内时，它表现为相对定位（`relative`）。\n- 一旦元素滚动到指定偏移位置，它就表现为固定定位（`fixed`），即相对于视口定位。\n\n#### 相对定位阶段（在容器视口内）\n\n- 元素还未达到指定的偏移位置，此时与普通的`**相对定位**`元素非常相似。\n- 修改 `left` 和 `right` 会影响元素的位置，因此可能会引发重排（reflow）。\n\n#### 固定定位阶段（到达偏移位置）\n\n- 元素达到偏移位置，变为相对视口定位。\n- 修改 `left` 和 `right` 的行为更像是**固定定位**，通常不影响其他元素的布局。\n- 这种情况下，可能只会导致重绘（repaint），不会引发重排。\n\n### 总结\n\n- 对于已经脱离文档流的元素（如 position: absolute 或 fixed），仅修改 left 和 right 的值通常不会导致其他元素的回流，但可能会导致该元素本身的重绘。\n- 对于` position: relative` 来说，对导致\n\n## 一些优化建议\n\n### `transform` 代替 `top/left` \n\n### 避免使用`CSS表达式`（如：`calc()`）\n\n### 批量修改 DOM\n```javascript\nconst fragment = document.createDocumentFragment();\nfor (let i = 0; i < 10; i++) {\n  const li = document.createElement('li');\n  li.textContent = `Item ${i}`;\n  fragment.appendChild(li);\n}\ndocument.getElementById('myList').appendChild(fragment);\n```\n\n   - 使用文档片段(DocumentFragment)或者先将元素设为不可见，进行多次修改后再显示。\n\n### 避免频繁操作样式\n```javascript\n// 不推荐\nconst el = document.getElementById('myElement');\nel.style.borderLeft = '1px';\nel.style.borderRight = '2px';\nel.style.padding = '5px';\n\n// 推荐\nel.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';\n// 或者\nel.classList.add('my-class');\n```\n\n- 合并多次样式修改，一次性修改。\n- 使用类名替代多次样式修改。\n- `classList.add/remove/toggle` 来切换样式，而不是直接修改` style 属性`\n\n### 缓存布局信息：批量修改\n```javascript\n// 不推荐\nfor (let i = 0; i < 100; i++) {\n  element.style.left = `${element.offsetLeft + 1}px`;\n}\n\n// 推荐\nlet left = element.offsetLeft;\nfor (let i = 0; i < 100; i++) {\n  left++;\n  element.style.left = `${left}px`;\n}\n```\n\n- 避免多次读取会引发重排的属性。\n\n### 使用绝对定位使元素脱离文档流\n\n- 对于频繁重排的元素，可以使用绝对定位使其脱离文档流。\n- `position: absolute、fixed `  脱离文档流，以避免对其他元素布局的影响。\n\n### 优化动画\n```javascript\nfunction animate() {\n  // 动画逻辑\n  requestAnimationFrame(animate);\n}\nrequestAnimationFrame(animate);\n```\n\n- 使用 `requestAnimationFrame` 来控制动画。\n- 使用 CSS3 动画和 transforms 替代 JavaScript 动画。\n\n### 使用 CSS3 硬件加速\n```css\n.move {\n  transform: translateX(100px);\n}\n```\n使用 transform、opacity、filters 等属性，触发 GPU 加速。\n\n使用`css3硬件加速`，`可以让transform`、`opacity`、`filters` 这些动画不会引起`回流重绘`\n\n### 避免使用 `table` 布局\n\n- 表格布局可能导致多次重排。\n\n### 降低 CSS 选择器的复杂性\n复杂的选择器会增加样式计算时间。\n\n### 离线操作：使用 `display: none` 进行大量 DOM 操作\n```javascript\nconst el = document.getElementById('myElement');\nel.style.display = 'none';\n// 进行大量 DOM 操作\nel.style.display = 'block';\n```\n> 当元素设为 `display: none` 时，对其进行的操作不会引发重排和重绘。\n\n### 使用虚拟 DOM\n\n- 像 React、Vue 这样的框架使用虚拟 DOM 来优化实际 DOM 操作。\n\n### 使用防抖(Debounce)和节流(Throttle)\n对于频繁触发的事件（如滚动、调整窗口大小等），使用这些技术来限制处理函数的执行频率。\n\n### 分离读写操作\n```javascript\n// 不推荐\nconst h1 = element1.clientHeight;\nelement1.style.height = `${h1 * 2}px`;\nconst h2 = element2.clientHeight;\nelement2.style.height = `${h2 * 2}px`;\n\n// 推荐\nconst h1 = element1.clientHeight;\nconst h2 = element2.clientHeight;\nelement1.style.height = `${h1 * 2}px`;\nelement2.style.height = `${h2 * 2}px`;\n```\n先进行所有的读操作，然后再进行写操作，避免读写交叉导致多次重排。\n\n> 在实际应用中，应根据具体情况选择合适的优化方法。\n\n","03d12d78-3af8-5f51-af73-33bdf71dc87a":"\n# 请列举 CSS 兼容性相关的知识点\n\n\n- `@supports not (--css: variables) {}` 用于确定是否支持`css 变量`\n- Autoprefixer\n- Can I use?\n- CSS Reset\n   - CSS Reset: 如Eric Meyer’s Reset CSS\n   - Normalize.css: 保留有用的默认样式，同时标准化跨浏览器的样式\n- Modernizr库: 一个流行的库，用于检测HTML5和CSS3特性，比如 `if (Modernizr.flexbox) {} `\n- IE条件注释，太老了，可以不用了吧？\n- 渐进增强和优雅降级\n- CSS Hack：比如 `*color: yellow; /* IE6,IE7 */`\n- 单位兼容性：使用 px , 有可能 rem/vw/vh 不支持\n","9cce188e-29f2-58ef-8fc3-75d318210e0a":"\n# JavaScript 引擎\n\n引擎很复杂，但是基本原理很简单。\n\n1. 引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。\n2. 然后，引擎将脚本转化（“编译”）为机器语言。\n3. 然后，机器代码快速地执行\n\n\nJavaScript 引擎是用于解释和执行 JavaScript 代码的程序。它们最常见于网页浏览器中，但也用于许多其他环境。主要的 JavaScript 引擎包括：\n\n1. **V8 (谷歌)**:\n   - 开发者：谷歌\n   - 用于：Chrome 浏览器、Node.js 等\n   - 特色：使用`即时编译`（JIT，Just-In-Time compilation），将 JavaScript 代码即时编译成与机器码，以提高执行效率。\n2. **SpiderMonkey (Mozilla)**:\n   - 开发者：Mozilla\n   - 用于：Firefox 浏览器\n   - 特色：是第一个 JavaScript 引擎，支持解释和编译两种模式，使用多层优化编译器。\n3. **Chakra (微软)**:\n   - 开发者：微软\n   - 用于：曾用于 Internet Explorer 和 Microsoft Edge (旧版，EdgeHTML)\n   - 特色：拥有一个强大的 JIT 编译器，支持优化的执行和垃圾回收。\n4. **JavaScriptCore (苹果)**:\n   - 开发者：苹果\n   - 用于：Safari 浏览器\n   - 特色：也被称为 Nitro，注重内存管理和执行性能。\n\n### JavaScript 引擎的组成部分\n\n1. **解析器 (Parser)**:\n   - 将源代码转换成抽象语法树 (AST，Abstract Syntax Tree)。\n   - 分析代码结构，保证语法正确。\n2. **解释器 (Interpreter)**:\n   - 逐行解释和执行 JavaScript 代码，使用 AST 生成中间代码。\n3. **编译器 (Compiler)**:\n   - JIT 编译器会在运行时将`频繁执行的代码`编译成机器码，以更快地执行。\n4. **运行时 (Runtime)**:\n   - 提供内置函数、内存管理（如垃圾回收）和执行环境。\n\n### 运行机制\n\n1. **解析和编译**\n   - 代码首先被解析器解析为 AST，然后 JIT 编译器将部分 AST 编译成机器码。当运行过程中发现某些代码片段被频繁调用，编译器会进一步优化这些片段。\n2. **执行**\n   - 执行引擎会根据编译后的代码直接运行机器码，从而提高性能。\n3. **垃圾回收 (Garbage Collection)**\n   - JavaScript 引擎会自动管理内存，自动回收不再使用的对象和变量。这通常是通过垃圾回收器实现的，常见的算法包括标记-清除 (mark-and-sweep)、引用计数 (reference counting) 等。\n\n### 性能优化\n\n1. **即时编译 (Just-In-Time Compilation, JIT)**\n   - 使用 JIT 编译器，代码在运行时被动态编译，避免了解释代码的开销。\n2. **内联缓存 (Inline Caching)**\n   - 用于加速属性查找和方法调用频繁的对象。\n3. **惰性解析 (Lazy Parsing)**\n   - 只在真正需要时解析 JavaScript 代码，提高初始加载性能。\n4. **垃圾回收优化**\n   - 通过分代垃圾回收、增量垃圾回收等技术，提高内存管理效率。\n\n总的来说，JavaScript 引擎通过多种技术和优化策略，极大地提升了 JavaScript 代码的运行效率和性能。这也是现代网页和应用程序复杂度和功能性得以提升的重要因素之一。\n\n\n\n\n\n# 参考\n\n- [https://zh.javascript.info/intro](https://zh.javascript.info/intro)\n- [https://kangax.github.io/compat-table](https://kangax.github.io/compat-table) ：一份列有语言功能以及引擎是否支持这些功能的表格。\n","1d7d1b02-0324-5e56-b961-9137b37ef98f":"\n# JavaScript 的垃圾回收机制\n\nJavaScript 的垃圾回收机制主要通过自动内存管理来处理不再使用的对象和变量，以释放内存资源。最常用的垃圾回收算法是 **标记-清除 (Mark-and-Sweep)**。以下是主要特点和步骤：\n\n### 标记-清除算法\n\n1. **标记阶段 (Marking Phase)**:\n   - 从根对象（例如全局对象、局部变量等）开始，标记所有可达的对象，即有引用的对象。\n2. **清除阶段 (Sweeping Phase)**:\n   - 遍历内存，将未被标记的对象视为垃圾，并将其内存释放。\n\n### 其他优化策略\n\n1. **分代垃圾回收 (Generational Garbage Collection)**:\n   - 将内存分为两代：新生代和老生代。\n   - 新生代对象生命周期短，频繁回收；老生代对象生命周期长，较少回收。\n2. **增量垃圾回收 (Incremental Garbage Collection)**:\n   - 将标记和清除过程分成多个小步进行，以避免长时间停顿。\n3. **惰性垃圾回收 (Lazy Garbage Collection)**:\n   - 当系统空闲时才进行垃圾回收，减少对应用程序性能的影响。\n\n### 垃圾回收触发条件\n\n- 内存使用达到一定阈值。\n- 系统空闲时主动触发垃圾回收。\n\n### 优点\n\n- **自动内存管理**：开发者无需手动管理内存，减少内存泄漏风险。\n- **优化性能**：现代垃圾回收机制通过多种优化策略，降低了对应用性能的影响。\n\n### 缺点\n\n- **不可控性**：垃圾回收时机和频率由引擎管理，开发者无法完全控制。\n- **潜在的性能影响**：尽管有多种优化策略，但垃圾回收仍可能在高负载应用中引入停顿。\n\n总的来说，JavaScript 的垃圾回收机制通过自动化和优化的内存管理，提供了便捷的开发体验，同时通过多种算法和策略提高了效率和性能。\n","7da471d0-d097-599f-a676-07b8bace685b":"\n# JavaScript 的核心语法\n\n\n# 现代模式，\"use strict\"\n\n## 原因\nES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— `\"use strict\"` 来明确地激活这些特性。\n\n\n## 语法\n```javascript\n\"use strict\"; // 必须放到开头\n\n// 代码以现代模式工作\n...\n```\n\n- 现代 JavaScript 支持 “class” 和 “module”，如果使用它们，无需添加  `\"use strict\"`\n\n\n# 6 种原始类型 + 1 种复杂数据类型\t\t\t\n\n- 原始类型：Undefined、Null、Boolean、Number、String 和 Symbol  \n- 复杂类型：Object\n\n\n# 变量、作用域与内存\n\n## 复制\n\n### 原始类型\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e3768b3af18a23c8cdeccb85e280c323.png)\n\n### 引用类型\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/bb555ee9faabf851d1d0d40946117804.png)\n\n\n## let、var、const 申明选择建议\n\n1. 不使用 var\n2. const 优先，let 次之\n> `var`就不解释了，`const` 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作\n\n\n\n","73ffd93b-6de6-59a2-bd55-bbdec7116850":"\n# JavaScript 的组成\n\n\n# Javascript 的组成\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/a9104fded4d48d2d613eecce29dc3a26.png)\n\n- ECMAScript：由 ECMA-262 定义并提供核心功能\n- 文档对象模型(DOM)：提供与`网页内容`交互的方法和接口\n- 浏览器对象模型(BOM)：提供与`浏览器`交互的方法和接口\n\n> - ECMA-262：ECMA-262 是由欧洲计算机制造商协会（ECMA）发布的一项标准，正式名称为“ECMAScript 语言规范” \n>    - 至于 262 没有什么特别的含义，就是一个代号\n> - TC39 委员会：ECMA-262 由 TC39（ECMAScript 技术委员会）负责制定和维护，该委员会由来自各大科技公司的专家组成，定期讨论和推进 ECMAScript 标准的演进。\n> - 最新的规范草案请见 [https://tc39.es/ecma262/](https://tc39.es/ecma262/)\n\n\n# Javascript 为何有如此“地位”\n\n- 与 HTML/CSS 完全集成\n- 所有的主流浏览器支持\n\n# 浏览器上的 Javascript 能做什么 和 不能做什么？\n\n- JavaScript 的能力很大程度上取决于它`**运行的环境**`。\n   - 例如，[Node.js](https://wikipedia.org/wiki/Node.js) 支持允许 JavaScript 读取/写入任意文件，执行网络请求等的函数\n   - 浏览器上的 Javascript 的能力都是浏览器提供的\n   - app  webview 上 JavaScript 的能力都是`嵌入的 APP` 提供的\n      - 比如 `webview` 组件提供了很多配置项，用于是否开启一些能力\n\n\n## 能做什么\n\n- DOM：操作 HTML 及 CSS\n- BOM：操作浏览器提供的各类 API\n- 请求资源：访问资源、上传、下载资源\n- 本地存储：cookie、localstarage 、sessionstrage 等\n\n## 不能做什么\n\n- 浏览器端读、写文件，但可以通过 `input type=file` 选择文件\n- 直接访问原生系统的一些能力，比如调取摄像头、麦克风等\n- 不能在随意在不同窗口间通信，需要一些限制，比如同域\n\n\n# JS 的超级们\n\n- [CoffeeScript](https://coffeescript.org/) ，现在基本不用了\n- [TypeScript](https://www.typescriptlang.org/) ，添加了严格的数据类型校验，后面会详细说它。微软出品。\n- [Flow](https://flow.org/) 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。\n- [Dart](https://www.dartlang.org/)  `Flutter` 使有语言，它也可以被编译成 JavaScript，由 Google 开发。\n- [Brython](https://brython.info/)  Python 到 JavaScript 的转译器\n- [Kotlin](https://kotlinlang.org/docs/reference/js-overview.html) 是一个现代、简洁且安全的编程语言，编写出的应用程序可以在浏览器和 Node 环境中运行。\n","7ef39500-51a5-5188-ad0d-f62115fd453f":"\n# JavaScript 简介\n\n\nJavaScript 是一种高层次的、解释型的编程语言。它在当今的信息技术领域中扮演着重要角色，尤其在Web开发方面。以下是关于JavaScript的全面介绍：\n\n# JavaScript 的基本概念\n\n### 1. 定义\n\n- **JavaScript** 是一种符合 ECMAScript 规范的高级编程语言。\n- 最初设计的目的是增强 HTML 网页的动态行为和交互能力。\n\n### 2. 历史\n\n- **诞生**：由 Brendan Eich 在 1995 年开发，并首次应用于 Netscape Navigator 浏览器。\n- **标准化**：ECMAScript 是由 ECMA International 管理的 JavaScript 标准化规范，ECMAScript 31999 年）和 ECMAScript 5（2009 年）是重要的里程碑。\n- **现代化**：ECMAScript 6（2015 年），又称 ES6 或 ES2015，引入了许多新特性类，模块，箭头函数等。\n\n# JavaScript 的核心特性\n\n### 1. 动态类型\n\n- JavaScript 是动态类型语言，变量可以在运行时改变类型。\n\n### 2. 解释执行\n\n- JavaScript解释型语言，不需要编译，直接在浏览器或 JS 引擎中解释执行。\n\n### 3. 弱类型\n\n- 支持隐式类型转换，可以灵活使用不同的数据类型。\n\n### 4. 单线程\n\n- JavaScript 本上是单线程的，但通过事件循环机制可以处理异步任务。\n\n### 5. 跨平台\n\n- JavaScript 可以在多种环境下运行，最常见的是浏览器环境和 Node.js 环境。\n\n# JavaScript 的应用场景\n\n## Web前端开发\n\n- **DOM操作**：控制和操作网页内容。\n- **事件处理**：响应用户操作（如点击、输入）。\n- **AJAX**：实现异步数据请求和更新。\n- **动态样式**：通过操作 CSS 打造动态效果。\n\n## 服务端开发\n\n- **Node.js**：基于 Chrome V8 引擎构建，支持服务器端开发。\n- **Express、Koa**：常用的服务器框。\n- **数据库操作**：如与 MongoDB、MySQL 的交互。\n\n## 全栈开发\n\n- **MEAN/MERN 栈**：MongoDB, Express, Angular/React, Node.js。\n- 基于 React 和 Vue.js 的服务端渲染框架: Next.js 和 Nuxt.js。\n\n## 移动应用开发\n\n- **React Native**：使用 JavaScript 构建原生移动应用。\n- **Ionic、PhoneGap/Cordova**：建跨平台移动应用。\n\n## 桌面应用开发\n\n- **Electron、NW.js**：使用 Web 技术构建跨平台桌面应用。\n\n## 游戏开发\n\n- **Three.js**：创建3D图形动画。\n- **Phaser**：2D游戏框架。\n\n## 数据可视化\n\n- **D3.js、Chart.js、Highcharts**：用于高级数据可视化和图表创建。\n\n## 机器学习人工智能\n\n- **TensorFlow.js、Brain.js**：让机器学习和神经网络在浏览器中运行。\n\n## 物联网 (IoT)\n\n- **Johnny-Five、Espruino**：用于智能设备和嵌式开发。\n\n## 自动化和脚本\n\n- **Gulp、Grunt**：任务自动化工具。\n- **ShellJS**：执行系统命令和脚本编写。\n\n# JavaScript 的重要概念和机制\n\n### 1. 原型和原型链\n\n- JavaScript 使用原型继承，即对象之间通过原型链形成继承关系。\n\n### 2. 闭包\n\n- 闭包是一个函数能记住并访问它的词法域，即使在函数在其词法作用域外执行。\n\n### 3. 事件循环\n\n- 事件循环是 JavaScript 处理异步操作的机制，检测调用栈是否为空，并从任务队列中取任务执行。\n\n### 4、异步编程\n\n- **回调函数**：基本的异步处理方式，但会导致“回调地狱”。\n- **Promise**：链式解决异步调用，避免回调地狱。\n- **async/await**：于 Promise 的语法糖，让异步代码看起来像同步代码。\n\n### 5. this 关键字\n\n- `this` 在不同的上下文中有不同的指向。\n- 比如，函数调用中的 `this` 指向局对象，用 `new` 调用构造函数时，`this` 指向新创建的对象。\n\n### 6. 模块化\n\n- ES6 提供了原生的模块化支持 (`import` 和 `export`)。\n- 之前解决方案包括 CommonJS (Node.js 使用的模块系统) 和 AMD (异步模块定义)。\n\n# JavaScript 的生态系统\n\n- **库和框架**：如 React、Vue.js、Angular、jQuery 等。\n- **包管理**：npm (Node Package Manager)、Yarn 等。\n- **构建工具**：Webpack、Parcel、Gulp、Grunt 等。\n- **测试工具**：Jest、Mocha、Chai、Cypress 等。\n- **版本控制：Babel，支持将新的 JavaScript 语法转换为旧的语法，以便在不支持的环境中运行。\n\n# JavaScript 的局限性\n\n- 单线程模型在进行 CPU 密集型任务时效率较低。\n 隐式类型转换可能导致一些预期之外的行为。\n- 动态类型系统可能在大型项目中引入类型相关的缺陷。\n\n\nJavaScript 是一门功能强大且灵活的语言，广泛应用于各种开发场景中理解其核心原理和生态系统有助于开发者更好地利用它的潜力。\n","8071d703-2ced-5a85-a073-1f1b4d398215":"\n# JavaScript 篇\n\nJavaScript 相关的知识点\n\n","99749d5e-8dfa-50a6-9c8d-3580cd97d2b8":"\n# Typescript 篇\n\n\n## 一、编译\n可通过 `tsconfig.json` 来指定哪些文件编译等编译选项，如\n```json\n{\n  \"files\": [\n    \"./some/file.ts\"\n  ],\n  \"include\": [\n    \"./folder\"\n  ],\n  \"exclude\": [\n    \"./folder/**/*.spec.ts\",\n    \"./folder/someSubFolder\"\n  ]\n}\n```\n>  playground： [http://www.typescriptlang.org/play/](http://www.typescriptlang.org/play/) \n\n可运行 `ts` 的编译工具\n1、TypeScript 官方提供的编译器叫做 `tsc` \n2、**ts-node**\n```bash\nnpx ts-node script.ts\n\n# 或者\nts-node script.ts\n```\n\n## 二、声明空间\n在 TypeScript 里存在两种声明空间：`类型声明空间`与`变量声明空间`\n\n### （一）类型声明空间\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/76e5d299da3f92d03fa51b2e9528079d.png)\n\n即 `interface B{}`  只是一个`类型申明`，不能当做变量使用\n>  看上图，`b1` 和 `c1` 都飘红警告了\n\n### （二）变量声明空间\n```javascript\n/**\n * ① Class Foo 提供了一个类型 Foo 到类型声明空间\n * ② 把一个类来当做变量传递时，ts 会把这个类当做值来处理\n * */\nclass Foo {\n}\n\nconst someVar: Foo = Foo;\n\n\n/**\n * ① 一些用 var 声明的变量，也只能在变量声明空间使用，不能用作类型注解，如下示例\n */\nconst foo = 123;\nlet bar: foo; \n// ts2749: 'foo' refers to a value, but is being used as a type here. Did you mean 'typeof foo'?\n\n```\n\n### （三）总结\n**总结就是：**\n\n1. `变量声明空间`可以直接当做变量赋值使用，但如`const foo = 123;` 中的 `foo`不能当做**类型注解**使用\n2. `类型声明空间` 都可以当做类型注解，但不能当做`类型注解` 使用\n\n## 三、TS 模块\n\n### （一）全局模块\n你可以在项目中创建一个 `全局声明文件 global.d.ts`，用于声明全局变量。比如全局使用的 `JQuery`\n```typescript\ndeclare var jQuery: (selector: string) => any;\n```\n>  需要使用 `declare` 关键词\n\n### （二）文件模块\n即 `文件模块系统`，耳熟能详的的 `CMD AMD ESM` 等等，这里只讨论 ESM ，而且只需要注意一下几种平时自己不常用的写法\n主要是`as` 的几个写法，如下：\n```typescript\nexport { someVar as aDifferentName };\n\nimport { someVar as aDifferentName } from './foo';\n\nimport * as foo from './foo';\n```\n\n## 四、命名空间\n使用 `namespace` 关键词，如下：\n```typescript\nnamespace Utility {\n  export function log(msg) {\n    console.log(msg);\n  }\n  export function error(msg) {\n    console.log(msg);\n  }\n}\n\n// usage\nUtility.log('Call me');\nUtility.error('maybe');\n\n```\n以上 `ts` 最终转成 `js` 的样子如下，是的，是不是很类似之前` JQuery` 的实现方式。\n```javascript\n(function (Utility) {\n  // 添加属性至 Utility\n})(Utility || Utility = {});\n\n```\n\n## 五、动态导入表达式\n其实就类似于 Webpack 的 `import()` （首选，ECMAScript 的提案）和 `require.ensure()` ，这样就能实现**代码分割能力** ，即`Code Splitting`  ，举个例子，比如我们需要懒加载 `mement`\n```typescript\nimport(/* webpackChunkName: \"momentjs\" */ 'moment')\n  .then(moment => {\n    // 懒加载的模块拥有所有的类型，并且能够按期工作\n    // 类型检查会工作，代码引用也会工作 \n    const time = moment().format();\n    console.log('TypeScript >= 2.4.0 Dynamic Import Expression:');\n    console.log(time);\n  })\n  .catch(err => {\n    console.log('Failed to load moment', err);\n  });\n```\n\n## 六、Typescript 类型系统\n\n### （一）基本类型\n即以下 8 种类型\n\n- boolean\n- string\n- number\n- bigint\n- symbol\n- object\n- undefined\n- null\n\n1、**TypeScript 继承了 JavaScript 的类型设计**，以上8种类型可以看作 TypeScript 的基本类型。\n2、`undefined` 和 `null` 既可以作为**值**，也可以作为**类型**，取决于在哪里使用它们。更多参考 [[#^d3044f]]\n3、这里单独说下 `object` 根据 JavaScript 的设计，`object` 类型包含了所有对象、数组和函数。\n```typescript\nconst x:object = { foo: 123 };\nconst y:object = [1, 2, 3];\nconst z:object = (n:number) => n + 1;\n```\n\n---\n\n4、包装类型：5 种\n（1）`Symbol()`** 和 **`BigInt()`** 不能作为构造函数使用** ，即他俩无法直接获取它们的**包装对象** \n\n- boolean：`Boolean()`\n- string    `String()`\n- number   `Number()`\n- bigint  \n- symbol\n\n（2）包装对象类型与字面量类型：**大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。**\n\n- **包装对象** 和 **字面量**   ： 对应关系如下\n- Boolean 和 boolean\n- String 和 string\n- Number 和 number\n- BigInt 和 bigint\n- Symbol 和 symbol\n\n举例：\n```typescript\n\n① 即大写是小写形式的超集 \n\nconst s1:String = 'hello'; // 正确\nconst s2:String = new String('hello'); // 正确\n\nconst s3:string = 'hello'; // 正确\nconst s4:string = new String('hello'); // 报错\n\n\n② 建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象，\n\n比如，Math.abs(小写类型)\nconst n1:number = 1;\nconst n2:Number = 1;\n\nMath.abs(n1) // 1\nMath.abs(n2) // 报错\n```\n（3）`Object` 类型与 `object` 类型 \n先看 **大写的 Object** \n```typescript\n\n①  大写的Object类型代表 JavaScript 语言里面的广义对象。\n    所有可以转成对象的值，都是Object类型，这囊括了几乎所有的值\n\nlet obj:Object;\n \nobj = true;\nobj = 'hi';\nobj = 1;\nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\n\n② 事实上，除了undefined和null这两个值不能转为对象，其他任何值都可以赋值给Object类型，比如一下示例会报错\n\nlet obj:Object;\n\nobj = undefined; // 报错\nobj = null; // 报错\n\n\n③ 空对象 {} 是Object类型的简写形式，所以使用Object时常常用空对象代替，如下：\n\nlet obj:{};\n \nobj = true;\nobj = 'hi';\nobj = 1;\nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\n\n④ 显然，无所不包的Object类型既不符合直觉，也不方便使用，所以不建议使用\n\n```\n\n> [!danger]\n **无所不包的Object类型既不符合直觉，也不方便使用，所以不建议使用**\n\n再看 **小写的 object**  ,  ==只包含对象、数组和函数==， 不包括原始类型的值，比如下面代码\n```typescript\nlet obj:object;\n \nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\nobj = true; // 报错\nobj = 'hi'; // 报错\nobj = 1; // 报错\n```\n注意，无论是大写的Object类型，还是小写的object类型，都 **只包含 JavaScript 内置对象原生的属性和方法**，用户自定义的属性和方法都不存在于这两个类型之中。\n```typescript\n\nconst o1:Object = { foo: 0 };\nconst o2:object = { foo: 0 };\n\no1.toString() // 正确\no1.foo // 报错\n\no2.toString() // 正确\no2.foo // 报错\n\n```\n> 如下图，都报警告了，这个值得注意，即 object 其实不常用，最好直接定义 interface 类型\n>  ![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b4674d165a9a0fa7a4faf5501b8ac303.png)\n\n### （二）数组类型\n\n#### 1、基本用法\n```typescript\nlet a:boolean[]; // 同 let a:Array<boolean>;\nlet b:any[];   // 同 let b:Array<any>;\nlet arr:(number|string)[];  // 同 let arr:Array<number|string>;\n```\n\n#### 2、读取数组成员类型\nTypeScript 允许使用方括号读取数组成员的类型。如下：\n```typescript\n① 读取数组成员的类型\ntype Names = string[];\ntype Name = Names[0]; // string\n\n② 由于数组成员的索引类型都是number，所以读取成员类型也可以写成下面这样\ntype Name = Names[number]; // string\n\n③ 那么这种写法是可以的吗？\ntype Name = Names[99999]\n\n```\n\n#### 3、数组的类型推断\n为数组赋值时，TypeScript 会**自动更新类型推断**，如下：\n```typescript\nconst arr = [];\narr // 推断为 any[]\n\narr.push(123);\narr // 推断类型为 number[]\n\narr.push('abc');\narr // 推断类型为 (string|number)[]\n\n② 下面这种会推断初始值为 number 后面再赋值就会报错了\n// 推断类型为 number[]\nconst arr = [123];\n\narr.push('abc'); // 报错\n```\n\n#### 4、只读数组\n（1）`const` 命令声明的数组变量是可以改变成员的，如下：\n```typescript\nconst arr = [0, 1];\narr[0] = 2;\n```\n（2）声明只读数组，即 `readonly`, 下面示例中，`arr` 是一个只读数组，删除、修改、新增数组成员都会报错。\n```typescript\nconst arr:readonly number[] = [0, 1];\n\narr[1] = 2; // 报错\narr.push(3); // 报错\ndelete arr[0]; // 报错\n```\n（3）`number[]`其实是`readonly number[]`的子类型\n```typescript\nlet c:number[] = [0, 1];\nlet p:readonly number[] = c; // 正确\n\nc = p; // 报错\n```\n> 所以，这里有个用法就是，如果只是希望根据数组生成另外一个数组，比如过滤出数组等，就可以传入 readonly 的数组 ？ \n\n```typescript\n\n① getSum()的参数s是一个数组，传入只读数组就会报错。原因就是只读数组是数组的父类型，父类型不能替代子类型\nfunction getSum(s:number[]) {\n  // ...\n}\n\nconst arr:readonly number[] = [1, 2, 3];\n\ngetSum(arr) // 报错\n\n② 使用 类型断言 as 解决报错\n\ngetSum(arr as number[])\n```\n\n---\n\n疑惑：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9e33333a92b80383104547a2393f5fef.png)\n\n> [!danger]\n**有点和自己理解的有偏差**，把 `readonly number[]` 当做是父类，`number[]` 子类，子类继承父类，所以会多出 比如 `pop` `push` 等可改变数组的方法\n\n---\n\n（4）使得数组可读的其他方法\n```typescript\n① readonly与数组的泛型写法一起使用，就会报错\n// 报错\nconst arr:readonly Array<number> = [0, 1];\n\n② TypeScript 提供了两个专门的泛型，用来生成只读数组的类型\nconst a1:ReadonlyArray<number> = [0, 1];\nconst a2:Readonly<number[]> = [0, 1];\n\n③ as const告诉 TypeScript，推断类型时要把变量arr推断为只读数组，从而使得数组成员无法改变。\n\nconst arr = [0, 1] as const;\narr[0] = [2]; // 报错 \n\n```\n\n#### 5、多维数组\n```typescript\n① TypeScript 使用T[][]的形式，表示二维数组，T是最底层数组成员的类型\n\nvar multi:number[][] = [[1,2,3], [23,24,25]];\n```\n\n### （三）any 、null 、 undefined 、void\n1、`any`  告诉 **TypeScript 编译器**不要进行任何的类型检查，失去了类型检查的意义，另外会造成**类型污染** ，如下： ^4fa065 \n```typescript\nlet user: any = {\n  avatar: {\n    url: '/user-1.png'\n  }\n};\nlet avatar = user.avatar; // any\nlet url = avatar.url; // any\n```\n使用场景：\n\n- 老旧项目，年代久远的项目\n- 其他特殊原因：需要关闭具体变量的类型检查\n\n另外，可通过 `tsc --noImplicitAny app.ts` 启动 `any` 检查\n\n2、`null` 、 `undefined`  : 任何类型，都能再赋值为  `null`  和 `undefined` ，如下代码 ^d3044f\n```typescript\n// strictNullChecks: false\nlet num: number;\nlet str: string;\n\n// 这些类型能被赋予\nnum = null;\nstr = undefined;\n\n它们的类型会被推断为any。\nlet a = undefined;   // any\nconst b = undefined; // any\n\nlet c = null;        // any\nconst d = null;      // any\n\n\n// 打开编译设置 strictNullChecks = true\nlet a = undefined;   // undefined\nconst b = undefined; // undefined\n\nlet c = null;        // null\nconst d = null;      // null\n\n\n// tsc --strictNullChecks app.ts\nlet age:number = 24;\nage = null;      // 报错\nage = undefined; // 报错\n\n\n// 打开 strictNullChecks\n\nlet x:undefined = null; // 报错\nlet y:null = undefined; // 报错\n\n```\n**总之，打开 strictNullChecks 以后，undefined和null只能赋值给自身，或者any类型和unknown类型的变量**\n```typescript\nlet x:any     = undefined;\nlet y:unknown = null;\n```\n\n3、`void`  标识 函数没有返回值，即**空值** ，其实可以理解为 `null | undefined` \n\n### （四）never\n**代表永远不会发生** 的类型，是 TypeScript 中的 **底层类型** ， 看下面的两个示例：\n\n1. 一个总是会抛出错误的函数\n2. 一个从来不会有返回值的函数，因为里面包含 `while(true)`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b010c6ee18dfa882025d20df3366730d.png)\n看一个具体**案例**：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/edc5b68e55702c323c6b2660dcec33a0.png)\n或者如下代码，统一包装一个 `fail` 函数\n```typescript\nfunction foo(x: string | number): boolean {\n  if (typeof x === 'string') {\n    return true;\n  } else if (typeof x === 'number') {\n    return false;\n  }\n\n  // 如果不是一个 never 类型，这会报错：\n  // - 不是所有条件都有返回值 （严格模式下）\n  // - 或者检查到无法访问的代码\n  // 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型\n  // 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。\n  return fail('Unexhaustive');\n}\n\nfunction fail(message: string): never {\n  throw new Error(message);\n}\n```\n>  1、注意：抛出异常后就直接中断程序了\n 2、**never 仅能被赋值给另外一个 never 类型**\n\n### （五）Unknown\n1、使用 `any` 有很多弊端 ，参考如上： [[#^4fa065]] ，这就引出了 `unknown`\n2、`any` 和 `unknown` 的 **本质区别**：\n `any` 和 `unknown` 的最大区别是, unknown 是 `top type` (任何类型都是它的 subtype) , 而  **any 即是 top type, 又是 bottom type** (它是任何类型的 `subtype` ) ，这导致 any 基本上就是放弃了任何类型检查。\n**所以， **`any`** 和 **`unknown`**  的 交集 和 并集都是 **`any` , 如下代码：\n```typescript\ntype U6 = unknown | any; // any\ntype U12 = unknown & any; // any;\n```\n3、 `unknown` 类型的值只能赋给 `unknown` 本身和 `any` 类型\n4、联合类型取最大集合，即**并集** ， 交叉类型中，取最小集合，即**交集** ，那么 unknown 的 联合类型 和 交叉类型如何呢？\n```typescript\n// 联合类型\ntype U1 = unknown | null; // unknown\ntype U2 = unknown | undefined; // unknown\ntype U3 = unknown | number; // unknown\ntype U4 = unknown | boolean; // unknown\ntype U5 = unknown | string[]; // unknown\ntype U6 = unknown | any; // any\n\n// 交叉类型\ntype U7 = unknown & null; // null;\ntype U8 = unknown & undefined; // undefined;\ntype U9 = unknown & number; // number;\ntype U10 = unknown & boolean; // boolean;\ntype U11 = unknown & string[]; // string[]\ntype U12 = unknown & any; // any;\n```\n总结一下就是： **unknown 也可以视为所有其他类型（除了any）的全集**\n>  TypeScript 有两个“**顶层类型**”（`any`和`unknown`），但是 **“底层类型”** 只有`never`唯一一个 \n\n### （六）值类型\n即 单个值也是一种类型，称为“**值类型**”。\n```typescript\nlet x:'hello';\n\nx = 'hello'; // 正确\nx = 'world'; // 报错\n\nconst x:5 = 4 + 1; // 报错\n// 在4 + 1后面加上as 5，就是告诉编译器，可以把 4 + 1的类型 视为值类型5 \nconst x:5 = (4 + 1) as 5; // 正确\n\n```\n> 单个值的值类型，用处不大，更多是配合 **联合类型** 使用\n\n### （七）联合类型\n```typescript\n\n① 常用示例\n\nlet x:string|number;\n\nlet setting:true|false;\n\nlet gender:'male'|'female';\n\nlet rainbowColor:'赤'|'橙'|'黄'|'绿'|'青'|'蓝'|'紫';\n\n// strictNullChecks = true\nlet nullOrUndefined = undefined | null\n\n// 方便书写\nlet x:\n  | 'one'\n  | 'two'\n  | 'three'\n  | 'four';\n\n② 如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”，比如：\n\nfunction printId(\n  id:number|string\n) {\n    console.log(id.toUpperCase()); // 报错\n}\n\n// 修改为 =========> \n\nfunction printId(\n  id:number|string\n) {\n  if (typeof id === 'string') {\n    console.log(id.toUpperCase());\n  } else {\n    console.log(id);\n  }\n}\n\n③ “类型缩小”的另一个例子\n\nfunction getPort(\n  scheme: 'http'|'https'\n) {\n  switch (scheme) {\n    case 'http':\n      return 80;\n    case 'https':\n      return 443;\n  }\n}\n\n\n```\n>  实际上，联合类型本身可以看成是一种“**类型放大**”（type widening），处理时就需要“**类型缩小**”（type narrowing）\n\n### （八）交叉类型\n交叉类型 `A&B` 表示，任何一个类型必须同时属于 `A` 和`B`，才属于交叉类型 `A&B`，即交叉类型同时满足`A`和`B`的特征。下面是示例\n```typescript\n\n① 变量obj同时具有属性foo和属性bar\nlet obj:\n  { foo: string } &\n  { bar: string };\n\nobj = {\n  foo: 'hello',\n  bar: 'world'\n};\n\n② x的类型实际是 never ，因为不可能有这样的 x \n\nlet x:number&string;\n\n③ 交叉类型常常用来为对象类型添加新属性。\n\ntype A = { foo: number };\ntype B = A & { bar: number };\n\n```\n\n### （九）type 命令\n`type` 命令用来定义一个类型的`别名`\n```typescript\n\n① 别名 Age 类型\ntype Age = number;\nlet age:Age = 55;\n\n② 别名不允许重名\ntype Color = 'red';\ntype Color = 'blue'; // 报错\n\n③ 别名的作用域是块级作用域\ntype Color = 'red';\nif (Math.random() < 0.5) {\n  type Color = 'blue';\n}\n\n④ 别名支持使用表达式\ntype World = \"world\";\ntype Greeting = `hello ${World}`;\n```\n>  type命令属于类型相关的代码，编译成 JavaScript 的时候，会被 ==全部删除==\n\n### （十） typeof 运算符\n1、JavaScript 里面，`typeof` 运算符只可能返回 **八种结果**，而且都是**字符串**。\n```javascript\ntypeof undefined; // \"undefined\"\ntypeof true; // \"boolean\"\ntypeof 1337; // \"number\"\ntypeof \"foo\"; // \"string\"\ntypeof {}; // \"object\"\ntypeof parseInt; // \"function\"\ntypeof Symbol(); // \"symbol\"\ntypeof 127n // \"bigint\"\n```\n2、TypeScript   `typeof` 运算符将返回 该值的 **TypeScript 类型**\n```typescript\nconst a = { x: 0 };\n\ntype T0 = typeof a;   // { x: number }\ntype T1 = typeof a.x; // number\n```\n3、类型运算 与 值运算\n\n- `typeof` 返回的是 TypeScript 类型，所以只能用在**类型运算**之中（即跟==类型相关的代码之中==），不能用在 **值运算**\n- typeof 的参数不能是一个值的运算式，如下示例：\n```typescript\n// Date()需要运算才知道结果\ntype T = typeof Date(); // 报错\n```\n\n- `typeof` 命令的参数不能是类型。如下代码\n```typescript\ntype Age = number;\ntype MyAge = typeof Age; // 报错\n```\n\n### （十一）类型声明的块级作用域\n```typescript\n存在两个代码块，其中分别有一个类型T的声明, 这两个声明都只在自己的代码块内部有效，在代码块外部无效。\nif (true) {\n  type T = number;\n  let v:T = 5;\n} else {\n  type T = string;\n  let v:T = 'hello';\n}\n```\n\n### （十二） 子类型与父类型\n即**子类型可以赋值给父类型**，但反过来不行，如下\n```typescript\n\n① 子类型 a 可以赋值给父类型 b\n\ntype T = number|string;\n\nlet a:number = 1;\nlet b:T = a; \n\n② 父类型 b 不可以赋值给 子类型 a\n\nlet a:'hi' = 'hi';\nlet b:string = 'hello';\n\nb = a; // 正确\na = b; // 报错\n```\n\n### （十三）元组\n\n#### 1、基本示例\n```typescript\nconst s:[string, string, boolean] = ['a', 'b', true];\n\n// 数组\nlet a:number[] = [1];\n// 元组\nlet t:[number] = [1];\n```\n>  数组与元组的区别在于，`number[]` 与 `[number]`\n\n#### 2、可选元素\n添加`?` 表示可选，比如\n```typescript\n① 正常用法\nlet a:[number, number?] = [1];\n\n② 它的成员数量可能有两个、三个和四个\ntype myTuple = [\n  number,\n  number,\n  number?,\n  string?\n];\n\n③ 扩展运算符（...），可以表示不限成员数量的元组\ntype NamedNums = [\n  string,\n  ...number[]\n];\nconst a:NamedNums = ['A', 1, 2];\nconst b:NamedNums = ['B', 1, 2, 3];\n\ntype t1 = [string, number, ...boolean[]];\ntype t2 = [string, ...boolean[], number];\ntype t3 = [...boolean[], string, number];\n```\n\n#### 3、成员或者元素名\n元组的成员可以添加成员名，这个**成员名**是说明性的\n```typescript\ntype Color = [\n  red: number,\n  green: number,\n  blue: number\n];\n\nconst c:Color = [255, 255, 255];\n\n```\n\n#### 4、读取成员类型\n元组可以通过方括号，**读取成员类型**\n```typescript\ntype Tuple = [string, number];\ntype Age = Tuple[1]; // number\n\n由于元组的成员都是数值索引，即索引类型都是number\ntype Tuple = [string, number, Date];\ntype TupleEl = Tuple[number];  // string|number|Date ,即 三种值的联合类型\n\n```\n\n#### 5、只读元组\n```typescript\n// 写法一\ntype t = readonly [number, string]\n\n// 写法二：泛型 Readonly<T>\ntype t = Readonly<[number, string]>\n```\n只读元组是元组的父类型，所以 **谁可以给谁赋值知道了吗？**\n如下代码，为什么传入`只读元组`就会报错呢？因为 **只读元组不能替代元组**\n```typescript\nfunction distanceFromOrigin([x, y]:[number, number]) {\n  return Math.sqrt(x**2 + y**2);\n}\n\nlet point = [3, 4] as const;\n\ndistanceFromOrigin(point); // 报错\n\n问：如何解决这个报错问题呢？使用类型断言，如下：\ndistanceFromOrigin(\n  point as [number, number]\n)\n```\n\n#### 6、成员数量的推断\n```typescript\n① ts 发现 元组point的长度是2，不可能等于3，报错\nfunction f(point: [number, number]) {\n  if (point.length === 3) {  // 报错\n    // ...\n  }\n}\n\n② TypeScript 发现point.length的类型是1|2|3，不可能等于4。\nfunction f(\n  point:[number, number?, number?]\n) {\n  if (point.length === 4) {  // 报错\n    // ...\n  }\n}\n\n③ 使用了扩展运算符，TypeScript 就无法推断出成员数量；故不会报错\nconst myTuple:[...string[]]\n  = ['a', 'b', 'c'];\n\nif (myTuple.length === 4) { // 正确\n  // ...\n}\n```\n\n#### 7、扩展运算符与成员数量\n```typescript\n\n① 报错原因是函数add()只能接受两个参数，但是传入的是...arr，TypeScript 认为转换后的参数个数是不确定的\nconst arr = [1, 2];\nfunction add(x:number, y:number){\n  // ...\n}\nadd(...arr) // 报错\n\n② arr是一个拥有两个成员的元组，所以 TypeScript 能够确定...arr可以匹配函数add()的参数数量，就不会报错了\nconst arr:[number, number] = [1, 2];\nfunction add(x:number, y:number){\n  // ...\n}\nadd(...arr) // 正确\n\n或者 const arr = [1, 2] as const; 使用 as const 断言即可\n\n\n③ 因为console.log()可以接受任意数量的参数\nconst arr = [1, 2, 3];\nconsole.log(...arr) // 正确\n\n\n```\n\n### （十四）symbol\n\n## 参考\n> [https://jkchao.github.io/typescript-book-chinese/project/dynamicImportExpressions.html](https://jkchao.github.io/typescript-book-chinese/project/dynamicImportExpressions.html)\n[https://ts.xcatliu.com/basics/primitive-data-types.html](https://ts.xcatliu.com/basics/primitive-data-types.html)\n [https://www.fullstackbb.com/typescript/typescript-unknown-as-top-type/](https://www.fullstackbb.com/typescript/typescript-unknown-as-top-type/)\n  [https://wangdoc.com/typescript/any](https://wangdoc.com/typescript/any)\n\n","41c38c6b-8154-5f70-b755-3135e23f8f5b":"\n# 浏览器篇\n\n\n## 浏览器渲染原理篇\n\n## 浏览器内核篇\n\n## 开发者工具\n\n> 整理所有关于开发这工具的一切！\n\n## CSS \n\n- 计算样式：在“元素”面板中，查看元素的计算样式，了解最终应用的样式值。\n- 盒模型：查看元素的盒模型，了解元素的尺寸、边距、边框和内边距。\n- CSS 断点：在“源代码”面板中，设置样式表断点，当样式表被修改时，代码会暂停执行，帮助定位问题。\n- 元素检查：右键点击页面元素，选择“检查”或按 F12 打开开发者工具，查看和修改元素的 CSS 样式。\n- 实时编辑：在“元素”面板中，直接编辑 CSS 规则，实时查看效果。\n- 样式层叠：查看元素的所有样式，包括用户代理样式、外部样式表、内联样式等，理解样式的层叠和优先级。\n\n## HTML\n\n## JS\n\n- 实时修改代码 ：`Shift+Enter` 你可以尝试搭配使用 Shift+Enter 按键去输入多行代码\n\n等等其他，\n","11a20c57-973d-5f65-a70b-8fa09d0cf2d3":"\n# 网络篇\n\n（HTTP、TCP/IP、DNS、UDP、websocket等计算机网络知识）\n","1516b8b7-ed2c-5ceb-9e7e-e0b86530a7a9":"\n# CSS\n\n\n到时再刷一刷\n\n- [https://juejin.cn/post/7270648629378531368#heading-49](https://juejin.cn/post/7270648629378531368#heading-49)\n","a0e5b7b9-1607-5c9c-b8d0-762fe8031d40":"\n# 说明\n\n","1331f499-92eb-5e54-92c3-105c719987cf":"\n# 1、开始、应用、模板语法\n\n\n# 此笔记包括以下内容：\n\n# ![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/93ed0ec22901e9d233ba4545d3c27a06.png)\n\n# 0、开始\n[简介 | Vue.js](https://cn.vuejs.org/guide/introduction.html)\n[快速上手 | Vue.js](https://cn.vuejs.org/guide/quick-start.html)\n[常见问题 | Vue.js](https://cn.vuejs.org/about/faq.html)\n\n## 简介\n\n## 几个关键词\nVue 的两个核心功能：\n\n- `**声明式渲染**`：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。\n- `**响应性**`：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。\n\n`单文件组件` (也被称为 `*.vue` 文件，英文 Single-File Components，缩写为 SFC)\n\n- 顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里\n\n## API 风格\nVue 的组件可以按两种不同的风格书写：选项式 API 和 组合式 API。\n\n### 选项式 API (Options API)\n即`vue2`的写法\n\n### 组合式 API (Composition API)\n即新的`vue3`的写法\n\n\n## ONLINE DEMO\n> 很重要，重要功能或者feature 可以直接在线体验\n\n\n- 想要快速体验 Vue，你可以直接试试我们的  [演练场](https://sfc.vuejs.org/#eNo9j01qAzEMha+iapMWOjbdDm6gu96gG2/cjJJM8B+2nBaGuXvlpBMwtj4/JL234EfO6toIRzT1UObMexvpN6fCMNHRNc+w2AgwOXbPL/caoBC3EjcCCPU0wu6TvE/wlYqfnnZ3ae2PXHKMfiwQYArZOyYhAHN+2y9LnwLrarTQ7XeOuTFch5Am8u8WRbcoktGPbnzFOXS3Q3BZXWqKkuRmy/4L1eK4GbUoUTtbPDPnOmpdj4ee/1JVKictlSot8hxIUQ3Dd0k/lYoMtrglwfUPkXdoJg==)。\n- 如果你更喜欢不用任何构建的原始 HTML，可以使用 [JSFiddle](https://jsfiddle.net/yyx990803/2ke1ab0z/) 入门。\n- 如果你已经比较熟悉 Node.js 和构建工具等概念，还可以直接在浏览器中打开 [StackBlitz](https://vite.new/vue) 来尝试完整的构建设置。\n\n\n## 类似于 unpkg 的东西\n\n-  [unpkg](https://unpkg.com/)\n-  [jsdelivr](https://www.jsdelivr.com/package/npm/vue) 或 [cdnjs](https://cdnjs.com/libraries/vue)\n\n\n## Vue2与Vue3 的区别\n\n- Vue 2 在 2023 年底将到达它的截止维护日期\n- vue3 仅支持 IE11及以上。Vue 3 用到了一些 IE11 不支持的现代 JavaScript 特性\n- vue3 只支持 [原生支持 ES2015 的浏览器](https://caniuse.com/es6) ，即es6\n\n\n# 1、应用\n\n- [创建一个 Vue 应用 | Vue.js](https://cn.vuejs.org/guide/essentials/application.html)\n\n\n## 1、每个 `Vue` 应用都是通过 [createApp](https://cn.vuejs.org/api/application.html#createapp) 函数创建一个新的 `应用实例`\n\n\n\n## 2、根组件\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b88a5a4d2277eff8f27cf31541ea7c84.png)\n\n\n## 3、挂载应用\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e83ae5da762a1f626745c2bb063513cf.png)\n\n\n## 4、应用配置\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/8a51b48b1e5e8ea2fd9d5590b63f12f0.png)\n\n\n## 5、多个应用实例\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/06eaeda3dcc927c55c1c786a078866da.png)\n\n# 2、模板语法\n[模板语法 | Vue.js](https://cn.vuejs.org/guide/essentials/template-syntax.html)\n\n### \n\n## 1、`{{}}`\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/348842d7954689c3fdb16c1a8c0f0cad.png)\n\n\n## 2、rawHtml 与 `v-html` 指令\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/5968a47d4e873e246b2520f15634070f.png)\n\n\n## 3、`v-bind:attrName` 与  简写`:attrName`  或 `v-bind:obj` 动态绑定多个值\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/26f05e6dfe25ed256f0eee99069f2010.png)\n简写： `:attrName`\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/50c1241f3a8803a2f5b58996c011aeea.png)\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/acf06258899c4d73a70ae439342aef61.png)\n\n\n## 4、`{{}}` 仅支持`表达式`，不支持`语句`\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/1ebe8a98b79792c966d3a75d935365ad.png)\n\n\n## 5、受限的全局访问，可以通过 `[app.config.globalProperties](https://cn.vuejs.org/api/application.html#app-config-globalproperties)` 配置\n\n模板中的表达式将被沙盒化，仅能够访问到[有限的全局对象列表](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3)。该列表中会暴露常用的内置全局对象，比如 `Math` 和 `Date`。\n\n```javascript\nimport { makeMap } from './makeMap'\n\nconst GLOBALS_WHITE_LISTED =\n  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'\n\nexport const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED)\n```\n\n没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 `[app.config.globalProperties](https://cn.vuejs.org/api/application.html#app-config-globalproperties) `上** **`**显式地添加它们**`，供所有的 Vue 表达式使用。\n\n\n## 6、指令 Directives\n\n### 1、`v-on` 有一个相应的缩写，即 `@` 字符 ， 如 `@click <=> v-on:click`\n\n\n### 2、`v-bind:href`  等价于  `:href` \n\n\n### 3、动态参数的说明如下：\n\n- 动态属性\n- 动态事件名称\n- 动态参数值的限制：为null 或者 字符串，否则编译警告\n- 动态参数的语法限制：大小写，注意空格等\n\n具体看下面：\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/0c3f6bbe4333afb3a4d663b954c16887.png)\n\n动态参数的语法限制：\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/53bf37f4be201240faf16a9c33191c14.png)\n\n\n### 4、指令的修饰符\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9f6397816b7d01663f22e57bbc383a36.png)\n\n\n\n\n\n","4a366fe1-f497-51a1-888a-7f1918e980c2":"\n# 2、响应式\n\n\n# 什么是响应式？\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/608a1ef779e42c64332ed24cd7ccad24.png)\n\n\n# 为什么`data()` 返回对象的顶层属性都能被 `this` 访问\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/16598b806f2b32702f3a0e2b770d316b.png)\n\n几个注意点：\n\n- 实例首次创建时，一些属性值还没确定，务必先 `**占位**`** ，因为** **直接通过 **`**this**`** 添加的属性将不再有 **`**响应式能力**`\n- Vue 在组件实例上暴露的`内置 API `使用 `$ `作为前缀。它同时也为`内部属性`保留 `_` 前缀。因此， 避免在顶层 `data` 上使用任何以这些字符作前缀的属性。\n\n2、\n","d4e1ff26-9bf1-584f-8252-1dcc0d30aeb9":"\n# 3.2 基础\n\n\n# Vue 应用实例\n- 通过 `createApp` 函数创建新的应用实例\n- 应用实例需要一个`根组件`来渲染内容\n- 使用 `.mount() `方法挂载应用实例到` DOM 元素`上\n- 可以配置应用实例的全局选项和资源，比如\n   - 应用级别错误处理器：`app.config.errorHandler = (err) => {})`\n   - 注册一个全局组件： `app.component('TodoDeleteButton', TodoDeleteButton)`\n- 一个页面可以创建多个共存的 Vue 应用实例。\n\n\n# Vue 模板\n1、Vue 使用基于 `HTML` 的模板语法, 将组件实例的数据绑定到呈现的 DOM 上。\n\n2、`文本插值`使用双大括号语法,可以将组件属性显示为纯文本 \n\n3、使用 `v-html 指令`可以将属性插入为`原始 HTML`, 但要注意安全风险。\n\n3、属性绑定使用 `v-bind` 指令或其`简写 `， 可以动态绑定多个 HTML 属性\n\n4、`指令`是带有 `v- 前缀`的特殊属性,可以根据表达式的值更新 DOM，`指令`可以带有参数,如 `v-bind:href` 或 `v-on:click`,用于指定绑定的目标\n\n5、`动态参数`允许使用`js 表达式`计算参数名称,如` :[someAttrObj]`\n\n6、`修饰符`是以点开头的特殊后缀，用于指定指令需要以特殊方式绑定，如` .prevent`。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3df5cd42ab14e6bb604f1a7fc53e3e91.png)\n\n7、JavaScript 表达式可以被使用在如下场景上\n\n- 在文本插值中 (双大括号)\n- 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中\n\n\n# 响应式基础\n\n1、建议使用 `<script setup>`，来简化暴露大量的状态和方法的繁琐\n\n2、`ref`可以包装`任何类型`的值并保持`深层响应性` ，即 改变嵌套对象或数组时，变化也会被检测到\n\n- 在`模板`渲染上下文中，只有`顶级的 ref` 属性才会被解包\n- DOM 更新不适合 ref 变化同步的，`nextTick()` 后可以保证更新\n- 非模板场景，**解构里面的属性也会丢失响应性**\n\n3、`reactive()` 将使`对象本身`具有响应性；\n\n- 另外只有`代理对象`是响应式的，更改`原始对象`不会触发更新\n- 同一个对象上调用 `reactive() `会返回相同的代理\n- 在一个代理上调用 `reactive() `会返回它自己\n- `reactive()` 的局限性\n   - `reactive()` 只能处理对象类型，不能处理原始类型\n   - `reactive()` 不能替换整个对象，否则会丢失响应式\n   - `解构`会丢失响应性，比如 `let { count } = state` 中，修改 `count`就没用了\n\n```javascript\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n\n// 只有代理对象是响应式的，更改原始对象不会触发更新\nconst raw = {}\nconst proxy = reactive(raw)\n\n\n// 在同一个对象上调用 reactive() 会返回相同的代理\nconsole.log(reactive(raw) === proxy) // true\n\n// 在一个代理上调用 reactive() 会返回它自己\nconsole.log(reactive(proxy) === proxy) // true\n\n\nlet state = reactive({ count: 0 })\n\n// 上面的 ({ count: 0 }) 引用将不再被追踪\n// (响应性连接已丢失！)\nstate = reactive({ count: 1 })\n```\n\n\n# 计算属性\n\n- 计算属性可以用来描述依赖响应式状态的复杂逻辑,比方法更加优雅和高效\n- 计算属性基于其响应式依赖被`缓存`,只有在依赖变化时才会重新计算,这`对于性能敏感的场景`很有帮助。\n- 计算属性可以定义为`可写属性`,提供 `getter` 和 `setter` 方法。\n- 计算属性的 `getter` 应该只做计算而没有任何`副作用`，不应该改变其他状态或执行异步操作。\n- 计算属性返回的值应该被视为`只读的`，不应该直接修改它，而是`**应该更新它所依赖的源状态**`\n\n\n\n```vue\n<script setup>\n  import { ref, computed } from 'vue'\n\n  const firstName = ref('John')\n  const lastName = ref('Doe')\n\n  const fullName = computed({\n    // getter\n    get() {\n      return firstName.value + ' ' + lastName.value\n    },\n    // setter\n    set(newValue) {\n      // 注意：我们这里使用的是解构赋值语法\n      [firstName.value, lastName.value] = newValue.split(' ')\n    }\n  })\n</script>\n```\n该文章主要介绍了如何在 Vue.js 中绑定 HTML class 和内联样式。\n\n# 类与样式\n\n- `:class ` 和 `:style` 都可以绑定`数组` 或者 `对象`，并且最后会被`合并` 处理。\n- `:style` 绑定的属性名可以使用 `camelCase` 或 `kebab-case`。\n- Vue 使用 `:style` 会自动添加`前缀`\n\n# 条件渲染\n\n- `v-if`\n   - `v-if 指令`用于条件性地渲染内容，**仅在表达式返回真值时渲染**。 \n   - 注意 `v-if ` `v-else-if` `v-else` 三个的配对关系。\n- `v-if` 与 `v-show`\n   - `v-if` 是真实的按条件渲染，切换时`**销毁与重建事件监听器和子组件**`；\n   - `v-show `则简单切换 CSS 属性（即始终保留在 DOM 中，仅切换 display 属性）\n   - `v-if` 有`**更高的切换开销**`，而 `v-show` 有`**更高的初始渲染开销**`\n- ` v-if` 优先级高于  `v-for`， 不推荐同时使用。\n\n\n# 列表渲染\n\n- 循环范围： `v-for=\"n in 10\"`\n- 循环列表：`v-for=\"item in items\"`\n- 使用 `of` ：  `v-for=\"item of items\"`\n- 使用 `key` 优化性能\n- 在`计算属性`中使用 `reverse()` 和 `sort()` 会修改原数组，务必小心\n```vue\n- return numbers.reverse()\n+ return [...numbers].reverse()\n```\n\n# 事件处理\n\n- 使用 `v-on` 指令监听 DOM 事件，并在事件触发时执行对应的 JavaScript。\n- 内联事件 与 方法事件\n   - `内联事件`处理器适用于简单场景，\n   - 而`方法事件`处理器适用于复杂逻辑。\n- 如何传入参数？\n   - 可以在`内联事件处理器`中`调用方法`，并`传入自定义参数`或访问原生事件。\n- Vue 提供了多种`事件修饰符`，\n   - 如 `.stop.prevent.self.capture.once.passive` ，以简化事件处理\n- `按键修饰符`和`系统按键修饰符`用于处理特定按键事件\n   - 按键修饰符： `.enter .tab .delete  .esc .space .up .down .left .right`\n   - 系统按键修饰符：  `.ctrl .alt .shift .meta` \n- `.exact` 修饰符允许精确控制触发事件所需的系统修饰符组合\n- `鼠标按键修饰符`用于处理特定鼠标按键触发的事件\n   - 比如 `.left.right.middle` \n\n> `passive` 是一个事件监听器选项，它告诉浏览器监听器不会调用 `preventDefault() `来阻止默认的滚动行为，可用于改善滚动性能。\n\n\n```javascript\nwindow.addEventListener('scroll', function(event) {\n    // 处理滚动事件\n}, { passive: true });\n```\n\n# 表单输入绑定\n\n- `v-model 指令`简化了表单输入与 JavaScript 变量的同步\n- `v-model` 支持多种表单元素，包括文本输入、复选框、单选按钮和选择器。比如\n   - 文本类型的` <input>` 和 `<textarea>` 元素会绑定 `value property` 并侦听` input 事件`；\n   - `<input type=\"checkbox\">` 和 `<input type=\"radio\">` 会绑定 `checked property `并侦听 `change 事件`；\n   - `<select> `会绑定 `value property `并侦听 `change` 事件\n   - `v-model` 会忽略任何表单元素上初始的 `value`、`checked` 或 `selected` attribute\n- `v-model` 可以与`修饰符`一起使用，如` .lazy、.number 和 .trim`，以实现不同的输入管理方式\n   - `.lazy`：在  `change` 事件后同步更新而不是 `input`\n- 除了`内置表单`外，可以在组件中使用 `v-model` 来创建具有`自定义行为`的可复用输入组件\n\n相对小众的一个用法：\n```vue\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"'选中了'\"\n  :false-value=\"'未选中'\" />\n```\n\n# 生命周期\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ecf5a16d3c2229d12c040cb757da8714.png)\n\n# 侦听器\n\n## watch \n```javascript\n// 侦听单个来源\nfunction watch<T>(\n  source: WatchSource<T>,\n  callback: WatchCallback<T>,\n  options?: WatchOptions\n): StopHandle\n\n// 侦听多个来源\nfunction watch<T>(\n  sources: WatchSource<T>[],\n  callback: WatchCallback<T[]>,\n  options?: WatchOptions\n): StopHandle\n\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\ntype WatchSource<T> =\n  | Ref<T> // ref\n  | (() => T) // getter\n  | T extends object\n  ? T\n  : never // 响应式对象\n\ninterface WatchOptions extends WatchEffectOptions {\n  immediate?: boolean // 默认：false\n  deep?: boolean // 默认：false\n  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  once?: boolean // 默认：false (3.4+)\n}\n```\n\n## watchEffect()\n```javascript\nfunction watchEffect(\n  effect: (onCleanup: OnCleanup) => void,\n  options?: WatchEffectOptions\n): StopHandle\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\ninterface WatchEffectOptions {\n  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\ntype StopHandle = () => void\n```\n\n## 几个注意点\n\n1、`watch` 的 `第一个参数` 都建议写成`箭头函数`\n\n2、注意 `watch`  的 `第二个参数` 有 `once` 、`immediate` ， `deep`\n\n- 但需要注意 `deep = true 时`  可能会引起性能问题\n\n3、 `[watchEffect函数](https://cn.vuejs.org/api/reactivity-core.html#watcheffect)`  会`**自动收集并追踪**`函数内所依赖的响应式数据，省得手动维护所需要监听的数据，他不需要像 `watch` 一样 递归地跟踪所有的属性，比较适合侦听一个嵌套数据结构中的`几个属性`。\n\n4、回调的触发时机\n\n（1）默认情况下，侦听器回调会在`父组件更新之后、所属组件的 DOM 更新之前`被调用，这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态\n\n（2）可以通过设置`flush: 'post'`选项在侦听器回调中访问被 Vue 更新之后的 DOM。\n\n（3）可以设置 `flush: 'sync'` 创建一个`同步触发的侦听器`，它会在 Vue 进行任何更新之前触发\n\n- 同步侦听器不会进行`**批处理**`，每当检测到响应式数据发生变化时就会触发。可以使用它来监视简单的布尔值，但应避免在可能多次同步修改的数据源 (如数组) 上使用\n\n5、停止侦听器\n（1）宿主组件卸载时自动停止，但异步回调里则不会\n```javascript\n<script setup>\nimport { watchEffect } from 'vue'\n\n// 它会自动停止\nwatchEffect(() => {})\n\n// ...这个则不会！\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>\n```\n\n> 需要`异步创建`侦听器的情况很少，请尽可能选择`同步创建`。如果需要等待一些异步数据，你可以使用`**条件式的侦听逻辑**`\n\n\n（2）手动停止一个侦听器，请调用 `watch` 或 `watchEffect` 返回的函数\n```javascript\nconst unwatch = watchEffect(() => {})\n\n// ...当该侦听器不再需要时\nunwatch()\n```\n\n\n# 模板引用\n\n1、使用 `ref attribute` 来引用 DOM ，如 `<input ref=\"input\"> `\n\n2、在组件挂载后 `onMounted` 中，使用 `ref` ,不然可能为 `null` ；或者 `watch ` 不为空时，也能正常获取到 DOM\n\n3、`v-for` 中的模板引用，`<li v-for=\"item in list\" ref=\"itemRefs\">` ， 其中 `const itemRefs = ref([]) `\n\n4、函数模板引用： `<input :ref=\"(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }\">`\n\n5、组件上的 `ref` ： `<Child ref=\"child\" />`，而后就可以通过 `child` 获取组件 `Child` 的实例，但访问`组件实例`的属性或方法需要通过 `defineExpose` 暴露出来，原因如下：\n\n> 使用了 `<script setup>` 的组件是默认私有的：一个父组件无法访问到一个使用了 `<script setup> `的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏 **显式暴露**\n\n\n","4ea9c78e-8ade-525c-8e7f-3a6201cd3e92":"\n# 3.3 组件\n\n\n# 基础\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/158cdda6d2da00692729eb12f32de205.png)\n\n1、定义：使用 `SFC` 或者 `特定JavaScript 对象`\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b3751bcb2ed0be8d12f1ebf08cf1fc8e.png)\n\n> 内联模板字符串时，必须这样：`<script type=\"text/x-template\">`\n\n\n2、使用组件：`<script setup>` 中，导入的组件都在模板中直接可用，或 全局注册组件都不需要导入\n\n3、传递 props：`<script setup>` 中 使用 `const props = defineProps(['title'])` 定义\n\n```javascript\nexport default {\n  props: ['title'],\n  setup(props) {\n    console.log(props.title)\n  }\n}\n```\n\n4、定义事件：`<script setup>` 中 使用 `const emit = defineEmits(['enlarge-text'])` 定义\n\n```javascript\nexport default {\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n5、插槽：像 HTML 元素一样向`组件`中传递内容\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e51ef16990a2a7456969b2eb98fbcd62.png)\n\n6、**动态组件**：`<component>` \n\n```vue\n<!-- currentTab 改变时组件也改变 -->\n<component :is=\"tabs[currentTab]\"></component>\n\n```\n\n> 被切换掉的组件会被`卸载` ，可使用 `KeepAlive` 强制`存活`\n\n\n7、**元素位置限制如何解决？ **比如 `li` 必须在 `ul` 里，`tr` 必须在 `table`里\n举例：\n```vue\n<table>\n  <blog-post-row></blog-post-row>\n</table>\n```\n解决方案：\n```vue\n<table>\n  <tr is=\"vue:blog-post-row\"></tr>\n</table>\n```\n\n# 注册组件\n1、全局注册，即应用内任何地方都可以直接使用 `<ComponentA/>`\n```vue\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.component(\n  // 注册的名字\n  'MyComponent',\n  // 组件的实现\n  {\n    /* ... */\n  }\n)\n\n// 链式调用  \napp\n.component('ComponentA', ComponentA)\n.component('ComponentB', ComponentB)\n.component('ComponentC', ComponentC)\n```\n\n2、全局注册的问题\n\n1. 不能被 `tree-shaking` ，会导致 js 包过大\n2. 和使用过多的`全局变量`一样，太多`全局注册的组件`可能会影响应用长期的可维护性\n\n3、局部注册：\n（1）使用 `<script setup>`，导入的组件可以直接在模板中使用，无需注册\n（2）不使用`<script setup>`， 则需要使用` components 选项`来`显式注册`\n（3）局部注册的组件在`后代组件`中不可用，即只在当前组件可用\n\n4、`组件定义命名`和`组件使用命名`：比如 `MyComponent` 为名注册的组件，在模板中可以通过 `<MyComponent>` 或 `<my-component>` \n（1）PascalCase 这样的组件定义在 IDE 中友好\n（2）`PascalCase` 格式的一看就是 `Vue 组件`，很容易和`自定义元素 (web components)` 区分开来\n\n# Props 定义\n**1、**`**props**`** 可以使用 **`**defineProps() **`**宏来声明**\n（1）` <script setup>` ： `const props = defineProps(['foo'])`\n（2）不使用`setup` ，使用 `props` 选项声明\n\n**2、使用一个对象绑定多个 **`**prop**`**，如下示例：**\n```typescript\nconst post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n  \n`<BlogPost v-bind=\"post\" />`\n\n  // 等价于\n`<BlogPost :id=\"post.id\" :title=\"post.title\" />`\n```\n\n**3、**`**props**`** 可以是静态值或动态绑定的值**\n（1）`静态` 即 `:key=1`\n（2）`动态`即`:key={post.title}`\n\n**4、所有的 **`**props**`** 都遵循着**`**单向绑定原则**`**，避免子组件修改父组件的状态。 否则数据流将很容易变得混乱而难以理解，更改一个 prop 的需求通常来源于以下几种场景**\n（1）prop 被用于传入`初始值`\n```javascript\nconst props = defineProps(['initialCounter'])\n\n// 计数器只是将 props.initialCounter 作为初始值\n// 像下面这样做就使 prop 和后续更新无关了\nconst counter = ref(props.initialCounter)\n```\n（2）需要对传入的` prop 值`做进一步的转换，建议使用 `computed`\n（3）更改`对象 / 数组类型`的 `props`，**仅在父子组件在设计上本来就需要**`**紧密耦合**`**，不然子组件不允许直接修改，否则都推荐子组件抛出一个**`**事件**`**来通知父组件做出改变，即都回到父组件修改**\n> 因为是引用类型，阻止这种更改不现实\n\n\n**5、Prop 校验**\n```javascript\ndefineProps({\n  // 基础类型检查\n  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）\n  propA: Number,\n  // 多种可能的类型\n  propB: [String, Number],\n  // 必传，且为 String 类型\n  propC: {\n    type: String,\n    required: true\n  },\n  // 必传但可为空的字符串\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number 类型的默认值\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // 对象类型的默认值\n  propF: {\n    type: Object,\n    // 对象或数组的默认值\n    // 必须从一个工厂函数返回。\n    // 该函数接收组件所接收到的原始 prop 作为参数。\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // 自定义类型校验函数\n  // 在 3.4+ 中完整的 props 作为第二个参数传入\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // 函数类型的默认值\n  propH: {\n    type: Function,\n    // 不像对象或数组的默认，这不是一个\n    // 工厂函数。这会是一个用来作为默认值的函数\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n> `defineProps() 宏`中的参数不可以访问` <script setup>` 中定义的其他变量，因为在编译时整个表达式都会被移到外部的函数中\n\n\n# 组件事件\n1、`<script setup>` 中 定义：`const emit = defineEmits(['inFocus', 'submit'])`\n> 非`<script setup>` 中，参考官方文档\n\n\n2、`defineEmits() 宏`还支持对象语法，比如\n```vue\n<script setup lang=\"ts\">\n  const emit = defineEmits<{\n    (e: 'change', id: number): void\n      (e: 'update', value: string): void\n  }>()\n </script>\n```\n\n3、如果一个原生事件的名字 (例如 `click`) 被定义在 `emits` 选项中，则监听器只会监听组件触发的 `click` 事件而不会再响应原生的` click` 事件。\n\n4、和`原生 DOM 事件`不一样，组件触发的事件`**没有冒泡机制**`。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的`**事件总线**`，或是使用一个`[全局状态管理方案](https://cn.vuejs.org/guide/scaling-up/state-management.html)`。\n\n5、事件校验，如下代码\n```vue\n<script setup>\nconst emit = defineEmits({\n  // 没有校验\n  click: null,\n\n  // 校验 submit 事件\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>\n```\n\n# 组件 v-model\n> 如果是 `v3.4以前`的版本，可以不看这部分\n\n\n**1、**`**v-model**`** 可以实现双向绑定**\n\n**2、vue 3.4 版本之前实现 **`**v-model**`** 双向绑定，比较麻烦，如下**\n```vue\n<!-- Child.vue -->\n<script setup>\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n</script>\n\n\n<template>\n  <input\n    :value=\"props.modelValue\"\n    @input=\"emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n```vue\n<!-- Parent.vue -->\n<Child\n  :modelValue=\"foo\"\n  @update:modelValue=\"$event => (foo = $event)\"\n/>\n```\n\n**3、所以，**`**Vue3.4**`** 实现了 **`**defineModel**`**，简化实现**`**v-model**`** 的流程，如下代码：**\n```vue\n<script setup>\nconst title = defineModel('title')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"title\" />\n</template>\n```\n> 比单独写简化了不少，这里再解释一下 `defineModel()宏`的作用：**这个宏可以用来声明一个双向绑定 prop，通过父组件的 v-model 来使用**\n\n\n**4、**`**defineModel**`** 的底层机制：**`**编译器**`**层面，实现了父子通信的语法糖**\n\n- 一个名为`modelValue`的 `prop`，本地 `ref` 的值与其同步；\n- 一个名为`update:modelValue`的事件，当本地 `ref` 的值发生变更时触发。\n\n所以效果就是：\n\n- 它的`.value`和`**父组件**`的`v-model`的值同步；\n- 当它被`**子组件**`变更了，会触发`**父组件**`绑定的值一起更新\n\n示例如下：\n```html\n<script setup>\nconst firstName = defineModel('firstName')\nconst lastName = defineModel('lastName')\n</script>\n\n\n<template>\n  <input type=\"text\" v-model=\"firstName\" />\n  <input type=\"text\" v-model=\"lastName\" />\n</template>\n\n```\n\n5、另外一种实现`双向绑定`的方法： 使用具有 `getter` 和 `setter` 的 `computed` 属性\n```vue\n<!-- CustomInput.vue -->\n<script>\n  export default {\n    props: ['modelValue'],\n    emits: ['update:modelValue'],\n    computed: {\n      value: {\n        get() {\n          return this.modelValue\n        },\n        set(value) {\n          this.$emit('update:modelValue', value)\n        }\n      }\n    }\n  }\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n6、`defineModel` 的参数说明，如下代码：\n```javascript\nconst title = defineModel('title', { required: true })\n```\n\n7、多个 `v-model` 绑定场景，如下代码：\n```vue\n<script setup>\n  const firstName = defineModel('firstName')\n  const lastName = defineModel('lastName')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"firstName\" />\n  <input type=\"text\" v-model=\"lastName\" />\n</template>\n```\n\n8、处理 `v-model` 修饰符 \n\n- [内置的修饰符](https://cn.vuejs.org/guide/essentials/forms.html#modifiers)，例如 `.trim`，`.number` 和 `.lazy`。\n- 自定义的修饰符呢？比如自定义的修饰符 `capitalize`，它会自动将 `v-model` 绑定输入的字符串值第一个字母转为大写：\n```vue\n<script setup>\n  const [model, modifiers] = defineModel({\n    // get() 省略了，因为这里不需要它\n    set(value) {\n      if (modifiers.capitalize) {\n        return value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      // 如果使用了 .trim 修饰符，则返回裁剪过后的值\n      if(modelModifiers.trim){\n        return value.trim()\n      }\n      return value\n    }\n  })\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"model\" />\n</template>\n```\n\n9、最后总结`defineModel` 使用\n```typescript\n// 声明 \"modelValue\" prop，由父组件通过 v-model 使用\nconst model = defineModel()\n// 或者：声明带选项的 \"modelValue\" prop\nconst model = defineModel({ type: String })\n\n// 在被修改时，触发 \"update:modelValue\" 事件\nmodel.value = \"hello\"\n\n// 声明 \"count\" prop，由父组件通过 v-model:count 使用\nconst count = defineModel(\"count\")\n// 或者：声明带选项的 \"count\" prop\nconst count = defineModel(\"count\", { type: Number, default: 0 })\n\nfunction inc() {\n  // 在被修改时，触发 \"update:count\" 事件\n  count.value++\n}\n```\n\n10、关于``v-model:title=\"bookTitle\"`` 和 `v-model=\"title\"` 究竟什么区别？\n\n- `v-model=\"title\" ``默认`绑定到 `modelValue prop`，并通过 `update:modelValue 事件`更新\n- `v-model:title=\"bookTitle\"` 绑定到` title prop`，并通过` update:title 事件`更新\n\n所以，其实`v-model=\"title\"` 是`v-model:modelValue=\"title\"` 一种`**简写方式**`\n\n具体差别如下：\n\n- 默认绑定的 props 字段不同\n- 是否支持`多属性`绑定，比如 `v-model:title`   `v-model:title1` 多个，但  `v-model=\"title\"` 只支持一个\n- 支持`多属性`绑定 适合**复杂组件**，比如组件库里的一些组件绑定场景\n\n11、在`表单输入元素`或`**组件**`上创建`双向绑定`，默认表单上直接使用，但组件上还需要使用配合 `defineModel`  \n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9dd55eaedb417f6eedd40bb0b5627e13.png)\n\n\n\n","b5f0abfc-0f3f-56be-ae2b-6b3a5f720d8b":"\n# 3.4 更多\n\n\n> 以上章节只列举了 Vue3 最基础的功能点，掌握了基本能够写出简单的 Vue3 页面，但后面还需要把 Vue3 官方文档读几遍\n\n","034bc89a-727a-5f3f-8e79-a789960884dd":"\n# 开始\n\n\n# Vue 简介\n- Vue 是一个用于构建用户界面的 JavaScript 框架，提供了`声明式渲染`和`响应式更新`等核心功能。\n- Vue 是一个`渐进式框架`，可以根据需求灵活地选择使用方式，适用于简单到复杂的各种 Web 开发场景，比如 HTML → Web Components   → SPA → SSR → SSG  →   桌面端、移动端、WebGL 等\n\n\n# 单文件组件\n即 Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里，如下示例：\n```vue\n<template>\n  <button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  const count = ref(0)\n</script>\n\n<style scoped>\n  button {\n  font-weight: bold;\n  }\n</style>\n```\n\n\n# 组合式 API (Composition API)  vs  选项式 API (Options API)\n\nVue 有两种主要的 API 风格：`选项式 API` 和`组合式 API`，开发者可以根据喜好和项目需求选择使用。\n\n```vue\n<script>\nexport default {\n  // data() 返回的属性将会成为响应式的状态\n  // 并且暴露在 `this` 上\n  data() {\n    return {\n      count: 0\n    }\n  },\n\n  // methods 是一些用来更改状态与触发更新的函数\n  // 它们可以在模板中作为事件处理器绑定\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n\n  // 生命周期钩子会在组件生命周期的各个不同阶段被调用\n  // 例如这个函数就会在组件挂载完成后被调用\n  mounted() {\n    console.log(`The initial count is ${this.count}.`)\n  }\n}\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 响应式状态\nconst count = ref(0)\n\n// 用来修改状态、触发更新的函数\nfunction increment() {\n  count.value++\n}\n\n// 生命周期钩子\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n> 自主开发我们要求使用 `组合式 API (Composition API)` +  `<script setup>`\n\n\n\n# 使用 Vue3 的几种方式\n\n\n## 1、npm 包引入\n```vue\nimport { createApp } from 'vue'\n\nconst app = createApp({\n  /* 根组件选项 */\n})\n```\n\n## 2、通过 CDN 使用 Vue\n```vue\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<div id=\"app\">{{ message }}</div>\n\n<script>\n  const { createApp, ref } = Vue\n\n  createApp({\n    setup() {\n      const message = ref('Hello vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n\n## 3、使用 ES 模块构建版本\n> 注意是 `<script type=\"module\">`\n\n\n```html\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n## 4、Import maps 方式引用\n```vue\n<!-- 这个标签包含一个 JSON 对象，用于定义模块的映射关系。 -->\n<script type=\"importmap\">\n  {\n    \"imports\": {\n      \"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\"\n    }\n  }\n</script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp, ref } from 'vue'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n> 注意 `<script type=\"importmap\">` 的兼容性\n\n\n","e6e8b628-b7f8-5560-91a1-2e19303d557a":"\n# Vue3 基础\n\n\n> \n\n本章源于 Vue3 官方文档，会对重点内容和章节做特别说明，完整内容也可以移步至  [Vue.js](https://cn.vuejs.org/) （内网环境下见开发资料包）\n","433780ec-0a07-5a7f-b8de-50fde7f0ea85":"\n# Vue 篇（一）\n\n","5214f707-6fd9-5ec3-8ce4-afb519b2bcf3":"\n# Leetcode 刷题篇前言\n\n","c7440b7f-0f7b-523d-89ff-dd36cc32a1bc":"\n# LeetCode 精华 75 题\n\n\n>  LeetCode 精华 75 题：[https://leetcode.cn/studyplan/leetcode-75/](https://leetcode.cn/studyplan/leetcode-75/)\n\n","7a8c85f5-7b83-541c-9e9d-3c8a65c4f54a":"\n# 确定两个字符串是否接近\n\n## 题目及理解\n\n![image.png600|622](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407260859792.png?imageSlim)\n\n## 解题思路\n\n需要满足以下三个条件：\n\n- 包含的字符集需要相同\n- **每种字符出现的频率排序后相同**\n\t- 如何理解呢？\n\t\t- `word1 = \"cabbba\" `  对应的频率  `[ 2, 3, 1 , 0, 0, ..., 0]`\n\t\t- `word2 = \"abbccc\"`    对应的频率  `[1, 2, 3, 0, 0, ..., 0]`\n\n## 代码实现\n\n> [!info]\n> `word1.charCodeAt(i) - 97` 这个平时不怎么常用，需要能够写出来！\n\n## 错误日志\n\n> [!danger]\n> 题意理解有误，一定是需要保证`互相更换相同的次数`后能够`互相得到`\n\n```javascript\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {boolean}\n */\nvar closeStrings = function (word1, word2) {\n  // 两个字符串的长度不相等，直接返回 false\n  if (word1.length !== word2.length) {\n    return false;\n  }\n  // 包含相同字符\n  // 转成数组，排序，转成字符串，去重\n  const str1 = word1.split(\"\").sort().join(\"\");\n  const str2 = word2.split(\"\").sort().join(\"\");\n  return str1 === str2;\n};\n\n```","1d802add-c908-5d4e-8855-0a55794b53c1":"\n# 相等行列对\n\n## 题目及理解\n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407260948859.png?imageSlim)\n\n## 解题思路\n \n- 第一步：创建一个`哈希表（Map）`来存储每一行的信息。 \n- 第二步：矩阵的每一行：\n\t- 将行转换为一个`唯一的字符串`表示（例如，用逗号连接元素）。\n\t- 在哈希表中记录这个字符串表示及其出现次数。 \n- 第三步：矩阵的每一列：\n\t- 同样将列转换为字符串表示。\n\t- 检查这个字符串是否在哈希表中存在。\n\t- 如果存在，将`计数器`增加哈希表中记录的出现次数。 \n- 最后：返回最终的计数器值。\n\n## 代码实现\n\n### 复杂度分析\n\n## 错误记录","3d60a6b2-3a4e-54c8-a9cb-4cdefae8e84b":"\n# 832 Monthly 第 000 期（2024.7.26）\n\n\nhello\n\nChangelog\n","8fd7ad03-4bde-5a56-be83-62987f343687":"\n# 832 Monthly 第 001 期（2024.7.26）\n\n\nhello 2\n","ef3a3c5a-2691-5232-b8ce-2f3766315281":"\n# 说明\n\n\n测试\n","c4122c98-162d-5470-b4ba-9b157dea5000":"\n# 播客：AI 时代的频率跃迁背景下个人的选择-高频的卷或低频的定\n\n\n## 每一次科技革命本质上都是一次频率的跃迁 \n\n> \n> 在张津剑看来，每次科技革命本质上都是频率的跃迁，而 AI 将把世界的频率再提升一个量级，从而让世界进入一个“困难模式”。**他认为，当前世界变得更加复杂和困难，尤其在创业领域**。现代创业者，特别是95后，整体素质显著提升，他们在学识、能力以及对全球化的信心方面远超前辈，这使得在竞争中脱颖而出变得更加艰难。\n> \n> 对比2012年和2024年的市场机会，2012年的中国市场充满了各种可能性，各行各业都可以重新开创。当时的O2O大潮中，不仅有外卖和打车服务，还有上门洗车、洗狗等各种创新服务。甚至有公司做上门美甲，估值高达10亿美元，这种情景在今天已难以想象。那时的市场环境允许各种大胆的尝试和巨额融资，而如今的市场环境更加严峻，创业者面临的挑战更大，机会也更加稀缺。\n> \n> 过去12年，中国的创业环境发生了巨大变化。**信息流加速和生活节奏的加快使得人们的注意力更加碎片化**，系统变得更加脆弱，人们越来越感到力不从心。面对这种高频时代的挑战，张津剑**建议关注长期趋势和低频信号，保持内心的定力和生命力。这意味着在面对快速变化和复杂环境时，需要有耐心和坚定的信念，不被短期波动和高频信息所干扰。**\n> \n> 总之，张津剑认为，在这个AI推动的高频时代，要想成功，需要更高的素质、更强的定力以及对长期趋势的敏锐洞察力。只有这样，才能在激烈的竞争中找到自己的位置，并应对日益复杂的挑战。\n\n## 第一，世界变难了\n\n### 创业者质量\n\n`**首先是创业者的质量，这波创业者素质比过往要强很多**`，特别是很多 95 年左右的年轻创业者，无论是他们的学识、能力，还是底层的安全感和对全球化的信心，都比 10 年初遇见的创业者高出很多，这可能是他们的成长环境塑造的，**要从这批人中脱颖而出变得越来越难**。\n\n### 2024 与 2012 的市场机会对比\n\n2012 年的中国，条条大路通罗马，所有行业皆可重做一遍。 O2O 大潮里，除了我们耳熟能详的外卖、打车之外，**还有上门洗车、洗狗，没有不能上的门，只有不敢想的心**。记得当年有一家公司做上门美甲，估值高达 10 亿美金，而且这个赛道不止这一家，还有三巨头在融资大战，动辄融资上亿美金。这种情景在今天不可想象，但在当年是却是常态。\n\n不仅如此，过去这 12 年中，伴随着中国创业者的不断出现、成长和成就，留给新进入创业者的机会也在变少。\n\n![image.jpg600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407251811998.png?imageSlim)\n\n## 第二，时间变快了\n\n2020 年 Covid-19 之后，**世界似乎变快了**。\n\n### 变快了，极端现象变多了\n\n时间加速后，`**极端现象**`也在变多。过去那些三年、五年才会发生的事情，今天在以年为单位发生：\n1) 去年一年，英伟达的股价涨了 3 倍。这是历史上第一次，也是唯一一次，一家两万亿人民币估值的公司在一年内翻了 3 倍。\n2) 过去一年，日经指数上涨了 30%，是过去 10 年年均增长率的 5 倍。也就是说，日本股票的整体波动，已经和比特币的波动不相上下了。\n3) 在维持了多年低利率后，美国国债利率在去年一年内涨到了 5.3%，以至于去年年初引发了 SVB 银行爆雷等一系列事件。\n![image.jpg600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407251811999.png?imageSlim)\n\n### 为什么变快了？\n那么，这背后的原因是什么？为什么今天的世界变难了、变快了？\n\n**我们可能首先要明确一个问题：当我们在谈论「世界」的时候，我们到底在谈论什么。**\n\n试想三个场景，同样的一天，同样的地点：\n\n- 一个你打开短视频；\n- 一个你静静发呆；\n- 一个你打开公司邮箱，处理工作。\n\n同样的你，心情是一样的吗？如果不一样，那为什么同样的时间地点下，你会有三种完全不同的体会呢？因为同样的你，进入了不同的信息流中，而我们的世界正是这些信息流构建的，**相同场景下，信息不同，我们的「世界」就不同。**\n\n**我有个朋友，他通勤的时候要听播客，睡前要刷公众号文章，随时随地要回微信、打电话，每天都在源源不断地获取信息。我想这是我们这代人的一个写照。**\n\n我们以为我们活在生活中，其实我们活在生活的信息流中。我们在`主动地`观察世界，也在`被动地`被信息所灌输。世界通过信息的方式进入到了我们所有的传感器里，构建了我们当下的所思、所想、所感。这就是我们每天的人生，这就是我们谈论的「世界」。\n\n然而 `**我们对信息的理解非常局限。我们往往自带「滤波器」，默认过滤掉我们不喜欢的信息**`。所以同样一个场景，不同参与者回顾发生过的事情，说过的话往往都是不一样甚至是冲突的。即使一些信息进入了我们的传感器，我们往往会对信息内容的变化更加敏感，而非这种变化的频率。\n\n#### 频率 与 耗能的关系\n\n举个例子，下图是两个合伙人，他们都有情绪周期，都会一段时间积极进取一段时间消极对抗。作为创业者，我们往往会更关注到他们状态的变化而非频率的变化。\n\n![image.jpg600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407251811000.png?imageSlim)\n\n在选择合作伙伴的时候，一些创业者会认为这两个人是差不多的，因为他们都有周期。**但在实际工作生活中，那些消耗我们的，恰恰是频率**。\n\n- 就像一个合伙人如果一起战斗 3 年之后，他说有点累了需要休息，你是可以理解和接受的，也会帮助他度过消极期。\n- 但是如果他每周来一轮，一年来 50 轮，心力再强的创始人也受不了吧。\n\n从信号学的角度来看，`**频率代表能量，频率越高耗能能量越高**`，所以一个高频变化的事物需要更高的能量来维持，也就是我们体验到的更加消耗。\n\n所以同样一个合作伙伴，你们 3 年关系好，3 年关系差，不会有太大问题；但是反反复复，就非常消耗；\n\n**同样看 2h 视频，如果是一部纪录片，看完非常治愈，但如果是刷 15s 短视频，可能让人筋疲力竭；**\n\n同样做内容输出，想赶上每一波流量热点，非常心累，但去讲一个你长期认可的东西，可能反而是一种滋养。就像巴菲特能把自己的理念讲几十年一样，他可能是受到滋养的一方，但如果巴菲特天天出来评论市场热点，恐怕他早就走了。\n\n所以回到开始，**我们的世界，是由信息构建的。因此，我们世界的频率，是由信息的频率决定的。信息频率越高，世界的频率也就越高**。\n\n下面这张图显示了电报时代、邮件时代和微信时代世界日均信息量的变化情况 (频率图没有完全按照比例来画，因为每次科技革命都是带来频率百倍级别的跃迁)。\n\n![image.jpg600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407251811001.jpeg?imageSlim)\n\n过去，家书抵万金，**今天，我们打开微信，每天回复的信息是古代一生的总和。**\n\n过去，一个官员从北京贬到南京，行车坐卧要 3 个月，而今天，甚至不用 3 小时。\n\n**每次科技革命，本质上都是信息频率的跃迁，都在让时间和空间重新加速流转。**\n\n当频率跃迁之后，我们对很多事物的感受也发生了变化。五一期间，我朋友给我拍了一段视频，一个家庭聚会上，他戴着 Vision Pro，一边带孩子，一边看比赛。他对这个场景特别骄傲，但我看了特别难过，因为那一刻，他看似是在陪孩子，但他的心是不在现场的。我们常有这样的经历，当你在跟一个人交流的时候，某一刻你会感觉他 “不在这儿” 。他可能人在这儿，但是心不在这儿。有些父母美其名曰陪了孩子一天，其实一直在回消息玩手机，注意力没有在孩子身上，心也就没有在孩子身上。\n\n而科技带来的频率跃迁，让我们的 **注意力越来越难集中**，如果说过去的一份注意力是两小时，今天的一份注意力可能只有两秒钟。世界的节奏越来越快，而我们的注意力越来越稀缺，在场感越来越弱。\n\n以前一个人只要离开电脑，他的频率就降下来了，因为他的信息频率降下来了；\n\n现在一个人得把手机放到一边，他的频率才能降下来。而这两年我们正在面临又一次大幅的频率跃迁。\n\nAI 会把这个世界的频率再拉高一个量级，等到未来，你的 agent 会实时跟在你身边，和你交流、对话、反馈工作，你时时刻刻都在信息流中，活在不断加速的高频世界中。\n\n我们做好准备了吗？\n\n工业革命出现的时候，所有人都认为工业革命会解放人类的劳动，但实际上人类比当年农奴的工作时间长多了。未来 10 年，我们的注意力会被切得更碎，工作和生活会弥合得更紧。\n\n#### 世界的高频化还会带来很多现象\n\n（1）系统变脆弱。这几年，大家越来越明显地感觉，世界似乎是一个巨大的草台班子。因为当一个系统频率越来越高的时候，这个系统会慢慢失去鲁棒性，就像一艘大船，晃得越来越厉害的时候，问题会越来越凸显。\n\n（2）力不从心的体验变多。以前有心力做很多事，现在更容易觉得累，心神更容易散。因为在社会频率变高后，每天的耗能变高了，你需要消耗三倍、五倍于过去的能量，做完一天的事情。\n\n（3）刺激变得更多。感到消耗后，**多数人应对消耗的方法不是让自己安静下来，而是通过暴饮暴食等刺激让自己麻木。**\n\n- 爆炒、爆烤，火锅类的连锁餐饮越来越多\n- 密室、鬼屋这类刺激性的娱乐越来越多。\n- 很多人通过强刺激，以此找回生而为人的感觉。我去东南亚，那里标准奶茶的糖精含量是中国的两倍，我们觉得太甜了，他们觉得刚刚好，这是一个趋势的缩影。\n\n（4）行业/地域的大流动。当一个人无法适应这个高频的环境时，他会通过各种方式`降回到从前熟悉的频率中去`。有人选择行业降频，比如放弃互联网，选择考编考公；有人选择地域降频，比如逃离北上广，回老家安居。去年，东三省人口净流入了，回去的不是老人，回去的是一大批卷累了的年轻人。他们不是躺平了，他们只是想回到熟悉的频率中，接下来的三到五年，这个趋势还会加剧。\n\n#### 为何卷起来了 ？\n\n我们再看下面这张图，左上角是过去的社会变化，这个变化在频谱上是一根直线，代表了频率不变。创业者 A 在频谱对应的位置里 `捕捉到` 了机会，并基于此构建了自己的产业，就是右上角那个小黑框。\n\n随着时代从左上角发展到左下角，变化越来越快，频率越来越高，这个变化在频谱上的机会从原来的位置向右移动了一段距离。\n\n![image.jpg600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407251811002.png?imageSlim)\n\n此时这个创业者发现，曾经的机会没有了。**以前一个月一个热点，现在微博一天十个热点，于是他开始努力伴随着社会变化往右移，让团队越来越拼、越来越快、越来越擅长处理纷繁的信息，这样他们能继续和这个机会待在一起。这是今天绝大多数人的选择，也就是我们所说的「卷」。**\n\n但，只有「卷」这一条路吗？\n\n#### 我们该如何应对这种 频率的跃迁？  →  「傅里叶变换」的思考方式\n\n信号与系统领域存在一个公式叫「傅里叶变换」，大致的涵义是，世界上所有的函数都可以拆解为不同周期函数的叠加。简单的说，万物皆有韵律，这个韵律是不同频率周期的叠加。之所以你没有看出韵律，是因为你没能拆解出背后对应的周期性规律。比如，下图这条绿色的曲线看似复杂，但进行一个傅里叶变换后，你会发现它其实是一个高频规律和一个低频规律的简单叠加。\n\n![image.jpg600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407251811003.jpeg?imageSlim)\n\n这个概念要怎么映射到现实世界？假设我是一个奶茶店的老板，这条绿线是整体的生意走势。进一步拆解后，我们可以把影响生意的要素拆分成两个函数。高频函数相当于每周的运营策略和管理策略，低频函数相当于产品定位，或者是人群画像。我们对世界的观察都是不同趋势的叠加，这些趋势有长有短，有快有慢，你在什么频率上思考问题，决定了你在玩一个什么模式的游戏。\n\n而这个信号有意思的地方在于，因为波长和频率的乘积是一个常数。所以频率越低，波长越长，传播距离越远。这就是为什么城市电视塔要修很高的原因，因为电视塔的高度和波长成正比，塔越高，波长越长，能覆盖的城市面积越大。\n\n所以 `**越是低频的信号，越是朴实无华，越是穿越周期**`**。**\n\n如果我们再看之前这张图，面对不断加速的世界，我们便有了另一种解法，就是通过「傅里叶变换」的思考方式，将变化分解为高频和低频信号的叠加，然后我们将自己专注在低频信号中，这个过程，我们称之为「定」。\n\n![image.jpg600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407251811004.png?imageSlim)\n\n此时这个创业者发现，公司重要的不是能否跟上每天的 10 个热点，或者每日数据的精确控制。而是把精力专注在了这个更加低频变化的长期趋势中，这个趋势对外可能是愿景，对内可能是初心。\n\n所以每一个当下我们都可以有两种选择。\n\n- 一个选择是 「卷」，不断提高自己的频率，应对社会变化。\n- 另一个方向是 「定」，回到最底层最本质的趋势上去，去想一想，你所处的这个行业的关键问题是什么？你个人的核心能力是什么？如果未来我所在的产业只会留下一个人，我怎么配得上做这一个人？AI 能如何放大我的能力，弥补我的短板？\n\n过去一年，我们看了很多 AI 公司，见了很多大牛，做了很多访谈，各个同事每天都在市场上找人聊天。但我和一个年轻同事说，你不要管那些，你就认认真真`读论文`就好。 小半年之后，有一天，我看他和一群资历更深的同事一起开会，我发现他问出来的问题是更尖锐，更有深度的。`这就是卷和定的区别`。\n\n未来的世界比的是定力，因为卷是没有穷尽，\n\n- `卷`是向着无穷大优化，\n- 而`定`是向着零优化。\n\n所以卷是没有上限的，而定是有下限的。一个人今天能跑信息，能追热点，能每天见 10 个人，但以后的世界都是 agent 和 agent 之间交流，**我们能卷得过一个 agent 吗**？\n\n越在高频的时代，越是忙得像热锅上的蚂蚁时，越要定下来，看长期。长期的事情之所以难做，是因为它往往看不到短期的收益。但也因此，你可以打败很多心急的人。因为频率变高，一旦共识确认，市场给你的反馈也会更大、更快。如果说以前的世界是亚马逊的股票，一步一步，稳定地涨到今天，那现在的世界更像英伟达的股票，虽然数年不涨，但可以突然一年涨十年的钱。\n\n**所以，找到根本的大势，之后便但行好事，静等风来。**\n\n## 内心的低频信号 - 生命力\n\n最后，除了外部的趋势和方向，我还希望大家都能找到自己内心的低频信号。\n\n对我来说，我人生中最重要的低频信号是`**「生命力」**`三个字。我是 2012 年入的行，这十几年间，观察了很多创始人的起起落落。最后我发现，真正造就成功的不是一个人的资源、经验、能力，而是困境之中的坚韧，和取得成就之后的自我突破。**其实人生很多重大决策，往往不是基于逻辑。而是当你安静下来时，你的内心深处就升起了一股力量，它给你一条暖流，而这条暖流会一直指引你前进的方向。这种内心最本真的力量，绿洲把它归结为「生命力」，希望大家去体会它、回应它、点亮它**。\n\n那什么是一个有「生命力」的人呢？我们观察了很多创始人，发现生命力强的创始人会有两个共同点：\n\n**一、实事求是**\n\n对事实求是的人而言，你夸他也好，骂他也好，说他想听的也好，说他不想听的也好，他都不会代入「我」去衡量自己的感受。他的反应会是，你说得对，我们马上改；你指出了很关键的问题，是我疏忽了，我们一起来解决。他们像机器人一样，不会关注感受，只是关注这个信息后面的启发和行动。\n\n**二、无条件地、全然地爱自己。**\n\n你会发现那些优秀的创始人大多都挺爱自己的。我见过一个企业家，当时公司遇到很大的挫折，我听说后，问他晚上在哪儿，他说他自己一个人在吃火锅。我就很奇怪，遇到这么大的事，你怎么去吃火锅了呢。他回我说，今天感觉有点沮丧，吃个火锅让自己开心一下。起初的三年创业中，他走过一些弯路，一个不爱自己的人可能会想，唉，我太傻了，不走弯路我早就起飞了。但一个爱自己的人会想，挺好，有点意思，不走这些弯路以后写书都不知道怎么写。\n\n所以一个有生命力的人对外会实事求是，因为只有实事求是才能解决问题。但实事求是需要勇敢的，是需要克服恐惧的，所以一个实事求是的人回到内心又是爱自己的。\n\n最后的最后，希望大家在这个频率跃迁的世界中，做一个有生命力的，有定力的人。思考事物本质，回到朴实的生活里。\n\n> 来自: [张津剑：投资中的高频与低频 | 42章经](https://mp.weixin.qq.com/s/oVGx54MEIAahpgY8QYcd-Q)\n\n","b4aad0c8-e880-5045-8d68-ca9b7cef4672":"\n# index\n\n\n前言","ba913f2d-99b7-5522-b030-2caf938e67ef":"\n# index\n\n","1b1c5252-44d2-54cc-965b-913cf9b92830":"\n# 关于\n\n\n## 关于本书\n\n### 联系我\n\n- 个人邮箱： liguwe@qq.com\n- 个人微信：liguwe (请备注：`832`)\n- 个人站点： [个人站点](https://liguwe.site)\n- Github：[Github](http://github.com/liguwe)\n\n### 问题反馈\n\n如果您发现了错误，您可通过以下途径来反馈给我：\n\n- **反馈方式**：[Github New Issues](https://github.com/liguwe/liguwe.github.io/issues/new)\n\n> 欢迎任何形式的改进意见和建议，请多多指教，谢谢！\n\n### 贡献指南\n\n#### 错误修正与现有内容改进\n\n如果您发现了错误（例如事实性错误、拼写错误、语法错误或），请随时指出，欢迎提交 PR 或通过上述方式联系我。\n\n#### 添加新内容\n\n如果您希望添加新章节或内容，欢迎提交 PR 或通过上述方式联系我。\n\n### 参考及推荐阅读\n\n### 版权声明\n\n### 致谢\n\n- 感谢 [mdbook](https://rust-lang.github.io/mdBook/) 提供的电子书生成工具\n- 感谢 [Github](https://github.com/) 提供的代码托管服务及静态页面服务\n"}