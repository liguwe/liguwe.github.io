{"aa0a5c16484e5093b49a182e8f4bf34c":"\n# 832 之书\n\n\n> 个人博客&播客、知识库、电子书、开源作品合集\n\n\n## 目录\n<!-- toc -->\n ## 📕 前端 \n\n> 详见《前端》\n\n结合以往的笔记，利用 GPT 工具，梳理个人所知道的关于大前端的一切，体系化大前端技术知识\n\n## 📗 算法\n\n结合以往数据结构与算法笔记和 LeetCode 刷题笔记，利用 GPT 工具，体系化数据结构与算法知识 \n\n## 🧠 AGI\n\n- 通往 AGI 之路\n- 如何使用 AGI 来武装自己，建立 AGI 知识体系\n\n","2d268e4a1df35904b881dc25abac5ead":"\n# 更新日志\n\n\n`#更新日志` \n\n\n## 目录\n<!-- toc -->\n ## 2024-08 \n\n## 2024-08-17 星期六\n\n- 算法\n\t- leetcode 刷题笔记\n- 前端\n\n### 2024-08-11 星期日\n\n- 算法 \n\t- 算法：单调列队\n\t- leetcode 刷题\n\t- 目录结构整理\n- 前端\n\t- 目录结构整理\n\n### 2024-08-10 星期六\n\n- 算法\n\t- leetcode 5 题\n- 前端\n\t- 添加前端框架原理篇\n\n### 2024-08-07 星期三\n\n- 算法\n\t- leetcode 1 题\n\n### 2024-08-05 星期一\n\n- 算法\n\t- leetcode 2 题\n\n## 2024-07\n\n### 2024-07-31 星期三\n\n- 算法\n\t- 《LeetCode 热题 100 题》2 题\n\n### 2024-07-30 星期二\n\n- 算法\n\t- leetcode 75 2 题\n- 前端\n\t- 转移到 obsidian 上写作\n\t- 更新目录，内容格式整理\n\n### 2024-07-28 周天\n\n- 算法\n\t- 整合之前的内容\n\n### 2024-07-17 周三\n\n- 前端\n\t-  将现代 Web 技术概述、 HTML、CSS 三个章节改成问答的形式\n\n### 2024-07-16 周二\n\n- 前端\n\t- 发现还是需要聚焦一些，借助 AI，通过问答的方式展开此书\n\t- 也得益于播客的一些启发，想通过 AI 的方式展开此书\n\n### 2024-07-14 周天\n\n- 前端\n\t- [ ] ~~HTML 章节完成~~\n\t- [ ] ~~CSS 章节完成~~\n\t- [ ] ~~Javascript 章节完成~~\n\t- [ ] ~~Typescript 章节完成~~\n\t- [ ] ~~整合之前整理的面试题笔记~~\n\n### 2024-07-12 周五\n\n- 前端\n\t- Javascript 大纲整理好\n\n### 2024-07-11 周四\n\n- 前端\n\t- [x] 添加 HTML 章节\n\t- [x] 添加 CSS 章节\n\n### 2024-07-10 周三\n\n- 前端\n\t- [x] 添加现代 Web 技术概述章节\n\n### 2024-07-07 周天\n\n- 前端\n\t- [x] 书籍目录大纲梳理\n\t- [x] 搭建电子书站点、流水线完成\n- 算法\n\t- 书籍目录大纲梳理\n\t- 搭建电子书站点、流水线完成\n","8f4cda4514295a0999b6e472e154bd1e":"\n# 更新计划\n\n\n\n## 目录\n<!-- toc -->\n ## 2024-08 \n\n- 迁移前端相关的所有笔记内容至 832 之书\n- 迁移算法相关的所有笔记内容至 832 之书\n\n","07e40f4348475b2aa6d5abbe2ceeb66e":"\n# 前言\n\n`#前端` \n\n这不是一本入门的书，写这书的**主要目的**是沉淀构建自己的前端知识体系，主要受众是我自己。\n\n前端十年，正赶上了 AGI 时代，和 AGI 好好探讨前端知识，故此卷会以问答的形式展开！\n\n> AGI 时代学习和教育的方式将被颠覆 ! \n\n","dada117fdec55ae5a6b8cca4f1798121":"\n# 说明\n\n\n前端基础篇，包含前端工程师必备的知识技能。","c2a8d70f5f385c929fb0981dd260f101":"\n# 前言\n\n\n`#前端` \n\n- 现代 Web 技术都有哪些？\n- 前端技术都有哪些关键词？\n\n","9e0662a1effb5e5ea2a7fb37347fabbd":"\n# 什么是互联网？\n\n\n`#前端` `#互联网` \n\n- 解释一：互联网（Internet）是一个全球性的计算机网络系统，通过一系列`标准化的通信协议（如 TCP/IP）`将世界各地的计算设备连接在一起。它允许用户在全球范围内共享和访问信息、资源和服务。\n- 解释二：互联网是一个通过`标准化通信协议`将全球计算设备连接在一起的网络系统，具有信息共享、电子邮件、在线搜索、社交媒体、电子商务和云计算等多种功能\n","fa3cf7ae69ea553981970b4e69bc5238":"\n# 什么是万维网（World Wide Web）？\n\n\n`#前端` `#互联网` \n\n- 一般称其为 `WWW`、`W3` 或 `the Web` 或 `Web` \n- 是一个基于`超文本和多媒体技术`的全球信息空间。它允许用户通过互联网访问和共享文本、图像、视频和其他形式的信息\n- 它经历以下三个阶段\n   - Web 1.0：早期的静态网页，主要用于信息展示。\n   - Web 2.0：引入用户生成内容和交互功能，如博客、社交媒体、维基等。\n   - Web 3.0：也称为语义网，旨在通过机器学习和人工智能提高信息的关联性和可用性\n\n> Web 与互联网不一样：Web 是建立在互联网之上的许多应用程序之一\n\n","9b1ae09bd96558e2872cd7fe9b9b93ca":"\n# 什么是 Web 应用（Web Application）？\n\n\n`#前端` \n\n是一种通过 `web 浏览器`访问的应用程序。它利用 `Web 技术`和标准来执行任务，通常包括与用户交互、数据处理和存储等功能，用户可以通过浏览器访问，无需下载或安装。它通常采用`客户端（浏览器）-服务器架构（即B/S架构）`，客户端是用户的浏览器，服务器是提供应用逻辑和数据存储的远程计算机。\n\n**特点：**\n\n- 浏览器访问，无需额外下载或安装软件\n- 动态内容：根据用户输入可显示不同内容\n- 交互性：javascript 来支持\n- 跨平台：因为浏览器而跨平台，支持不同操作系统和设备（如 PC、手机、平板）\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/34cffa574854ba3eac6cd1e59a715885.png)\n","e736862721bc5226a36105ef4e5cb5fa":"\n# 前端技术关键词解释\n\n\n`#前端` \n\n> 以下是一些`相对不过时的前端技术关键词`及其简要介绍\n\n\n## 目录\n<!-- toc -->\n ## 1. React 和 React Hooks \n\n- **React**：一个由 Facebook 开发的用于构建用户界面的 JavaScript 库。它的虚拟 DOM 和组件化设计使其非常受欢迎。\n- **React Hooks**：React 16.8 引入的一组新特性，允许在函数组件中使用状态和其他 React 特性，如 `useState`、`useEffect` 等。\n\n## 2. Vue 3\n\n- **Vue.js**：一个用于构建用户界面的渐进式 JavaScript 框架。Vue 3 引入了 Composition API、性能改进和更好的 TypeScript 支持。\n\n## 3. Svelte 和 SvelteKit\n\n- `**Svelte**`：一个新的前端框架，与传统框架不同，**Svelte 在编译时将组件转换为高效的命令式代码，而不是在运行时解释代码**。\n   - Svelte 是一种全新的构建用户界面的方法。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建应用程序的编译阶段来处理。\n   - Svelte 在 `构建/编译阶段` 将你的应用程序转换为理想的 JavaScript 应用，而不是在`运行阶段` 解释应用程序的代码。这意味着你不需要为框架所消耗的性能付出成本，并且在应用程序首次加载时没有额外损失。\n- `**SvelteKit**`：一个用于构建 Svelte 应用的全栈框架，支持服务器端渲染、静态站点生成等功能。\n\n## 4. Next.js 和 Nuxt.js\n\n- **Next.js**：一个基于 `React` 的框架，支持服务器端渲染（SSR）、静态站点生成（SSG）和增量静态再生（ISR）。\n- **Nuxt.js**：一个基于 `Vue.js` 的框架，提供类似的功能，如 SSR 和 SSG。\n\n## 5. JAMstack\n\n- **JAMstack**：一种现代 Web 开发架构，强调使用 JavaScript、API 和 Markup。常用工具包括静态站点生成器（如 Gatsby、Next.js）和无服务器函数（如 Netlify Functions）。\n\n> 后文会详细说明\n\n## 6. WebAssembly (Wasm)\n\n- **WebAssembly**：一种新的二进制指令格式，设计用于在浏览器中实现高性能应用。它允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，并在浏览器中运行。\n\n## 7. TypeScript\n\n- **TypeScript**：微软开发的一种 JavaScript 的超集，增加了类型检查和其他特性\n\t- TypeScript 近年来在前端开发中变得非常流行，尤其是在大型项目中。\n\n## 8. GraphQL\n\n- **GraphQL**：由 Facebook 开发的一种用于 API 的查询语言，允许客户端指定所需的数据结构。与传统的 REST API 相比，GraphQL 提供了更高效的数据获取方式。\n\n## 9. Tailwind CSS\n\n- **Tailwind CSS**：一个实用优先的 CSS 框架，允许开发者直接在 HTML 中使用类名来应用样式。它的灵活性和可定制性使其在前端开发中越来越受欢迎。\n\n> 有点类似于之前的 `bootstrap`\n\n## 10. Headless CMS\n\n- **Headless CMS**：一种内容管理系统，只提供内容管理的后台，通过 API 提供内容，而不负责前端展示。常见的 Headless CMS 有 Contentful、Strapi 和 Sanity。\n\n## 11. Progressive Web Apps (PWA)\n\n- **PWA**：渐进式 Web 应用，通过使用现代 Web 技术（如 `Service Worker` 和 `Web App Manifest`）提供类似本地应用的体验，包括`离线访问`和`推送通知`\n\n## 12. 微前端：Micro Frontends \n\n- **Micro Frontends**：一种将前端应用拆分为多个小型、独立的模块的架构，每个模块可以独立开发、部署和运行。\n\n## 13. Web Components\n\n- **Web Components**：一组标准技术，允许开发者创建可重用的自定义 HTML 元素。包括 Custom Elements、Shadow DOM 和 HTML Templates。\n\n## 14. Server-side Rendering (SSR) 和 Static Site Generation (SSG)\n\n- **SSR** 和 **SSG**：通过在服务器端生成 HTML，提高了页面加载速度和 SEO 性能。Next.js 和 Nuxt.js 都支持这些功能。\n\n## 15. Modern Build Tools\n\n- **Webpack**、**Rollup**、**Parcel** 和 **Vite**：现代 JavaScript 构建工具，提供代码打包、模块化和性能优化等功能。\n\n## 16. WebRTC\n\n- **WebRTC**：一种支持浏览器和移动应用进行实时通信（如视频、音频、数据传输）的技术。它使得开发者可以构建视频会议、实时聊天和 P2P 文件共享等应用。\n\n## 17. WebSockets\n\n- **WebSockets**：一种在客户端和服务器之间建立持久连接的协议，允许双向通信。适用于实时应用，如在线游戏、实时聊天和实时更新的仪表盘。\n\n## 18. Service Workers\n\n- **Service Workers**：一种在后台运行的脚本，能够拦截和处理网络请求，提供离线支持、缓存管理和推送通知等功能，是 PWA 的核心技术之一。\n\n## 19. Single Page Applications (SPA)\n\n- **SPA**：单页应用，通过动态加载内容和更新 URL 实现不重新加载整个页面的用户体验。常用框架包括 React、Vue.js 和 Angular。\n\n## 20. Microservices Architecture：微服务架构\n\n- **Microservices**：将应用拆分为一组小的、独立部署的服务，每个服务负责特定的业务功能。前端可以通过 API 网关或服务编排与这些微服务进行交互。\n\n## 21. APIs and Backend for Frontend (BFF)\n\n- **BFF**：一种设计模式，为每个前端应用（如 Web、移动）创建专门的后端服务，优化 API 调用和数据处理。\n\n## 22. 状态管理库：State Management Libraries\n用于数据流管理的！\n\n- **Redux**：一个流行的 JavaScript 状态管理库，常与 React 一起使用。\n- **MobX**：另一种状态管理库，基于响应式编程，适用于需要更灵活状态管理的应用。\n- **Recoil**：Facebook 开发的状态管理库，专为 React 设计，提供更好的性能和开发体验。\n- vuex\n- pinia\n- umi/dva\n\n## 23. Component Libraries and Design Systems：组件库&设计系统\n\n- **Material-UI**：基于 Google 的 Material Design 规范的 React 组件库。\n- **Ant Design**：一个企业级的 UI 设计语言和 React 组件库。\n- **Chakra UI**：一个简单、模块化且可访问的 React 组件库。\n\n## 24. Serverless Architecture\n\n- **Serverless**：一种云计算模型，开发者只需编写代码而无需管理服务器。常用的服务包括 AWS Lambda、Azure Functions 和 Google Cloud Functions。\n- 国内各个云商也都有提供\n\n## 25. Static Site Generators (SSG)\n\n- **Gatsby**：基于 React 的静态站点生成器，支持 GraphQL 数据层。\n- **Hugo**：一个用 Go 语言编写的静态站点生成器，构建速度非常快。\n- **Eleventy**：一个简单灵活的静态站点生成器，支持多种模板语言。\n\n## 26. CSS-in-JS\n\n- **Styled Components**：一种将 CSS 直接写在 JavaScript 中的技术，提供组件级的样式隔离。\n- **Emotion**：一个高性能的 CSS-in-JS 库，支持标签模板和对象样式。\n\n## 27. Modern CSS Features\n\n- **CSS Grid**：一种用于创建二维布局的 CSS 布局系统。\n- **CSS Variables**：也称为自定义属性，允许定义可重用的值。\n- **Flexbox**：一种用于创建一维布局的 CSS 布局系统。\n\n## 28. Web Animations API\n\n- **Web Animations API**：一种用于在 Web 上创建高性能动画的 API，提供了对动画的精细控制。\n\n## 29. Web Components \n\n- **LitElement**：一个用于构建 Web Components 的轻量级库，简化了自定义元素的创建。\n- **Stencil**：一个用于构建高性能 Web Components 的编译器，支持 TypeScript 和 JSX。\n\n## 30. Testing Frameworks and Tools\n\n- **Jest**：一个由 Facebook 开发的 JavaScript 测试框架，支持快照测试和并行测试。\n- **Cypress**：一个用于端到端测试的现代 JavaScript 测试框架，提供了直观的 API 和强大的调试功能。\n- **Playwright**：一个用于端到端测试的工具，由 Microsoft 开发，支持多种浏览器。\n\n## 31. Web Vitals\n\n- **Web Vitals**：一组由 Google 定义的指标，用于衡量和优化 Web 性能，包括 Largest Contentful Paint (LCP)、First Input Delay (FID) 和 Cumulative Layout Shift (CLS)。\n\n## 32. 边缘计算：Edge Computing\n\n- **Edge Computing**：一种在`靠近数据源的地方`进行计算和数据处理的技术，减少了延迟，提高了性能。常见的服务包括 Cloudflare Workers 和 AWS Lambda@Edge。\n\n## 33. Low-Code/No-Code Platforms\n\n- **Low-Code/No-Code**：一种通过图形化界面和拖放组件来构建应用的开发方式，降低了开发门槛。常见平台包括 OutSystems、Mendix 和 Webflow。\n\n## 34. Remote Procedure Calls (RPC)\n\n- RPC：通过网络调用远程服务的方法，常见实现有 `gRPC`，适用于高性能的前后端通信。\n\n## 35. Module Federation：模块联邦\nModule Federation：Webpack 5 的新特性，支持在不同应用之间动态加载模块，适用于微前端架构。\n\n## 36. 增量静态再生（Incremental Static Regeneration, ISR）\n\n增量静态再生（Incremental Static Regeneration, ISR）是 Next.js 提供的一种功能，结合了静态站点生成（Static Site Generation, SSG）和服务器端渲染（Server-Side Rendering, SSR）的优点。它允许开发者在构建时生成静态页面，并在运行时按需更新这些页面，从而实现高性能和最新数据的平衡。\n\n> 随着技术的不断发展，前端开发领域将继续涌现出更多的东西\n\n## 37. Storybook\n\n- 介绍：用于开发和测试UI组件的工具。\n- 特点：独立环境、组件文档、交互测试。\n\n## 38. 参考\n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [web 入门 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web)\n- [Web 和 Web 标准 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/The_web_and_web_standards)\n- [万维网 - MDN Web 文档术语表：Web 相关术语的定义 | MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/World_Wide_Web)\n- [万维网是如何工作的 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/How_the_Web_works)\n- [什么是 JAMstack？](https://www.cloudflare.com/zh-cn/learning/performance/what-is-jamstack/)\n- [什么是JAMStack前端架构](https://juejin.cn/post/6999897855695683614)\n- [前端知识图谱](https://f2e.tech/mindmap?)\n\n","2ff6651ace3052cf8324d0685f7e06b0":"\n# 现代 Web 技术有哪些变化和趋势？\n\n\n`#前端` \n\n现代 Web 技术正在不断发展，以适应用户需求和技术进步。以下是一些主要的变化和趋势：\n\n\n## 目录\n<!-- toc -->\n ## 1. 前端技术的演变 \n\n1. **单页应用（SPA）**：\n   - 单页应用通过动态加载内容，使用户体验更加流畅。常用框架有 React、Angular 和 Vue.js。\n   - 使用`**虚拟 DOM 技术**`，提高了性能和响应速度。\n2. **渐进式 Web 应用（PWA）**：\n   - **PWA** 结合了 Web 应用和本地应用的优点，提供离线访问、推送通知和安装到主屏幕等功能，使 Web 应用具有更好的性能和用户体验。\n   - 通过` Service Worker` 实现离线缓存和后台同步。\n3. **Web 组件**：\n   - Web 组件是一种封装 HTML、CSS 和 JavaScript 的技术，允许开发者创建`**可重用的自定义元素**`。\n   - 标准技术包括 `Custom Elements`、`Shadow DOM` 和 `HTML Templates`。\n4. **CSS-in-JS**：\n   - 将 CSS 样式直接写在 JavaScript 中，方便样式的动态生成和管理。\n   - 常用库有 `styled-components` 和 `Emotion`。\n\n## 2. 后端技术的演变\n\n1. **无服务器架构（Serverless Architecture）**：\n   - 开发者可以将代码部署到云服务提供商（如 AWS Lambda、Azure Functions），无需管理服务器。\n   - 按需收费，自动扩展，适合事件驱动的应用程序。\n2. **微服务架构**：\n   - 将大型应用拆分为多个小型、独立的服务，每个服务负责单一功能。\n   - 提高了应用的可扩展性和维护性，常用技术包括 Docker 和 Kubernetes。\n3. **GraphQL**：\n   - 由 Facebook 开发的一种查询语言，允许客户端指定所需的数据结构。\n   - 减少了冗余数据传输，提高了数据获取的灵活性和效率。\n\n## 3. DevOps 和 CI/CD\n\n1. **持续集成和持续部署（CI/CD）**：\n   - 自动化代码测试、构建和部署流程，提高了开发效率和代码质量。\n   - 常用工具有` Jenkins`、`GitHub Actions`、`GitLab CI/CD`。\n2. **容器化和编排**：\n   - 使用 Docker 将应用打包成独立的容器，确保在不同环境中的一致性。\n   - 使用 `Kubernetes` 管理和编排容器，提供自动扩展、负载均衡和故障恢复。\n\n## 4. 安全和性能优化\n\n1. **内容安全策略（CSP）**：\n   - 通过设置 HTTP 头，防止跨站脚本攻击（XSS）和数据注入攻击。\n   - 限制资源加载的来源，提高应用的安全性。\n2. **HTTP/2 和 HTTP/3**：\n   - HTTP/2 提供多路复用、头部压缩和服务器推送，显著提高了 Web 性能。\n   - HTTP/3 基于 `QUIC 协议`，进一步减少了延迟和提高了传输效率。\n3. **Web 性能优化**：\n   - 使用懒加载（Lazy Loading）和代码分割（Code Splitting）减少初始加载时间。\n   - 通过使用 CDN（内容分发网络）加速资源传输。\n\n## 5. 新兴技术和标准\n\n1. **WebAssembly (Wasm)**：\n   - 一种新的二进制指令格式，允许开发者用 C、C++、Rust 等语言编写高性能的 Web 应用。\n   - 提高了 Web 应用的计算性能，适用于游戏、图像处理等高性能需求的应用。\n2. **WebXR**：\n   - 用于构建虚拟现实（VR）和增强现实（AR）应用的标准 API。\n   - 提供了在 Web 浏览器中体验沉浸式内容的能力。\n3. **机器学习和 AI**：\n   - `TensorFlow.js` 和 `ml5.js` 等库使得在浏览器中进行机器学习和人工智能应用成为可能。\n   - 实现图像识别、自然语言处理等功能，增强用户体验。\n\n> 下文还有详细介绍\n\n## 6. 用户体验和设计\n\n1. **响应式设计**：\n   - 使用媒体查询和弹性布局，使网页在不同设备上都有良好的显示效果。\n   - 提高了移动设备用户的体验。\n2. **无障碍设计**：\n   - 确保 Web 应用对所有用户，包括残障人士，都具有可访问性。\n   - 遵循 WAI-ARIA 标准，提供语义化的 HTML 标签和辅助功能。\n\n综上所述，现代 Web 技术在前端、后端、DevOps、安全、性能优化、新兴技术和用户体验等方面都发生了显著变化。这些技术的进步不仅提升了 Web 应用的功能和性能，还大大改善了开发者的工作流程和用户的使用体验。\n","ef1796c989955d27961ba575f14d5f19":"\n# Web 技术都有哪些？\n\n\n`#前端` \n\n`Web 技术`是用于创建和维护 Web 应用、网站和 Web 服务的一组技术和标准。以下是一些主要的 Web 技术及其相关概念：\n\n\n## 目录\n<!-- toc -->\n ## 1. 前端技术 \n\n前端技术主要用于构建用户界面和用户体验，涉及到网页的结构、样式和交互功能。\n\n1. **HTML (HyperText Markup Language)**：\n   - 用于定义网页的结构和内容。\n   - HTML 标签用于标记文本、图像、链接等元素。\n2. **CSS (Cascading Style Sheets)**：\n   - 用于控制网页的外观和布局。\n   - 通过样式规则定义元素的颜色、字体、排版等。\n3. **JavaScript**：\n   - 一种脚本语言，用于实现网页的动态功能和交互效果。\n   - 可以操作 HTML 和 CSS，实现动画、表单验证、动态内容加载等功能。\n4. **前端框架和库**：\n   - **React**：由 Facebook 开发的 JavaScript 库，用于构建用户界面。\n   - **Angular**：由 Google 开发的前端框架，用于构建复杂的单页应用。\n   - **Vue.js**：一个渐进式 JavaScript 框架，易于集成和使用。\n5. **AJAX (Asynchronous JavaScript and XML)**：\n   - 用于在不重新加载整个页面的情况下与服务器进行异步数据交换。\n   - 常用于动态内容更新和后台数据加载。\n\n> 后面章节都会展开\n\n## 2. 后端技术\n\n后端技术主要用于处理业务逻辑、数据存储和服务器端的操作。\n\n1. **服务器端编程语言**：\n   - **Node.js**：基于 JavaScript 的服务器端运行环境，适用于构建高性能网络应用。\n   - **Python**：常用于 Web 开发的语言，框架如 Django 和 Flask。\n   - **Ruby**：用于 Web 开发的语言，框架如 Ruby on Rails。\n   - **PHP**：广泛应用于 Web 开发的语言，特别是内容管理系统（如 WordPress）。\n   - Java\n   - Golang \n   - 等\n2. **数据库**：\n   - **关系型数据库**：如 MySQL、PostgreSQL，使用 SQL 进行数据查询和操作。\n   - **NoSQL 数据库**：如 MongoDB、Cassandra，适用于处理大规模和非结构化数据。\n3. **Web 框架**：\n   - 提供结构化的开发环境和工具，简化 Web 应用的开发过程。\n   - 常见的框架如 Express (Node.js)、Django (Python)、Rails (Ruby)。\n4. **API (Application Programming Interface)**：\n   - 用于客户端和服务器之间的数据交换。\n   - 常见的 API 形式有 RESTful API 和 GraphQL。\n\n## 3. 协议和标准\n\n1. **HTTP/HTTPS (HyperText Transfer Protocol / Secure)**：\n   - 用于在浏览器和服务器之间传输数据。\n   - HTTPS 是 HTTP 的安全版本，使用 SSL/TLS 加密数据传输。\n2. **WebSocket**：\n   - 一种全双工通信协议，允许客户端和服务器之间的实时数据交换。\n   - 常用于实时聊天、在线游戏等应用。\n3. **REST (Representational State Transfer)**：\n   - 一种架构风格，用于设计网络应用的 API。\n   - 基于 HTTP 协议，使用标准的 HTTP 方法（如 GET、POST、PUT、DELETE）。\n4. **GraphQL**：\n   - 由 Facebook 开发的一种查询语言，用于 API 数据查询。\n   - 允许客户端指定所需的数据结构，减少冗余数据传输。\n\n## 4. 开发工具套件和环境\n\n1. **版本控制系统**：\n   - **Git**：用于跟踪代码变更和协作开发的版本控制系统。\n   - **GitHub/GitLab**：基于 Git 的代码托管平台，提供协作和项目管理工具。\n2. **集成开发环境（IDE）和代码编辑器**：\n   - **Visual Studio Code**：流行的代码编辑器，支持多种编程语言和扩展。\n   - **WebStorm**：专为 Web 开发设计的 IDE，提供强大的代码编辑和调试功能。\n3. **构建工具和包管理器**：\n   - **Webpack**：用于打包 JavaScript 模块和资源的构建工具。\n   - **npm/yarn**：JavaScript 包管理器，用于管理项目依赖。\n\n综上所述，Web 技术涵盖了从前端到后端、从协议到工具的广泛领域，支持构建功能丰富、性能优异的 Web 应用。\n","3bfb0eff20705638af582e507c5308d3":"\n# Web 技术新兴技术和标准\n\n\n`#前端` \n\n现代 Web 技术中，新兴技术和标准正在推动 Web 开发领域的创新和进步。以下是一些主要的新兴技术和标准的详细介绍：\n\n\n## 目录\n<!-- toc -->\n ## 1. WebAssembly (Wasm) \n\n### 1.1. 定义\n\nWebAssembly 是一种新的二进制指令格式，设计用于浏览器中的高性能执行。它是一种低级、类似于汇编语言的格式，可以与 JavaScript 一起使用。\n\n### 1.2. 特点\n\n- **高性能**：接近原生代码的执行速度，适用于需要高计算性能的应用。\n- **跨平台**：在不同的操作系统和设备上运行一致。\n- **语言无关**：支持多种编程语言，如 C、C++、Rust 等。\n\n### 1.3. 应用场景\n\n- **游戏开发**：高性能的图形渲染和计算。\n- **图像和视频处理**：实时的图像编辑和视频编码。\n- **科学计算**：复杂的数学运算和模拟。\n\n## 2. WebXR\n\n### 2.1. 定义\n\nWebXR 是一种用于构建虚拟现实（VR）和增强现实（AR）体验的标准 API。它是 WebVR 的扩展，提供了更广泛的功能和更好的性能。\n\n### 2.2. 特点\n\n- **跨设备支持**：支持多种 VR 和 AR 设备，如 Oculus Rift、HTC Vive、Microsoft HoloLens 等。\n- **高性能**：优化了渲染和交互的性能，提供沉浸式体验。\n- **易于集成**：与现有的 Web 技术（如 WebGL）无缝集成。\n\n### 2.3. 应用场景\n\n- **游戏和娱乐**：沉浸式游戏和虚拟旅游。\n- **教育和培训**：虚拟实验室和模拟训练。\n- **电商和营销**：虚拟试衣间和产品展示。\n\n## 3. 机器学习和 AI \n\n### 3.1. TensorFlow.js 和 ml5.js\n\n- **TensorFlow.js**：一个用于在浏览器中运行机器学习模型的库。支持训练和推理，允许开发者直接在客户端进行机器学习操作。\n- **ml5.js**：基于 TensorFlow.js 的高级库，提供了简单易用的 API，用于实现常见的机器学习任务。\n\n### 3.2. 特点\n\n- **实时处理**：在浏览器中实时运行机器学习模型，无需服务器端处理。` ===> 端侧模型`\n- **隐私保护**：数据在本地处理，减少了隐私泄露的风险。\n- **易于使用**：提供了丰富的预训练模型和简化的 API，降低了机器学习的入门门槛。\n\n### 3.3. 应用场景\n\n- **图像识别**：实时的图像分类和对象检测。\n- **自然语言处理**：文本分类、情感分析和翻译。\n- **推荐系统**：个性化推荐和内容过滤。\n\n## 4. HTTP/3\n\n### 4.1. 定义\nHTTP/3 是 HTTP 协议的最新版本，基于 QUIC 协议（Quick UDP Internet Connections）。它旨在提高 Web 的传输效率和可靠性。\n\n### 4.2. 特点\n\n- **基于 UDP**：使用 `UDP` 代替 TCP，减少了连接建立的延迟。\n- **多路复用**：在一个连接中同时传输多个数据流，避免了“队头阻塞”问题。\n- **内置加密**：默认使用 TLS 1.3 提供安全传输。\n\n### 4.3. 优势\n\n- **更快的连接建立**：减少了握手时间，提高了页面加载速度。\n- **更好的性能**：在高延迟和丢包环境下表现更好。\n- **增强的安全性**：内置加密提供了更强的安全保障。\n\n> HTTP 章节会展开聊\n\n## 5. WebRTC\n\n### 5.1. 定义\n\nWebRTC（Web Real-Time Communication）是一个支持浏览器和移动应用进行实时通信的开源项目。它**允许音频、视频和数据的直接传输，无需中介服务器。**\n\n### 5.2. 特点\n\n- **点对点通信**：**直接在客户端之间传输数据，减少了延迟**。\n- **跨平台支持**：在不同浏览器和设备上运行一致。\n- **高质量传输**：支持高质量的音频和视频传输。\n\n### 5.3. 应用场景\n\n- **视频会议**：实时的视频通话和会议。\n- **在线教育**：实时的教学和互动。\n- **游戏和娱乐**：实时的多人游戏和互动体验。\n\n## 6. Progressive Web Apps (PWA)\n\n### 6.1. 定义\n\n渐进式 Web 应用（PWA）是一种结合了 Web 和本地应用优点的新型应用形式。PWA 使用现代 Web 技术提供类似本地应用的用户体验。\n\n### 6.2. 特点\n\n- **离线访问**：通过 `Service Worker` 实现离线缓存。\n- **推送通知**：支持推送通知，保持用户互动。\n- **安装到主屏幕**：用户可以将 PWA 安装到主屏幕，像本地应用一样使用。\n\n### 6.3. 优势\n\n- **跨平台**：在不同操作系统和设备上运行一致。\n- **无需安装**：用户通过浏览器访问，无需下载和安装。\n- **自动更新**：应用更新自动推送到用户，无需手动操作。\n\n## 7. JAM stack 架构\n\n> 下文有详细介绍\n\n### 7.1. 定义\n\nJAM 代表 JavaScript、APIs、Markup。\n\n- JavaScript 是网络应用程序使用的编程语言\n- API（应用程序编程接口）是一种从别人的程序或应用程序中请求数据的方式\n- Markup 是向浏览器提供格式化指示的代码（HTML 和 CSS）。\n\nJAMstack 是一种现代 Web 开发架构，强调客户端 JavaScript、可重用 API 和预构建标记（Markup）。它旨在提高 Web 应用的性能、安全性和可扩展性。\n\n### 7.2. 特点\n\n- **静态生成**：使用静态站点生成器（如 Gatsby、Next.js）预构建页面，提高加载速度。\n- **无服务器**：通过 API 调用实现动态功能，减少服务器管理。\n- **分离关注点**：前端和后端分离，前端通过 API 获取数据。\n\n### 7.3. 优势\n\n- **高性能**：静态页面加载速度快，用户体验好。\n   - 因为：**JAMstack 应用程序中的几乎所有内容都由从 CDN 提供的静态 HTML 文件组成**\n- **高安全性**：减少了服务器攻击面，提高了安全性。\n- **易于扩展**：通过 API 扩展功能，灵活性高。\n   - 由于 JAMstack 前端速度快且后端轻量化，因此 JAMstack 应用程序通常具有极强的可扩展性。\n\n这些新兴技术和标准正在推动 Web 开发的不断进步，提供了更高的性能、更好的用户体验和更强的开发灵活性。了解和掌握这些技术对于现代 Web 开发者来说至关重要。\n","a585d1e5f4065e0c8824ec309b8acc61":"\n# JAMstack 架构概述\n\n`#前端` \n\n## 目录\n<!-- toc -->\n ## 定义 \n\nJAMstack 是一种现代 Web 开发架构，强调使用 JavaScript、API 和 Markup（标记）来构建高性能和高安全性的 Web 应用。\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ff6bf70189d55690f74889441c4f9ca2.png)\n\n## 产生背景\n\n> **传统的网站架构 ： 无论如何都需要一个实时的在线服务，它在处理这些不怎么变动的内容时，很鸡肋：计算量很小，但是依旧需要大量后端和运维人员维护网站的安全性、稳定性、可伸缩性……**\n\n## JAMstack 的核心概念\n\n### JavaScript\n\n- 用于处理前端逻辑和交互。可以使用各种 JavaScript 框架和库，如 React、Vue.js、Angular 等。\n- JavaScript 代码通常在客户端执行，减少了服务器负担。\n\n### API\n\n- 通过 API 调用来获取动态数据和执行服务器端操作。\n- 可以使用第三方服务（如 Auth0、Stripe、Firebase等）或 自建的 API（如 RESTful API、GraphQL）。\n- API 通常是无状态的，提供了良好的可扩展性和灵活性。\n\n### Markup（标记）\n\n- 使用静态站点生成器（如 Gatsby、Next.js、Hugo、vitepress 等）预生成 HTML 页面。\n- 这些页面在构建时生成，可以直接部署到 CDN，提高加载速度和性能。\n\n## JAMstack 的优势\n\n### 高性能\n\n   - 预生成的静态页面可以通过 CDN 快速分发，减少了服务器响应时间。\n   - 静态资源通常比动态内容加载更快，提高了用户体验。\n\n### 高安全性\n\n   - 减少了服务器端代码的执行，降低了攻击面。\n   - 静态文件不容易受到传统的服务器攻击（如 SQL 注入）。\n\n### 可扩展性\n\n   - 静态站点可以轻松扩展，通过增加新的静态文件和 API 调用来实现更多功能。\n   - API 调用可以根据需要进行扩展和修改，而不影响前端代码。\n\n### 开发效率\n\n   - 开发者可以专注于前端代码和用户体验，而不需要处理复杂的服务器端逻辑。\n   - 使用现代前端框架和工具链，提高了开发效率和代码质量。\n\n## JAMstack 的劣势\n\n**业务场景非常狭小，只能用于内容更新不大频繁的 CMS 站点**。国外也有无头电商（Headless Commerce）的商业实践，但是前景并不明朗。\n\n## 常见的 JAMstack 工具和框架\n\n### 静态站点生成器\n\n- **Gatsby**：基于 React 的静态站点生成器，支持 GraphQL 数据查询。\n- **Next.js**：提供静态生成和服务器端渲染（SSR）的混合模式，适用于复杂的 Web 应用。\n- **Hugo**：一个快速、灵活的静态站点生成器，使用 `Go 语言`编写。\n- Jekyll\n- Nuxt.js\n   - 基于Vue.js的框架，支持静态生成和服务器端渲染（SSR）。\n   - 适用于构建复杂的Vue.js应用。\n\n### API 服务\n\n- **Headless CMS**：如 Contentful、Sanity、Strapi，提供内容管理和 API 接口。\n- **服务器端功能**：如 AWS Lambda、Netlify Functions，用于实现无服务器计算。\n   - **正常云服务厂商都有提供，比如用过腾讯云提供serverless服务**\n- **第三方 API**：如 Auth0（身份验证）、Stripe（支付）、Algolia（搜索）。\n\n### 部署和托管\n\n- **Netlify**：提供静态站点托管、无服务器函数和持续集成（CI/CD）服务。\n- **Vercel**：支持` Next.js` 和其他静态站点的托管，提供无服务器函数和自动部署。\n- **GitHub Pages**：适用于简单的静态站点托管，集成了 GitHub 仓库。\n- **正常云服务产商都有提供这个能力，比如 Amazon、阿里云、腾讯云等**\n\n## JAMstack 的工作流程\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/20b4de6008f7cfc8c07f1d11772e1573.png)\n\n> 其实很类似 [https://elog.1874.cool/notion/vy55q9xwlqlsfrvk](https://elog.1874.cool/notion/vy55q9xwlqlsfrvk) 的思路\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/fd45c197b1ed7399ddf97db551d64af0.png)\n\n### 开发阶段\n\n- 使用静态站点生成器（如 Gatsby、Next.js）编写前端代码和模板。\n- **通过 API 获取动态数据，并将其嵌入到静态页面中**。\n- 使用 JavaScript 实现前端交互和动态功能。\n\n### 构建阶段\n\n- 运行构建工具，生成静态 HTML、CSS 和 JavaScript 文件。\n- 预生成的页面文件可以直接部署到 CDN 或静态托管服务。\n\n### 部署阶段\n\n- 将静态文件上传到托管平台（如 Netlify、Vercel）。\n- 配置 CDN 分发，确保全球用户都能快速访问。\n\n### 运行时\n\n- 用户访问网站时，CDN 会提供预生成的静态页面，确保快速加载。\n- 前端 JavaScript 代码在浏览器中执行，调用 API 获取和更新数据。\n- 无服务器函数处理特定的服务器端任务，如表单提交、身份验证等。\n\n## 使用 JAMstack 的场景\n\n### 博客和内容网站\n\n   - 使用 Headless CMS 管理内容，通过静态站点生成器生成 HTML 页面。\n   - 预生成的页面通过 CDN 分发，提供快速的阅读体验。\n\n### 电商网站\n\n   - 产品信息和库存通过 API 获取，前端使用 JavaScript 实现购物车和结账功能。\n   - 静态页面展示产品列表和详情，提高页面加载速度。\n\n### 企业官网\n\n   - 静态页面展示公司信息、服务和案例，减少服务器负担。\n   - 表单提交和用户交互通过无服务器函数处理。\n\n## 总结\n\nJAMstack 通过将 JavaScript、API 和 Markup 结合起来，提供了一种高效、安全和可扩展的 Web 开发架构。它适用于各种类型的 Web 应用，从简单的博客到复杂的电商网站。通过使用现代工具和框架，开发者可以快速构建和部署高性能的 Web 应用，提供卓越的用户体验。\n","0c2a1295472f5e6a8794d923daf8b0ff":"\n# HTML 篇\n\n`#前端` `#HTML` \n\n\n## 目录\n<!-- toc -->\n ## 参考 \n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [web.dev](https://web.dev/learn/html/welcome?continue=https%3A%2F%2Fweb.dev%2Flearn%2Fhtml&hl=zh-cn`#article-https://web.dev/learn/html/welcome&hl=zh-cn)`\n- [HTML 语言简介](https://wangdoc.com/html/intro`#%E6%A0%87%E7%AD%BE)`\n- [HTML 简介 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML)\n- [https://whatwg-cn.github.io/html/](https://whatwg-cn.github.io/html/)\n- [https://whatwg.org/?locale=zh_CN](https://whatwg.org/?locale=zh_CN)\n- [https://html.spec.whatwg.org/?locale=zh_CN](https://html.spec.whatwg.org/?locale=zh_CN)\n- [ARIA - 无障碍 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/ARIA)\n","ba72cdd2d8185468891cca9c12c3648f":"\n# HTML 概述\n\n\n`#前端` `#HTML` \n\n\n## 目录\n<!-- toc -->\n ## 什么是 HTML？ \n\n- HTML 的全名是“超文本标记语言”（HyperText Markup Language），可以说有了它，才有互联网的**内容**。\n- 它是用于构建网页的基本语言，用于定义网页的结构和内容\n- 任何网站的请求，第一个请求回来的资源就是`.html` 文件。\n\n## HTML 元素基本格式\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/5807dd04c7c94cbf0070e1ea5ec7d024.png)\n\n## HTML 基本结构\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>页面标题</title>\n  </head>\n  <body>\n    <h1>欢迎</h1>\n    <p>这是一个段落。</p>\n  </body>\n</html>\n```\n\n","31c71668e2fd54e68c4b49131696fc7e":"\n# HTML 标签与 HTML 属性\n\n\n`#前端` `#HTML` \n\n\n## 目录\n<!-- toc -->\n ## 1. 说说 `<meta>` 标签的用处？ \n\n使用 `<meta>` 标记 Metadata \n> 更多参考：[https://web.dev/learn/html/metadata?hl=zh-cn](https://web.dev/learn/html/metadata?hl=zh-cn)\n\n## 2. 标签语义化是什么意思？\n\n每个标签都有语义，需要注意使用场景，比如下图：\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/acc28644f26ef7363764d208cbc08ba3.png)\n\n## 3. 列举一些不常用但特别有用的标签\n\n### 3.1. abbr：缩写 abbreviation\n\n![image.png|572](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/dd23fcc1f51d799987d70f160ed51031.png)\n\n### 3.2. 展示计算机代码\n\n![image.png|492](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3949d49f5800384366ecff6d88bc091b.png)\n\n> 所以不只有`pre/code` ，但其他确实不太常用\n\n### 3.3. 对话框\n\n```html\n<dialog open>\n  <p>Greetings, one and all!</p>\n  <form method=\"dialog\">\n    <button>OK</button>\n  </form>\n</dialog>\n```\n\n### 3.4. 其他：HTML 元素，多看 MDN\n\n> **这里只是强调您可能还有很多标签元素没有使用过，建议多多参考文档**\n\n> 更多参考： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a\n\n## 4. 说说 HTML 属性有哪些类型？\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e5d1702720265eaec8f3a3af0dce9349.png)\n\n又分`布尔属性`、`枚举属性`、`全局属性`及`自定义属性`，可见下面代码示例\n\n```html\n<input required>\n<section id=\"reg\"/>\n<blockquote data-machine-learning=\"workshop\"></blockquote>\n```\n\n> 更多可参考：[网页元素的属性](https://wangdoc.com/html/attribute)\n\n## 5. 列举多媒体嵌入相关的标签\n\n- 常见标签为`<img> 、<video> 、<audio>、、<iframe>、<embed> 、 <object>、<track>、<param>`\n   - 可插入如图片、视频、音频、网页、字幕\n- `<embed>` 和 `<object>` : 可嵌入各类资源，如音频、视频、pdf 文件等\n\n> 更多参考：\n> [多媒体与嵌入 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding)\n> [多媒体标签](https://wangdoc.com/html/multimedia`#embed)`\n\n","275be1d4bdca52899ae034aaa2709dc8":"\n# HTML 技术关键词\n\n\n`#前端` `#HTML` \n\n\n## 目录\n<!-- toc -->\n ## 1. 列举一些HTML 技术关键词（Sonnet） \n\n关于HTML技术，以下是一些关键词和概念：\n\n1. 语义化标签：如header, nav, main, article, section, aside, footer等\n2. 表单元素：input, select, textarea, button等\n3. 多媒体标签：audio, video, canvas, svg\n4. 元数据：meta标签，用于定义页面的各种元数据\n5. 响应式设计：使用viewport meta标签和媒体查询\n6. 无障碍性（Accessibility）：使用aria属性，alt文本等\n7. 结构化数据：使用microdata, RDFa, JSON-LD等\n8. 离线Web应用：使用manifest文件（现在更多使用Service Workers）\n9. 本地存储：localStorage, sessionStorage\n10. **拖放API：drag and drop**\n11. 地理定位：Geolocation API\n12. Web Workers：用于在后台运行脚本\n13. WebSockets：用于实时双向通信\n14. 跨文档消息传递：postMessage API\n15. 内容安全策略（CSP）：用于防止XSS攻击\n16. 自定义数据属性：data-*属性\n17. 模板：template标签\n18. **图片响应式：srcset和sizes属性**\n19. 延迟加载：使用loading=\"lazy\"属性\n20. 表单验证：使用pattern, required等属性\n21. 输入类型：如date, time, email, url等\n22. 字符编码：使用UTF-8\n23. DOCTYPE声明：\n24. 语言声明：lang属性\n25. 链接关系：rel属性，如stylesheet, icon等\n26. 跨域资源共享（CORS）：通过HTTP头部控制\n27. 内容可编辑：contenteditable属性\n28. 自动完成：autocomplete属性\n29. 页面可见性API：用于检测页面是否可见\n30. 历史API：用于操作浏览历史\n\n这些关键词涵盖了HTML的基本结构、新特性、API以及与Web开发相关的重要概念。它们反映了现代HTML的功能和最佳实践。\n\n## 2. 列举一些HTML 技术关键词（GPT-4o）\n\n关于HTML技术的关键词，可以涵盖HTML的基础知识、标签、属性、功能以及相关的技术和概念。以下是一些重要的HTML技术关键词：\n\n### 2.1. 基础知识\n\n- **HTML (HyperText Markup Language)**: 超文本标记语言\n- **DOCTYPE**: 文档类型声明\n- **元素 (Element)**: HTML的基本构建块\n- **标签 (Tag)**: 用于定义HTML元素的标记\n- **属性 (Attribute)**: 提供元素的附加信息\n\n### 2.2. 常用标签\n\n- `<html>`: 定义HTML文档的根元素\n- `<head>`: 包含文档的元数据\n- `<title>`: 定义文档的标题\n- `<meta>`: 提供文档的元数据\n- `<link>`: 链接外部资源\n- `<script>`: 嵌入或引用JavaScript代码\n- `<style>`: 嵌入CSS样式\n- `<body>`: 定义文档的主体内容\n- `<header>`: 定义页面或节的头部\n- `<footer>`: 定义页面或节的尾部\n- `<nav>`: 定义导航链接\n- `<main>`: 定义文档的主要内容\n- `<section>`: 定义文档的节\n- `<article>`: 定义独立的内容块\n- `<aside>`: 定义侧边栏内容\n- `<h1>` 到 `<h6>`: 定义标题\n- `<p>`: 定义段落\n- `<a>`: 定义超链接\n- `<img>`: 定义图像\n- `<ul>`: 定义无序列表\n- `<ol>`: 定义有序列表\n- `<li>`: 定义列表项\n- `<table>`: 定义表格\n- `<tr>`: 定义表格行\n- `<td>`: 定义表格单元\n- `<th>`: 定义表格头单元\n- `<form>`: 定义表单\n- `<input>`: 定义输入控件\n- `<button>`: 定义按钮\n- `<textarea>`: 定义多行文本输入控件\n- `<select>`: 定义下拉列表\n- `<option>`: 定义下拉列表中的选项\n- `<label>`: 定义表单控件的标签\n- `<div>`: 定义文档中的分区或区域\n- `<span>`: 定义文档中的行内元素\n\n### 2.3. 表单和输入类型\n\n- `<input>` 类型: `text, password, email, url, number, date, time, checkbox, radio, file, submit, reset, button, hidden, color, range, search, tel\n- **表单验证属性**: `required, pattern, min, max, minlength, maxlength, step`\n\n### 2.4. 多媒体标签\n\n- `<audio>`: 定义音频内容\n- `<video>`: 定义视频内容\n- `<source>`: 定义多媒体资源\n- `<track>`: 定义视频和音频的文本轨道\n\n### 2.5. 图形和绘图\n\n- `<canvas>`: 用于绘制图形\n   - 2d\n   - 3d\n- **SVG (Scalable Vector Graphics)**: 可缩放矢量图形\n\n### 2.6. 响应式设计\n\n- `<meta name=\"viewport\">`: 定义视口属性\n- **媒体查询 (Media Queries)**: 用于响应式设计的CSS技术\n\n### 2.7. 本地存储\n\n- **localStorage**: 本地存储数据\n- **sessionStorage**: 会话存储数据\n\n### 2.8. Web Components\n\n- **自定义元素 (Custom Elements)**: 创建自定义HTML标签\n- **Shadow DOM**: 隐藏DOM树\n- **HTML模板 (HTML Templates)**: 定义可重用的HTML片段\n\n### 2.9. 语义化和可访问性\n\n- **语义化标签**: `<header>`, `<footer>`, `<nav>`, `<main>`, `<section>`, `<article>`, `<aside>`\n- **ARIA (Accessible Rich Internet Applications)**: 增强可访问性的属性\n\n### 2.10. 安全和性能\n\n- **内容安全策略 (CSP)**: 防止XSS攻击\n- **懒加载 (Lazy Loading)**: 延迟加载图像和其他资源\n- **预加载 (Preloading)**: 提前加载关键资源\n\n### 2.11. 其他相关技术\n\n- **HTML5**: HTML的最新版本\n- **CSS (Cascading Style Sheets)**: 层叠样式表，用于样式和布局\n- **JavaScript**: 用于交互和动态内容的编程语言\n- **DOM (Document Object Model)**: 文档对象模型\n- **SEO (Search Engine Optimization)**: 搜索引擎优化\n\n这些关键词涵盖了HTML技术的各个方面，从基础知识到高级功能，帮助开发者更好地理解和使用HTML来构建现代Web应用。\n","567ddf1a0b835b929f5c71c19e10c004":"\n# 请列举你认为最重要 HTML 技术清单？\n\n\n`#前端` `#HTML` \n\n以下是一些最重要的HTML技术清单，这些技术和概念对于现代Web开发至关重要：\n\n\n## 目录\n<!-- toc -->\n ## 1. **HTML5** \n\n- **介绍**：HTML的最新版本，提供了许多新特性和API。\n- **特点**：语义化标签、新的表单控件、多媒体支持（audio、video）、本地存储（localStorage、sessionStorage）。\n\n## 2. **语义化标签**\n\n- **介绍**：使用具有明确含义的标签来构建页面结构。\n- **特点**：提高可读性和可维护性、增强SEO、改善无障碍访问。\n- **示例**：`<header>`, `<footer>`, `<article>`, `<section>`, `<nav>`, `<aside>`。\n\n## 3. **表单元素和验证**\n\n- **介绍**：HTML5引入了许多新的表单控件和属性，简化了表单的创建和验证。\n- **特点**：新的输入类型（如`email`, `url`, `date`）、表单验证属性（如`required`, `pattern`）、增强的用户体验。\n\n## 4. **多媒体元素**\n\n- **介绍**：HTML5引入了原生的多媒体支持。\n- **特点**：`<audio>`和`<video>`标签，支持嵌入音频和视频内容，无需第三方插件。\n\n## 5. **Canvas**\n\n- **介绍**：用于绘制2D图形的HTML元素。\n- **特点**：通过JavaScript绘制图形、动画和游戏。\n\n## 6. **SVG**\n\n- **介绍**：可缩放矢量图形，基于XML的图像格式。\n- **特点**：高质量的图形、可交互、可动画化、支持CSS样式。\n\n## 7. **本地存储**\n\n- **介绍**：HTML5提供了两种本地存储机制：localStorage和sessionStorage。\n- **特点**：持久化存储（localStorage）、会话存储（sessionStorage）、简化客户端数据管理。\n\n## 8. **离线支持**\n\n- **介绍**：通过`<manifest>`文件和`Service Workers`实现离线支持。\n- **特点**：离线访问、缓存资源、提高应用的可靠性。\n\n## 9. **Web Workers**\n\n- **介绍**：在后台线程中运行JavaScript代码，避免阻塞主线程。\n- **特点**：并行处理、提高性能、增强用户体验。\n\n## 10. **ARIA（Accessible Rich Internet Applications）**\n\n- **介绍**：一组属性，用于增强Web内容的可访问性。\n- **特点**：改善无障碍访问、提高屏幕阅读器支持、增强用户体验。\n\n## 11. **自定义数据属性**\n\n- **介绍**：使用`data-*`属性在HTML元素中存储自定义数据。\n- **特点**：灵活的数据存储、简化JavaScript交互。\n\n## 12. **模板元素**\n\n- **介绍**：`<template>`标签，用于定义可重用的HTML片段。\n- **特点**：延迟渲染、提高性能、增强代码复用性。\n\n## 13. **Shadow DOM**\n\n- **介绍**：Web Components 的一部分，用于封装元素的内部结构和样式。\n- **特点**：样式隔离、避免样式冲突、提高组件化开发。\n\n## 14. **自定义元素**\n\n- **介绍**：Web Components 的一部分，允许创建自定义的HTML标签。\n- **特点**：增强HTML的可扩展性、提高代码复用性、与框架无关。\n\n## 15. **响应式设计**\n\n- **介绍**：使用HTML和CSS技术创建适应不同设备和屏幕尺寸的页面。\n- **特点**：媒体查询、弹性布局、视口设置。\n\n## 16. **微数据（Microdata）**\n\n- **介绍**：一种嵌入 HTML 的结构化数据的方式。\n- 目的:  为HTML元素添加机器可读的标签,描述其含义\n- **组成:** 主要由 itemscope, itemtype, 和 itemprop 属性组成。\n   - itemscope: 创建一个新的项目,表示其中包含的标记描述了一个特定的项目。\n   - itemtype: 指定项目的类型,通常是一个URL,指向一个词汇表或架构。\n   - itemprop: 定义项目的属性\n- **特点**：增强SEO、提高搜索引擎理解页面内容的能力。\n- 常用词汇表：Schema.org，最广泛使用的结构化数据词汇表，由主要搜索引擎共同支持。\n\n```html\n<div itemscope itemtype=\"http://schema.org/Person\">  \n  <span itemprop=\"name\">John Doe</span>  \n  <span itemprop=\"jobTitle\">Software Developer</span>  \n  <a href=\"mailto:john@example.com\" itemprop=\"email\">john@example.com</a>  \n</div>  \n\n```\n\n## 17. **内容安全策略（CSP）**\n\n- **介绍**：一种Web安全策略，用于防止跨站脚本攻击（XSS）等安全威胁。\n- **特点**：定义允许加载的资源、提高安全性、减少攻击面。\n\n内容安全策略（`Content Security Policy`，简称CSP）是一种重要的Web安全机制，用于防止跨站脚本攻击（XSS）、数据注入等攻击。让我详细解释一下CSP\n\n### 17.1. 基本概念\n\nCSP是一种由服务器声明的安全策略，它告诉浏览器哪些资源可以被加载和执行。\n\n### 17.2. 主要目标\n\n- 防止XSS攻击\n- 减少数据注入风险\n- 报告违规行为\n- 强制使用HTTPS\n\n### 17.3. 工作原理\n\nCSP通过`HTTP 头部 或 meta 标签`来实现，指定允许加载的资源的来源。\n\n### 17.4. 实现方式\n\n#### 17.4.1. HTTP头部方式\n\n```\nContent-Security-Policy: directive1 source1 source2; directive2 source3 source4\n```\n\n#### 17.4.2. Meta标签方式\n\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"directive1 source1 source2; directive2 source3 source4\">\n```\n\n### 17.5. 常用指令\n\n- `default-src`: 默认加载策略\n- `script-src`: JavaScript来源\n- `style-src`: CSS样式来源\n- `img-src`: 图片来源\n- `connect-src`: AJAX、WebSocket等连接来源\n- `font-src`: 字体文件来源\n- `object-src`: 插件来源（如Flash）\n- `media-src`: 音视频来源\n- `frame-src`: iframe来源\n\n> **即规定了所有可能加载资源的来源要求**\n\n### 17.6. 示例\n\n```\nContent-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com; img-src *\n```\n\n这个策略允许：\n\n- 默认只加载同源资源\n- 脚本只能从自身域名和trusted.cdn.com加载\n- 图片可以从任何源加载\n\n### 17.7. 报告模式\n\n可以使用`Content-Security-Policy-Report-Only`头部来测试策略，不实际阻止资源，只报告违规。\n\n### 17.8. 违规报告\n\n可以通过`report-uri`指令指定违规报告的接收地址。\n\n### 17.9. 优势\n\n- 大幅降低XSS风险\n- 控制资源加载，提高安全性\n- 强制使用HTTPS，保护数据传输\n- 提供违规报告，便于监控和调试\n\n### 17.10. 挑战和注意事项\n\n- 可能影响第三方脚本和插件的使用\n- 需要仔细配置以避免破坏网站功能\n- 旧版浏览器可能不支持\n\n### 17.11. 最佳实践\n\n- 从严格策略开始，逐步放宽\n- 使用报告模式进行测试\n- 定期审查和更新策略\n- 结合其他安全措施使用（如HTTPS、安全Cookie等）\n\n### 17.12. 与其他安全措施的结合\n\n- HSTS (HTTP Strict Transport Security)\n- X-Frame-Options\n- X-XSS-Protection\n\n### 17.13. 未来发展\n\n- 更细粒度的控制\n- 更好的浏览器支持\n- 与新兴Web技术的集成\n\n内容安全策略是现代Web安全的重要组成部分。它提供了一种强大的方式来控制资源加载，大大提高了网站抵御各种攻击的能力。然而，实施CSP需要仔细规划和测试，以确保既提高安全性，又不影响网站的正常功能。\n\n## 18. **Web Components**\n\n- **介绍**：一组Web平台API，用于创建可复用的自定义元素。\n- **特点**：组件化开发、样式和功能封装、与框架无关。\n\n## 19. **媒体查询**\n\n- **介绍**：用于在不同设备和屏幕尺寸上应用不同的CSS样式。\n- **特点**：响应式设计、提高用户体验、适应多种设备。\n","14c8da1a9fe853d1a61ce66f24e5e931":"\n# 如何判断你自己对 HTML 标签了解是否全面？\n\n\n`#前端` `#HTML` \n\n你可以通过下面的清单来检测自己对于 HTML 标签的了解是否全面\n\n- HTML 简介\n- HTML 的标准规范有哪些？\n- URL ：通过 a 标签，构建了互联网\n- 标签语义\n- 全局属性：比如 `spellcheck/translate` 是做什么用的？\n   - 拼写和翻译\n- HTML的字符实体表示方法：为什么？\n   - 网页使用 utf-8 ，那么类似于`<p>` 中的 `<` 如何表示呢？\n- `a 标签`\n   - 它的下面这些属性都是干嘛的？\n      - [href](https://wangdoc.com/html/a`#href)`\n      - [hreflang](https://wangdoc.com/html/a`#hreflang)`\n      - [title](https://wangdoc.com/html/a`#title)`\n      - [target](https://wangdoc.com/html/a`#target)`\n      - [rel](https://wangdoc.com/html/a`#rel)`\n      - [referrerpolicy](https://wangdoc.com/html/a`#referrerpolicy)`\n      - [ping](https://wangdoc.com/html/a`#ping)：用于打点`\n      - [type](https://wangdoc.com/html/a`#type)`\n      - [download](https://wangdoc.com/html/a`#download)` ：==用于下载==\n   - 发邮件：调用邮件客户端\n   - 打电话：H5\n- link 标签\n   - rel：全称 `relationship`\n      - 预加载相关：preload / prefetch /dns-prefetch / prerender / preconnect\n      - 其他：比如 icon / stylessheet 等\n   - media：媒体查询\n   - crossorigin ：跨域访问相关\n   - manifest：文件清单\n   - 更多参考 [<link>](https://wangdoc.com/html/link`#hreflang-%E5%B1%9E%E6%80%A7)`\n- `<script> 、<noscript>`\n   - type \n   - async/defer\n   - crossorigin\n   - integrity：哈希防篡改\n   - nonce：密码随机值，配合服务器，只有白名单才执行\n- iframe\n   - `sandbox`：沙盒权限属性，比如是否允许提交表单、是否允许提示框等等\n   - `importance`：下载优先级\n   - `loading`: auto/lazy/eager \n- `table` 相关标签都有哪些\n   - 如何合并单元格？\n- `details/summary/dialog 标签`是干什么用的 ？ \n- form\n   - input type 有哪些？\n   - 每种 type 有不同的属性：比如 min/pattern/autocomplete ...\n   - 更多参考：[表单标签](https://wangdoc.com/html/form`#meter)`\n\n","cb7ba769c4b45928bd973f5163c2f39f":"\n# 什么是 Web Components？\n\n`#前端` `#HTML` \n\nWeb 组件标准由三部分组成：[HTML 模板](https://developer.mozilla.org/docs/Web/Web_Components/Using_templates_and_slots)、[自定义元素](https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements) 和 [Shadow DOM](https://developer.mozilla.org/docs/Web/Web_Components/Using_shadow_DOM)\n\n> 更多参考：[Web Component - Web API | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components)\n> 后面会有独立章节单独讲这块\n\n","4cff5010243b5467b14801b482f78b80":"\n# 说说 HTML 标准规范都有哪些？\n\n\n`#HTML`  `#前端/HTML`  \n\n- **WHATWG** 全称是 `Web Hypertext Application Technology Working Group`，即 `Web 超文本应用技术工作组`\n- WHATWG HTML 规范：定义了 HTML 的语法和行为，涵盖了网页开发的**所有**方面，确保网页在不同浏览器中的一致性。\n- ARIA（Accessible Rich Internet Applications 规范：专注于增强网页的无障碍性，使得辅助技术用户能够更好地访问和操作网页内容\n   - 主要定义了一组属性，比如如 role、aria-label、aria-hidden、aria-live 等，用于增强现有 HTML 元素的语义信息。\n","98b41efe4ed35d88bc5b1bc8fce3bf74":"\n# 什么是响应式图片\n\n\n`#HTML`   `#前端`\n\n图片响应式设计是现代Web开发中一个重要的概念，旨在根据不同设备和屏幕尺寸提供适合的图片资源，以提高页面加载速度和用户体验。以下是关于图片响应式设计的详细说明：\n\n\n## 目录\n<!-- toc -->\n ## 1. 背景和重要性 \n\n随着移动设备的普及，用户访问网站的设备种类和屏幕尺寸变得多样化。传统的固定尺寸图片在不同设备上可能会导致加载时间过长或显示效果不佳。响应式图片技术通过提供不同尺寸和分辨率的图片，确保在各种设备上都能获得最佳的显示效果和性能。\n\n## 2. 基本概念\n\n- **响应式图片**: 根据设备特性（如屏幕尺寸、分辨率等）动态选择和加载合适的图片。\n- **视口（Viewport）**: 用户设备的可视区域。\n- **DPR（Device Pixel Ratio）**: 设备像素比，表示设备物理像素与CSS像素的比例。\n\n## 3. 实现方法\n\n### 3.1. 使用 `srcset` 和 `sizes` 属性\n\n`srcset` 和 `sizes` 属性是 HTML5 中引入的，用于指定不同分辨率和尺寸的图片资源。\n\n```html\n<img src=\"small.jpg\" \n     srcset=\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\" \n     sizes=\"(max-width: 600px) 480px, (max-width: 1200px) 800px, 100vw\" \n     alt=\"Responsive Image\">\n```\n\n- `srcset`: 定义一组图片资源及其对应的宽度描述符（如500w表示500像素宽）。\n- `sizes: 定义图片在不同视口宽度下的显示尺寸（如**`**(max-width: 600px) 480px**`**表示视口宽度小于600px时图片宽度为480px）。**\n\n浏览器会根据视口大小和设备像素比自动选择最合适的图片进行加载。\n\n### 3.2. 使用 `<picture>` 元素\n\n`<picture>` 元素提供了更强大的响应式图片支持，可以根据不同的媒体条件加载不同的图片资源。\n```html\n<picture>\n  <source media=\"(max-width: 600px)\" srcset=\"small.jpg\">\n  <source media=\"(max-width: 1200px)\" srcset=\"medium.jpg\">\n  <img src=\"large.jpg\" alt=\"Responsive Image\">\n</picture>\n\n```\n\n- `<source>`: 定义不同的媒体条件和对应的图片资源。\n- `<img>`: 定义默认图片，当所有媒体条件都不满足时加载。\n\n## 4. 示例\n\n### 4.1. 使用 `srcset` 和 `sizes`\n\n```html\n<img src=\"images/default.jpg\"\n     srcset=\"images/small.jpg 480w, images/medium.jpg 800w, images/large.jpg 1200w\"\n     sizes=\"(max-width: 600px) 480px, (max-width: 1200px) 800px, 100vw\"\n     alt=\"Example of responsive image\">\n```\n\n### 4.2. 使用 `<picture>` 元素\n\n```html\n<picture>\n  <source media=\"(max-width: 600px)\" srcset=\"images/small.jpg\">\n  <source media=\"(max-width: 1200px)\" srcset=\"images/medium.jpg\">\n  <img src=\"images/large.jpg\" alt=\"Example of responsive image\">\n</picture>\n\n```\n\n## 5. 优势\n\n- **提高性能**: 通过加载适合的图片资源，减少不必要的带宽消耗，提高页面加载速度。\n- **优化用户体验**: 确保在不同设备上都能获得最佳的图片显示效果。\n- **SEO友好**: 提供合适的图片资源，有助于搜索引擎优化。\n\n## 6. 注意事项\n\n- **图片格式**: 使用现代`图片格式（如WebP）`可以进一步优化图片加载性能。\n- **缓存策略**: 合理设置图片的缓存策略，减少重复加载。\n- **测试和优化**: 在不同设备和浏览器上测试响应式图片效果，确保兼容性和性能。\n\n## 7. 工具和资源\n\n- **图片生成工具**: 使用工具（如ImageMagick）批量生成不同尺寸和分辨率的图片。\n- **在线服务**: 使用在线服务（如Cloudinary）自动生成和管理响应式图片资源。\n- **浏览器开发者工具**: 使用浏览器开发者工具测试和调试响应式图片效果。\n\n通过合理使用响应式图片技术，可以显著提升Web应用的性能和用户体验，适应现代Web开发的需求。\n","3de769b726755bb0b8052c64f53b27bd":"\n# HTML 模板语言\n\n\n`#HTML`  `#2024/07/30`  `#前端`\n\nHTML 模板语言是一种用于生成动态 HTML 内容的工具，通常用于 Web 开发中以简化和自动化 HTML 代码的生成，比如\n\n- `Handlebars.js` ，适用于前端和后端渲染\n- `Nunjucks`，适用于前端和后端渲染\n- `pug/ejs` ，适用于 nodejs\n- 还有 \n   - php：`smarty `\n   - java：`jsp / Velocity`\n\n等等\n","55663541ce625ad5adbd6caa0198052b":"\n# CSS 篇\n\n\n`#前端/CSS` \n\n> CSS 完全可以写一大本书了，这里只列举一些相对前沿或我认为比较重要的知识点\n\n\n## 目录\n<!-- toc -->\n ## 1. 参考 \n\n- [GPT-4o](https://chatgpt.com/)\n- [Claude 3.5 Sonnet](https://www.anthropic.com/news/claude-3-5-sonnet?locale=zh_CN)\n- [https://www.w3.org/Style/CSS/`#specs](https://www.w3.org/Style/CSS/``#specs)`\n- [CSS：层叠样式表 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS)\n- [https://web.dev/learn/css/color?hl=zh-cn](https://web.dev/learn/css/color?hl=zh-cn)\n\n## 2. 推荐书籍\n\n- 《CSS 揭秘》\n\n","1419e55b00725d61a1310c0d58e71c2a":"\n# CSS 是什么？\n\n\n`#css`  `#前端/CSS`   \n\n即为 HTML 添加样式\n","54a1407e9f185a1aa4dedd23e311481d":"\n# CSS 定位都有哪些？\n\n\n`#2024/07/30`  `#前端/CSS`  \n\n- 静态定位（Static Positioning）\n- 相对定位（Relative Positioning）\n- 绝对定位（Absolute Positioning）\n- 固定定位（Fixed Positioning）\n- 粘性定位（Sticky Positioning）\n\n不展开了\n","c570636b247f5c8d8ae91b6a73a48549":"\n# CSS 滚动自动吸附效果与吸顶效果的区别？\n\n`#前端/CSS`  `#2024/07/30` \n\n\n## 目录\n<!-- toc -->\n ## 1. CSS 滚动自动吸附效果如何实现？ \n\n`**CSS Scroll Snap**` 用于创建更流畅、更控制的滚动体验，确保滚动容器滚动到`预定义`的位置，使用户可以`精确地滚动到相邻的部分`\n\n- **描述**：提供了一种控制滚动行为的方式，使滚动条在指定位置停止。\n- **特点**：适用于创建滑动视图和画廊。\n- **示例**：\n```css\n.container {\n  scroll-snap-type: x mandatory;\n}\n.item {\n  scroll-snap-align: center;\n}\n```\n\n可以理解为幻灯片的效果，或者画廊滚动的效果，具体效果可参考：[https://codepen.io/chriscoyier/full/pMRgwW](https://codepen.io/chriscoyier/full/pMRgwW)\n\n具体 CSS Scroll Snap 属性包括如下：\n\n- [scroll-snap-type](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type)\n- [scroll-padding](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding)\n   - [scroll-padding-top](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-top)\n   - [scroll-padding-right](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-right)\n   - [scroll-padding-bottom](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-bottom)\n   - [scroll-padding-left](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-left)\n   - [scroll-padding-inline](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline)\n   - [scroll-padding-inline-start](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline-start)\n   - [scroll-padding-inline-end](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-inline-end)\n   - [scroll-padding-block](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block)\n   - [scroll-padding-block-start](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block-start)\n   - [scroll-padding-block-end](https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-padding-block-end)\n\n> 如何使用具体参考上面的链接即可\n\n## 2. 上面说的 css 的`自动吸附效果`和`吸顶`有什么区别吗？\n\n- `position: sticky` 主要用于使元素在滚动时`粘性`地保持在其父元素的某个位置。\n- `CSS Scroll Snap` 主要用于创建更流畅和可控制的滚动体验，通过自动捕捉和对齐滚动点来提升用户体验。\n","03cd37cc641f53899e0541df8df69d5d":"\n# 如何使用 CSS 变量？\n\n\n`#前端/CSS`   `#2024/07/30` \n\nCSS 变量使用 `--` 作为前缀来定义，并且通常定义在 `:root` 选择器中，以便在整个文档中全局可用。\n\n```css\n:root {\n  --main-color: `#3498db;`\n  --padding-size: 10px;\n  --font-size: 16px;\n}\n```\n\nCSS 变量可以存储任何合法的 CSS 值，包括颜色、长度、百分比、字符串等\n\n\n## 目录\n<!-- toc -->\n ## 1. 使用 CSS 变量 \n\n使用 `var()` 函数来引用 CSS 变量。\n```css\n.element {\n  color: var(--main-color);\n  padding: var(--padding-size);\n  font-size: var(--font-size);\n}\n```\n\n## 2. 变量的作用域\n\nCSS 变量的作用域可以是全局的（定义在 `:root` 中）或局部的（定义在特定选择器中）。\n\n### 2.1. 全局变量\n\n定义在 `:root` 中的变量可以在整个文档中使用。\n```css\n:root {\n  --global-color: `#3498db;`\n}\n.element {\n  color: var(--global-color);\n}\n```\n\n### 2.2. 局部变量\n\n定义在特定选择器中的变量只能在该选择器及其子元素中使用。\n\n```css\n.container {\n  --local-color: `#e74c3c;`\n}\n.element {\n  color: var(--local-color); /* 仅在 .container 内部有效 */\n}\n```\n\n## 3. 变量的默认值\n\n`var()` 函数可以接受一个可选的`第二个参数`作为默认值，当变量未定义时使用该默认值。\n\n```css\n.element {\n  color: var(--undefined-color, `#2ecc71);` /* 如果 --undefined-color 未定义，则使用 `#2ecc71` */\n}\n```\n\n## 4. 嵌套变量\n\nCSS 变量可以嵌套使用，即一个变量的值可以引用另一个变量。\n\n```css\n:root {\n  --primary-color: `#3498db;`\n  --secondary-color: var(--primary-color);\n}\n.element {\n  color: var(--secondary-color); /* 等同于 `#3498db` */\n}\n```\n\n## 5. 变量的计算\n\nCSS 变量可以与其他 CSS 属性值一起使用，并且可以参与计算。\n\n```css\n:root {\n  --base-padding: 10px;\n}\n.element {\n  padding: calc(var(--base-padding) * 2); /* 等同于 20px */\n}\n```\n\n## 6. 动态更新变量\n\nCSS 变量的值可以通过 JavaScript 动态更新，从而实现动态样式更改。\n\n```html\n<style>\n  :root {\n    --dynamic-color: `#3498db;`\n  }\n  .element {\n    color: var(--dynamic-color);\n  }\n</style>\n\n<div class=\"element\">Hello World</div>\n\n<script>\n  document.documentElement.style.setProperty('--dynamic-color', '`#e74c3c');`\n</script>\n\n```\n\n## 7. 变量的继承\n\nCSS 变量遵循 CSS 的继承规则，子元素可以继承父元素定义的变量。\n\n```css\n.parent {\n  --inherited-color: `#3498db;`\n}\n.child {\n  color: var(--inherited-color); /* 继承自 .parent */\n}\n```\n\n## 8. 变量的类型\n\nCSS 变量可以存储任何合法的 CSS 值，包括颜色、长度、百分比、字符串等。\n\n```css\n:root {\n  --color: `#3498db;`\n  --padding: 10px;\n  --font: 'Arial, sans-serif';\n}\n.element {\n  color: var(--color);\n  padding: var(--padding);\n  font-family: var(--font);\n}\n```\n\n## 9. CSS @property\n\n- 描述：用于注册自定义属性，并定义其初始值和继承行为。\n- 特点：增强了 CSS 变量的功能。\n- 示例：\n```css\n@property --main-color {\n  syntax: '<color>';\n  initial-value: `#3498db;`\n  inherits: true;\n}\n```\n\n> 源于 GPT 4.0 ，总结得很好！\n\n","a598013c660858f484df04fbadc72f60":"\n# CSS 的计算属性都有哪些？\n\n\n`#前端/CSS`  `#2024/07/30` \n\n在 CSS 中，计算属性（也称为计算值）是指那些可以通过数学运算、函数或其他方式动态计算的属性值。\n\n\n## 目录\n<!-- toc -->\n ## 1. `calc()` \n\n`calc()` 函数允许你在 CSS 属性中进行基本的数学运算（加、减、乘、除）。\n```css\n.element {\n  width: calc(100% - 50px);\n  height: calc(50vh + 20px);\n  margin: calc(10px * 2);\n}\n```\n\n## 2. `var()`\n\n`var()` 函数用于引用 CSS 变量。这些变量可以包含计算值。\n\n```css\n:root {\n  --base-size: 10px;\n}\n\n.element {\n  padding: calc(var(--base-size) * 2);\n}\n```\n\n## 3. `min()`, `max()`, `clamp()`\n\n这些函数允许你在多个值之间进行选择。\n\n- `min()` 返回最小值。\n- `max()` 返回最大值。\n- `clamp()` 返回一个在指定范围内的值。\n\n```css\n.element {\n  width: min(50vw, 500px); /* 取 50vw 和 500px 中的最小值 */\n  height: max(100px, 10vh); /* 取 100px 和 10vh 中的最大值 */\n  font-size: clamp(1rem, 2vw, 3rem); /* 字体大小在 1rem 到 3rem 之间，取 2vw */\n}\n```\n\n## 4. `attr()`\n\n`attr()` 函数允许你在 CSS 中使用 HTML 属性的值。虽然这个函数的支持仍然有限，但它可以用于一些简单的场景。\n\n```css\n.element::before {\n  content: attr(data-content);\n}\n```\n\n## 5. `env()`\n\n`env()` 函数用于访问环境变量，例如安全区域（safe area）内边距。\n\n```css\n.element {\n  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);\n}\n```\n\n## 6. `url()`\n\n`url()` 函数用于引用外部资源，例如图像、字体等。\n\n```css\n.element {\n  background-image: url('path/to/image.jpg');\n}\n```\n\n## 7. `rgba()`, `hsla()`\n\n这些函数用于定义颜色，可以包含计算值。\n\n```css\n.element {\n  background-color: rgba(255, 0, 0, 0.5); /* 半透明的红色 */\n  color: hsla(120, 100%, 50%, 0.3); /* 半透明的绿色 */\n}\n```\n\n## 8. `repeat()`\n\n`repeat()` 函数用于在 CSS Grid 布局中重复轨道定义。\n\n```css\n.grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr); /* 三列，每列平分 */\n}\n```\n\n## 9. `fit-content()`\n\n`fit-content()` 函数用于定义一个自适应内容的大小。\n\n```css\n.element {\n  width: fit-content(200px); /* 根据内容自适应宽度，不超过 200px */\n}\n```\n\n## 10. `rotate()`, `scale()`, `translate()`, `skew()`\n\n这些变换函数用于定义元素的变换效果。\n\n```css\n.element {\n  transform: rotate(45deg) scale(1.5) translate(10px, 20px);\n}\n```\n\n## 11. `cubic-bezier()`, `steps()`\n\n这些函数用于定义动画的时间函数。\n\n```css\n.element {\n  transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);\n  animation-timing-function: steps(4, end);\n}\n```\n\n## 12. `conic-gradient()` \n\n`conic-gradient()` 函数用于创建圆锥渐变。\n```css\n.element {\n  background: conic-gradient(from 0deg at 50% 50%, red, yellow, green, blue);\n}\n```\n\n## 13. `linear-gradient()`\n\n`linear-gradient()` 函数用于创建线性渐变。\n```css\n.element {\n  background: linear-gradient(to right, red, yellow, green);\n}\n```\n\n## 14. `radial-gradient()`\n\n`radial-gradient()` 函数用于创建径向渐变。\n```css\n.element {\n  background: radial-gradient(circle, red, yellow, green);\n}\n```\n\n## 15. `repeating-linear-gradient()`\n\n`repeating-linear-gradient()` 函数用于创建重复的线性渐变。\n\n```css\n.element {\n  background: repeating-linear-gradient(45deg, red, yellow 10%, green 20%);\n}\n```\n\n## 16. `repeating-radial-gradient()`\n\n`repeating-radial-gradient()` 函数用于创建重复的径向渐变。\n\n```css\n.element {\n  background: repeating-radial-gradient(circle, red, yellow 10%, green 20%);\n}\n```\n\n## 17. `hsl()`, `hsla()`\n\n`hsl()` 和 `hsla()` 函数用于定义 HSL 颜色值，可以包含计算值。\n\n```css\n.element {\n  color: hsl(120, 100%, 50%);\n  background-color: hsla(240, 100%, 50%, 0.5);\n}\n```\n\n## 18. `rotateX()`, `rotateY()`, `rotateZ()\n`\n这些 3D 变换函数用于定义元素的旋转效果。\n\n```css\n.element {\n  transform: rotateX(45deg) rotateY(30deg) rotateZ(60deg);\n}\n```\n\n## 19. `scaleX()`, `scaleY()`, `scaleZ()`\n\n这些 3D 变换函数用于定义元素的缩放效果。\n\n```css\n.element {\n  transform: scaleX(1.2) scaleY(0.8) scaleZ(1.5);\n}\n```\n\n## 20. `translateX()`, `translateY()`, `translateZ()`\n\n这些 3D 变换函数用于定义元素的平移效果。\n\n```css\n.element {\n  transform: translateX(10px) translateY(20px) translateZ(30px);\n}\n```\n\n## 21. `skewX()`, `skewY()`\n\n这些变换函数用于定义元素的倾斜效果。\n\n```css\n.element {\n  transform: skewX(30deg) skewY(20deg);\n}\n```\n\n## 22. `matrix()`, `matrix3d()`\n\n这些函数用于定义 2D 和 3D 变换矩阵。\n\n```css\n.element {\n  transform: matrix(1, 0, 0, 1, 50, 100); /* 2D 变换矩阵 */\n  transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 50, 100, 0, 1); /* 3D 变换矩阵 */\n}\n```\n\n## 23. `perspective()`\n\n`perspective()` 函数用于定义 3D 透视效果。\n\n```css\n.element {\n  transform: perspective(500px) rotateY(45deg);\n}\n```\n\n## 24. `path()`\n\n`path()` 函数用于定义一个路径，常用于 `clip-path` 属性。\n\n```css\n.element {\n  clip-path: path('M10 10 H 90 V 90 H 10 L 10 10');\n}\n```\n\n## 25. `circle()`, `ellipse()`, `inset()`, `polygon()`\n\n这些函数用于定义裁剪路径（clip path）。\n\n```css\n.element {\n  clip-path: circle(50% at 50% 50%);\n  clip-path: ellipse(50% 50% at 50% 50%);\n  clip-path: inset(10% 20% 30% 40%);\n  clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);\n}\n```\n\n## 26. `counter()`, `counters()`\n\n这些函数用于生成计数器内容。\n\n```css\nol {\n  counter-reset: section;\n}\n\nli::before {\n  counter-increment: section;\n  content: counter(section) \". \";\n}\n```\n\n## 27. `rotate3d()`\n\n`rotate3d()` 函数用于定义沿着任意轴的 3D 旋转。\n\n```css\n.element {\n  transform: rotate3d(1, 1, 0, 45deg);\n}\n```\n\n## 28. `translate3d()`\n\n`translate3d()` 函数用于定义 3D 平移。\n\n```css\n.element {\n  transform: translate3d(10px, 20px, 30px);\n}\n```\n\n","2fed16afd8ff5ae894ce456d73e352eb":"\n# CSS 处理器都有哪些？\n\n\n`#css`  `#前端/CSS`  `#2024/07/30` \n\n又分为 `前置处理器（预处理器）`和 `后置处理器（后处理器）`\n\n\n## 目录\n<!-- toc -->\n ## 1. CSS 前置处理器（预处理器） \n\n- Sass/SCSS\n\t- Sass (Syntactically Awesome Style Sheets)\n- Less (Leaner CSS)\n- Stylus\n\n## 2. CSS 后置处理器（后处理器）\n\n代表\n\n- PostCSS（虽然它也可以作为预处理器使用）\n- Autoprefixer（自动添加浏览器前缀）\n- CSS Nano（压缩和优化 CSS）\n\n## 3. CSS-in-JS\n\n将 CSS 写入 JavaScript 代码中的技术，比如 styled-components、Emotion、JSS 等。\n\n","f4debad7e9355605abfcc8dddf665044":"\n# CSS 选择器的优先级\n\n\n`#前端/CSS`  `#2024/07/30`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 特异性（Specificity） ：优先级 \n\nCSS 选择器的优先级由四个数值组成，用来计算选择器的`特异性（Specificity）`。这些数值从高到低分别是：\n\n1. 内联样式：如果样式是通过元素的 `style` 属性内联定义的，例如 `<div style=\"color: red;\"></div>`。\n   1. 特异性（Specificity）：1000\n2. ID 选择器：例如 ``#id``\n   1. 特异性（Specificity）：100\n3. 类选择器、属性选择器和`伪类选择器`：例如 `.class`、`[type=\"text\"]`、`:hover`\n   1. 特异性（Specificity）：10\n4. 元素选择器 和`伪元素`选择器：例如 `div`、`p`、`::before`\n   1. 特异性（Specificity）：1\n5. 通配符选择器（*）\n   1. 特异性（Specificity）：0\n\n> 特异性（Specificity） 即 优先级\n\n## 2. 示例\n\n1. `style=\"color: red;\"` 内联样式，特异性值为 `1000`\n2. ``#idSelector`` ID 选择器，特异性值为 `100`\n3. `.classSelector` 类选择器，特异性值为 `10`\n4. `[type=\"text\"]` 属性选择器，特异性值为 `10`\n5. `:hover` 伪类选择器，特异性值为 `10`\n6. `div` 元素选择器，特异性值为 `1`\n\n## 3. `important`\n\n1. `!important` 提升声明的优先级，覆盖任何通常的权重计算。\n2. 任意规则使用 `!important`，该规则将优先权。\n3. 多个 `!important`之间情况，优先级基于特异性。\n\n## 4. 总结\n\n1. `!important` 声明\n2. 内联样式（`style 属性`）\n3. ID 选择器（``#id`）`\n4. 类选择器（`.class`）、属性选择器（`[attr]`）和 `伪类（:hover 等）`\n5. 元素选择器（`div, p 等`）和 `伪元素（::before, ::after 等`）\n6. 通配符选择器（`*`）\n\n> 是有一个很详细的计算公式的，CSS 引擎会严格计算具体的值\n\n","3b854b0c2a6e5155ab56e6b25a03d926":"\n# CSS Houdini API\n\n\n`#前端/CSS`  `#2024/07/30` \n\n- **描述**：一组低级 API，允许开发者扩展 CSS 的功能。\n- **特点**：可以创建自定义的 CSS 属性、值和渲染逻辑。\n- **示例**：使用 Houdini Paint API 创建自定义背景图案。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/fbc8c2fd3e2020705eca7a56269f9619.png)\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/66aa45d5394512e154f5316bb589f85f.png)\n\n","cdc22342ad8d5b868ff148263b69be3a":"\n# Tailland CSS 的使用\n\n\n`#前端/CSS`  `#2024/07/30`\n\n\n## 目录\n<!-- toc -->\n ## 1. 主要特点 \n\n- 原子级类：每个类通常只做一件事。\n- 组合使用：通过组合多个类来实现复杂的样式。\n- 直接在 HTML 中应用：样式直接在 HTML 元素上应用，而不是在单独的 CSS 文件中。\n- 预定义类：使用框架提供的预定义类，而不是自定义 CSS。\n\n## 2. 优势解释\n\n- 快速开发：不需要切换到 CSS 文件，直接在 HTML 中应用样式。\n- 一致性：使用预定义的类确保整个项目的样式一致。\n- 响应式设计：可以轻松添加响应式前缀（如 `md:`, `lg:`）来适应不同屏幕尺寸。\n- 避免命名困难：不需要为每个元素想独特的类名。\n\n## 3. 问题\n\n- HTML 膨胀、可维护性\n- **语义化问题**\n- 可能不适合小项目\n- 设计一致性的挑战\n\n","e72e5d1e7a3755f69521e87ae7903469":"\n# CSS 性能优化有哪些思路？\n\n\n`#前端/CSS`  `#2024/07/30`\n\n在进行 CSS 性能优化时，有许多注意事项和最佳实践可以帮助提高网页的加载速度和渲染性能。以下是一些关键的性能优化技巧：\n\n\n## 目录\n<!-- toc -->\n ## 1. 减少 CSS 文件的大小 \n\n- 压缩 CSS 文件：使用工具（如 CSSNano、csso）压缩 CSS 文件，去除空格、注释和不必要的字符。\n- 移除未使用的 CSS：使用工具（如 PurifyCSS、PurgeCSS）检测并移除未使用的 CSS 规则。\n\n## 2. 优化选择器\n\n- 避免过于具体的选择器：复杂的选择器（如后代选择器）会增加浏览器的匹配时间。尽量使用简单的选择器。\n- 避免使用通配符选择器：如 `*` 选择器会匹配所有元素，性能较差。\n- 减少嵌套层级：过深的嵌套会增加选择器的复杂度，影响性能。\n\n## 3. 使用高效的布局技术\n\n- 优先使用 Flexbox 和 Grid 布局：这些布局模型在现代浏览器中性能较好，且代码简洁易维护。\n- 避免使用浮动布局：浮动布局需要更多的清理和处理，影响性能。\n\n## 4. 减少重排和重绘\n\n- 避免频繁修改样式：频繁修改样式会导致重排和重绘，影响性能。尽量批量修改样式。\n- 使用 `class` 切换而不是直接修改样式：通过切换 `class` 来改变样式，而不是直接修改元素的 `style` 属性。\n- 避免使用 JavaScript 修改样式：尽量使用 CSS 过渡和动画，而不是通过 JavaScript 修改样式。\n\n## 5. 使用硬件加速\n\n- 启用 GPU 加速：使用 `transform`、`opacity` 和 `will-change` 属性来启用 GPU 加速，减少 CPU 负载。\n```css\n.element {\n  will-change: transform, opacity;\n}\n```\n\n## 6. 延迟加载和异步加载\n\n- 异步加载 CSS：使用 `media` 属性和 `onload` 事件异步加载非关键 CSS。\n```html\n<link rel=\"stylesheet\" href=\"non-critical.css\" media=\"print\" onload=\"this.media='all'\">\n<noscript><link rel=\"stylesheet\" href=\"non-critical.css\"></noscript>\n\n```\n\n> 打印的样式肯定需要后置\n\n## 7. 使用 CSS 预处理器和后处理器\n\n- 使用预处理器（如 Sass、Less）：预处理器可以帮助组织和优化 CSS 代码，提高可维护性。\n- 使用后处理器（如 PostCSS）：后处理器可以自动添加浏览器前缀、压缩 CSS 等。\n\n## 8. 优化字体加载\n\n- 使用字体显示策略：使用 `font-display` 属性优化字体加载体验。\n```css\n@font-face {\n  font-family: 'MyFont';\n  src: url('myfont.woff2') format('woff2');\n  font-display: swap;\n}\n```\n\n- 只加载必要的字体：避免加载过多的字体变体和字符集。\n\n## 9. 代码分割和按需加载\n\n- 按需加载 CSS：将不同页面的样式分割成不同的 CSS 文件，按需加载。\n\n## 10. 使用现代 CSS 特性\n\n- 使用 CSS 变量：CSS 变量可以减少重复代码，提高可维护性和性能。\n```css\n:root {\n  --primary-color: `#3498db;`\n}\n\n.element {\n  color: var(--primary-color);\n}\n```\n\n- 使用现代布局和功能：如 CSS Grid、Flexbox、`clamp()`、`min()`、`max()` 等，减少依赖 JavaScript 实现复杂布局和功能。\n\n## 11. 提前加载关键 CSS\n\n- 内联关键 CSS：将关键 CSS 内联到 HTML 中，减少初始渲染时间。\n```html\n<style>\n  /* 关键 CSS */\n  body {\n    font-family: 'Arial', sans-serif;\n  }\n</style>\n\n```\n\n## 12. 使用内容分发网络 (CDN)\n\n- 使用 CDN 提供 CSS：使用 CDN 提供的 CSS 文件，可以加速文件加载。\n","29b67bb34e9b5c179ee373eac571a7d8":"\n# 媒体查询\n\n`#2024/07/30`   `#前端/CSS`  \n\n常见的媒体查询语句如下\n\n- min-width,\n- max-width\n- orientation\n- @container\n\n\n## 目录\n<!-- toc -->\n ## 1. `Container` Queries  \n\n- **描述**：允许根据容器的尺寸而不是视口尺寸来应用样式。\n- **特点**：**更灵活的响应式设计，更灵活的媒体查询**\n- **示例**：\n```css\n@container (min-width: 500px) {\n  .element {\n    background-color: blue;\n  }\n}\n```\n\n","141b6061b4c05084b07b5b9ae1115e98":"\n# 请列举 CSS 兼容性相关的知识点\n\n\n`#2024/07/30`  `#前端/CSS`  \n\n- `@supports not (--css: variables) {}`  用于确定是否支持 `css 变量`\n- Autoprefixer\n- Can I use?\n- CSS Reset\n   - `CSS Reset`:  如Eric Meyer’s Reset CSS\n   - `Normalize.css`:  保留有用的默认样式，同时标准化跨浏览器的样式\n- Modernizr库: 一个流行的库，用于检测HTML5和CSS3特性，比如 `if (Modernizr.flexbox) {} `\n- IE条件注释，太老了，可以不用了吧？\n- 渐进增强和优雅降级\n- CSS Hack：比如 `*color: yellow; /* IE6,IE7 */`\n- 单位兼容性：使用 `px` , 有可能 `rem/vw/vh` 不支持\n","bd1b0823089551deac82946f00f7f000":"\n# 说说回流和重绘\n\n\n`#2024/07/30`  `#前端/CSS`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 先看定义 \n\n- `回流（或重排）`：布局引擎会根据各种样式计算每个盒子在页面上的`大小与位置`\n   - 重排（也称为回流）是浏览器重新计算页面中`**元素位置和几何形状**`的过程\n- `重绘`：当计算好盒模型的`位置、大小及其他属性`后，浏览器根据每个盒子特性进行绘制\n- `重绘`不一定导致`重排`，但`重排`一定会导致`重绘`  ，如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/0e89990a6d49095e5a717c3af1edeb53.png)\n\n## 2. 导致`回流`的场景\n\n- 页面`首次渲染`\n- 浏览器`窗口大小`发生改变\n- 元素`尺寸或位置`发生改变\n- 元素内容变化（`文字数量`或`图片大小`等等）\n- 元素`字体大小`变化\n- `添加或者删除`可见的DOM元素\n- 激活CSS伪类（例如：`:hover`）\n- `calc()` 本身不会引起 `回流`，但是因为需要重新计算布局的属性，比如父元素的宽度改变了，那必然会导致子元素的一个 `回流`\n- `查询某些属性`或`调用某些方法`\n   - `dom.style.width/height` ，只能取`行内样式的宽和高`，`style` 中 `link` 外链取不到。可写，修改时会导致`重排`\n   - `window.getComputedStyle(dom).width/height`，指定`第二参数`指定一个要匹配的伪元素的字符串。必须对普通元素省略（`或null`） ，\n      - 读取的样式是`最终样式`，包括了内联样式、嵌入样式和外部样式\n      - 比如`getComputedStyle(h3, '::after').content` \n      - 会导致`回流` 因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），为求一个`“即时性”`和`“准确性”`。\n   - `dom.getBoundingClientRect().width/height 、top/left/right/bottom`  得到`渲染后的宽和高`，及`相对于视窗的上下左右`的距离\n   - 获取`布局信息`时，会导致`重排`。相关的方法属性如 `offsetTop`   `getComputedStyle` 等\n   - `scrollIntoView()`、`scrollIntoViewIfNeeded()` 、 `scrollTo()` 滚动时，会导致`重排`\n\n>  总之， `查询某些属性`或`调用某些方法` 是否会导致重排，关键需要看  `只读了` ，还是有`写入`操作\n\n>  另外一些容易被忽略的操作：如 getComputedStyle，  offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 这些属性有一个共性，就是需要通过`**即时计算**`得到。因此浏览器为了获取这些值，也会进行`回流`\n\n## 3. opacity、display 和 visibility\n\n- 修改 `opacity` 和 `visibility` 属性通常只会触发`重绘`，而不会触发`回流`\n- 而修改 `display` 属性则可能会触发`回流和重绘`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/d416ea83c9a78c5f5445f7568c9de8ba.png)\n\n> - `**opacity**`** 为 0 ，可以点击**\n> - visibility 为 hidden时，不能点击\n\n## 4. 修改  `left` 和 `right` 的影响\n\n### 4.1. 对于绝对定位 (`position: absolute`) 和 固定定位 (`position: fixed`)的元素\n\n> [!abstract]\n>  > **结论： 对于脱离文档流的元素：一般不会引起文档流的重排，但会导致该元素的重绘。**\n\n- 这些元素脱离正常文档流，它们的布局不再影响和被其他元素影响\n- 对于脱离文档流的元素（如`position: absolute`或`position: fixed`），修改`left`和`right`属性通常直接影响该元素本身的位置，而不会影响到其他元素的布局，因此**不会引起整体布局的重排**。\n- 然而，依然会 **导致该元素的重绘（repaint），但不涉及到重排（reflow）**\n\n### 4.2. 对于对于未脱离文档流的元素（如`position: relative`）\n\n- 可能会导致该元素及其子元素的重排\n- 元素本身改变了，自然有可能导致整个文档的重排\n\n### 4.3. 对于 `position: sticky` 的元素\n\n#### 4.3.1. `position: sticky` 的特性\n\n- 当元素在容器视口内时，它表现为相对定位（`relative`）。\n- 一旦元素滚动到指定偏移位置，它就表现为固定定位（`fixed`），即相对于视口定位。\n\n#### 4.3.2. 相对定位阶段（在容器视口内）\n\n- 元素还未达到指定的偏移位置，此时与普通的`**相对定位**`元素非常相似。\n- 修改 `left` 和 `right` 会影响元素的位置，因此可能会引发重排（reflow）。\n\n#### 4.3.3. 固定定位阶段（到达偏移位置）\n\n- 元素达到偏移位置，变为相对视口定位。\n- 修改 `left` 和 `right` 的行为更像是**固定定位**，通常不影响其他元素的布局。\n- 这种情况下，可能只会导致重绘（repaint），不会引发重排。\n\n### 4.4. 总结\n\n- 对于已经脱离文档流的元素（如 position: absolute 或 fixed），仅修改 left 和 right 的值通常不会导致其他元素的回流，但可能会导致该元素本身的重绘。\n- 对于` position: relative` 来说，会导致\n\n## 5. 一些优化建议\n\n### 5.1. `transform` 代替 `top/left` \n\n### 5.2. 避免使用`CSS表达式`（如：`calc()`）\n\n### 5.3. 批量修改 DOM\n\n```javascript\nconst fragment = document.createDocumentFragment();\nfor (let i = 0; i < 10; i++) {\n  const li = document.createElement('li');\n  li.textContent = `Item ${i}`;\n  fragment.appendChild(li);\n}\ndocument.getElementById('myList').appendChild(fragment);\n```\n\n   - 使用文档片段(DocumentFragment)或者先将元素设为不可见，进行多次修改后再显示。\n\n### 5.4. 避免频繁操作样式\n\n```javascript\n// 不推荐\nconst el = document.getElementById('myElement');\nel.style.borderLeft = '1px';\nel.style.borderRight = '2px';\nel.style.padding = '5px';\n\n// 推荐\nel.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';\n// 或者\nel.classList.add('my-class');\n```\n\n- 合并多次样式修改，一次性修改。\n- 使用类名替代多次样式修改。\n- `classList.add/remove/toggle` 来切换样式，而不是直接修改` style 属性`\n\n### 5.5. 缓存布局信息：批量修改\n\n```javascript\n// 不推荐\nfor (let i = 0; i < 100; i++) {\n  element.style.left = `${element.offsetLeft + 1}px`;\n}\n\n// 推荐\nlet left = element.offsetLeft;\nfor (let i = 0; i < 100; i++) {\n  left++;\n  element.style.left = `${left}px`;\n}\n```\n\n- 避免多次读取会引发重排的属性。\n\n### 5.6. 使用绝对定位使元素脱离文档流\n\n- 对于频繁重排的元素，可以使用绝对定位使其脱离文档流。\n- `position: absolute、fixed `  脱离文档流，以避免对其他元素布局的影响。\n\n### 5.7. 优化动画\n\n```javascript\nfunction animate() {\n  // 动画逻辑\n  requestAnimationFrame(animate);\n}\nrequestAnimationFrame(animate);\n```\n\n- 使用 `requestAnimationFrame` 来控制动画。\n- 使用 CSS3 动画和 `transforms` 替代 JavaScript 动画。\n\n### 5.8. 使用 CSS3 硬件加速\n\n```css\n.move {\n  transform: translateX(100px);\n}\n```\n\n使用 transform、opacity、filters 等属性，触发 GPU 加速。\n\n使用`css3硬件加速`，`可以让transform`、`opacity`、`filters` 这些动画不会引起`回流重绘`\n\n### 5.9. 避免使用 `table` 布局\n\n- 表格布局可能导致多次重排。\n\n### 5.10. 降低 CSS 选择器的复杂性\n\n复杂的选择器会增加样式计算时间。\n\n### 5.11. 离线操作：使用 `display: none` 进行大量 DOM 操作\n\n```javascript\nconst el = document.getElementById('myElement');\nel.style.display = 'none';\n// 进行大量 DOM 操作\nel.style.display = 'block';\n```\n> 当元素设为 `display: none` 时，对其进行的操作不会引发重排和重绘。\n\n### 5.12. 使用虚拟 DOM\n\n- 像 React、Vue 这样的框架使用虚拟 DOM 来优化实际 DOM 操作。\n\n### 5.13. 使用防抖(Debounce)和节流(Throttle)\n\n对于频繁触发的事件（如滚动、调整窗口大小等），使用这些技术来限制处理函数的执行频率。\n\n### 5.14. 分离读写操作\n\n```javascript\n// 不推荐\nconst h1 = element1.clientHeight;\nelement1.style.height = `${h1 * 2}px`;\nconst h2 = element2.clientHeight;\nelement2.style.height = `${h2 * 2}px`;\n\n// 推荐\nconst h1 = element1.clientHeight;\nconst h2 = element2.clientHeight;\nelement1.style.height = `${h1 * 2}px`;\nelement2.style.height = `${h2 * 2}px`;\n```\n\n先进行所有的读操作，然后再进行写操作，避免读写交叉导致多次重排。\n\n> 在实际应用中，应根据具体情况选择合适的优化方法。\n\n","fb54a82478835b018bfc3c1a56734a25":"\n# CSS  开启 GPU 硬件加速的原理\n\n\n`#前端/CSS`  `#2024/07/30` \n\n\n## 目录\n<!-- toc -->\n ## 1. 原理 \n\n### 1.1. 核心原理\n\nGPU 硬件加速的`核心原理`在于将特定的渲染任务从 CPU 移交给 GPU 进行处理。GPU 擅长处理大规模的并行任务，这对于动画、变换和其他复杂的视觉效果来说尤其有效。通过 GPU 硬件加速，可以大幅提升这些任务的执行效率和渲染速度。\n\n### 1.2. 从浏览器的渲染过程分析原理\n\nCSS 开启 GPU 硬件加速的原理主要涉及浏览器的渲染过程和`图层（Layer`）的概念。让我们深入了解这个过程：\n\n浏览器渲染页面通常遵循以下步骤：\n\n- 解析 HTML 构建 DOM 树\n- 解析 CSS 构建 CSSOM 树\n- 将 DOM 和 CSSOM 合并成渲染树\n- 布局（Layout）：计算元素的位置和大小\n- 绘制（Paint）：将元素绘制到屏幕上\n- 合成（Composite）：将`不同的图层`合并到一起\n\n#### 1.2.1. 图层（Layer） \n\n**浏览器会将页面分成多个图层**。默认情况下，普通元素都在同一个图层中。但某些`特定的 CSS 属性`可以让元素提升为单独的图层。\n\n当一个元素被提升为单独的`图层`时，它的渲染会被委托给 GPU 处理。GPU 擅长处理纹理和图形，能够高效地处理图层的变换、缩放、旋转等操作。这样就能够 `**GPU 硬件加速**`\n\n#### 1.2.2. 以 `transform: translate3d(0,0,0)` 为例\n\n- 这个看似无用的 3D 变换会强制浏览器为该元素创建一个`新的图层`。\n- 新图层会被送到 GPU 处理。\n- GPU 可以高效地处理这个图层的后续变换，`无需重新布局或重绘`整个页面。\n\n#### 1.2.3. 内部工作机制\n\n- 当元素被提升为独立图层后，它会被存储为纹理在 GPU 中。\n- GPU 可以直接操作这个纹理，进行位置移动、缩放、旋转等操作，无需 CPU 参与\n- 这大大减少了 CPU 的工作负担，提高了动画的流畅度。\n\n## 2. CSS 触发 GPU 加速的属性\n\n以下是一些可以触发 GPU 硬件加速的 CSS 属性，告诉浏览器在最开始就把`**该元素放到新图层渲染**`。\n\n### 2.1. transform\n\n应用二维或三维变换，如 `transform: translate3d(0, 0, 0);`\n\n> 注意：其实`二维`也行\n\n### 2.2. opacity：改变元素的透明度\n\n### 2.3. filter：应用图像处理效果\n\n`filter` 属性用于应用各种图形处理效果（例如模糊、亮度、对比度等），这些效果通常也会使用 GPU 加速来提高性能。\n```css\n.element {\n  filter: blur(5px);\n}\n```\n\n### 2.4. will-change\n\n显式声明某些属性将发生变化，从而让浏览器提前优化这些元素\n\n### 2.5. CSS 动画和过渡（`transition` 或 `animation`）\n\n`will-change` 属性让开发者可以显式地告诉浏览器哪些属性将会变化，从而让浏览器提前优化这些元素。\n```css\n.element {\n  will-change: transform, opacity;\n}\n```\n\n## 3. 优势\n\n- 减少重绘：图层的变化不会影响其他图层，减少了不必要的`重绘`。\n- 提高性能：GPU 并行处理能力强，适合处理图形任务。\n- 流畅动画：减少了 CPU 的参与，使动画更加流畅。\n\n## 4. 注意事项\n\n- 过度使用可能导致内存占用增加。\n- 不是所有设备都有强大的 GPU，过度依赖可能在低端设备上适得其反。\n- 不同浏览器的实现可能有差异。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/61f5c262db0860b921ca61e0479d99d2.png)\n\n","545434ac824d50e5a957fe6f9dffab26":"\n# 说一说盒模型\n\n\n`#前端/CSS`  `#2024/07/30` \n\n\n## 目录\n<!-- toc -->\n ## 1. 标准盒模型 和 IE 盒模型 \n\n- 标准盒模型：`width = content`\n- IE 盒模型：`width = border + padding + content`\n\n如下图所示：\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3193f0e277d0e85d83a2451b624006f3.png)\n\n## 2. box-sizing 可以设置装两种模型\n\n如下图：\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3514efe3929b598730be168652a3e627.png)\n\n","9f7eeaa2b8355cd8b7a0c2150c43439f":"\n# 说说 BFC 与外边距重叠\n\n\n`#前端/CSS`  `#2024/07/30` \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n`BFC（Block Formatting Context，块级格式化上下文）`是 CSS 中一个重要的概念，它是页面布局中的一个独立渲染区域，决定了元素如何定位及与其他元素之间的关系。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/54562a17d3dbd31f0f89a9e125bfe2c3.png)\n\n## 2. BFC 的特性\n\n1. **内部的盒子会在垂直方向，一个接一个地放置。**\n2. **盒子垂直方向上的距离由 **`margin`** 决定。相邻块级元素的外边距会发生折叠。**\n3. **BFC 的区域不会与浮动元素的盒子重叠。**\n4. **BFC 是一个隔离的独立容器，容器内部的元素不会影响外部的元素。**\n\n## 3. 创建 BFC 的方式\n\n以下 CSS 属性会触发创建 BFC：\n\n1. 设置 `float` 不为 `none` 的元素；\n2. 设置 `position` 为 `absolute` 或 `fixed` 的元素；\n3. 设置 `display` 为 `inline-block`, `table-cell`, `table-caption`, `flex`, 或 `grid` 的元素；\n4. 设置 `overflow` 不为 `visible` 的元素。\n\n示例：\n```css\n.bfc {\n  overflow: hidden;  /* 触发 BFC */\n}\n```\n\n## 4. 外边距重叠（Margin Collapsing）\n\n外边距重叠是指`**当两个上下相邻的块级元素的垂直外边距相遇时，它们会合并为一个外边距**`，其高度为最大的那个外边距值，而不是两者之和。\n\n### 4.1. 兄弟元素的边界重叠 &  父子元素的边界重叠\n\n![A792D720-3B01-4A74-B5BD-7DC9028EFE9D.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e34a6a6d31a5c93b4d342ec4a57f596b.png)\n\n### 4.2. 外边距重叠的规则\n\n- 同正，较大值 \n- 同负，绝对值最大值\n- 一正一负：相加\n\n## 5. 使用 BFC 防止外边距重叠\n\n- 解决方案：即去触发`BFC`即可，如`BFC` 不会与 `float` 元素发生重叠。\n\n![240B4A71-C78E-47B2-A432-BF18ACC1134C.png|428](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/c4f97a2d27026987eb2967c1a6d48207.png)\n\n![E87FF6E8-F4A6-458C-B71C-9D230BAC5BB1.png|484](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ff8df8522e39084cec5d64669309ac23.png)\n\n","fd0c4431d13f5a828235dbfd3898a17a":"\n# CSS 布局都有了哪些？\n\n\n`#前端/CSS`  `#2024/07/30` \n\n- CSS Grid Layout：二维布局系统\n- CSS Flexbox：维布局模型\n- 多列布局：column-count、column-gap 等\n- 浮动布局：不展开了，不建议使用了\n","2b0b7f8b0e735a6d840766a33d1d4bda":"\n# CSS 定位或布局相关的参考坐标系都有哪些？\n\n\n`#前端/CSS`  `#2024/07/30` \n\n![image.png|480](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/c792c133990e2818a06482c7117b141c.png)\n\n> 这里可以对应 JS 获取某个元素的各种位置信息：比如 clientX pageX 、width 、offesetLeft 等等等等\n> \n\nCSS 中的“参考坐标系”或“参考系”是指为定位、对齐或变换 CSS 元素而使用的坐标系。理解不同的参考系对于掌握 CSS 布局和定位非常重要。以下是一些常见的参考坐标系及其使用方法：\n\n\n## 目录\n<!-- toc -->\n ## 1. **文档坐标系** \n\n文档坐标系是整个 HTML 文档的坐标系，所有位置和尺寸都是相对于文档的起点（通常是左上角）来指定的。\n\n- **元素的宽度和高度**：以整个文档为参考系。\n- **滚动位置**：以整个文档为基准的滚动。\n\n> - `块级元素`独占一行,`内联元素`在一行内排列\n\n## 2. **视口坐标系**\n\n视口坐标系是指`浏览器窗口或视口`的坐标系。\n\n- **百分比宽度和高度**：如`width: 100vw`表示宽度为 100% 视口宽度。\n- **固定定位**：`position: fixed;` 会以视口为参考系来定位元素。\n\n## 3. **包含块（Containing Block）**\n\n`包含块`是一个元素在正常流或其他指定布局上下文中的直接父块或祖先块，用于确定其坐标和大小。\n\n- **相对定位**：`position: relative;` 会以包含块为参考来定位元素。\n- **绝对定位**：`position: absolute;` 会以最近的非静态定位的祖先元素（包含块）为参考。\n\n## 4. **边框框（Border Box）**\n\n边框框是包含元素的内容、内边距和边框的区域。\n\n- **盒模型**：用于计算元素的总计宽度和高度。\n\n## 5. **内边距框（Padding Box）**\n\n内边距框是包含元素内容和内边距的区域。\n\n- **背景和边框**：默认情况下，`**背景和边框**`会扩展到内边距框之外。\n\n## 6. **内容框（Content Box）**\n\n内容框是仅包含元素内容的区域，不包括内边距、边框和外边距。\n\n- **内容尺寸**：通过`box-sizing`属性可以设置为以`**内容框或边框框**`来计算元素尺寸（默认是`content-box`）。\n\n## 7. **变换参考系（Transform Reference）**\n\n当你对元素应用 CSS 变换（比如`transform`属性）时，使用的是变换参考系。\n\n- **变换中心点**：默认情况下，**变换中心点为元素的中心**。\n- 创建一个新的坐标系,不影响其他元素\n- 变换后的元素成为其子元素的`包含块`\n\n```css\n.transform {  \n  transform: rotate(45deg) translateX(100px);  \n}\n```\n\n## 8. 表格布局\n\n- display: `table 和 table-cell`\n- 模拟表格的布局结构\n\n## 9. Flex 布局、 Grid 布局、CSS 多列布局（Multi-Column Layout）\n\n这些布局模型创建了自己的坐标系:\n\n- Flexbox 坐标系: 主轴(main axis)和交叉轴(cross axis)\n- Grid 坐标系:  行和列定义的`网格坐标系`\n- Multi-Column Layout：用于将文本分为多列\n\n## 10. 示例\n\n下面示例展示了几种不同的坐标系的使用：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CSS Reference Coordinate Systems</title>\n\n    <style>\n        .relative-container {\n            position: relative;\n            width: 300px;\n            height: 300px;\n            background-color: lightgray;\n            margin: 50px; /* 文档坐标系 */\n        }\n\n        .relative-child {\n            position: absolute;\n            top: 10px; /* 包含块参考系 */\n            left: 10px;\n            width: 100px;\n            height: 100px;\n            background-color: lightcoral;\n        }\n\n        .fixed-element {\n            position: fixed;\n            top: 20px; /* 视口坐标系 */\n            right: 20px;\n            width: 100px;\n            height: 100px;\n            background-color: lightblue;\n        }\n\n        .transform-element {\n            width: 100px;\n            height: 100px;\n            background-color: lightgreen;\n            margin: 50px;\n            transform: rotate(45deg); /* 变换参考系 */\n        }\n    </style>\n\n</head>\n\n<body>\n    <div class=\"fixed-element\">Fixed</div>\n\n    <div class=\"relative-container\">\n        <div class=\"relative-child\">Absolute</div>\n\n    </div>\n\n    <div class=\"transform-element\">Transform</div>\n\n</body>\n\n</html>\n\n```\n\n## 11. 关键点\n\n1. **文档坐标系**：用于整体文档的布局和滚动。\n2. **视口坐标系**：用于固定定位和视口相对尺寸。\n3. **包含块**：用于`相对和绝对`定位。\n4. **边框框、内边距框和内容框**：用于`盒模型`计算。\n5. **变换参考系**：用于应用 CSS 变换。\n\n这些参考坐标系在实际布局和定位中常常结合使用，因此理解它们如何协同工作是掌握 CSS 布局的关键。\n\n","bd4811c6285b56dbb3c419022b8bc7e4":"\n# JavaScript 引擎\n\n引擎很复杂，但是基本原理很简单。\n\n1. 引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。\n2. 然后，引擎将脚本转化（“编译”）为机器语言。\n3. 然后，机器代码快速地执行\n\n\nJavaScript 引擎是用于解释和执行 JavaScript 代码的程序。它们最常见于网页浏览器中，但也用于许多其他环境。主要的 JavaScript 引擎包括：\n\n1. **V8 (谷歌)**:\n   - 开发者：谷歌\n   - 用于：Chrome 浏览器、Node.js 等\n   - 特色：使用`即时编译`（JIT，Just-In-Time compilation），将 JavaScript 代码即时编译成与机器码，以提高执行效率。\n2. **SpiderMonkey (Mozilla)**:\n   - 开发者：Mozilla\n   - 用于：Firefox 浏览器\n   - 特色：是第一个 JavaScript 引擎，支持解释和编译两种模式，使用多层优化编译器。\n3. **Chakra (微软)**:\n   - 开发者：微软\n   - 用于：曾用于 Internet Explorer 和 Microsoft Edge (旧版，EdgeHTML)\n   - 特色：拥有一个强大的 JIT 编译器，支持优化的执行和垃圾回收。\n4. **JavaScriptCore (苹果)**:\n   - 开发者：苹果\n   - 用于：Safari 浏览器\n   - 特色：也被称为 Nitro，注重内存管理和执行性能。\n\n\n## 目录\n<!-- toc -->\n ## # JavaScript 引擎的组成部分 \n\n1. **解析器 (Parser)**:\n   - 将源代码转换成抽象语法树 (AST，Abstract Syntax Tree)。\n   - 分析代码结构，保证语法正确。\n2. **解释器 (Interpreter)**:\n   - 逐行解释和执行 JavaScript 代码，使用 AST 生成中间代码。\n3. **编译器 (Compiler)**:\n   - JIT 编译器会在运行时将`频繁执行的代码`编译成机器码，以更快地执行。\n4. **运行时 (Runtime)**:\n   - 提供内置函数、内存管理（如垃圾回收）和执行环境。\n\n### 运行机制\n\n1. **解析和编译**\n   - 代码首先被解析器解析为 AST，然后 JIT 编译器将部分 AST 编译成机器码。当运行过程中发现某些代码片段被频繁调用，编译器会进一步优化这些片段。\n2. **执行**\n   - 执行引擎会根据编译后的代码直接运行机器码，从而提高性能。\n3. **垃圾回收 (Garbage Collection)**\n   - JavaScript 引擎会自动管理内存，自动回收不再使用的对象和变量。这通常是通过垃圾回收器实现的，常见的算法包括标记-清除 (mark-and-sweep)、引用计数 (reference counting) 等。\n\n### 性能优化\n\n1. **即时编译 (Just-In-Time Compilation, JIT)**\n   - 使用 JIT 编译器，代码在运行时被动态编译，避免了解释代码的开销。\n2. **内联缓存 (Inline Caching)**\n   - 用于加速属性查找和方法调用频繁的对象。\n3. **惰性解析 (Lazy Parsing)**\n   - 只在真正需要时解析 JavaScript 代码，提高初始加载性能。\n4. **垃圾回收优化**\n   - 通过分代垃圾回收、增量垃圾回收等技术，提高内存管理效率。\n\n总的来说，JavaScript 引擎通过多种技术和优化策略，极大地提升了 JavaScript 代码的运行效率和性能。这也是现代网页和应用程序复杂度和功能性得以提升的重要因素之一。\n\n\n\n\n\n# 参考\n\n- [https://zh.javascript.info/intro](https://zh.javascript.info/intro)\n- [https://kangax.github.io/compat-table](https://kangax.github.io/compat-table) ：一份列有语言功能以及引擎是否支持这些功能的表格。\n","91720bc07a045f83a89c6160b86e8c72":"\n# JavaScript 的垃圾回收机制\n\nJavaScript 的垃圾回收机制主要通过自动内存管理来处理不再使用的对象和变量，以释放内存资源。最常用的垃圾回收算法是 **标记-清除 (Mark-and-Sweep)**。以下是主要特点和步骤：\n\n\n## 目录\n<!-- toc -->\n ## # 标记-清除算法 \n\n1. **标记阶段 (Marking Phase)**:\n   - 从根对象（例如全局对象、局部变量等）开始，标记所有可达的对象，即有引用的对象。\n2. **清除阶段 (Sweeping Phase)**:\n   - 遍历内存，将未被标记的对象视为垃圾，并将其内存释放。\n\n### 其他优化策略\n\n1. **分代垃圾回收 (Generational Garbage Collection)**:\n   - 将内存分为两代：新生代和老生代。\n   - 新生代对象生命周期短，频繁回收；老生代对象生命周期长，较少回收。\n2. **增量垃圾回收 (Incremental Garbage Collection)**:\n   - 将标记和清除过程分成多个小步进行，以避免长时间停顿。\n3. **惰性垃圾回收 (Lazy Garbage Collection)**:\n   - 当系统空闲时才进行垃圾回收，减少对应用程序性能的影响。\n\n### 垃圾回收触发条件\n\n- 内存使用达到一定阈值。\n- 系统空闲时主动触发垃圾回收。\n\n### 优点\n\n- **自动内存管理**：开发者无需手动管理内存，减少内存泄漏风险。\n- **优化性能**：现代垃圾回收机制通过多种优化策略，降低了对应用性能的影响。\n\n### 缺点\n\n- **不可控性**：垃圾回收时机和频率由引擎管理，开发者无法完全控制。\n- **潜在的性能影响**：尽管有多种优化策略，但垃圾回收仍可能在高负载应用中引入停顿。\n\n总的来说，JavaScript 的垃圾回收机制通过自动化和优化的内存管理，提供了便捷的开发体验，同时通过多种算法和策略提高了效率和性能。\n","0034af677b1d53b5974c2f6a251aa69d":"\n# JavaScript 的核心语法\n\n\n# 现代模式，\"use strict\"\n\n\n## 目录\n<!-- toc -->\n ## 原因 \nES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— `\"use strict\"` 来明确地激活这些特性。\n\n\n## 语法\n```javascript\n\"use strict\"; // 必须放到开头\n\n// 代码以现代模式工作\n...\n```\n\n- 现代 JavaScript 支持 “class” 和 “module”，如果使用它们，无需添加  `\"use strict\"`\n\n\n# 6 种原始类型 + 1 种复杂数据类型\t\t\t\n\n- 原始类型：Undefined、Null、Boolean、Number、String 和 Symbol  \n- 复杂类型：Object\n\n\n# 变量、作用域与内存\n\n## 复制\n\n### 原始类型\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e3768b3af18a23c8cdeccb85e280c323.png)\n\n### 引用类型\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/bb555ee9faabf851d1d0d40946117804.png)\n\n\n## let、var、const 申明选择建议\n\n1. 不使用 var\n2. const 优先，let 次之\n> `var`就不解释了，`const` 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作\n\n\n\n","a65f5635589b540bbcf5017dbeefc26a":"\n# JavaScript 的组成\n\n\n# Javascript 的组成\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/a9104fded4d48d2d613eecce29dc3a26.png)\n\n- ECMAScript：由 ECMA-262 定义并提供核心功能\n- 文档对象模型(DOM)：提供与`网页内容`交互的方法和接口\n- 浏览器对象模型(BOM)：提供与`浏览器`交互的方法和接口\n\n> - ECMA-262：ECMA-262 是由欧洲计算机制造商协会（ECMA）发布的一项标准，正式名称为“ECMAScript 语言规范” \n>    - 至于 262 没有什么特别的含义，就是一个代号\n> - TC39 委员会：ECMA-262 由 TC39（ECMAScript 技术委员会）负责制定和维护，该委员会由来自各大科技公司的专家组成，定期讨论和推进 ECMAScript 标准的演进。\n> - 最新的规范草案请见 [https://tc39.es/ecma262/](https://tc39.es/ecma262/)\n\n\n# Javascript 为何有如此“地位”\n\n- 与 HTML/CSS 完全集成\n- 所有的主流浏览器支持\n\n# 浏览器上的 Javascript 能做什么 和 不能做什么？\n\n- JavaScript 的能力很大程度上取决于它`**运行的环境**`。\n   - 例如，[Node.js](https://wikipedia.org/wiki/Node.js) 支持允许 JavaScript 读取/写入任意文件，执行网络请求等的函数\n   - 浏览器上的 Javascript 的能力都是浏览器提供的\n   - app  webview 上 JavaScript 的能力都是`嵌入的 APP` 提供的\n      - 比如 `webview` 组件提供了很多配置项，用于是否开启一些能力\n\n\n\n## 目录\n<!-- toc -->\n ## 能做什么 \n\n- DOM：操作 HTML 及 CSS\n- BOM：操作浏览器提供的各类 API\n- 请求资源：访问资源、上传、下载资源\n- 本地存储：cookie、localstarage 、sessionstrage 等\n\n## 不能做什么\n\n- 浏览器端读、写文件，但可以通过 `input type=file` 选择文件\n- 直接访问原生系统的一些能力，比如调取摄像头、麦克风等\n- 不能在随意在不同窗口间通信，需要一些限制，比如同域\n\n\n# JS 的超级们\n\n- [CoffeeScript](https://coffeescript.org/) ，现在基本不用了\n- [TypeScript](https://www.typescriptlang.org/) ，添加了严格的数据类型校验，后面会详细说它。微软出品。\n- [Flow](https://flow.org/) 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。\n- [Dart](https://www.dartlang.org/)  `Flutter` 使有语言，它也可以被编译成 JavaScript，由 Google 开发。\n- [Brython](https://brython.info/)  Python 到 JavaScript 的转译器\n- [Kotlin](https://kotlinlang.org/docs/reference/js-overview.html) 是一个现代、简洁且安全的编程语言，编写出的应用程序可以在浏览器和 Node 环境中运行。\n","1607f731aeb957ea8ab026b4a579ac25":"\n# JavaScript 简介\n\n\nJavaScript 是一种高层次的、解释型的编程语言。它在当今的信息技术领域中扮演着重要角色，尤其在Web开发方面。以下是关于JavaScript的全面介绍：\n\n# JavaScript 的基本概念\n\n\n## 目录\n<!-- toc -->\n ## # 1. 定义 \n\n- **JavaScript** 是一种符合 ECMAScript 规范的高级编程语言。\n- 最初设计的目的是增强 HTML 网页的动态行为和交互能力。\n\n### 2. 历史\n\n- **诞生**：由 Brendan Eich 在 1995 年开发，并首次应用于 Netscape Navigator 浏览器。\n- **标准化**：ECMAScript 是由 ECMA International 管理的 JavaScript 标准化规范，ECMAScript 31999 年）和 ECMAScript 5（2009 年）是重要的里程碑。\n- **现代化**：ECMAScript 6（2015 年），又称 ES6 或 ES2015，引入了许多新特性类，模块，箭头函数等。\n\n# JavaScript 的核心特性\n\n### 1. 动态类型\n\n- JavaScript 是动态类型语言，变量可以在运行时改变类型。\n\n### 2. 解释执行\n\n- JavaScript解释型语言，不需要编译，直接在浏览器或 JS 引擎中解释执行。\n\n### 3. 弱类型\n\n- 支持隐式类型转换，可以灵活使用不同的数据类型。\n\n### 4. 单线程\n\n- JavaScript 本上是单线程的，但通过事件循环机制可以处理异步任务。\n\n### 5. 跨平台\n\n- JavaScript 可以在多种环境下运行，最常见的是浏览器环境和 Node.js 环境。\n\n# JavaScript 的应用场景\n\n## Web前端开发\n\n- **DOM操作**：控制和操作网页内容。\n- **事件处理**：响应用户操作（如点击、输入）。\n- **AJAX**：实现异步数据请求和更新。\n- **动态样式**：通过操作 CSS 打造动态效果。\n\n## 服务端开发\n\n- **Node.js**：基于 Chrome V8 引擎构建，支持服务器端开发。\n- **Express、Koa**：常用的服务器框。\n- **数据库操作**：如与 MongoDB、MySQL 的交互。\n\n## 全栈开发\n\n- **MEAN/MERN 栈**：MongoDB, Express, Angular/React, Node.js。\n- 基于 React 和 Vue.js 的服务端渲染框架: Next.js 和 Nuxt.js。\n\n## 移动应用开发\n\n- **React Native**：使用 JavaScript 构建原生移动应用。\n- **Ionic、PhoneGap/Cordova**：建跨平台移动应用。\n\n## 桌面应用开发\n\n- **Electron、NW.js**：使用 Web 技术构建跨平台桌面应用。\n\n## 游戏开发\n\n- **Three.js**：创建3D图形动画。\n- **Phaser**：2D游戏框架。\n\n## 数据可视化\n\n- **D3.js、Chart.js、Highcharts**：用于高级数据可视化和图表创建。\n\n## 机器学习人工智能\n\n- **TensorFlow.js、Brain.js**：让机器学习和神经网络在浏览器中运行。\n\n## 物联网 (IoT)\n\n- **Johnny-Five、Espruino**：用于智能设备和嵌式开发。\n\n## 自动化和脚本\n\n- **Gulp、Grunt**：任务自动化工具。\n- **ShellJS**：执行系统命令和脚本编写。\n\n# JavaScript 的重要概念和机制\n\n### 1. 原型和原型链\n\n- JavaScript 使用原型继承，即对象之间通过原型链形成继承关系。\n\n### 2. 闭包\n\n- 闭包是一个函数能记住并访问它的词法域，即使在函数在其词法作用域外执行。\n\n### 3. 事件循环\n\n- 事件循环是 JavaScript 处理异步操作的机制，检测调用栈是否为空，并从任务队列中取任务执行。\n\n### 4、异步编程\n\n- **回调函数**：基本的异步处理方式，但会导致“回调地狱”。\n- **Promise**：链式解决异步调用，避免回调地狱。\n- **async/await**：于 Promise 的语法糖，让异步代码看起来像同步代码。\n\n### 5. this 关键字\n\n- `this` 在不同的上下文中有不同的指向。\n- 比如，函数调用中的 `this` 指向局对象，用 `new` 调用构造函数时，`this` 指向新创建的对象。\n\n### 6. 模块化\n\n- ES6 提供了原生的模块化支持 (`import` 和 `export`)。\n- 之前解决方案包括 CommonJS (Node.js 使用的模块系统) 和 AMD (异步模块定义)。\n\n# JavaScript 的生态系统\n\n- **库和框架**：如 React、Vue.js、Angular、jQuery 等。\n- **包管理**：npm (Node Package Manager)、Yarn 等。\n- **构建工具**：Webpack、Parcel、Gulp、Grunt 等。\n- **测试工具**：Jest、Mocha、Chai、Cypress 等。\n- **版本控制：Babel，支持将新的 JavaScript 语法转换为旧的语法，以便在不支持的环境中运行。\n\n# JavaScript 的局限性\n\n- 单线程模型在进行 CPU 密集型任务时效率较低。\n 隐式类型转换可能导致一些预期之外的行为。\n- 动态类型系统可能在大型项目中引入类型相关的缺陷。\n\n\nJavaScript 是一门功能强大且灵活的语言，广泛应用于各种开发场景中理解其核心原理和生态系统有助于开发者更好地利用它的潜力。\n","8d0815b9ae095a4e84f455f164451ed9":"\n# JavaScript 篇\n\nJavaScript 相关的知识点\n\n","8c7c513d03805f34a37ca4ecbbd79c15":"\n# Typescript 篇\n\n\n\n## 目录\n<!-- toc -->\n ## 一、编译 \n可通过 `tsconfig.json` 来指定哪些文件编译等编译选项，如\n```json\n{\n  \"files\": [\n    \"./some/file.ts\"\n  ],\n  \"include\": [\n    \"./folder\"\n  ],\n  \"exclude\": [\n    \"./folder/**/*.spec.ts\",\n    \"./folder/someSubFolder\"\n  ]\n}\n```\n>  playground： [http://www.typescriptlang.org/play/](http://www.typescriptlang.org/play/) \n\n可运行 `ts` 的编译工具\n1、TypeScript 官方提供的编译器叫做 `tsc` \n2、**ts-node**\n```bash\nnpx ts-node script.ts\n\n# 或者\nts-node script.ts\n```\n\n## 二、声明空间\n在 TypeScript 里存在两种声明空间：`类型声明空间`与`变量声明空间`\n\n### （一）类型声明空间\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/76e5d299da3f92d03fa51b2e9528079d.png)\n\n即 `interface B{}`  只是一个`类型申明`，不能当做变量使用\n>  看上图，`b1` 和 `c1` 都飘红警告了\n\n### （二）变量声明空间\n```javascript\n/**\n * ① Class Foo 提供了一个类型 Foo 到类型声明空间\n * ② 把一个类来当做变量传递时，ts 会把这个类当做值来处理\n * */\nclass Foo {\n}\n\nconst someVar: Foo = Foo;\n\n\n/**\n * ① 一些用 var 声明的变量，也只能在变量声明空间使用，不能用作类型注解，如下示例\n */\nconst foo = 123;\nlet bar: foo; \n// ts2749: 'foo' refers to a value, but is being used as a type here. Did you mean 'typeof foo'?\n\n```\n\n### （三）总结\n**总结就是：**\n\n1. `变量声明空间`可以直接当做变量赋值使用，但如`const foo = 123;` 中的 `foo`不能当做**类型注解**使用\n2. `类型声明空间` 都可以当做类型注解，但不能当做`类型注解` 使用\n\n## 三、TS 模块\n\n### （一）全局模块\n你可以在项目中创建一个 `全局声明文件 global.d.ts`，用于声明全局变量。比如全局使用的 `JQuery`\n```typescript\ndeclare var jQuery: (selector: string) => any;\n```\n>  需要使用 `declare` 关键词\n\n### （二）文件模块\n即 `文件模块系统`，耳熟能详的的 `CMD AMD ESM` 等等，这里只讨论 ESM ，而且只需要注意一下几种平时自己不常用的写法\n主要是`as` 的几个写法，如下：\n```typescript\nexport { someVar as aDifferentName };\n\nimport { someVar as aDifferentName } from './foo';\n\nimport * as foo from './foo';\n```\n\n## 四、命名空间\n使用 `namespace` 关键词，如下：\n```typescript\nnamespace Utility {\n  export function log(msg) {\n    console.log(msg);\n  }\n  export function error(msg) {\n    console.log(msg);\n  }\n}\n\n// usage\nUtility.log('Call me');\nUtility.error('maybe');\n\n```\n以上 `ts` 最终转成 `js` 的样子如下，是的，是不是很类似之前` JQuery` 的实现方式。\n```javascript\n(function (Utility) {\n  // 添加属性至 Utility\n})(Utility || Utility = {});\n\n```\n\n## 五、动态导入表达式\n其实就类似于 Webpack 的 `import()` （首选，ECMAScript 的提案）和 `require.ensure()` ，这样就能实现**代码分割能力** ，即`Code Splitting`  ，举个例子，比如我们需要懒加载 `mement`\n```typescript\nimport(/* webpackChunkName: \"momentjs\" */ 'moment')\n  .then(moment => {\n    // 懒加载的模块拥有所有的类型，并且能够按期工作\n    // 类型检查会工作，代码引用也会工作 \n    const time = moment().format();\n    console.log('TypeScript >= 2.4.0 Dynamic Import Expression:');\n    console.log(time);\n  })\n  .catch(err => {\n    console.log('Failed to load moment', err);\n  });\n```\n\n## 六、Typescript 类型系统\n\n### （一）基本类型\n即以下 8 种类型\n\n- boolean\n- string\n- number\n- bigint\n- symbol\n- object\n- undefined\n- null\n\n1、**TypeScript 继承了 JavaScript 的类型设计**，以上8种类型可以看作 TypeScript 的基本类型。\n2、`undefined` 和 `null` 既可以作为**值**，也可以作为**类型**，取决于在哪里使用它们。更多参考 【undefined】\n3、这里单独说下 `object` 根据 JavaScript 的设计，`object` 类型包含了所有对象、数组和函数。\n```typescript\nconst x:object = { foo: 123 };\nconst y:object = [1, 2, 3];\nconst z:object = (n:number) => n + 1;\n```\n\n---\n\n4、包装类型：5 种\n（1）`Symbol()`** 和 **`BigInt()`** 不能作为构造函数使用** ，即他俩无法直接获取它们的**包装对象** \n\n- boolean：`Boolean()`\n- string    `String()`\n- number   `Number()`\n- bigint  \n- symbol\n\n（2）包装对象类型与字面量类型：**大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。**\n\n- **包装对象** 和 **字面量**   ： 对应关系如下\n- Boolean 和 boolean\n- String 和 string\n- Number 和 number\n- BigInt 和 bigint\n- Symbol 和 symbol\n\n举例：\n```typescript\n\n① 即大写是小写形式的超集 \n\nconst s1:String = 'hello'; // 正确\nconst s2:String = new String('hello'); // 正确\n\nconst s3:string = 'hello'; // 正确\nconst s4:string = new String('hello'); // 报错\n\n\n② 建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象，\n\n比如，Math.abs(小写类型)\nconst n1:number = 1;\nconst n2:Number = 1;\n\nMath.abs(n1) // 1\nMath.abs(n2) // 报错\n```\n（3）`Object` 类型与 `object` 类型 \n先看 **大写的 Object** \n```typescript\n\n①  大写的Object类型代表 JavaScript 语言里面的广义对象。\n    所有可以转成对象的值，都是Object类型，这囊括了几乎所有的值\n\nlet obj:Object;\n \nobj = true;\nobj = 'hi';\nobj = 1;\nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\n\n② 事实上，除了undefined和null这两个值不能转为对象，其他任何值都可以赋值给Object类型，比如一下示例会报错\n\nlet obj:Object;\n\nobj = undefined; // 报错\nobj = null; // 报错\n\n\n③ 空对象 {} 是Object类型的简写形式，所以使用Object时常常用空对象代替，如下：\n\nlet obj:{};\n \nobj = true;\nobj = 'hi';\nobj = 1;\nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\n\n④ 显然，无所不包的Object类型既不符合直觉，也不方便使用，所以不建议使用\n\n```\n\n> [!danger]\n **无所不包的Object类型既不符合直觉，也不方便使用，所以不建议使用**\n\n再看 **小写的 object**  ,  ==只包含对象、数组和函数==， 不包括原始类型的值，比如下面代码\n```typescript\nlet obj:object;\n \nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a:number) => a + 1;\nobj = true; // 报错\nobj = 'hi'; // 报错\nobj = 1; // 报错\n```\n注意，无论是大写的Object类型，还是小写的object类型，都 **只包含 JavaScript 内置对象原生的属性和方法**，用户自定义的属性和方法都不存在于这两个类型之中。\n```typescript\n\nconst o1:Object = { foo: 0 };\nconst o2:object = { foo: 0 };\n\no1.toString() // 正确\no1.foo // 报错\n\no2.toString() // 正确\no2.foo // 报错\n\n```\n> 如下图，都报警告了，这个值得注意，即 object 其实不常用，最好直接定义 interface 类型\n>  ![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b4674d165a9a0fa7a4faf5501b8ac303.png)\n\n### （二）数组类型\n\n#### 1、基本用法\n```typescript\nlet a:boolean[]; // 同 let a:Array<boolean>;\nlet b:any[];   // 同 let b:Array<any>;\nlet arr:(number|string)[];  // 同 let arr:Array<number|string>;\n```\n\n#### 2、读取数组成员类型\nTypeScript 允许使用方括号读取数组成员的类型。如下：\n```typescript\n① 读取数组成员的类型\ntype Names = string[];\ntype Name = Names[0]; // string\n\n② 由于数组成员的索引类型都是number，所以读取成员类型也可以写成下面这样\ntype Name = Names[number]; // string\n\n③ 那么这种写法是可以的吗？\ntype Name = Names[99999]\n\n```\n\n#### 3、数组的类型推断\n为数组赋值时，TypeScript 会**自动更新类型推断**，如下：\n```typescript\nconst arr = [];\narr // 推断为 any[]\n\narr.push(123);\narr // 推断类型为 number[]\n\narr.push('abc');\narr // 推断类型为 (string|number)[]\n\n② 下面这种会推断初始值为 number 后面再赋值就会报错了\n// 推断类型为 number[]\nconst arr = [123];\n\narr.push('abc'); // 报错\n```\n\n#### 4、只读数组\n（1）`const` 命令声明的数组变量是可以改变成员的，如下：\n```typescript\nconst arr = [0, 1];\narr[0] = 2;\n```\n（2）声明只读数组，即 `readonly`, 下面示例中，`arr` 是一个只读数组，删除、修改、新增数组成员都会报错。\n```typescript\nconst arr:readonly number[] = [0, 1];\n\narr[1] = 2; // 报错\narr.push(3); // 报错\ndelete arr[0]; // 报错\n```\n（3）`number[]`其实是`readonly number[]`的子类型\n```typescript\nlet c:number[] = [0, 1];\nlet p:readonly number[] = c; // 正确\n\nc = p; // 报错\n```\n> 所以，这里有个用法就是，如果只是希望根据数组生成另外一个数组，比如过滤出数组等，就可以传入 readonly 的数组 ？ \n\n```typescript\n\n① getSum()的参数s是一个数组，传入只读数组就会报错。原因就是只读数组是数组的父类型，父类型不能替代子类型\nfunction getSum(s:number[]) {\n  // ...\n}\n\nconst arr:readonly number[] = [1, 2, 3];\n\ngetSum(arr) // 报错\n\n② 使用 类型断言 as 解决报错\n\ngetSum(arr as number[])\n```\n\n---\n\n疑惑：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9e33333a92b80383104547a2393f5fef.png)\n\n> [!danger]\n**有点和自己理解的有偏差**，把 `readonly number[]` 当做是父类，`number[]` 子类，子类继承父类，所以会多出 比如 `pop` `push` 等可改变数组的方法\n\n---\n\n（4）使得数组可读的其他方法\n```typescript\n① readonly与数组的泛型写法一起使用，就会报错\n// 报错\nconst arr:readonly Array<number> = [0, 1];\n\n② TypeScript 提供了两个专门的泛型，用来生成只读数组的类型\nconst a1:ReadonlyArray<number> = [0, 1];\nconst a2:Readonly<number[]> = [0, 1];\n\n③ as const告诉 TypeScript，推断类型时要把变量arr推断为只读数组，从而使得数组成员无法改变。\n\nconst arr = [0, 1] as const;\narr[0] = [2]; // 报错 \n\n```\n\n#### 5、多维数组\n```typescript\n① TypeScript 使用T[][]的形式，表示二维数组，T是最底层数组成员的类型\n\nvar multi:number[][] = 【undefined】;\n```\n\n### （三）any 、null 、 undefined 、void\n1、`any`  告诉 **TypeScript 编译器**不要进行任何的类型检查，失去了类型检查的意义，另外会造成**类型污染** ，如下： ^4fa065 \n```typescript\nlet user: any = {\n  avatar: {\n    url: '/user-1.png'\n  }\n};\nlet avatar = user.avatar; // any\nlet url = avatar.url; // any\n```\n使用场景：\n\n- 老旧项目，年代久远的项目\n- 其他特殊原因：需要关闭具体变量的类型检查\n\n另外，可通过 `tsc --noImplicitAny app.ts` 启动 `any` 检查\n\n2、`null` 、 `undefined`  : 任何类型，都能再赋值为  `null`  和 `undefined` ，如下代码 ^d3044f\n```typescript\n// strictNullChecks: false\nlet num: number;\nlet str: string;\n\n// 这些类型能被赋予\nnum = null;\nstr = undefined;\n\n它们的类型会被推断为any。\nlet a = undefined;   // any\nconst b = undefined; // any\n\nlet c = null;        // any\nconst d = null;      // any\n\n\n// 打开编译设置 strictNullChecks = true\nlet a = undefined;   // undefined\nconst b = undefined; // undefined\n\nlet c = null;        // null\nconst d = null;      // null\n\n\n// tsc --strictNullChecks app.ts\nlet age:number = 24;\nage = null;      // 报错\nage = undefined; // 报错\n\n\n// 打开 strictNullChecks\n\nlet x:undefined = null; // 报错\nlet y:null = undefined; // 报错\n\n```\n**总之，打开 strictNullChecks 以后，undefined和null只能赋值给自身，或者any类型和unknown类型的变量**\n```typescript\nlet x:any     = undefined;\nlet y:unknown = null;\n```\n\n3、`void`  标识 函数没有返回值，即**空值** ，其实可以理解为 `null | undefined` \n\n### （四）never\n**代表永远不会发生** 的类型，是 TypeScript 中的 **底层类型** ， 看下面的两个示例：\n\n1. 一个总是会抛出错误的函数\n2. 一个从来不会有返回值的函数，因为里面包含 `while(true)`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b010c6ee18dfa882025d20df3366730d.png)\n看一个具体**案例**：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/edc5b68e55702c323c6b2660dcec33a0.png)\n或者如下代码，统一包装一个 `fail` 函数\n```typescript\nfunction foo(x: string | number): boolean {\n  if (typeof x === 'string') {\n    return true;\n  } else if (typeof x === 'number') {\n    return false;\n  }\n\n  // 如果不是一个 never 类型，这会报错：\n  // - 不是所有条件都有返回值 （严格模式下）\n  // - 或者检查到无法访问的代码\n  // 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型\n  // 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。\n  return fail('Unexhaustive');\n}\n\nfunction fail(message: string): never {\n  throw new Error(message);\n}\n```\n>  1、注意：抛出异常后就直接中断程序了\n 2、**never 仅能被赋值给另外一个 never 类型**\n\n### （五）Unknown\n1、使用 `any` 有很多弊端 ，参考如上： 【undefined】 ，这就引出了 `unknown`\n2、`any` 和 `unknown` 的 **本质区别**：\n `any` 和 `unknown` 的最大区别是, unknown 是 `top type` (任何类型都是它的 subtype) , 而  **any 即是 top type, 又是 bottom type** (它是任何类型的 `subtype` ) ，这导致 any 基本上就是放弃了任何类型检查。\n**所以， **`any`** 和 **`unknown`**  的 交集 和 并集都是 **`any` , 如下代码：\n```typescript\ntype U6 = unknown | any; // any\ntype U12 = unknown & any; // any;\n```\n3、 `unknown` 类型的值只能赋给 `unknown` 本身和 `any` 类型\n4、联合类型取最大集合，即**并集** ， 交叉类型中，取最小集合，即**交集** ，那么 unknown 的 联合类型 和 交叉类型如何呢？\n```typescript\n// 联合类型\ntype U1 = unknown | null; // unknown\ntype U2 = unknown | undefined; // unknown\ntype U3 = unknown | number; // unknown\ntype U4 = unknown | boolean; // unknown\ntype U5 = unknown | string[]; // unknown\ntype U6 = unknown | any; // any\n\n// 交叉类型\ntype U7 = unknown & null; // null;\ntype U8 = unknown & undefined; // undefined;\ntype U9 = unknown & number; // number;\ntype U10 = unknown & boolean; // boolean;\ntype U11 = unknown & string[]; // string[]\ntype U12 = unknown & any; // any;\n```\n总结一下就是： **unknown 也可以视为所有其他类型（除了any）的全集**\n>  TypeScript 有两个“**顶层类型**”（`any`和`unknown`），但是 **“底层类型”** 只有`never`唯一一个 \n\n### （六）值类型\n即 单个值也是一种类型，称为“**值类型**”。\n```typescript\nlet x:'hello';\n\nx = 'hello'; // 正确\nx = 'world'; // 报错\n\nconst x:5 = 4 + 1; // 报错\n// 在4 + 1后面加上as 5，就是告诉编译器，可以把 4 + 1的类型 视为值类型5 \nconst x:5 = (4 + 1) as 5; // 正确\n\n```\n> 单个值的值类型，用处不大，更多是配合 **联合类型** 使用\n\n### （七）联合类型\n```typescript\n\n① 常用示例\n\nlet x:string|number;\n\nlet setting:true|false;\n\nlet gender:'male'|'female';\n\nlet rainbowColor:'赤'|'橙'|'黄'|'绿'|'青'|'蓝'|'紫';\n\n// strictNullChecks = true\nlet nullOrUndefined = undefined | null\n\n// 方便书写\nlet x:\n  | 'one'\n  | 'two'\n  | 'three'\n  | 'four';\n\n② 如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”，比如：\n\nfunction printId(\n  id:number|string\n) {\n    console.log(id.toUpperCase()); // 报错\n}\n\n// 修改为 =========> \n\nfunction printId(\n  id:number|string\n) {\n  if (typeof id === 'string') {\n    console.log(id.toUpperCase());\n  } else {\n    console.log(id);\n  }\n}\n\n③ “类型缩小”的另一个例子\n\nfunction getPort(\n  scheme: 'http'|'https'\n) {\n  switch (scheme) {\n    case 'http':\n      return 80;\n    case 'https':\n      return 443;\n  }\n}\n\n\n```\n>  实际上，联合类型本身可以看成是一种“**类型放大**”（type widening），处理时就需要“**类型缩小**”（type narrowing）\n\n### （八）交叉类型\n交叉类型 `A&B` 表示，任何一个类型必须同时属于 `A` 和`B`，才属于交叉类型 `A&B`，即交叉类型同时满足`A`和`B`的特征。下面是示例\n```typescript\n\n① 变量obj同时具有属性foo和属性bar\nlet obj:\n  { foo: string } &\n  { bar: string };\n\nobj = {\n  foo: 'hello',\n  bar: 'world'\n};\n\n② x的类型实际是 never ，因为不可能有这样的 x \n\nlet x:number&string;\n\n③ 交叉类型常常用来为对象类型添加新属性。\n\ntype A = { foo: number };\ntype B = A & { bar: number };\n\n```\n\n### （九）type 命令\n`type` 命令用来定义一个类型的`别名`\n```typescript\n\n① 别名 Age 类型\ntype Age = number;\nlet age:Age = 55;\n\n② 别名不允许重名\ntype Color = 'red';\ntype Color = 'blue'; // 报错\n\n③ 别名的作用域是块级作用域\ntype Color = 'red';\nif (Math.random() < 0.5) {\n  type Color = 'blue';\n}\n\n④ 别名支持使用表达式\ntype World = \"world\";\ntype Greeting = `hello ${World}`;\n```\n>  type命令属于类型相关的代码，编译成 JavaScript 的时候，会被 ==全部删除==\n\n### （十） typeof 运算符\n1、JavaScript 里面，`typeof` 运算符只可能返回 **八种结果**，而且都是**字符串**。\n```javascript\ntypeof undefined; // \"undefined\"\ntypeof true; // \"boolean\"\ntypeof 1337; // \"number\"\ntypeof \"foo\"; // \"string\"\ntypeof {}; // \"object\"\ntypeof parseInt; // \"function\"\ntypeof Symbol(); // \"symbol\"\ntypeof 127n // \"bigint\"\n```\n2、TypeScript   `typeof` 运算符将返回 该值的 **TypeScript 类型**\n```typescript\nconst a = { x: 0 };\n\ntype T0 = typeof a;   // { x: number }\ntype T1 = typeof a.x; // number\n```\n3、类型运算 与 值运算\n\n- `typeof` 返回的是 TypeScript 类型，所以只能用在**类型运算**之中（即跟==类型相关的代码之中==），不能用在 **值运算**\n- typeof 的参数不能是一个值的运算式，如下示例：\n```typescript\n// Date()需要运算才知道结果\ntype T = typeof Date(); // 报错\n```\n\n- `typeof` 命令的参数不能是类型。如下代码\n```typescript\ntype Age = number;\ntype MyAge = typeof Age; // 报错\n```\n\n### （十一）类型声明的块级作用域\n```typescript\n存在两个代码块，其中分别有一个类型T的声明, 这两个声明都只在自己的代码块内部有效，在代码块外部无效。\nif (true) {\n  type T = number;\n  let v:T = 5;\n} else {\n  type T = string;\n  let v:T = 'hello';\n}\n```\n\n### （十二） 子类型与父类型\n即**子类型可以赋值给父类型**，但反过来不行，如下\n```typescript\n\n① 子类型 a 可以赋值给父类型 b\n\ntype T = number|string;\n\nlet a:number = 1;\nlet b:T = a; \n\n② 父类型 b 不可以赋值给 子类型 a\n\nlet a:'hi' = 'hi';\nlet b:string = 'hello';\n\nb = a; // 正确\na = b; // 报错\n```\n\n### （十三）元组\n\n#### 1、基本示例\n```typescript\nconst s:[string, string, boolean] = ['a', 'b', true];\n\n// 数组\nlet a:number[] = [1];\n// 元组\nlet t:[number] = [1];\n```\n>  数组与元组的区别在于，`number[]` 与 `[number]`\n\n#### 2、可选元素\n添加`?` 表示可选，比如\n```typescript\n① 正常用法\nlet a:[number, number?] = [1];\n\n② 它的成员数量可能有两个、三个和四个\ntype myTuple = [\n  number,\n  number,\n  number?,\n  string?\n];\n\n③ 扩展运算符（...），可以表示不限成员数量的元组\ntype NamedNums = [\n  string,\n  ...number[]\n];\nconst a:NamedNums = ['A', 1, 2];\nconst b:NamedNums = ['B', 1, 2, 3];\n\ntype t1 = [string, number, ...boolean[]];\ntype t2 = [string, ...boolean[], number];\ntype t3 = [...boolean[], string, number];\n```\n\n#### 3、成员或者元素名\n元组的成员可以添加成员名，这个**成员名**是说明性的\n```typescript\ntype Color = [\n  red: number,\n  green: number,\n  blue: number\n];\n\nconst c:Color = [255, 255, 255];\n\n```\n\n#### 4、读取成员类型\n元组可以通过方括号，**读取成员类型**\n```typescript\ntype Tuple = [string, number];\ntype Age = Tuple[1]; // number\n\n由于元组的成员都是数值索引，即索引类型都是number\ntype Tuple = [string, number, Date];\ntype TupleEl = Tuple[number];  // string|number|Date ,即 三种值的联合类型\n\n```\n\n#### 5、只读元组\n```typescript\n// 写法一\ntype t = readonly [number, string]\n\n// 写法二：泛型 Readonly<T>\ntype t = Readonly<[number, string]>\n```\n只读元组是元组的父类型，所以 **谁可以给谁赋值知道了吗？**\n如下代码，为什么传入`只读元组`就会报错呢？因为 **只读元组不能替代元组**\n```typescript\nfunction distanceFromOrigin([x, y]:[number, number]) {\n  return Math.sqrt(x**2 + y**2);\n}\n\nlet point = [3, 4] as const;\n\ndistanceFromOrigin(point); // 报错\n\n问：如何解决这个报错问题呢？使用类型断言，如下：\ndistanceFromOrigin(\n  point as [number, number]\n)\n```\n\n#### 6、成员数量的推断\n```typescript\n① ts 发现 元组point的长度是2，不可能等于3，报错\nfunction f(point: [number, number]) {\n  if (point.length === 3) {  // 报错\n    // ...\n  }\n}\n\n② TypeScript 发现point.length的类型是1|2|3，不可能等于4。\nfunction f(\n  point:[number, number?, number?]\n) {\n  if (point.length === 4) {  // 报错\n    // ...\n  }\n}\n\n③ 使用了扩展运算符，TypeScript 就无法推断出成员数量；故不会报错\nconst myTuple:[...string[]]\n  = ['a', 'b', 'c'];\n\nif (myTuple.length === 4) { // 正确\n  // ...\n}\n```\n\n#### 7、扩展运算符与成员数量\n```typescript\n\n① 报错原因是函数add()只能接受两个参数，但是传入的是...arr，TypeScript 认为转换后的参数个数是不确定的\nconst arr = [1, 2];\nfunction add(x:number, y:number){\n  // ...\n}\nadd(...arr) // 报错\n\n② arr是一个拥有两个成员的元组，所以 TypeScript 能够确定...arr可以匹配函数add()的参数数量，就不会报错了\nconst arr:[number, number] = [1, 2];\nfunction add(x:number, y:number){\n  // ...\n}\nadd(...arr) // 正确\n\n或者 const arr = [1, 2] as const; 使用 as const 断言即可\n\n\n③ 因为console.log()可以接受任意数量的参数\nconst arr = [1, 2, 3];\nconsole.log(...arr) // 正确\n\n\n```\n\n### （十四）symbol\n\n## 参考\n> [https://jkchao.github.io/typescript-book-chinese/project/dynamicImportExpressions.html](https://jkchao.github.io/typescript-book-chinese/project/dynamicImportExpressions.html)\n[https://ts.xcatliu.com/basics/primitive-data-types.html](https://ts.xcatliu.com/basics/primitive-data-types.html)\n [https://www.fullstackbb.com/typescript/typescript-unknown-as-top-type/](https://www.fullstackbb.com/typescript/typescript-unknown-as-top-type/)\n  [https://wangdoc.com/typescript/any](https://wangdoc.com/typescript/any)\n\n","c8c167ccb6bf5293bd53273e87861090":"\n# 浏览器篇\n\n\n\n## 目录\n<!-- toc -->\n ## 浏览器渲染原理篇 \n\n## 浏览器内核篇\n\n## 开发者工具\n\n> 整理所有关于开发这工具的一切！\n\n## CSS \n\n- 计算样式：在“元素”面板中，查看元素的计算样式，了解最终应用的样式值。\n- 盒模型：查看元素的盒模型，了解元素的尺寸、边距、边框和内边距。\n- CSS 断点：在“源代码”面板中，设置样式表断点，当样式表被修改时，代码会暂停执行，帮助定位问题。\n- 元素检查：右键点击页面元素，选择“检查”或按 F12 打开开发者工具，查看和修改元素的 CSS 样式。\n- 实时编辑：在“元素”面板中，直接编辑 CSS 规则，实时查看效果。\n- 样式层叠：查看元素的所有样式，包括用户代理样式、外部样式表、内联样式等，理解样式的层叠和优先级。\n\n## HTML\n\n## JS\n\n- 实时修改代码 ：`Shift+Enter` 你可以尝试搭配使用 Shift+Enter 按键去输入多行代码\n\n等等其他，\n","4cc7360449485c78b1c50c65b4971daa":"\n# 网络篇\n\n（HTTP、TCP/IP、DNS、UDP、websocket等计算机网络知识）\n","7ce730a0d300564893c3814ea64055fc":"\n# CSS\n\n\n\n- [https://juejin.cn/post/7270648629378531368`#heading-49](https://juejin.cn/post/7270648629378531368``#heading-49)`\n","d542cd6adc2759b5adb7626c43fa677e":"\n# 说明\n\n`#前端框架` `#2024/08/18`\n\n本篇主要介绍常用的前端框架，以及框架的原理及框架的最佳实践，包括内容\n\n1. 前端框架原理篇\n2. React 篇\n3. Vue 篇\n4. 其他框架篇\n\n","2547a7c2f31e5a22a991c5a40f03ed1d":"\n# 前言\n\n\n前端框架原理","cbfcd56f3e055d3c887b292543d7c147":"\n# 前端框架相关的前置知识点\n\n\n`#2024/08/10`  `#前端/前端框架`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 何为前端框架 \n\n- umi 算是框架，内置了路由、构建、流水线部署等\n- Angular 是框架\n- Next.js ：基于 React 的，支持 SSR、SSG的`服务端框架`\n\n## 2. 前端库与前端框架的区别？\n\n- 框架：React（虽然有时被称为库，但因其生态系统更像框架）、Angular 、Vue.js \n- 库：\n\t- 提供特定功能的工具集，比如 jQuery、Lodash、Moment.js\n\n> 严格说，React 和 Vue 都不算是**框架**，而算是**库**\n\n## 3. 现代前端框架的实现原理\n\n现代前端框架的**核心实现原理**是通过组件化、虚拟DOM和响应式系统等，实现**高效的声明式UI渲染和状态管理**。\n- 其实就是围绕 `UI = f(state)`  展开的\n\t- `UI` 依赖与宿主环境的渲染引擎\n\t- `f` 是框架本身的运行机制\n\t- `state` 当前视图的动态\n- 至于组件化、VDom、响应式等都是手段和一些关键模块\n\n## 4. 现代前端框架的核心模块组成有哪些？\n\n1. **组件化**：\n\t- 前端框架通常以组件为基础构建应用程序。组件是封装了 UI 和逻辑的独立单元，可以重复使用\n2. **虚拟 DOM**：\n    - 虚拟 DOM 是内存中的一个轻量级表示，用于优化实际 DOM 操作。\n3. **响应式系统**：\n    - 现代框架提供自动化的响应式数据绑定，确保当应用状态变化时，UI 会自动更新。\n    - 实现：\n        - Vue：使用 `Proxy` 和 `Object.defineProperty` 来检测数据变更。\n        - React：通过状态（state）管理系统更新，通常结合 `setState` 或 `hooks`。\n4. **单向数据流**：\n    - 通过单向数据流来管理组件之间的数据传递，以确保应用的数据流动方向明确，易于跟踪和调试。\n    - 实现：通常采用状态管理库（如 Redux、Vuex），管理全局应用状态，并通过严格的操作步骤来更新状态。\n5. **模板和声明式渲染**：\n    - 使用模板来描述 UI，提供声明式的视图定义。\n    - 实现：模板语法被编译为渲染函数，将数据映射到 UI 组件。\n6. **路由管理**：\n    - 实现单页应用（SPA）的视图切换，方便在不同页面之间导航。\n    - 实现：框架提供路由功能（如 React Router、Vue Router），匹配路径并渲染相应组件。\n7. **生命周期管理**：\n    - 提供钩子函数，允许开发者在组件特定的生命周期阶段执行代码。\n    - 实现：通过生命周期方法（React 的 componentDidMount、useEffect，Vue 的 created、mounted 等）来获取个性化控制。\n8. **性能优化**：\n    - 现代框架通过多种技术优化性能，如懒加载、代码分割等。\n    - 实现：框架提供内置的工具和约定，以减少初始加载时间和优化更新性能。\n9. **跨平台渲染**： -支持服务器端渲染（SSR）、静态站点生成（SSG）、以及与移动和桌面平台（如 React Native）集成。 -实现在：抽象出渲染层，并提供多平台兼容的实现\n10. **事件处理**\n    - 管理和优化事件绑定\n    - 实现: 事件委托，统一管理事件监听\n\n## 5. 如何描述 UI\n\n### 5.1. 方式一：声明式描述 UI  -  模板\n\n主流其实都是**模板**来描述，无论是 jsx 或者模板引擎都是**模板**\n\n- JSX 也是一种特殊的模板，兼顾以下两个特性\n\t- 强逻辑表达\n\t- UI 描述丰富性\n- 模板，即声明式描述 UI  \n\t- 代表 \n\t\t- HTML\n\t\t- php smarty\n\t\t- jsp 等等\n\t\t- ejs\n\t- 主要问题是逻辑表达性弱了些\n\n举例：`声明式描述 UI`\n- 比如 `<div class='btn' id='test' @click=\"handle\"> button </div>`， 包含信息 tag名，属性，事件，层级关系  \n\n### 5.2. 方式二：JavaScript 对象  \n\n 使用 `JavaScript对象 ` 来描述 UI，如下代码  \n\n```javascript  \nconst title = {\n    tag: 'h1', // tag 名称\n    props:{\n\t    // 属性与事件\n\t    onClick:handler\n\t}\n\tchildren:[\n      // 子节点\n      {tag: 'span'}\n  ]\n}\n```  \n\n#### 5.2.1. V-DOM\n\n`虚拟 DOM` 描述 UI，比如 vue 中的 `渲染函数 - h` ，如下代码：  \n\n```javascript  \nimport {h} from \"vue\";\nexport default{\n    render(){\n    \n        // 虚拟 DOM\n        return h('h1',{ onClick: fn }); \n        \n        // 或者直接返回 js 对的\n        return {\n            tag: 'h1', // tag 名称\n            props:{ // 属性与事件\n                onClick:handler\n            }\n            children:[ // 子节点\n                {tag: 'span'}\n            ]\n        }\n    }\n}\n```  \n\n`h` 返回的其实就是 `js 对象`， `h 函数`就是辅助创建虚拟 DOM 的工具函数而已，**所以他俩其实是一个东西**  \n\n### 5.3. 两种方式的对比\n\n- 哪种方式**更灵活**呢？  \n  - 答案是：`JavaScript 对象`（或`虚拟 DOM` ） 的方式，  \n     - 比如表现 `H1-H6` ，使用 `tag:H${index}` 即可  \n     - 又比如说，`jsx`的方式实现 `递归树`，更方便  \n- 那种方式**更直观**呢？当然是 `模板`\n\n## 6. 数据 与 UI \n\n简单说，前端框架需要数据驱动 UI 渲染，即数据变化了，UI 视图跟着一起变化\n\n## 7. 什么是副作用\n\n指的是在组件渲染过程中，那些会影响到**组件之外**的其他部分的操作，比如\n\n- 发起网络请求（如 API 调用）\n- 修改 DOM（直接操作，而非通过框架的渲染机制）\n- 设置定时器或间隔器，如 `setTimeout` 或 `setInterval`\n- 订阅外部事件\n- 修改全局变量\n- 写入本地存储，如修改 `localStorage` 或 `sessionStorage`\n- 日志记录等\n\n比如：访问/修改 localStorage（副作用）\n\n```jsx\n// 这个组件将用户名存储在浏览器的 localStorage 中，这是一个影响外部环境的操作。\nfunction RememberMe({ username }) {\n \n useEffect(() => {\n   localStorage.setItem('username', username);\n }, [username]);\n \n return <div>Remembering {username}</div>;\n}\n```\n\n相对比的，**纯函数**或者没有副作用代表不会影响到它本身以外的任何东西，比如\n\n```jsx\n// 这个组件只是单纯地渲染文本，不会影响其他任何东西。\nfunction Welcome(props) {\n return <h1>Hello, {props.name}</h1>;\n}\n```\n   \n副作用不是简单的渲染操作，而是会影响组件外部状态或环境的操作。\n\n>  在现代前端框架中，妥善管理这些副作用是保证应用稳定性和性能的关键。\n\n## 8. 说说前面提的 Vue 的 `h 函数` \n\n`h函数` 是**用于创建虚拟 DOM 节点**的一个函数，通常**在渲染函数中使用**。\n\n`h 函数`本质上是**一个创建虚拟 DOM 节点的工厂函数**。它的作用可以类比为用 JavaScript 来写 HTML。\n\n简单来说：\n- 作用：创建虚拟 DOM 节点\n- 使用场景：当你需要用 JavaScript 来精确控制渲染内容时\n- 基本语法：`h(标签或组件, 属性对象, 子节点)`\n\n一个简单的例子：\n\n```javascript\n// HTML: <div class=\"greeting\">Hello, World!</div>\nh('div', { class: 'greeting' }, 'Hello, World!')\n\n// HTML: <button onClick=\"alert('Hi')\">Click me</button>\nh('button', { onClick: () => alert('Hi') }, 'Click me')\n\n// 嵌套使用\nh('div', [\n  h('h1', 'Title'),\n  h('p', 'Paragraph')\n])\n```\n\n### 8.1. 主要用途\n\n1. **创建虚拟 DOM**:\n\t- `h` 函数通过 JavaScript 对象来描述 DOM 结构，这对于动态创建组件结构、进行复杂的条件渲染等场景十分有用。\n2. **渲染函数中使用**:\n\t- 在需要完全控制渲染逻辑时，`h` 函数可以与渲染函数一起使用，以构建组件的虚拟 DOM 树。\n3. **支持 JSX 语法**:\n\t- 在使用 JSX 语法时，JSX 会被编译成 `h` 函数调用。\n\n### 8.2. 常见的 `h` 函数参数\n\n- **第一个参数**：标签名称、组件类型或异步组件（可以是字符串或组件变量）。\n- **第二个参数**（可选）：一个数据对象，包括属性、class、事件等。\n- **第三个参数**（可选）：子节点，可以是字符串、数组或更多 `h` 函数调用。\n\n### 8.3. 示例\n\n```javascript\nimport { h } from 'vue';\n\nexport default {\n  render() {\n    return h('div', { class: 'container' }, [\n      h('h1', 'Hello World'),\n      h('p', 'This is a paragraph.'),\n      h(MyButton, { onClick: this.handleClick }, 'Click Me')\n    ]);\n  },\n  methods: {\n    handleClick() {\n      alert('Button clicked!');\n    }\n  }\n}\n```\n\n在这个例子中，`h` 函数用于创建一个 `div` 包含一个标题、一个段落和一个自定义按钮组件。这种方式提供了非常灵活的界面渲染能力，可以在不依赖模板的情况下，直接使用 JavaScript 表达业务逻辑。\n\n## 9. 聊聊前端框架中的一些编译技术或编译策略\n\n代码编译技术或者策略，对**应用程序的性能和开发体验**有重要影响，还直接影响开发效率和调试能力。选择合适的编译策略通常需要权衡开发体验、应用性能和部署环境等多个因素。\n\n### 9.1. JIT（Just-in-Time）编译：即时编译、运行时编译\n\n**JIT 编译**是在**运行时**进行的编译。代码在执行时被动态编译为机器码。\n\n特点：\n- 灵活性高：可以根据运行时的情况进行优化。\n- 启动时间较长：因为需要在运行时编译。\n- 内存占用较大：需要保存原始代码和编译后的代码。\n\n应用：\n- 在浏览器中广泛使用，如 V8 引擎（Chrome）。\n- Angular 的**开发时模式**默认使用 JIT。\n\n优势：\n- 开发过程中更快的构建时间。\n- 易于调试，因为源代码和运行代码之间有直接对应关系。\n\n### 9.2. AOT（Ahead-of-Time）：预编译\n\n**AOT 编译**是在**构建阶段**就将代码编译为机器码或更低级的代码。\n\n特点：\n- 更快的启动时间：因为代码已经预先编译。\n- 更小的包体积：不需要包含编译器。\n- 更好的安全性：源代码不暴露在客户端。\n\n应用：\n- **Angular 生产模式**默认使用 AOT。\n- React 的 Prepack 是一种 AOT 优化工具。\n\n优势：\n- 更快的首次加载和渲染速度。\n- 在构建时就能发现某些类型的错误。\n\n### 9.3. 增量编译（Incremental Compilation）\n\n只重新编译**发生变化的部分（增量部分）**，而不是整个应用。\n\n特点：\n- 加快开发中的编译速度。\n- 在大型项目中特别有效。\n\n应用：\n- TypeScript 和许多现代构建工具支持增量编译。\n\n### 9.4. 懒加载（Lazy Loading）\n\n- 不是的编译技术，是一种编译策略\n- 定义\n\t- 按需加载代码块，而不是一次性加载整个应用\n- 特点：\n\t- 改善初始加载时间。\n\t- 减少不必要的网络传输。\n- 应用：\n\t- Angular、React Router 等都支持路由级别的懒加载\n\n### 9.5. Tree Shaking\n\n- 定义：移除未使用的代码（死代码消除）。\n- 特点：\n\t- 减小最终的包大小。\n\t- 通常与 ES6 模块和 AOT 编译结合使用。\n- 应用：\n\t- Webpack、Rollup 等构建工具支持 Tree Shaking。\n\n### 9.6. 源码映射（Source Mapping）\n\n- 定义：在生产环境中将压缩和转换后的代码映射回原始源代码。\n- 特点：\n\t- 便于在生产环境中进行调试。\n\t- 通常与 AOT 编译结合使用。\n\n### 9.7. 选择\n\n- **开发期间**，快速迭代和调试需求往往让 JIT 更受青睐。\n- **生产环境**，启动性能和安全性通常使 AOT 成为更好的选择\n\n","b0540cdc45165633ae8c87ab199af84e":"\n# 前端框架设计里的\"权衡\" 与\"选择\"\n\n\n`#vue` `#前端架构`  `#2023/03/17`  `#前端/前端框架`  \n\n\n## 目录\n<!-- toc -->\n ## 1、命令式框架与声明式框架   \n  \n- `Jquery` 就是典型的 **命令式框架**，关注`过程`  \n- Vue 暴露给用户使用的是 `声明式` ，但底层内部实现肯定也是 `命令式` ，如下示例：面向用户的是声明式的  \n  \n```vue  \n<template>  \n  <div @click=\"hello()\"></div>  \n</template>  \n```  \n  \n但问题是，**声明式的代码性能**`不会高于` 命令式代码的性能 ，所以这是一个选择 或者 权衡\n\n## 2、性能 与 维护性 的平衡  \n  \n![图片&文件](./files/Pastedimage20240810211402.png)\n## 3、运行时 与 编译时  \n\n### 纯运行时，即直接`Render`即可  \n\n![图片&文件](./files/Pastedimage20240810211504.png)\n\n### 运行时 + 编译时  \n  \n如下图，常用的 Vue/Angular/React 都属于这类框架 \n\n![图片&文件](./files/Pastedimage20240810211529.png)\n\n### 纯编译时框架，代表`Svelte`  \n\n![图片&文件](./files/Pastedimage20240810211619.png)\n\n## 4、原生 JS 操作 DOM、InnerHTML 与 虚拟 DOM 快慢对比  \n  \n可从以下三个方面来度量  \n  \n- 理解成本上，**原生 JS 操作 DOM > InnerHTML > 虚拟 DOM**  \n- 维护性上，**原生 JS 操作 DOM 、 InnerHTML < 虚拟 DOM**  \n- 性能上，取决于`页面大小`，`页面变更大小，`是`新建页面` 还是`更新页`面 甚至是`更新策略`等，都有关系，不同场景下有不同结论。  \n\n## 5、最后  \n  \n无论是`命令式`还`是声明式`，或者框架需要设计成`运行时`、`编译时`或`运行时+编译时`，都需要结合 `性能`、`理解成本`、`维护性`上做权衡选择。  \n\n## 参考\n\n- 《Vue.js 设计与实现》","265d67421b165e2faf1efe705047ae08":"\n# 前端框架设计时需要考虑的点\n\n`#前端` `#前端框架`  `#vue`\n\n对于开发一个前端框架来说，有哪些`核心要素`呢？ 如下：\n\n\n## 目录\n<!-- toc -->\n ## 1、开发体验 \n\n- **报错警告提示，是否能够让开发者立马定位到问题**\n\t- 比如 如何提示 `App.mount('`#app')`` 中 ``#app`` 节点 不存在\n- **开发调试是否直观？**\n\t- 比如`const obj = ref()` ，每次都是打印 `obj`的值都需要 `obj.value` ?  \n\t\t- 框架层面肯定需要提供好的 log 方式。\n\t- DevTools 提供 `custom formmaters` ，框架层面会提供 `initCustomFormatter` 的定义\n\n## 2、控制框架代码体积\n\n如何做到开发环境下更多提示，而不增加代码体积呢？\n- 需要使用 `roolup 插件` 或者 `webpack 插件` 的 `__DEV__常量`  来做到这一点，生成环境下形成  `dead code` , 在使用打包工具 `tree-shaking` 的能力，进行移除\n\n> [!info]\n`dead code` 即 永远不会执行的代码，如 `if(true)` 或者 `import 后没使用的模块`等\n\n## 3、良好的 `tree-shaking` 机制\n\n- 上面说的`dead code` 很容易被 `tree-shaking`掉，但是`副作用` 呢，因为 `proxy` 能力`只读每个属性`也可能引起`副作用`。\n\t- 答案是：`/*`#__PURE__*/``   \n\t\t- `rollup` 和 `webpack` 、`terser` 都可以识别它 ，它告诉打包工具，`放心 tree-shaking 掉吧`\n\n## 4、多种环境下的构建产物不一样\n\n比如：\n- `rollup` 下，设置 `format` 为 `iife` 给 `script` 标签直接使用\n- `rollup` 下，设置 `format` 为 `esm` 给 `<script type=\"module\">` 直接使用\n- `rollup` 下，设置 `format` 为 `cjs` 给 nodejs 环境使用 ，为了 SSR\n\n另外，如何打包给 `rollup` 或者 `webpack` 工具使用呢？\n- 答案是 `esm` , 但又如何 与   `<script type=\"module\">` 区别呢？\n-  看 package.json  , 如下 `代码` 和 `图片`\n\n```json\n{\n\t\"main\":\"index.js\",\n\t\"module\":\"dist/vue.runtime.esm-bundler.js\",\n}\n```\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202303191018366.png)\n\n## 5、支持特性开关\n\n  比如 vue3 的 `组合式 API` 和 `选项式 API`， 如果用户确定只需要使用 `组合式 API` ，那么可以通过设置 `__VUE_OPTIONS_API__` 预定于常量来开启或者关闭.\n\n## 6、错误处理机制\n\n比如一个工具库提供一个 `fetch` 方法 ，但使用的方式必须传入回调 `fetch(callback)`，怎么容错呢？三种\n1. 用户自己 `try catch`，但是如果有很多方法，需要每个都 `try catch` 吗\n2. 用户自己实现一个 `handleError` 方法\n3. 工具库提一个 `utils.registerErrorHandler` 静态方法, 用户使用它注册错误处理程序。\n\t- 第 3 种，就是 Vue 的处理方式，`app.config.errorHandler`  , 为用户提供更好的框架层面的健壮性。\n\n## 7、Typescript 支持\n\n完善 Typescript 支持，可能比框架本身还要花精力和时间\n\n## 参考\n\n- 《Vue.js 设计与实现》","6ce298e829a851ad8cdcc5074c4720b2":"\n# 前言\n\n","4b0c106fd24c508797a8b5dbee2f02fe":"\n# 前言\n\n","8fc566e7460a576eb8d80de0eaa5dc1a":"\n# 前言\n\n\nvue 篇包括\n- vue 基础篇\n- Vue 原理篇\n- Vue 实践篇\n\n","23ee92d569e557768d8c9e2a1b105a9b":"\n# 前言\n\n`#vue3`  `#前端` \n\n\n## 目录\n<!-- toc -->\n ## Vue 简介 \n\n- Vue 是一个用于构建用户界面的 JavaScript 框架，提供了`声明式渲染`和`响应式更新`等核心功能。\n- Vue 是一个`渐进式框架`，可以根据需求灵活地选择使用方式，适用于简单到复杂的各种 Web 开发场景，比如 HTML → Web Components   → SPA → SSR → SSG  →   桌面端、移动端、WebGL 等\n\n## 单文件组件\n\n即 Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里，如下示例：\n\n```vue\n<template>\n  <button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  const count = ref(0)\n</script>\n\n<style scoped>\n  button {\n  font-weight: bold;\n  }\n</style>\n```\n\n## 组合式 API (Composition API)  vs  选项式 API (Options API)\n\nVue 有两种主要的 API 风格：`选项式 API` 和`组合式 API`，开发者可以根据喜好和项目需求选择使用。\n\n```vue\n<script>\nexport default {\n  // data() 返回的属性将会成为响应式的状态\n  // 并且暴露在 `this` 上\n  data() {\n    return {\n      count: 0\n    }\n  },\n\n  // methods 是一些用来更改状态与触发更新的函数\n  // 它们可以在模板中作为事件处理器绑定\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n\n  // 生命周期钩子会在组件生命周期的各个不同阶段被调用\n  // 例如这个函数就会在组件挂载完成后被调用\n  mounted() {\n    console.log(`The initial count is ${this.count}.`)\n  }\n}\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 响应式状态\nconst count = ref(0)\n\n// 用来修改状态、触发更新的函数\nfunction increment() {\n  count.value++\n}\n\n// 生命周期钩子\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n> 自主开发我们要求使用 `组合式 API (Composition API)` +  `<script setup>`\n\n## 使用 Vue3 的几种方式\n\n### 1、npm 包引入\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({\n  /* 根组件选项 */\n})\n```\n\n### 2、通过 CDN 使用 Vue\n\n```html\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<div id=\"app\">{{ message }}</div>\n\n<script>\n  const { createApp, ref } = Vue\n\n  createApp({\n    setup() {\n      const message = ref('Hello vue!')\n      return {\n        message\n      }\n    }\n  }).mount('`#app')`\n</script>\n```\n\n### 3、使用 ES 模块构建版本\n\n> 注意是 `<script type=\"module\">`\n\n```html\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\nimport { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('`#app')`\n</script>\n```\n\n### 4、Import maps 方式引用\n\n```vue\n<!-- 这个标签包含一个 JSON 对象，用于定义模块的映射关系。 -->\n<script type=\"importmap\">\n  {\n    \"imports\": {\n      \"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\"\n    }\n  }\n</script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp, ref } from 'vue'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('`#app')`\n</script>\n```\n\n> 注意 `<script type=\"importmap\">` 的兼容性\n\n","1e38f6cf143a51918fec74770ba78353":"\n# 基础概念\n\n\n`#2024/08/18` `#vue3`  `#前端框架/vue`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 几个关键词 \n\n### 1.1. Vue 的两个核心功能\n\n- `声明式渲染`：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。\n- 响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。\n\n### 1.2. 单文件组件\n\n- `单文件组件` (也被称为 `*.vue` 文件，英文 Single-File Components，缩写为 SFC)\n- 顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里\n\n### 1.3. API 风格\n\nVue 的组件可以按两种不同的风格书写：选项式 API 和 组合式 API。\n\n#### 1.3.1. 选项式 API (Options API)\n\n即`vue2`的写法\n\n#### 1.3.2. 组合式 API (Composition API)\n\n即新的`vue3`的写法\n\n### 1.4. ONLINE DEMO\n\n> 很重要，重要功能或者feature 可以直接在线体验\n\n- 想要快速体验 Vue，你可以直接试试我们的  [演练场](https://sfc.vuejs.org/`#eNo9j01qAzEMha+iapMWOjbdDm6gu96gG2/cjJJM8B+2nBaGuXvlpBMwtj4/JL234EfO6toIRzT1UObMexvpN6fCMNHRNc+w2AgwOXbPL/caoBC3EjcCCPU0wu6TvE/wlYqfnnZ3ae2PXHKMfiwQYArZOyYhAHN+2y9LnwLrarTQ7XeOuTFch5Am8u8WRbcoktGPbnzFOXS3Q3BZXWqKkuRmy/4L1eK4GbUoUTtbPDPnOmpdj4ee/1JVKictlSot8hxIUQ3Dd0k/lYoMtrglwfUPkXdoJg==)。`\n- 如果你更喜欢不用任何构建的原始 HTML，可以使用 [JSFiddle](https://jsfiddle.net/yyx990803/2ke1ab0z/) 入门。\n- 如果你已经比较熟悉 Node.js 和构建工具等概念，还可以直接在浏览器中打开 [StackBlitz](https://vite.new/vue) 来尝试完整的构建设置。\n\n### 1.5. 类似于 unpkg 的东西\n\n-  [unpkg](https://unpkg.com/)\n-  [jsdelivr](https://www.jsdelivr.com/package/npm/vue) 或 [cdnjs](https://cdnjs.com/libraries/vue)\n\n### 1.6. Vue2 与 Vue3 的区别\n\n- Vue 2 在 2023 年底将到达它的截止维护日期\n- vue3 仅支持 IE11及以上。Vue 3 用到了一些 IE11 不支持的现代 JavaScript 特性\n- vue3 只支持 [原生支持 ES2015 的浏览器](https://caniuse.com/es6) ，即es6\n\n## 2. 应用\n\n1、每个 `Vue` 应用都是通过 [createApp](https://cn.vuejs.org/api/application.html`#createapp)` 函数创建一个新的 `应用实例`\n\n2、根组件\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b88a5a4d2277eff8f27cf31541ea7c84.png)\n\n3、挂载应用\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e83ae5da762a1f626745c2bb063513cf.png)\n\n4、应用配置\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/8a51b48b1e5e8ea2fd9d5590b63f12f0.png)\n\n5、多个应用实例\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/06eaeda3dcc927c55c1c786a078866da.png)\n\n## 3. 模板语法\n\n1、`{{}}`\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/348842d7954689c3fdb16c1a8c0f0cad.png)\n\n2、rawHtml 与 `v-html` 指令\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/5968a47d4e873e246b2520f15634070f.png)\n\n3、`v-bind:attrName` 与  简写`:attrName`  或 `v-bind:obj` 动态绑定多个值\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/26f05e6dfe25ed256f0eee99069f2010.png)\n\n简写： `:attrName`\n\n![image.png|488](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/50c1241f3a8803a2f5b58996c011aeea.png)\n\n![image.png|472](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/acf06258899c4d73a70ae439342aef61.png)\n\n4、`{{}}` 仅支持`表达式`，不支持`语句`\n\n![image.png|512](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/1ebe8a98b79792c966d3a75d935365ad.png)\n\n5、受限的全局访问，可以通过 [app.config.globalProperties](https://cn.vuejs.org/api/application.html`#app-config-globalproperties)` 配置\n\n模板中的表达式将被沙盒化，仅能够访问到[有限的全局对象列表](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts`#L3)。该列表中会暴露常用的内置全局对象，比如` `Math` 和 `Date`。\n\n```javascript\nimport { makeMap } from './makeMap'\n\nconst GLOBALS_WHITE_LISTED =\n  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'\n\nexport const isGloballyWhitelisted = /*`#__PURE__*/` makeMap(GLOBALS_WHITE_LISTED)\n```\n\n没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 [app.config.globalProperties](https://cn.vuejs.org/api/application.html`#app-config-globalproperties)` 上 显式地添加它们，供所有的 Vue 表达式使用。\n\n## 4. 指令 Directives\n\n1、`v-on` 有一个相应的缩写，即 `@` 字符 ， 如 `@click <=> v-on:click`\n\n2、`v-bind:href`  等价于  `:href` \n\n3、动态参数的说明如下\n\n- 动态属性\n- 动态事件名称\n- 动态参数值的限制：为null 或者 字符串，否则编译警告\n- 动态参数的语法限制：大小写，注意空格等\n\n具体看下面：\n\n![image.png|552](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/0c3f6bbe4333afb3a4d663b954c16887.png)\n\n动态参数的语法限制：\n\n![image.png|640](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/53bf37f4be201240faf16a9c33191c14.png)\n\n4、指令的修饰符\n\n![image.png|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9f6397816b7d01663f22e57bbc383a36.png)\n\n","9de19e78cb9f5e31900cadff592de4d9":"\n# 响应式\n\n`#vue3`  `#前端框架`  `#前端` \n\n\n## 目录\n<!-- toc -->\n ## 1. 什么是响应式？ \n\n![image.png|376](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/608a1ef779e42c64332ed24cd7ccad24.png)\n\n## 2. 为什么`data()` 返回对象的顶层属性都能被 `this` 访问\n\n![image.png|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/16598b806f2b32702f3a0e2b770d316b.png)\n\n几个注意点：\n\n- 实例首次创建时，一些属性值还没确定，务必先 `**占位**`** ，因为** **直接通过 **`**this**`** 添加的属性将不再有 **`**响应式能力**`\n- Vue 在组件实例上暴露的`内置 API `使用 `$ `作为前缀。它同时也为`内部属性`保留 `_` 前缀。因此， 避免在顶层 `data` 上使用任何以这些字符作前缀的属性。\n\n","239eba1ff968547dbc2b1c4f5ad08c96":"\n# 基础\n\n\n\n## 目录\n<!-- toc -->\n ## 1. Vue 应用实例 \n\n- 通过 `createApp` 函数创建新的应用实例\n- 应用实例需要一个`根组件`来渲染内容\n- 使用 `.mount() `方法挂载应用实例到` DOM 元素`上\n- 可以配置应用实例的全局选项和资源，比如\n   - 应用级别错误处理器：`app.config.errorHandler = (err) => {})`\n   - 注册一个全局组件： `app.component('TodoDeleteButton', TodoDeleteButton)`\n- 一个页面可以创建多个共存的 Vue 应用实例。\n\n## 2. Vue 模板\n\n1、Vue 使用基于 `HTML` 的模板语法, 将组件实例的数据绑定到呈现的 DOM 上。\n\n2、`文本插值`使用双大括号语法,可以将组件属性显示为纯文本 \n\n3、使用 `v-html 指令`可以将属性插入为`原始 HTML`, 但要注意安全风险。\n\n3、属性绑定使用 `v-bind` 指令或其`简写`， 可以动态绑定多个 HTML 属性\n\n4、`指令`是带有 `v- 前缀`的特殊属性,可以根据表达式的值更新 DOM，`指令`可以带有参数,如 `v-bind:href` 或 `v-on:click`,用于指定绑定的目标\n\n5、`动态参数`允许使用`js 表达式`计算参数名称,如` :[someAttrObj]`\n\n6、`修饰符`是以点开头的特殊后缀，用于指定指令需要以特殊方式绑定，如` .prevent`。\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/3df5cd42ab14e6bb604f1a7fc53e3e91.png)\n\n7、JavaScript 表达式可以被使用在如下场景上\n\n- 在文本插值中 (双大括号)\n- 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中\n\n## 3. 响应式基础\n\n1、建议使用 `<script setup>`，来简化暴露大量的状态和方法的繁琐\n\n2、`ref`可以包装`任何类型`的值并保持`深层响应性` ，即 改变嵌套对象或数组时，变化也会被检测到\n\n- 在`模板`渲染上下文中，只有`顶级的 ref` 属性才会被解包\n- DOM 更新不适合 ref 变化同步的，`nextTick()` 后可以保证更新\n- 非模板场景，**解构里面的属性也会丢失响应性**\n\n3、`reactive()` 将使`对象本身`具有响应性；\n\n- 另外只有`代理对象`是响应式的，更改`原始对象`不会触发更新\n- 同一个对象上调用 `reactive() `会返回相同的代理\n- 在一个代理上调用 `reactive() `会返回它自己\n- `reactive()` 的局限性\n   - `reactive()` 只能处理对象类型，不能处理原始类型\n   - `reactive()` 不能替换整个对象，否则会丢失响应式\n   - `解构`会丢失响应性，比如 `let { count } = state` 中，修改 `count`就没用了\n\n```javascript\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n\n// 只有代理对象是响应式的，更改原始对象不会触发更新\nconst raw = {}\nconst proxy = reactive(raw)\n\n\n// 在同一个对象上调用 reactive() 会返回相同的代理\nconsole.log(reactive(raw) === proxy) // true\n\n// 在一个代理上调用 reactive() 会返回它自己\nconsole.log(reactive(proxy) === proxy) // true\n\n\nlet state = reactive({ count: 0 })\n\n// 上面的 ({ count: 0 }) 引用将不再被追踪\n// (响应性连接已丢失！)\nstate = reactive({ count: 1 })\n```\n\n## 4. 计算属性\n\n- 计算属性可以用来描述依赖响应式状态的复杂逻辑,比方法更加优雅和高效\n- 计算属性基于其响应式依赖被`缓存`,只有在依赖变化时才会重新计算,这`对于性能敏感的场景`很有帮助。\n- 计算属性可以定义为`可写属性`,提供 `getter` 和 `setter` 方法。\n- 计算属性的 `getter` 应该只做计算而没有任何`副作用`，不应该改变其他状态或执行异步操作。\n- 计算属性返回的值应该被视为`只读的`，不应该直接修改它，而是`应该更新它所依赖的源状态**\n\n```vue\n<script setup>\n  import { ref, computed } from 'vue'\n\n  const firstName = ref('John')\n  const lastName = ref('Doe')\n\n  const fullName = computed({\n    // getter\n    get() {\n      return firstName.value + ' ' + lastName.value\n    },\n    // setter\n    set(newValue) {\n      // 注意：我们这里使用的是解构赋值语法\n      [firstName.value, lastName.value] = newValue.split(' ')\n    }\n  })\n</script>\n```\n\n该文章主要介绍了如何在 Vue.js 中绑定 HTML class 和内联样式。\n\n## 5. 类与样式\n\n- `:class ` 和 `:style` 都可以绑定`数组` 或者 `对象`，并且最后会被`合并` 处理。\n- `:style` 绑定的属性名可以使用 `camelCase` 或 `kebab-case`。\n- Vue 使用 `:style` 会自动添加`前缀`\n\n## 6. 条件渲染\n\n- `v-if`\n   - `v-if 指令`用于条件性地渲染内容，**仅在表达式返回真值时渲染**。 \n   - 注意 `v-if ` `v-else-if` `v-else` 三个的配对关系。\n- `v-if` 与 `v-show`\n   - `v-if` 是真实的按条件渲染，切换时**销毁与重建事件监听器和子组件**；\n   - `v-show `则简单切换 CSS 属性（即始终保留在 DOM 中，仅切换 display 属性）\n   - `v-if` 有**更高的切换开销**，而 `v-show` 有**更高的初始渲染开销**\n- ` v-if` 优先级高于  `v-for`， 不推荐同时使用。\n\n## 7. 列表渲染\n\n- 循环范围： `v-for=\"n in 10\"`\n- 循环列表：`v-for=\"item in items\"`\n- 使用 `of` ：  `v-for=\"item of items\"`\n- 使用 `key` 优化性能\n- 在`计算属性`中使用 `reverse()` 和 `sort()` 会修改原数组，务必小心\n\n```js\n- return numbers.reverse()\n+ return [...numbers].reverse()\n```\n\n## 8. 事件处理\n\n- 使用 `v-on` 指令监听 DOM 事件，并在事件触发时执行对应的 JavaScript。\n- 内联事件 与 方法事件\n   - `内联事件`处理器适用于简单场景，\n   - 而`方法事件`处理器适用于复杂逻辑。\n- 如何传入参数？\n   - 可以在`内联事件处理器`中`调用方法`，并`传入自定义参数`或访问原生事件。\n- Vue 提供了多种`事件修饰符`，\n   - 如 `.stop.prevent.self.capture.once.passive` ，以简化事件处理\n- `按键修饰符`和`系统按键修饰符`用于处理特定按键事件\n   - 按键修饰符： `.enter .tab .delete  .esc .space .up .down .left .right`\n   - 系统按键修饰符：  `.ctrl .alt .shift .meta` \n- `.exact` 修饰符允许精确控制触发事件所需的系统修饰符组合\n- `鼠标按键修饰符`用于处理特定鼠标按键触发的事件\n   - 比如 `.left.right.middle` \n\n> `passive` 是一个事件监听器选项，它告诉浏览器监听器不会调用 `preventDefault() `来阻止默认的滚动行为，可用于改善滚动性能。\n\n```javascript\nwindow.addEventListener('scroll', function(event) {\n    // 处理滚动事件\n}, { passive: true });\n```\n\n## 9. 表单输入绑定\n\n- `v-model 指令`简化了表单输入与 JavaScript 变量的同步\n- `v-model` 支持多种表单元素，包括文本输入、复选框、单选按钮和选择器。比如\n   - 文本类型的` <input>` 和 `<textarea>` 元素会绑定 `value property` 并侦听` input 事件`；\n   - `<input type=\"checkbox\">` 和 `<input type=\"radio\">` 会绑定 `checked property `并侦听 `change 事件`；\n   - `<select> `会绑定 `value property `并侦听 `change` 事件\n   - `v-model` 会忽略任何表单元素上初始的 `value`、`checked` 或 `selected` attribute\n- `v-model` 可以与`修饰符`一起使用，如` .lazy、.number 和 .trim`，以实现不同的输入管理方式\n   - `.lazy`：在  `change` 事件后同步更新而不是 `input`\n- 除了`内置表单`外，可以在组件中使用 `v-model` 来创建具有`自定义行为`的可复用输入组件\n\n相对小众的一个用法：\n\n```vue\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"'选中了'\"\n  :false-value=\"'未选中'\" />\n```\n\n## 10. 生命周期\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/ecf5a16d3c2229d12c040cb757da8714.png)\n\n## 11. 侦听器\n\n### 11.1. watch \n\n```javascript\n// 侦听单个来源\nfunction watch<T>(\n  source: WatchSource<T>,\n  callback: WatchCallback<T>,\n  options?: WatchOptions\n): StopHandle\n\n// 侦听多个来源\nfunction watch<T>(\n  sources: WatchSource<T>[],\n  callback: WatchCallback<T[]>,\n  options?: WatchOptions\n): StopHandle\n\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\ntype WatchSource<T> =\n  | Ref<T> // ref\n  | (() => T) // getter\n  | T extends object\n  ? T\n  : never // 响应式对象\n\ninterface WatchOptions extends WatchEffectOptions {\n  immediate?: boolean // 默认：false\n  deep?: boolean // 默认：false\n  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  once?: boolean // 默认：false (3.4+)\n}\n```\n\n### 11.2. watchEffect()\n\n```javascript\nfunction watchEffect(\n  effect: (onCleanup: OnCleanup) => void,\n  options?: WatchEffectOptions\n): StopHandle\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\ninterface WatchEffectOptions {\n  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\ntype StopHandle = () => void\n```\n\n### 11.3. 几个注意点\n\n1、`watch` 的 `第一个参数` 都建议写成`箭头函数`\n\n2、注意 `watch`  的 `第二个参数` 有 `once` 、`immediate` ， `deep`\n- 但需要注意 `deep = true 时`  可能会引起性能问题\n\n3、 [watchEffect函数](https://cn.vuejs.org/api/reactivity-core.html`#watcheffect)`  会**自动收集并追踪**函数内所依赖的响应式数据，省得手动维护所需要监听的数据，他不需要像 `watch` 一样 递归地跟踪所有的属性，比较适合侦听一个嵌套数据结构中的`几个属性`。\n\n4、回调的触发时机\n\n（1）默认情况下，侦听器回调会在`父组件更新之后、所属组件的 DOM 更新之前`被调用，这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态\n\n（2）可以通过设置`flush: 'post'`选项在侦听器回调中访问被 Vue 更新之后的 DOM。\n\n（3）可以设置 `flush: 'sync'` 创建一个`同步触发的侦听器`，它会在 Vue 进行任何更新之前触发\n\n（4）同步侦听器不会进行**批处理**，每当检测到响应式数据发生变化时就会触发。可以使用它来监视简单的布尔值，但应避免在可能多次同步修改的数据源 (如数组) 上使用\n\n5、停止侦听器\n\n（1）宿主组件卸载时自动停止，但异步回调里则不会\n\n```javascript\n<script setup>\nimport { watchEffect } from 'vue'\n\n// 它会自动停止\nwatchEffect(() => {})\n\n// ...这个则不会！\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>\n```\n\n> 需要`异步创建`侦听器的情况很少，请尽可能选择`同步创建`。如果需要等待一些异步数据，你可以使用**条件式的侦听逻辑**\n\n（2）手动停止一个侦听器，请调用 `watch` 或 `watchEffect` 返回的函数\n\n```javascript\nconst unwatch = watchEffect(() => {})\n\n// ...当该侦听器不再需要时\nunwatch()\n```\n\n## 12. 模板引用\n\n1、使用 `ref attribute` 来引用 DOM ，如 `<input ref=\"input\"> `\n\n2、在组件挂载后 `onMounted` 中，使用 `ref` ,不然可能为 `null` ；或者 `watch ` 不为空时，也能正常获取到 DOM\n\n3、`v-for` 中的模板引用，`<li v-for=\"item in list\" ref=\"itemRefs\">` ， 其中 `const itemRefs = ref([]) `\n\n4、函数模板引用： `<input :ref=\"(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }\">`\n\n5、组件上的 `ref` ： `<Child ref=\"child\" />`，而后就可以通过 `child` 获取组件 `Child` 的实例，但访问`组件实例`的属性或方法需要通过 `defineExpose` 暴露出来，原因如下：\n\n> 使用了 `<script setup>` 的组件是默认私有的：一个父组件无法访问到一个使用了 `<script setup> `的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏 **显式暴露**\n\n","5ee6ad49d55d5d6b898b72412786f018":"\n# 组件\n\n`#vue3`  `#前端框架/vue`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 基础 \n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/158cdda6d2da00692729eb12f32de205.png)\n\n### 1.1. 定义\n\n定义：使用 `SFC` 或者 `特定JavaScript 对象`\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/b3751bcb2ed0be8d12f1ebf08cf1fc8e.png)\n\n> 内联模板字符串时，必须这样：`<script type=\"text/x-template\">`\n\n### 1.2. 使用组件\n\n使用组件：`<script setup>` 中，导入的组件都在模板中直接可用，或 全局注册组件都不需要导入\n\n### 1.3. 传递 props\n\n`<script setup>` 中 使用 `const props = defineProps(['title'])` 定义\n\n```javascript\nexport default {\n  props: ['title'],\n  setup(props) {\n    console.log(props.title)\n  }\n}\n```\n\n### 1.4. 定义事件\n\n`<script setup>` 中 使用 `const emit = defineEmits(['enlarge-text'])` 定义\n\n```javascript\nexport default {\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    ctx.emit('enlarge-text')\n  }\n}\n```\n\n### 1.5. 插槽\n\n像 HTML 元素一样向`组件`中传递内容\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/e51ef16990a2a7456969b2eb98fbcd62.png)\n\n### 1.6. 动态组件\n\n即使用  `<component>`  \n\n```vue\n<!-- currentTab 改变时组件也改变 -->\n<component :is=\"tabs[currentTab]\"></component>\n```\n\n> 被切换掉的组件会被`卸载` ，可使用 `KeepAlive` 强制`存活`\n\n### 1.7. `:is` 的用法\n\n元素位置限制如何解决？  比如 `li` 必须在 `ul` 里，`tr` 必须在 `table`里\n\n举例：\n\n```vue\n<table>\n  <blog-post-row></blog-post-row>\n</table>\n```\n\n解决方案：\n\n```vue\n<table>\n  <tr is=\"vue:blog-post-row\"></tr>\n</table>\n```\n\n## 2. 注册组件\n\n### 2.1. 全局注册\n\n即应用内任何地方都可以直接使用 `<ComponentA/>`\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.component(\n  // 注册的名字\n  'MyComponent',\n  // 组件的实现\n  {\n    /* ... */\n  }\n)\n\n// 链式调用  \napp\n.component('ComponentA', ComponentA)\n.component('ComponentB', ComponentB)\n.component('ComponentC', ComponentC)\n```\n\n#### 2.1.1. 全局注册的问题\n\n1. 不能被 `tree-shaking` ，会导致 js 包过大\n2. 和使用过多的`全局变量`一样，太多`全局注册的组件`可能会影响应用长期的可维护性\n\n### 2.2. 局部注册\n\n（1）使用 `<script setup>`，导入的组件可以直接在模板中使用，无需注册\n\n（2）不使用`<script setup>`， 则需要使用` components 选项`来`显式注册\n`\n（3）局部注册的组件在`后代组件`中不可用，即只在当前组件可用\n\n### 2.3. 组件命名和使用命名\n\n`组件定义命名`和`组件使用命名`：比如 `MyComponent` 为名注册的组件，在模板中可以通过 `<MyComponent>` 或 `<my-component>` \n- PascalCase 这样的组件定义在 IDE 中友好\n- `PascalCase` 格式的一看就是 `Vue 组件`，很容易和`自定义元素 (web components)` 区分开来\n\n## 3. Props 定义\n\n1、`props` 可以使用  `defineProps()`  宏来声明\n\n（1）` <script setup>` ： `const props = defineProps(['foo'])`\n\n（2）不使用`setup` ，使用 `props` 选项声明\n\n--- \n\n2、使用一个对象绑定多个 `prop`，如下示例：\n\n```typescript\nconst post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n  \n`<BlogPost v-bind=\"post\" />`\n\n//******************=======>  等价于\n`<BlogPost :id=\"post.id\" :title=\"post.title\" />`\n```\n\n---\n\n3、`props` 可以是静态值或动态绑定的值\n\n（1）`静态` 即 `:key=1`\n\n（2）`动态`即`:key={post.title}`\n\n4、所有的 `props` 都遵循着`单向绑定原则`，避免子组件修改父组件的状态。 否则数据流将很容易变得混乱而难以理解，更改一个 prop 的需求通常来源于以下几种场景\n\n（1）prop 被用于传入`初始值`\n\n```javascript\nconst props = defineProps(['initialCounter'])\n\n// 计数器只是将 props.initialCounter 作为初始值\n// 像下面这样做就使 prop 和后续更新无关了\nconst counter = ref(props.initialCounter)\n```\n\n（2）需要对传入的` prop 值`做进一步的转换，建议使用 `computed`\n\n（3）更改`对象 / 数组类型`的 `props`，仅在父子组件在设计上本来就需要`紧密耦合`，不然子组件不允许直接修改，否则都推荐子组件抛出一个`事件`来通知父组件做出改变，即都回到父组件修改\n\n> 因为是引用类型，阻止这种更改不现实\n\n---\n\n5、Prop 校验\n\n```javascript\ndefineProps({\n  // 基础类型检查\n  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）\n  propA: Number,\n  // 多种可能的类型\n  propB: [String, Number],\n  // 必传，且为 String 类型\n  propC: {\n    type: String,\n    required: true\n  },\n  // 必传但可为空的字符串\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number 类型的默认值\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // 对象类型的默认值\n  propF: {\n    type: Object,\n    // 对象或数组的默认值\n    // 必须从一个工厂函数返回。\n    // 该函数接收组件所接收到的原始 prop 作为参数。\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // 自定义类型校验函数\n  // 在 3.4+ 中完整的 props 作为第二个参数传入\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // 函数类型的默认值\n  propH: {\n    type: Function,\n    // 不像对象或数组的默认，这不是一个\n    // 工厂函数。这会是一个用来作为默认值的函数\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\n`defineProps() 宏`中的参数不可以访问` <script setup>` 中定义的其他变量，因为在编译时整个表达式都会被移到外部的函数中\n\n## 4. 组件事件\n\n1、`<script setup>` 中 定义：`const emit = defineEmits(['inFocus', 'submit'])`\n> 非`<script setup>` 中，参考官方文档\n\n2、`defineEmits()宏`还支持对象语法，比如\n\n```vue\n<script setup lang=\"ts\">\n  const emit = defineEmits<{\n      (e: 'change', id: number): void\n      (e: 'update', value: string): void\n  }>()\n </script>\n```\n\n3、如果一个原生事件的名字 (例如 `click`) 被定义在 `emits` 选项中，则监听器只会监听组件触发的 `click` 事件而不会再响应原生的` click` 事件。\n\n4、和`原生 DOM 事件`不一样，组件触发的事件`没有冒泡机制`。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的`事件总线`，或是使用一个[全局状态管理方案](https://cn.vuejs.org/guide/scaling-up/state-management.html)。\n\n5、事件校验，如下代码\n\n```vue\n<script setup>\nconst emit = defineEmits({\n  // 没有校验\n  click: null,\n\n  // 校验 submit 事件\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>\n```\n\n## 5. 组件 v-model\n\n> 如果是 `v3.4以前`的版本，可以不看这部分\n\n1、`v-model` 可以实现双向绑定\n\n2、vue 3.4 版本之前实现 `v-model` 双向绑定，比较麻烦，如下\n\n```vue\n<!-- Child.vue -->\n<script setup>\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n</script>\n\n\n<template>\n  <input\n    :value=\"props.modelValue\"\n    @input=\"emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n```vue\n<!-- Parent.vue -->\n<Child\n  :modelValue=\"foo\"\n  @update:modelValue=\"$event => (foo = $event)\"\n/>\n```\n\n3、所以，`Vue3.4` 实现了 `defineModel`，简化实现`v-model` 的流程，如下代码：\n\n```vue\n<script setup>\nconst title = defineModel('title')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"title\" />\n</template>\n```\n\n> 比单独写简化了不少，这里再解释一下 `defineModel()宏`的作用：这个宏可以用来声明一个双向绑定 prop，通过父组件的 v-model 来使用\n\n4、`defineModel` 的底层机制：`编译器`层面，实现了父子通信的语法糖\n\n- 一个名为`modelValue`的 `prop`，本地 `ref` 的值与其同步；\n- 一个名为`update:modelValue`的事件，当本地 `ref` 的值发生变更时触发。\n\n所以效果就是：\n\n- 它的`.value`和`父组件`的`v-model`的值同步；\n- 当它被`子组件`变更了，会触发`父组件`绑定的值一起更新\n\n示例如下：\n\n```html\n<script setup>\nconst firstName = defineModel('firstName')\nconst lastName = defineModel('lastName')\n</script>\n\n\n<template>\n  <input type=\"text\" v-model=\"firstName\" />\n  <input type=\"text\" v-model=\"lastName\" />\n</template>\n\n```\n\n5、另外一种实现`双向绑定`的方法： 使用具有 `getter` 和 `setter` 的 `computed` 属性\n\n```vue\n<!-- CustomInput.vue -->\n<script>\n  export default {\n    props: ['modelValue'],\n    emits: ['update:modelValue'],\n    computed: {\n      value: {\n        get() {\n          return this.modelValue\n        },\n        set(value) {\n          this.$emit('update:modelValue', value)\n        }\n      }\n    }\n  }\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n6、`defineModel` 的参数说明，如下代码：\n\n```javascript\nconst title = defineModel('title', { required: true })\n```\n\n7、多个 `v-model` 绑定场景，如下代码：\n\n```vue\n<script setup>\n  const firstName = defineModel('firstName')\n  const lastName = defineModel('lastName')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"firstName\" />\n  <input type=\"text\" v-model=\"lastName\" />\n</template>\n```\n\n8、处理 `v-model` 修饰符 \n\n- [内置的修饰符](https://cn.vuejs.org/guide/essentials/forms.html`#modifiers)，例如` `.trim`，`.number` 和 `.lazy`。\n- 自定义的修饰符呢？比如自定义的修饰符 `capitalize`，它会自动将 `v-model` 绑定输入的字符串值第一个字母转为大写：\n\n```vue\n<script setup>\n  const [model, modifiers] = defineModel({\n    // get() 省略了，因为这里不需要它\n    set(value) {\n      if (modifiers.capitalize) {\n        return value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      // 如果使用了 .trim 修饰符，则返回裁剪过后的值\n      if(modelModifiers.trim){\n        return value.trim()\n      }\n      return value\n    }\n  })\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"model\" />\n</template>\n```\n\n9、最后总结`defineModel` 使用\n\n```typescript\n// 声明 \"modelValue\" prop，由父组件通过 v-model 使用\nconst model = defineModel()\n// 或者：声明带选项的 \"modelValue\" prop\nconst model = defineModel({ type: String })\n\n// 在被修改时，触发 \"update:modelValue\" 事件\nmodel.value = \"hello\"\n\n// 声明 \"count\" prop，由父组件通过 v-model:count 使用\nconst count = defineModel(\"count\")\n// 或者：声明带选项的 \"count\" prop\nconst count = defineModel(\"count\", { type: Number, default: 0 })\n\nfunction inc() {\n  // 在被修改时，触发 \"update:count\" 事件\n  count.value++\n}\n```\n\n10、关于``v-model:title=\"bookTitle\"`` 和 `v-model=\"title\"` 究竟什么区别？\n\n- `v-model=\"title\" `默认`绑定到 `modelValue prop`，并通过 `update:modelValue 事件`更新\n- `v-model:title=\"bookTitle\"` 绑定到` title prop`，并通过` update:title 事件`更新\n\n所以，其实`v-model=\"title\"` 是`v-model:modelValue=\"title\"` 一种`简写方式`\n\n具体差别如下：\n\n- 默认绑定的 props 字段不同\n- 是否支持`多属性`绑定，比如 `v-model:title`   `v-model:title1` 多个，但  `v-model=\"title\"` 只支持一个\n- 支持`多属性`绑定 适合复杂组件，比如组件库里的一些组件绑定场景\n\n11、在`表单输入元素`或`组件`上创建`双向绑定`，默认表单上直接使用，但组件上还需要使用配合 `defineModel`  \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/yuque/9dd55eaedb417f6eedd40bb0b5627e13.png)\n\n","5f06a2cb379f54d9a738c805f67d0260":"\n# 更多\n\n\n以上章节只列举了 Vue3 最基础的功能点，掌握了基本能够写出简单的 Vue3 页面，但后面还需要把 Vue3 官方文档读几遍\n\nvue3 官方文档是最好的教程，多看就好！\n\n","012961f1cc2459e2ad394bcbedea1185":"\n# 前言\n\n\n\n本篇主要讲解 Vue3 的实现原理 \n\n","137e2839e6755536987ad31894d2ed8b":"\n# Vue3 的渲染器原理\n\n\n`#vue` `#2023/05/19`  `#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n### 1.1. 摘要\n\n本文深入探讨了Vue3渲染器的原理和实现。\n- 文章详细解释了渲染器的概念、工作原理以及与响应式系统的结合。\n- 同时，介绍了如何实现一个跨平台的渲染器\n- 并详细讲解了渲染过程中的各种细节，包括属性处理、事件处理、子节点更新等。\n- 文章还讨论了一些特殊情况的处理，如Fragment和文本节点的渲染。\n\n### 1.2. 要点\n\n- 渲染器的作用是将虚拟DOM对象渲染为真实DOM元素，其核心在于更新时的Diff算法。\n- 实现跨平台渲染器的关键是将渲染操作抽象为可配置的对象。\n- 属性处理需要区分HTML Attributes和DOM Properties，并正确处理特殊属性如class和style。\n- 事件处理采用**特殊的设计**来优化性能并解决事件冒泡和更新时机的问题。\n- 子节点更新涉及多种情况，需要正确处理新旧节点的变化。\n- 特殊节点如文本节点、注释节点和Fragment需要特殊处理。\n- Vue3的渲染器设计考虑了性能优化、跨平台兼容性和特殊场景的处理。\n- 渲染器的实现涉及多个方面，包括挂载、更新、卸载等操作的细节处理。\n- Fragment的存在简化了组件的结构，类似于React的空标签或Fragment组件。\n\n## 2. 何为渲染器？\n\n以`浏览器平台`来说，如下的`renderer函数`就是一个`渲染器` 。\n\n```js\nfunction renderer(domString, container) {\n  container.innerHTML = domString\n}\n\nrenderer(`<h1>hello app</h1>`, document.getElementById('app'));\n```\n\n> [!info]\n> 渲染器的作用是，把虚拟DOM 对象渲染为真实 DOM元素。它的工作原理是，递归地遍历虛拟DOM对象，并调用原生  DOM  API 来完成真实 DOM 的创建。渲染器的精髓在于后续的更新，它会通过Diff算法我出变更点，并且只会更新需要更新的内容\n\n## 3. 渲染器与响应式系统\n\n即结合 `响应式能力`，实现 `自动`调用渲染器完成渲染和更新。\n- 即变量变了，UI 主动更新\n\n如下代码，使用 `effect`, `ref` 两个变量。\n\n```vue hl:8,\n\n<div id=\"app\"></div>\n\n<script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\"></script>\n\n<script>\n\n// ::::暴露的全局 API\nconst { effect, ref } = VueReactivity; \n\nfunction renderer(domString, container) {\n  container.innerHTML = domString\n}\n\nconst count = ref(1)\n\neffect(() => {\n  renderer(`<h1>${count.value}</h1>`, document.getElementById('app'))\n})\n\ncount.value++\n\n// 2s后更新\nsetTimeout(() => {\n    count.value++;\n},2000)\n\n</script>\n```\n\n## 4. 渲染的一些基本概念\n\n- `渲染器`与`渲染`\n\t- 名词 和 动词 的区别\n- `挂载`\n\t- 即 `mount` ，将 `虚拟 DOM` 渲染成 `真实 DOM 节点`\n- `容器`\n\t- 即渲染`到哪儿`？\n\n下面来看一个如何实现一个**渲染器函数**\n- `createRender`\n\n```vue hl:42\n<div id=\"app\"></div>\n\n<script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\"></script>\n\n<script>\n    function createRenderer() {\n        /**\n         * @desc 补丁函数\n         * @param {VNode} oldNode 旧的 VNode\n         * @param {VNode} newNode 新的 VNode\n         * @param {HTMLElement} container 容器\n         * */\n        function patch(oldNode, newNode, container) {\n        \n        }\n        function render(vnode, container) {\n            if (vnode) {\n                // ::: 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数进行打补丁\n                patch(container._vnode, vnode, container);\n                \n            } else {\n                if (container._vnode) { // ::::卸载操作\n                    // 旧 vnode 存在，且新 vnode 不存在，说明是 卸载(unmount)操作\n                    // 只需要将 container 内的 DOM 清空即可\n                    container.innerHTML = ''\n                }\n            }\n            // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\n            container._vnode = vnode\n        }\n        // 服务端渲染时会用到\n        function hydrate() {\n        \n        }\n        return {\n            render,\n            hydrate\n        }\n    }\n    \n    const renderer = createRenderer()\n    // 三次渲染，都渲染到`#app上` \n    // 首次渲染\n    renderer.render(vnode1, document.querySelector('`#app'))`\n    // 第二次渲染\n    renderer.render(vnode2, document.querySelector('`#app'))`\n    // 第三次渲染\n    renderer.render(null, document.querySelector('`#app'))`\n    \n</script>\n```\n\n## 5. 实现一个极简跨平台渲染器\n\n- 如何实现一个渲染器，即不依赖于`具体宿主`\n\t- 如 浏览器的 `DOM API`\n\t- 或 Node.js 端\n\t- 或 客户端 等\n\n```js\nfunction createRenderer(options) {\n    // ::::为了实现跨平台，将渲染器的操作抽象为 options 对象::::\n    // 如：创建元素 createElement，\n    // 如：设置元素文本 setElementText\n    // 如：插入元素 insert\n    const {\n        createElement,\n        insert,\n        setElementText\n    } = options;\n    \n    function mountElement(vnode, container) {\n        \n        // 这里的 createElement 依赖于具体宿主\n        const el = createElement(vnode.type)\n        \n        // 说明是文本内容，调用 setElementText 插入\n        if (typeof vnode.children === 'string') {\n            setElementText(el, vnode.children)\n        }\n        \n        insert(el, container)\n    }\n    \n    function patch(n1, n2, container) {\n        if (!n1) {\n            mountElement(n2, container)\n        } else {\n            // n1 存在，这里需要打补丁\n        }\n    }\n    \n    function render(vnode, container) {\n        if (vnode) {\n            // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数进行打补丁\n            patch(container._vnode, vnode, container)\n        } else {\n            if (container._vnode) {\n                // 旧 vnode 存在，且新 vnode 不存在，说明是卸载(unmount)操作\n                // 只需要将 container 内的 DOM 清空即可\n                container.innerHTML = ''\n            }\n        }\n        // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\n        container._vnode = vnode\n    }\n    return {\n        render\n    }\n}\n```\n\n上面代码把`创建、修改、及删除操作`等抽象成可配置的对象\n\n### 5.1. 浏览器端\n\n比如在浏览器环境下，调用`浏览器`特定的 `DOM API` ，如下代码：\n\n```js\nconst renderer = createRenderer({\n  createElement(tag) {\n    return document.createElement(tag)\n  },\n  setElementText(el, text) {\n    el.textContent = text\n  },\n  insert(el, parent, anchor = null) {\n    parent.insertBefore(el, anchor)\n  }\n})\n\nconst vnode = {\n    type: 'h1',\n    children: 'hello'\n}\n\nrenderer.render(vnode, document.querySelector('`#app'))`\n\n```\n\n### 5.2. Nodejs 端\n\n而在 `Nodejs 环境`下，如下代码：\n\n```js\n\nconst renderer2 = createRenderer({\n    createElement(tag) {\n        console.log(`创建元素 ${tag}`)\n        return {tag}\n    },\n    setElementText(el, text) {\n        console.log(`设置 ${JSON.stringify(el)} 的文本内容：${text}`)\n        el.text = text\n    },\n    insert(el, parent, anchor = null) {\n        console.log(`将${JSON.stringify(el)}添加到${JSON.stringify(parent)} 下`)\n        parent.children = el\n    }\n});\n\nconst container = {type: 'root'};\nrenderer2.render(vnode, container);\n```\n\n## 6. 如何挂载 `子节点` 及 `子节点的属性`\n\n### 6.1. 首先看一个能够如何挂载子节点\n\n以下是是一个能够跑起来的 `最简易的 DEMO` :\n\n```js\n<div id=\"app\"></div>\n\n<script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\"></script>\n\n<script>\n    function createRenderer(options) {\n        const {\n            createElement,\n            insert,\n            setElementText\n        } = options\n        function mountElement(vnode, container) {\n            const el = createElement(vnode.type)\n            if (typeof vnode.children === 'string') {\n                setElementText(el, vnode.children)\n                // :::::::::递归渲染子节点即可\n            } else if (Array.isArray(vnode.children)) {\n                vnode.children.forEach(child => {\n                    patch(null, child, el)\n                })\n            }\n            // :::::::::设置属性\n            if (vnode.props) {\n                for (const key in vnode.props) {\n                    el.setAttribute(key, vnode.props[key])\n                }\n            }\n            // ::插入到容器中\n            insert(el, container)\n        }\n        function patch(n1, n2, container) {\n            if (!n1) {\n                mountElement(n2, container)\n            } else {\n                // // ::::补丁逻辑\n            }\n        }\n\n        function render(vnode, container) {\n            if (vnode) {\n                // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数进行打补丁\n                patch(container._vnode, vnode, container)\n            } else {\n                if (container._vnode) {\n                    // 旧 vnode 存在，且新 vnode 不存在，说明是卸载(unmount)操作\n                    // 只需要将 container 内的 DOM 清空即可\n                    container.innerHTML = ''\n                }\n            }\n            // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\n            container._vnode = vnode\n        }\n\n        return {\n            render\n        }\n    }\n    const renderer = createRenderer({\n        createElement(tag) {\n            return document.createElement(tag)\n        },\n        setElementText(el, text) {\n            el.textContent = text\n        },\n        insert(el, parent, anchor = null) {\n            parent.insertBefore(el, anchor)\n        }\n    })\n    const vnode = {\n        type: 'div',\n        props: {\n            id: 'foo'\n        },\n        children: [\n            {\n                type: 'p',\n                children: 'p tag'\n            },\n            {\n                type: 'h1',\n                children: 'H1 tag'\n            },\n            {\n                type: 'div',\n                children: [\n                    {\n                        type: 'span',\n                        children: 'div > span > tag'\n                    }\n                ]\n            }\n        ]\n    }\n    renderer.render(vnode, document.querySelector('`#app'))`\n\n</script>\n```\n\n下图是最终`渲染的效果`：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305232003540.png)\n\n> [figma jam](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=147-181&t=sZSmw8G9XgtflSer-4)\n\n两个注意点：\n\n- 递归逻辑：如果存在 `children` 则接着遍历\n- 设置属性使用 `el.setAttribute(key,value)` \n\t- 我们也可以使用 `el[key] = value` 的方式\n\t- 但是，**为元素设置属性比想象中的更复杂得多**\n\n下面先区分 `HTML Attributes` 和 `DOM Properities`\n\n### 6.2. `HTML Attributes` 和 `DOM Properities` 不一样\n\n浏览器解析完以下 `HTML代码段` 后，会创建以之相符的 `DOM 元素对象` ，比如\n- `id=\"app\"` 对应 `el.id`\n- `class=\"green\"` 对应 `el.className` ，说明两者并不是一一对应的。\n\n```html\n<div id=\"app\" class=\"green\"></div>\n\n<div data-a=\"3\" mmm=\"asdf\" draggable=\"true\"></div>\n\n<form id=\"aaa\"></form>\n```\n\n又比如下面的 HTML 片段，把 `foo` 改成 `bar`\n\n```html\n<!-- 如果 foo 改成 bar -->\n<input value=\"foo\" form=\"aaa\"/>\n```\n\n- `el.getAttribute('value')` 和 `el.defaultValue` 始终是 `foo`\n- 只有 `el.value` 为修改的值\n\n又比如修改上面 input 的 type 值： `el.type = 'xxx'` ，浏览器会矫正这个不合法的 `xxx` 为 `text`\n\n> [!abstract]\n> \n**综上：** `HTML Attributes` **是为** `DOM Properities`**设置**`初始值`**的**\n\n### 6.3. 如何正常正常的设置属性\n\n比如如下 `vnode` \n- `disabled` 需要处理成 布尔值\n\n```js\nconst vnode = {\n  type: 'button',\n  props: {\n    disabled: '' // 需要处理成 false \n  },\n  children: 'Button'\n}\n```\n\n```js\n// form 是只读的，只能通过 setAttribute 来设置\nfunction shouldSetAsProps(el, key, value) {\n  if (key === 'form' && el.tagName === 'INPUT') return false\n  return key in el\n}\n\n// 省略了很多逻辑\nif (vnode.props) {\n  for (const key in vnode.props) {\n\tpatchProps(el, key, null, vnode.props[key])\n  }\n}\n\n// 下面是传入的 patchProp 的场景\npatchProps(el, key, preValue, nextValue) {\n    if (shouldSetAsProps(el, key, nextValue)) {\n      const type = typeof el[key];\n      // 兼容 el.disabled = false 这种情况, 以及 el.disabled = '' 这种情况\n      if (type === 'boolean' && nextValue === '') {\n        el[key] = true\n      } else {\n        el[key] = nextValue\n      }\n    } else {\n      el.setAttribute(key, nextValue)\n    }\n  }\n```\n\n上面代码展示了如何正确设置属性，即根据不同的标签类型，使用不同的设置属性的方法，另外需要关注下更新前后的值，如 `preValue, nextValue`\n\n> 上面代码只展示了关键逻辑部分\n\n## 7. `class属性` 与 `style属性` 的处理\n\n如下节点，我们希望挂载子节点的 class 属性，并且做增强\n\n```js\nconst vnode = {\n  type: 'p',\n  props: {\n    class: 'foo bar baz',\n    class: {'foo': true},\n    class: ['foo bar baz','abc'],\n  },\n  children: 'text'\n}\n```\n\n主要逻辑如下：\n\n```js\n  patchProps(el, key, preValue, nextValue) {\n    //************** here 这里  ************//\n    if (key === 'class') {\n      el.className = nextValue\n    } else if (shouldSetAsProps(el, key, nextValue)) {\n      const type = typeof el[key]\n      if (type === 'boolean' && nextValue === '') {\n        el[key] = true\n      } else {\n        el[key] = nextValue\n      }\n    } else {\n      el.setAttribute(key, nextValue)\n    }\n  }\n```\n\n- 这里为什么要使用 `className` ，而不是 `el.classList` 和`setAttribute('class','xxxx')` \n\t- 因为`性能更优` \n\n另外，vue 也对 `style` 属性做了些增强，支持 `对象和字符串` \n\n## 8. 如何卸载一个节点\n\n前面，我们自己通过 `InnerHTML` 的方式来卸载，有以下问题\n\n1. 这个组件可能由多个组件组成，`没办法细粒度的控制每个组件的卸载`，即不能正确调用 `钩子生命周期函数`，如 `beforeUnmount` 或者 `unmounted` 等\n2. 有些元素存在`指令`，卸载时，应该正确执行对应的 `指令钩子函数`\n3. 没法正确移除 DOM 上绑定的`事件`\n\n所以，我们需要通过以下方式来实现：\n\n```js hl:6\nfunction unmount(vnode) {\n    const parent = vnode.el.parentNode\n    if (parent) {\n        parent.removeChild(vnode.el)\n    }\n    // 在这里，我们可以调用该节点树下的指令钩子函数 和 生命周期函数\n}\n\nfunction render(vnode, container) {\n    if (vnode) {\n        patch(container._vnode, vnode, container)\n    } else {\n        if (container._vnode) {\n            // 旧 vnode 存在，且新 vnode 不存在，说明是卸载(unmount)操作\n            unmount(container._vnode)\n        }\n    }\n    // 把 vnode 存储到 container._vnode 下，即 后续渲染中的旧 vnode\n    container._vnode = vnode\n}\n```\n\n单独提出 `unmount` ，好处是：我们可以调用该节点树下的指令钩子函数 和 生命周期函数\n\n>[!info]  \n其实，卸载时，真正还有很多事情要搞，比如遍历 `虚拟 DOM树节点`，`递归卸载`子元素等等，这里只是给了一个简单的说明\n\n## 9. 为什么要区分 vnode 的 类型 ?\n\n看下面一个例子：\n\n```js\nconst vnode = {\n    type: 'p',\n    props: {\n        class: 'foo bar baz'\n    },\n    children: 'text'\n}\nrenderer.render(vnode, document.querySelector('`#app'))`\n\nconst newVnode = {\n    type: 'div',\n    props: {\n        id: 'foo'\n    },\n    children: 'hello'\n}\n\nsetTimeout(() => {\n    renderer.render(newVnode, document.querySelector('`#app'))`\n}, 1000);\n```\n\n我们发现 `vnode` 的 `type` 值都发生变化了，由 `p` 变成 `div` ，这个时候，还需要`打补丁`吗？\n- 是的\n\t- ① 应该先把 `p 挂载` \n\t- ②  然后再将 `div 挂载`\n- 如下代码：\n\n```js hl:2,7,15 \nfunction patch(n1, n2, container) {\n    // 类型不同，直接卸载\n    if (n1 && n1.type !== n2.type) {\n        unmount(n1);\n        n1 = null\n    }\n    // 挂载新的 vnode \n    const {type} = n2\n    if (typeof type === 'string') {\n        if (!n1) {\n            mountElement(n2, container)\n        } else {\n            patchElement(n1, n2)\n        }\n    // 如果是 Object ，需要再特殊处理,递归处理\t\n    } else if (typeof type === 'object') {\n        // 组件\n    }\n}\n```\n\n- 如果是 `Object` ， 需要调用 `mountComponent` 和 `patchComponent` 来继续`递归处理`，直到遇到`普通的标签元素`，如 `div`\n\n下面是`对具体元素打补丁`的逻辑：\n\n```js\nfunction patchElement(n1, n2) {\n    const el = n2.el = n1.el\n    const oldProps = n1.props\n    const newProps = n2.props;\n    \n    // 对【新添加的元素属性】打补丁\n    for (const key in newProps) {\n        if (newProps[key] !== oldProps[key]) {\n            patchProps(el, key, oldProps[key], newProps[key])\n        }\n    }\n    // 对 【旧的的元素属性】 打补丁\n    for (const key in oldProps) {\n        if (!(key in newProps)) {\n            patchProps(el, key, oldProps[key], null)\n        }\n    }\n}\n```\n\n## 10. 事件的处理\n\n如何给 `vnode` 绑定事件呢？比如如 `虚拟节点`\n\n```js\n\nconst vnode = {\n    type: 'p',\n    props: {\n        onClick: [\n            () => {\n                alert('clicked 1')\n            },\n            () => {\n                alert('clicked 2')\n            }\n        ]\n    },\n    children: 'text'\n}\n```\n\n我们直接来看代码实现，后面再说明为什么这么设计？\n\n```js hl:2\npatchProps(el, key, prevValue, nextValue) {\n    if (/^on/.test(key)) {\n        const invokers = el._vei || (el._vei = {})\n        let invoker = invokers[key]\n        const name = key.slice(2).toLowerCase()\n        if (nextValue) {\n            if (!invoker) {\n                invoker = el._vei[key] = (e) => {\n                    if (Array.isArray(invoker.value)) {\n                        invoker.value.forEach(fn => fn(e))\n                    } else {\n                        invoker.value(e)\n                    }\n                }\n                invoker.value = nextValue\n                el.addEventListener(name, invoker)\n            } else {\n                invoker.value = nextValue\n            }\n        } else if (invoker) {\n            el.removeEventListener(name, invoker)\n        }\n    } else if (key === 'class') {\n        \n    } else if (shouldSetAsProps(el, key, nextValue)) {\n        \n    } else {\n        \n    }\n}\n})\n```\n\n说明：\n- `on` 开头的属性才需要处理\n\t- `invokers：事件处理函数` 用于处理事件回调函数\n\t- 真正的事件 callback 存在 `invokers.value` 中\n- 问：为什么要这样，\n\t- 解决性能问题，比如更新事件时，直接更新 `invokers.value` 即可，没必要每次都调用 `removeEventListener` 来移除上一次绑定的事件？\n\t- `el._vei[key]` 中存储着**所有事件信息**，它的数据结构可能是一个**数组**，比如同一事件如 `click` 有多个回调callback，所以才有 `invoker.value.forEach(fn => fn(e))`\n\t- 它还能解决`事件冒泡`和`更新相互冲突`的问题，见下面：\n\n## 11. 事件冒泡与更新时机问题\n\n看如下代码：\n\n```js\nconst {effect, ref} = VueReactivity\nconst bol = ref(false)\n\neffect(() => {\n    const vnode = {\n        type: 'div',\n        props: bol.value ? {\n            onClick: () => { \n                alert('父元素 clicked')\n            }\n        } : {},\n        children: [\n            {\n                type: 'p',\n                props: {\n                    onClick: () => {\n                        bol.value = true\n                    }\n                },\n                children: 'text'\n            }\n        ]\n    }\n    renderer.render(vnode, document.querySelector('`#app'))`\n})\n```\n\n一开始 `bol` 为 `false`， \n- 所以 `div` 没有回调事件 ， `p` 有回调 ， 所以 `正常预期` 是 点击 `p 元素`，冒泡到 `div` , 不 `alert`。\n- 但是，竟然执行了，为什么呢？\n\t- 因为 `bol 是响应数据`， 变化了会导致 副作用执行，然后就给 div 绑定了事件；\n\n如何解决呢？符合正常预期。如下代码：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202305252000226.png)\n\n即，屏蔽所有`绑定时间 晚于 真正执行时间`的执行 。\n\n## 12. 如何更新子节点\n\n6种情况：`【新节点、老节点】 * 【文本节点、一组节点、null】`\n\n需要在特定情况 调用 `旧节点卸载操作` 和 `新加节点的挂载操作` ，如下代码：\n\n```js\n\nfunction patchChildren(oldNode, newNode, container) {\n    // 新节点是否是文本节点\n    if (typeof newNode.children === 'string') {\n        // 老节点是仅在是是一组节点时，才需要遍历卸载\n        if (Array.isArray(oldNode.children)) {\n            oldNode.children.forEach((c) => unmount(c))\n        }\n        setElementText(container, newNode.children)\n    // 新节点是一组节点\n    } else if (Array.isArray(newNode.children)) {\n        // 老节点是一组节点\n        if (Array.isArray(oldNode.children)) {\n            oldNode.children.forEach(c => unmount(c))\n            newNode.children.forEach(c => patch(null, c, container))\n        } else {\n            setElementText(container, '')\n            newNode.children.forEach(c => patch(null, c, container))\n        }\n    } else {\n        if (Array.isArray(oldNode.children)) {\n            oldNode.children.forEach(c => unmount(c))\n        } else if (typeof oldNode.children === 'string') {\n            setElementText(container, '')\n        }\n    }\n}\n```\n\n其实上面代码很简单粗暴，比如，如果旧节点是一组节点，简单粗暴的全部卸载，再全部挂载新节点操作；其实更好的方式是 `使用 Diff 算法，最大可能利用`，以提高性能。\n\n## 13. 文本节点与注释节点\n\n- **文本节点**：用于表示纯文本。\n- **注释节点**：用于在HTML中添加注释，这些注释不会显示在页面上但可能对开发者有帮助。\n- 如何使用 `vnode` 描述真实场景中的 `文本节点` 与 `注释节点` ？\n\t- 答案是：使用 `Symbol()` ，如下代码：\n\t\t- 使用 Symbol 的原因：\n\t\t    - Symbol 是 JavaScript中的一种基本数据类型，用于**创建唯一的标识符**。\n\t\t    - 通过使用 Symbol，我们可以创建独特的标识来代表**文本节点**和**注释节点**。\n\t\t- 使用 Symbol 的**优势** ，我们可以清晰且安全地在虚拟DOM中定义和区分不同类型的节点\n\t\t\t- 统一的节点表示方式\n\t\t\t- 清晰的类型区分\n\t\t\t- 易于在渲染过程中进行特殊处理\n\n```js\nconst Text = Symbol();\nconst Comment = Symbol();\n\nconst vnode1 = {\n  type: Text,\n  children: 'Some Text'\n}\n\nconst vnode2 = {\n  type: Comment,\n  children: 'Some Comment'\n}\n```\n\n然后根据具体节点类型，在挂载、更新、卸载等操作时根据具体情况处理即可。\n\n## 14. Fragment\n\n存在的意义是什么 ？ 其实就是类似于React 的 `<></>` 和 `<fragment>`\n\n如下 vnode ：\n\n```js\nconst Fragment = Symbol()\nconst newVnode = {\n  type: 'div',\n  children: [\n    {\n      type: Fragment,\n      children: [\n        { type: 'p', children: 'text 1' },\n        { type: 'p', children: 'text 2' },\n        { type: 'p', children: 'text 3' }\n      ]\n    },\n    { type: 'section', children: '分割线' }\n  ]\n}\n```\n\n**在挂载、更新、卸载操作是，不处理它本身，只处理它的子节点即可**\n","c80f89e649b95ceeb658a4c8f72146c0":"\n# Vue3 组件的实现原理\n\n\n`#vue` `#vue3` `#2023/06/10` `#vue原理`\n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n### 1.1. 摘要\n\n本文详细介绍了Vue3组件的实现原理，包括渲染器、组件和虚拟DOM之间的关系，组件状态的保存和更新机制，组件实例和生命周期的实现，props的处理，setup函数的作用，组件事件和emit的实现，插槽的工作原理，以及生命周期的注册方法。文章深入探讨了Vue3组件系统的核心概念和内部机制，为理解Vue3的工作原理提供了全面的视角。\n\n### 1.2. 关键点\n\n- 渲染器根据vdom类型判断是否为组件，并使用mountComponent或patchComponent进行挂载和更新。\n- 组件状态：通过`data()`保存，并使用reactive使其成为响应式数据。\n- 组件实例：是一个对象，存储组件运行过程的所有信息，包括状态、props、生命周期等。\n- props机制：需要编写大量边界代码，并通过渲染上下文对象暴露数据。\n- setup函数：为组合式API设计，可返回**渲染函数**或**数据对象**。\n- emit函数：用于发射组件自定义事件，v-on指令绑定的事件会存储在props对象中。\n- 插槽内容：被编译为插槽函数，`<slot>`标签被编译为插槽函数的调用。\n- 生命周期函数通过onMounted等方法注册，存储在组件实例的相应数组中。\n\n## 2. 渲染器、组件与 vdom 之间的关系\n\n前文  【1. Vue3 的渲染器原理】 实现了对单个 `vdom` 的渲染，比如对下面 `vdom` 的渲染：\n\n```js\nconst Fragment = Symbol()\nconst newVnode = {\n  type: 'div',\n  children: [\n    {\n      type: Fragment,\n      children: [\n        { type: 'p', children: 'text 1' },\n        { type: 'p', children: 'text 2' },\n        { type: 'p', children: 'text 3' }\n      ]\n    },\n    { type: 'section', children: '分割线' }\n  ]\n}\n```\n\n但实际页面，会包括很多 `vdom` 甚至是各种嵌套的 `vdom`\n\n那么，**如何使用** `vdom` **来描述页面，描述 UI 呢？**\n\n这里直接给出答案：如下结构\n\n```js\nconst C1 = {\n    name: 'C1',\n    render() {\n        return {\n            type: 'div',\n            children: [\n                { type: 'p', children: 'text 1' },\n                { type: 'p', children: 'text 2' },\n                { type: 'p', children: 'text 3' }\n            ]\n        }\n    }\n}\n```\n\n两个要点：\n\n- ①  包含 `render` 函数\n- ②  `return` 一个 `vnode`\n\n下图展示了 `渲染器、组件 、 vnode 的关系` , **很重要，打开看看**\n- [figjam](https://www.figma.com/file/hT9k2YbVvV1UIITtUmbJ0C/2023.05.LOG?type=whiteboard&node-id=201-996&t=x2AAJuGlw9iHBGmM-4)\n\n- 总结下就是，渲染器会根据 vdom 的类型\n\t- 是字符串\n\t- 是文本类型（Symbol）\n\t- 是 Fragment\n\t- 是对象或者函数\n\t\t- 来判断它是否是否是`组件`，\n\t\t\t- 如果是，则会继续递归使用 `mountComponent` 或者 `patchComponent`来完成组件的挂载和更新\n\t\t\t- 部分代码如下：\n\n```js\nif (typeof type === 'string') {\n    if (!n1) {\n        mountElement(n2, container, anchor)\n    } else {\n        patchElement(n1, n2)\n    }\n} else if (type === Text) {\n    if (!n1) {\n        const el = n2.el = createText(n2.children)\n        insert(el, container)\n    } else {\n        const el = n2.el = n1.el\n        if (n2.children !== n1.children) {\n            setText(el, n2.children)\n        }\n    }\n} else if (type === Fragment) {\n    if (!n1) {\n        n2.children.forEach(c => patch(null, c, container))\n    } else {\n        patchChildren(n1, n2, container)\n    }\n} else if (typeof type === 'object' || typeof type === 'function') {\n    // component\n    if (!n1) {\n        mountComponent(n2, container, anchor)\n    } else {\n        patchComponent(n1, n2, anchor)\n    }\n}\n```\n\n## 3. 如何保存组件状态，以及状态改变了同步更新组件\n\n如果保存组件状态呢？答案是 `data()` ，并且需要让 data 数据是响应式的，所以代码应该如下\n\n```js\nconst state = data ? reactive(data()) : null\n```\n\n所以，每次更新 data ，会重新渲染，但是浏览器渲染是`同步任务`，所以需要有个**调度器**来调度，它通过`promise` 实现了一个`微任务队列`，避免重复渲染，去重任务队列等。\n\n关于调度器微任务队列的实现，更多参考 【3. Vue3 的响应式的系统设计原理】\n\n部分代码如下：注意下面的 `scheduler`\n\n```js\n const state = data ? reactive(data()) : null\n effect(() => {\n    const subTree = render.call(renderContext, renderContext)\n}, {\n    scheduler: queueJob\n})\n```\n\n## 4. 组件实例与组件的生命周期\n\n- **组件实例**，本质就是一个对象，**存储着组件运行过程的所有信息**，比如\n\t- 组件状态\n\t- 是否卸载\n\t- 组件的子树\n\t- 插槽\n\t- 生命周期等\n- 如下代码：\n\n```js\nconst instance = {\n        state,\n        props: shallowReactive(props),\n        isMounted: false,\n        subTree: null,\n        slots,\n        mounted: []\n}\n```\n\n各类生命周期，就在具体位置上添加即可，如下：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101223326.png)\n\n一个组件可能存在多个同类型的组件，比如 `mixin` 进来的组件，这时候就需要数组了。但核心原理不变\n\n## 5. props 与组件的被动更新\n\n- `副作用自更新`所引起的子组件更新叫作`子组件的被动更新`。\n- 我们需要检查是否需要真的更新\n\t- 比如 `props` 如果根本就没变？\n\t- 如果需要更新，需要同步更新子组件的 `props` 、`slots` 等内容\n\t- 其实要 **完善 vue 中的 props 机制，需要编写大量的边界代码**\n\n由于 props 数据与组件自身的状态数据都需要暴露到`渲染函数`中，并使得渲染函数能够通过 this 访问它们，因此我们需要封装一个`渲染上下文对象（renderContext）`， 它实际上是组件实例的代理对象。在渲染函数内访问组件实例所暴露的数据都是通过该代理对象实现的。\n\nvue 中，没有在 `props 选项`中的 props 数据都将存储到 `attrs` 对象中\n\n## 6. setup 函数的作用 与 实现\n\n`setup` 函数，它只会在挂载时执行一次，该函数是为了`组合式 API` 而生的，==所以我们要避免将其与 `Vue.js 2 中的“传统”组件选项（如 methods watch data）` 混合使用。==\n\n`setup` 函数的返回值可以是**两种类型**\n- 如果返回`函数`，则**将该函数作为组件的渲染函数**；\n- 如果返回`数据对象`，则将该对象暴露到渲染上下文中，暴露给模板使用。\n\n```js\nconst InnerComp = {\n    name: 'InnerComp',\n    /**\n     * expose: 暴露给父组件的属性\n     * */\n    setup(props, {emit, slots,attrs,expose}) {\n        const count = ref(0);\n        // 返回一个【数据对象】\n        return {\n            count,\n        }\n        // 返回一个【渲染函数】\n        return () => ({\n            type: 'span',\n            children: 'inner'\n        })\n    }\n}\n```\n\n## 7. 组件事件与 emit\n\n- emit 函数包含在 `setupContext 对象`中，可以通过 emit 函数 发射组件的自定义事件。\n- 通过 `v-on` 指令为组件绑定的事件在经过`编译`后，会以 `onXxx` 的形式存储到 `props 对象`中。\n- 当 emit 函数执行时，会在 **props 对象中寻找对应的事件处理函数**并执行它。\n\n## 8. 插槽 slot\n\n它借鉴了 Web Component 中 `<slot> 标签`的概念。\n- **插槽内容会被编译为插槽函数，插槽函数的返回值就是向槽位填充的内容**。\n- `<slot>` 标签则会被编译为插槽函数的调用，通过执行对应的**插槽函数**，得到外部向槽位填充的内容（即虚拟 DOM），最后将该内容渲染到`槽位`中。\n\n我们以 `MyComponent` 组件为例，它的模板如下：\n\n![|376](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101327730.png)\n\n上面的代码会**编译**成如下：\n\n![|328](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101329712.png)\n\n具体使用 `MyComponent` 组件\n\n![|288](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101327662.png)\n\n上面的模板，会编译成如下`渲染函数`：\n\n![|512](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101328116.png)\n\n**插槽的实现是不是和 React render props 的概念很像？**，如下图：\n\n![|464](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101333060.png)\n\n## 9. 注册生命周期\n\n先看代码，下面注册两个 `onMounted` ，它会被放到一个数组中。\n\n![|424](https://od-1310531898.cos.ap-beijing.myqcloud.com/202306101337074.png)\n\n- 通过 `onMounted` 注册的生命周期函数会被注册到**当前组件实例**的**instance.mounted 数组**中。\n- 为了维护当前正在初始化的**组件实例**，我们定义了`全局变量currentinstance`，以及用来设置该变量的 `setCurrentInstance` 函数。\n- 其他生命周期同理。\n\n## 10. 最后\n\n一些具体代码实现细节，没有太抠，知道大致的原理即可，真有应用场景再仔细研究一下具体代码实现细节。\n\n## 11. 参考\n\n- 《Vue 设计与实现》","3e7117d93f3152dabb39341aab7f76c1":"\n# Vue3 的响应式的系统设计原理\n\n\n`#前端框架/vue` `#2023/03/25`  `#前端` `#vue3` \n\n\n## 目录\n<!-- toc -->\n ## 1. 总结 \n\n### 1.1. 摘要\n\n本文详细介绍了Vue3响应式系统的设计原理和实现过程。文章从副作用函数的概念出发，逐步讲解了\n- 响应式数据的实现\n- 数据结构的设计\n- 分支切换问题的解决\n- effect函数嵌套的处理\n- 调度系统的实现\n- 计算属性的原理\n- watch函数的实现\n\n文章通过循序渐进的方式，展示了Vue3响应式系统从简单到复杂的演进过程，并提供了大量代码示例来解释各个概念和实现细节。\n\n### 1.2. 要点\n\n- 响应式数据的基本实现依赖于Proxy和副作用函数\n- 使用WeakMap、Map和Set组合的数据结构来存储依赖关系\n- 通过cleanup函数解决分支切换问题\n- 使用effectStack来处理effect函数的嵌套问题\n- 实现调度系统来控制副作用函数的执行时机和次数\n- 计算属性的实现基于lazy执行和缓存机制\n- watch函数的实现涉及递归遍历对象属性和处理竞态问题\n\n## 2. 何为副作用函数？\n\n如修改了全局变量等\n\n> 更多参考 【什么是副作用】\n\n## 3. 为何响应式数据？\n\n如下代码，希望 `data.text` 值改变时，会自己执行 `effect函数` ， 那么`data 数据`就是`响应式的`。\n\n```js\n// 原始数据\nconst data = { text: 'hello world' }\nfunction effect() {\n  document.body.innerText = obj.text\n}\neffect()\n```\n\n## 4. 响应式数据最简单的实现\n\n借助 `Proxy` ， 每次`读取`时，将 effect 函数存储到`桶：bucket` 中，每次`set 时`，从`桶`中取出并执行，如下代码：\n\n```js\n\n// 存储副作用函数的桶\nconst bucket = new Set()\n\n// 原始数据\nconst data = { text: 'hello world' }\n// 对原始数据的代理\nconst obj = new Proxy(data, {\n  // 拦截读取操作\n  get(target, key) {\n    // 将副作用函数 effect 添加到存储副作用函数的桶中\n    bucket.add(effect)\n    // 返回属性值\n    return target[key]\n  },\n  // 拦截设置操作\n  set(target, key, newVal) {\n    // 设置属性值\n    target[key] = newVal\n    // 把副作用函数从桶里取出并执行\n    bucket.forEach(fn => fn())\n  }\n})\n\nfunction effect() {\n  document.body.innerText = obj.text\n}\neffect()\n```\n\n但上面的方式缺点是`硬编码`了 `effect`\n\n## 5. 解决 硬编码 `effect` 函数的问题\n\n思路是，`effect(fn)` 传入一个函数，标识注册副作用函数 `fn` ,\n- 并使用全局变量 `activeEffect` 来存储 `当前激活的 effect 函数`\n\n```js hl:25\n// 存储副作用函数的桶\nconst bucket = new Set()\n\n// 原始数据\nconst data = { text: 'hello world' }\n// 对原始数据的代理\nconst obj = new Proxy(data, {\n  // 拦截读取操作\n  get(target, key) {\n    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\n    bucket.add(activeEffect)\n    // 返回属性值\n    return target[key]\n  },\n  // 拦截设置操作\n  set(target, key, newVal) {\n    // 设置属性值\n    target[key] = newVal\n    // 把副作用函数从桶里取出并执行\n    bucket.forEach(fn => fn())\n  }\n})\n\n\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\nfunction effect(fn) {\n  // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n  activeEffect = fn\n  // 执行副作用函数\n  fn()\n}\n\neffect(() => {\n  console.log('effect run')\n  document.body.innerText = obj.text\n})\n\nsetTimeout(() => {\n  obj.text2 = 'hello vue3'\n}, 1000)\n```\n\n但是，上面代码如果我们设置不存在的属性时，如 `obj.noExist = 'hello '` , `传入的effect` 中的 `fn` 会**执行两次**\n\n所以，`副作用函数`需要与`目标字段` 建立映射，所以我们需要重新设计数据结构\n\n## 6. 重新设计数据结构\n\n解决上面设置不存在的属性时也执行问题，可以**重新设计数据结构**\n\n如下代码：\n\n```js\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\nfunction effect(fn) {\n    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n    activeEffect = fn\n    // 执行副作用函数\n    fn()\n}\n\nconst obj = { text1: 'text1', text2: 'text2' };\nconst obj2 = { text1: 'text1', text2: 'text2' };\n\neffect(function fn1() {\n    console.log(obj.text1);\n})\n\neffect(function fn2() {\n    console.log(obj.text2);\n    console.log(obj.text1);\n})\n\n/*************************************************\n * :::: 以上代码的映射关系如下\n * obj\n *  text1: [fn1,fn2]\n *  text2: [fn2]\n ************************************************/\n\neffect(function fn3() {\n    console.log(obj.text1);\n    console.log(obj.text2);\n})\n/*************************************************\n * :::: 以上代码的映射关系如下\n * obj\n *  text1: [fn3]\n *  text2: [fn3]\n ************************************************/\n\neffect(function fn1() {\n    console.log(obj.text1);\n})\n\neffect(function fn2() {\n    console.log(obj2.text2);\n    console.log(obj.text1);\n})\n\n/*************************************************\n * :::: 以上代码的映射关系如下\n * obj\n *   text1: [fn1,fn2] \n * obj2\n *   text2: [fn2]\n ************************************************/\n```\n\n结构如下：\n\n- `WeakMap`\n\t- `key` 为 `obj` 或者 `obj1` 对象\n\t- `value` 为 `Map`\n\t\t- `key` 为 字段名，如 `text1` ,`text2`\n\t\t- `value`为 `Set` ，比如上面的 `fn1` `fn2`\n\n如下图：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081112785.png)\n\n### 6.1. 为什么要使用 WeakMap？\n\n```js\nconst weakMap = new WeakMap();\nconst map = new Map();\n\n(function () {\n    let w = {w: \"w\"};\n    let m = {m: \"m\"};\n    weakMap.set(w, 1);\n    map.set(m, 2);\n    console.log(weakMap);\n    console.log(map);\n    w = null;\n    m = null;\n})()\n\n// 这 5s的时间，weakMap 会被回收，而 map 不会，因为 map 的 key 是强引用，不会被回收\n// chrome performance 手动触发垃圾回收\nsetTimeout(() => {\n    console.log(weakMap);\n    console.log(map);\n}, 5000);\n```\n\n手动触发垃圾回收机制：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081153881.png)\n\n最终打印打印结果如下：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081151462.png)\n\n所以，结论就是：使用 `WeakMap` 能够保证 `GC`，不会像 `Map` 那个强引用导致`内存溢出`\n\n### 6.2. 最终代码\n\n**最终代码如下**：封装 `track(targe,key)` 和 `trigger(targe,key)`\n\n```js\n// 存储副作用函数的桶\nconst bucket = new WeakMap()\n// 原始数据\nconst data = { text: 'hello world' }\n// 对原始数据的代理\nconst obj = new Proxy(data, {\n  // 拦截读取操作\n  get(target, key) {\n    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\n    track(target, key)\n    // 返回属性值\n    return target[key]\n  },\n  // 拦截设置操作\n  set(target, key, newVal) {\n    // 设置属性值\n    target[key] = newVal\n    // 把副作用函数从桶里取出并执行\n    trigger(target, key)\n  }\n})\n\nfunction track(target, key) {\n  let depsMap = bucket.get(target)\n  if (!depsMap) {\n    bucket.set(target, (depsMap = new Map()))\n  }\n  let deps = depsMap.get(key)\n  if (!deps) {\n    depsMap.set(key, (deps = new Set()))\n  }\n  deps.add(activeEffect)\n}\n\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key)\n  effects && effects.forEach(fn => fn())\n}\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\nfunction effect(fn) {\n  // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n  activeEffect = fn\n  // 执行副作用函数\n  fn()\n}\n\neffect(() => {\n  console.log('effect run')\n  document.body.innerText = obj.text\n})\n\nsetTimeout(() => {\n  trigger(data, 'text')\n}, 1000)\n```\n\n>[!tip]  \n其实如何能够梳理清楚这个数据结构，那么就容易写出代码，所以也不用抠代码细节，真正需要自己使用即可！\n\n## 7. 分支切换问题\n\n即使用**三元符号**时，如何避免不必要的执行？\n\n如下代码：\n\n```js\neffect(() => {\n  console.log('effect run')\n  document.body.innerText = obj.ok ? obj.text : 'not'\n})\n```\n\n根据上面，我们知道关系如下：\n\n- obj\n\t- ok\n\t- fn\n- text\n\t- fn\n\n所以，当 `text` 值改变时，必然会导致 `fn` 重新执行 ，但其实当`ok` 为 `false` 时，无论 `text` 如何变化，我们不希望 `fn` 重新执行。如何解决呢？\n\n解决方案是 **每次副作用函数执行之前，清除上一次建立的关系**。\n\n重新设计结构，`effect.deps` 用来存储 `所有与该副作用函数相关的依赖集合` ，如下代码：\n\n```js\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\nfunction effect(fn) {\n  const effectFn = () => {\n    cleanup(effectFn)\n    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n    activeEffect = effectFn\n    fn()\n  }\n  // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合\n  effectFn.deps = []\n  // 执行副作用函数\n  effectFn()\n}\n\n// 每次都会清除\nfunction cleanup(effectFn) {\n  for (let i = 0; i < effectFn.deps.length; i++) {\n    const deps = effectFn.deps[i]\n    deps.delete(effectFn)\n  }\n  effectFn.deps.length = 0\n}\n```\n\n下面看 `trigger` 函数：\n\n```js\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key);\n  // here ，这里出现无限循环\n  effects && effects.forEach(effectFn => effectFn())\n}\n```\n\n但是，上面的代码会出现无限循环，原因类似于下面的代码：\n\n```js\nconst set = new Set([1])\nset.forEach(item => {\n  set.delete(1)\n  set.add(1)\n  console.log(999)\n})\n```\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304081406196.png)\n\n解决方案：**新的变量** `newSet`\n\n```\nconst set = new Set([1])\nconst newSet = new Set(set)\nnewSet.forEach(item => {\n  set.delete(1)\n  set.add(1)\n  console.log(999)\n})\n```\n\n所以最终 `trigger` 代码：创建`新的变量` `effectsToRun`\n\n```js\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key)\n\n  const effectsToRun = new Set()\n  effects && effects.forEach(effectFn => effectsToRun.add(effectFn))\n  effectsToRun.forEach(effectFn => effectFn())\n  // effects && effects.forEach(effectFn => effectFn())\n}\n```\n\n## 8. Effect 函数嵌套的场景\n\n### 8.1. 先说说为什么要支持嵌套\n\n因为 `jsx` 天然需要支持嵌套，如下代码：\n\n```js\nconst Foo = {\n    render() {\n        return h('div', 'foo')\n    }\n}\n\nconst Bar = {\n    render() {\n        return h(Foo, 'bar')\n    }\n}\n```\n\n### 8.2. 现有 `effect` 函数不支持嵌套\n\n如下代码：\n\n```js\nlet temp1, temp2\n\neffect(function effectFn1() {\n  console.log('1')\n  effect(function effectFn2() {\n    console.log('2')\n    temp2 = obj.bar\n  })\n  temp1 = obj.foo\n})\n\n// obj.foo之前的值为 true\nsetTimeout(() => {\n    obj.foo = false\n}, 5000);\n```\n\n我们修改 `obj.foo` , 预期是：\n\n- 输出 `1 2 1` , 因为 obj.foo 修改导致 `fn1` 的执行，打印 `1`，`fn2` 嵌套在 `fn1` 里，所以还会执行`fn2` 打印出 `2`，5s 后，值`obj.foo`改变了，导致 `fn1` 执行，打印出 `2`\n\n但实际上是 `1 2 2`\n\n原因是：发生嵌套时，内层激活的 `activeEffect` 会覆盖`外层的副作用函数`，所以最终执行的都是`内层副作用函数`\n\n### 8.3. 解决思路：副作用函数栈 `efectStack`\n\n如下代码：\n\n```js\n// 用一个全局变量存储当前激活的 effect 函数\nlet activeEffect\n// effect 栈\nconst effectStack = []\nfunction effect(fn) {\n  const effectFn = () => {\n    cleanup(effectFn)\n    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect\n    activeEffect = effectFn\n    // 在调用副作用函数之前将当前副作用函数压栈\n    effectStack.push(effectFn)\n    fn()\n    // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈\n    // 并还原 activeEffect 为之前的值\n    effectStack.pop()\n    activeEffect = effectStack[effectStack.length - 1]\n  }\n  // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合\n  effectFn.deps = []\n  // 执行副作用函数\n  effectFn()\n}\n```\n\n## 9. 新的问题：无限递归循环\n\n如下代码，会引起 `栈溢出`\n\n```js\neffect(() => {\n    obj.foo++;\n})\n```\n\n因为 `obj.foo 同时读取和设置` ，从而导致无限递归循环。\n\n因为读取和操作是在同一个副作用函数中，进行的。所以可以增加`守卫条件`： **trigger 触发的副作用函数和当前执行的副作用函数，是一个函数，则不执行。**\n\n```js\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key)\n  const effectsToRun = new Set()\n  effects && effects.forEach(effectFn => {\n    // 守卫条件\n    if (effectFn !== activeEffect) {\n      effectsToRun.add(effectFn)\n    }\n  })\n  effectsToRun.forEach(effectFn => effectFn())\n}\n```\n\n## 10. 响应式系统的调度\n\n所谓`调度`，即 `trigger` 重新触发副作用函数时，能够决定执行的时机，次数等`自定义行为`。\n\n### 10.1. 例子 1\n\n以下执行顺序是：`1 ，2 ，end...`\n\n```js\nconst data = {foo: 1};\nconst obj = new Proxy(data, {});\n\neffect(() => {\n    console.log(obj.foo);\n})\n\nobj.foo++;\nconsole.log('end...');\n// ::::顺序是：1 ，2 ，end... \n```\n\n如果我们希望顺序变成了：`1 ，end... ，2` 呢？？？\n\n**解法方法是**：给 `effect` 函数添加一个 `options` 参数\n\n```js\nfunction trigger(target, key) {\n  const depsMap = bucket.get(target)\n  if (!depsMap) return\n  const effects = depsMap.get(key)\n\n  const effectsToRun = new Set()\n  effects && effects.forEach(effectFn => {\n    if (effectFn !== activeEffect) {\n      effectsToRun.add(effectFn)\n    }\n  })\n  effectsToRun.forEach(effectFn => {\n      // ::::新增代码::::\n    if (effectFn.options.scheduler) {\n      effectFn.options.scheduler(effectFn)\n    } else {\n      effectFn()\n    }\n  })\n}\n```\n\n修改上面例子代码如下：\n\n```js\nconst data = {foo: 1};\nconst obj = new Proxy(data, {});\n\neffect(\n    () => {\n        console.log(obj.foo);\n    },\n    {\n        scheduler: (fn) => {\n            setTimeout(fn, 0);\n        }\n    }\n);\n\nobj.foo++;\nconsole.log('end...');\n\n// ::::顺序就可以变成 1 ，end... ，2\n```\n\n### 10.2. 示例 2\n\n如下代码\n\n```js\nconst data = {foo: 1};\nconst obj = new Proxy(data, {});\n\neffect(\n    () => {\n        console.log(obj.foo);\n    }\n);\n\nobj.foo++;\nobj.foo++;\nobj.foo++;\nobj.foo++;\n\n// ::::顺序： 1 2 3 4 5 \n```\n\n如果我只打印 `初始值` 和 `最终值`呢？其实就有点类似于 **React 中的 setState 多次或者 Vue 中的连续改变响应式数据。**\n\n#### 10.2.1. 微任务队列\n\n所以，关键是 需要`实现一个微任务队列，并去重，并且如何保证一个微任务队列里，只执行一次`，如下代码：\n\n```js\nconst jobQueue = new Set()\nconst p = Promise.resolve()\n// 标识是否正在刷新微任务队列，\n// 如果正在刷新，则不再执行 flushJob，所以一个事件循环中只会执行一次 flushJob\nlet isFlushing = false\n// 利用 promise ，保证 flushJob 在一个事件循环中只执行一次\nfunction flushJob() {\n  if (isFlushing) return\n  isFlushing = true;\n  // 将一个函数添加到微任务队列中\n  p.then(() => {\n    jobQueue.forEach(job => job())\n  }).finally(() => {\n    isFlushing = false\n  })\n}\n\neffect(() => {\n  console.log(obj.foo)\n}, {\n  scheduler(fn) {\n    // 使用 Set 来去重\n    jobQueue.add(fn);\n    // 刷新微任务队列\n    flushJob()\n  }\n})\n```\n\n## 11. 计算属性 `computed` 与 `lazy`\n\n### 11.1. 懒执行\n\n以下代码是立即执行的，如何实现代码 `lazy 执行` 呢？如下代码：\n\n```js\nconst data = {foo: 1};\nconst obj = new Proxy(data, {});\neffect(\n    () => {\n        console.log(obj.foo); // ::::立即执行\n    }\n);\n```\n\n添加 `options.lazy = true`, 使得 `effect` 不会立即执行 ? 如下代码：\n\n```js\neffect(\n    () => {\n        console.log(obj.foo); // ::::不立即执行\n    },\n    // ::::options.lazy = true 时不立即执行\n    {lazy: true}\n);\n```\n\n改造 `effect函数` 代码如下：\n\n![|536](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091113904.png)\n\n但是，上面的代码，仅仅能够`手动执行` ，如下代码：\n\n![|496](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091118724.png)\n\n如果 `fn` 为 `getter函数`呢？ 如下：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091121697.png)\n\n上面代码能否再抽象成 `computed` ? 这就引出了 `computed`\n\n### 11.2. `computed` 计算属性\n\n- 计算属性的 `懒计算`，即 `只有读取时，才会计算`\n- 另外，多次读取一个属性时，还需要做到 `缓存`，避免`多次计算`，通过脏变量 `dirty`来标识，类似于 Angular 的概念。\n- 类似于 Vue ， 如果`计算属性发生变化会重新触发渲染` ， 但是如果一个计算属性依赖另外一个计算属性时，会发生 `effect 嵌套`，所以，每次读取计算属性时，需要`手动触发 trigger 追踪`\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091154769.png)\n\n所以，上面的代码会建立响应联动关系如下：\n\n- `computed(obj)`\n- `value`\n- `effectFn`\n\n即，你就把 `对于computed嵌套，当做是两个副作用函数的嵌套来理解`，就对了！\n\n最终代码见【undefined】 地址\n\n> [!info]  \n真正还是需要看代码去，说真的，自己手写实现完整的功能，得实现多久啊！！，这就是业务代码和真正技术代码的区别吧！\n\n>[!tip]  \n所以，**这里基本思路掌握即可，不用装牛角尖**，也不可能让你段时间内徒手写出来，需要的话就去自己看代码。\n\n## 12. `watch函数` 的实现原理\n\n### 12.1. 简单实现\n\n通过前面我们知道，副作用函数重新执行时，`可调度` ，所以 我们把调度里，加个`回调`，就能实现，如下代码：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091223151.png)\n\n上面代码硬编码了 `source.foo` 的读取操作，更通用的解法：`递归读取对象的所有属性`\n\n### 12.2. 相对完善的实现\n\n就想想如何使用 `watch` 函数的？ 所以，需要支持一下功能：\n\n- watch 入参支持`三个`，想想是 哪三个？\n\t- `第一个`参数 支持 `getter 函数` 和 `对象`\n\t- `第二个`参数，回调函数里支持 `newVal` 和 `oldVal`\n\t- `第三个`自定义参数 `options`\n\n下面是 `watch 函数`的代码  \n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091242677.png)\n\n> [!tip]  \n注意，上面代码**高亮的部分** ，另外 `flush` 的值 `pre` 和 `post` 代表**组件更新前和更新后**，后面会涉及到具体原理，这里不深究。\n\n### 12.3. 回调的第三个参数？\n\n先看一个例子，如果 `watch` 一个 `obj 对象`，改变了就发请求，如下：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091258200.png)\n\n所以，会存在`过期的副作用函数`，`第三个参数`就是解决这种`竞态问题`的 ，以下是代码实现：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091303363.png)\n\n注意上面代码的 **高亮部分**\n\n下面是 **使用实例**：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091304118.png)\n\n所以，最终的效果如下：\n\n![](https://od-1310531898.cos.ap-beijing.myqcloud.com/202304091306983.png)\n\n## 13. 最后\n\n>[!warning]  \n强调下，这一章很难啃的，但层层递进的思想比代码本身更重要，具体如何实现，代码最终如何编写实现，远远没有理解来龙去脉重要。**最终代码都有，多些思考与理解，装牛角尖意义不大**\n\n## 14. 参考\n\n- 《Vue.js设计与实现》\n- [https://github.com/HcySunYang/code-for-vue-3-book](https://github.com/HcySunYang/code-for-vue-3-book)","1cb6970fbe18510abc0a4b336a14a4ca":"\n# 前言\n\n","f5ec65b0e05059cd90d5f75a6e38d2f8":"\n# 前言\n\n\n算法、数据结构、及 LeetCode 刷题\n","7355a99274745660b11ef03c300eae0a":"\n# 前言\n\n\n数据结构篇\n\n","386f08d4c9a25464980951770ce7ac56":"\n# 基础数据结构\n\n\n`#算法/数据结构`  `#2023/07/30` \n\n\n## 目录\n<!-- toc -->\n ## 一、数据结构的分类 \n\n数据结构可以从`逻辑结构`和`物理结构`两个维度进行分类\n\n### （一）`线性`与`非线性`：按组成数据元素之前的逻辑结构关系分类\n\n即：**数据元素之间的逻辑关系是线性的或者非线性的**， 如\n\n- 数组与链表 是`线性`的\n- 树，体现祖先与后代之间的派生关系，是`非线性`的\n- 图，由节点和边构成，反映了复杂的网络关系，也是`非线性`的\n\n具体分类如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/6aeacad0d7561d5f2597cbdc70d72f0a.png)\n\n**非线性数据结构**可以进一步被划分为 `树形结构` 和  `网状结构`。\n\n总结：按逻辑结构分类：线性与非线性\n\n> - 线性结构 ：数组、链表、队列、栈、哈希表，元素存在`**一对一**`的顺序关系。\n> - 非线性结构： \n>    - 树形结构 ：树、堆、哈希表，元素存在`**一对多**`的关系。\n>    - 网状结构 ：图，元素存在`**多对多**`的关系。\n\n### （二）连续与离散：按物理结构分类\n\n在数据结构与算法的设计中，算法所占用的`**内存峰值**`不应超过 `**系统剩余空闲内存**`；所以如果运行的程序很多并且缺少大量连续的内存空间，那么所选用的数据结构必须能够存储在**离散的内存空间内**。相反，可以存储到`**连续的内存空间**`\n\n**「物理结构」** 反映了数据在计算机内存中的**存储方式** ，如下图：\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/3bea47250c1ae6402c1c25bc35f11b05.png)\n\n> 注意上图中的 `节点指针` 与 `节点值`\n\n**所有数据结构都是基于数组、链表或二者的组合实现的**\n\n> - 基于`数组`可实现 ：栈、队列、哈希表、树、堆、图、矩阵、张量（维度的数组）等\n> - 基于`链表`可实现 ：栈、队列、哈希表、树、堆、图等。\n\n按照数据结构在初始化后，是否可对其长度进行调整，又可以分为：\n\n- **静态数据结构**，即 基于数组实现的数据结构\n- **动态数据结构**，即 基于链表实现的数据结构\n\n## 二、基本数据类型\n\n**基本数据类型**提供了数据的 **内容类型**，而 **数据结构** 提供了数据的 **组织方式**，如：\n\n```javascript\n// JavaScript 的数组数据结构 可以自由存储各种 【基本数据类型】 和 对象\nconst array = [0, 0.0, 'a', false];\n```\n\n**基本数据类型是 CPU 可以直接进行运算的类型，在算法中直接被使用**，下表列举了`**各种基本数据类型**`** **的占用空间、取值范围和默认值\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/c85e009fb908c7eb08587ad9e1633918.png)\n\n> 1、现代计算机 CPU  通常将 `1 字节`作为  `最小寻址内存单元`。因此，即使表示`布尔量`仅需 1 位（0 或 1 ）， 它在内存中通常被存储为 1 字节。\n>  \n> 2、`1 bytes = 8 bits` , 可以表示 `2^8` 个不同的数字\n\n## 三、数字编码\n\n> `1 byte` 的取值范围是 `[-128,127]` 为什么不是 `[-128,128]`？ 它 内在原因涉及到**原码、反码、补码**的相关知识\n\n### （一）原码、反码、补码\n\n- 原码： \n   - **最高位**：视为`符号位`，其中 `0` 表示正数，`1` 表示负数\n   - **其余位**：表示数字的\n- 反码： \n   - `**正数**`** **的反码与其原码相同\n   - `**负数**`** **的反码是对其原码除符号位外的所有位取反。\n- 补码： \n   - `**正数**`的补码与其原码相同\n   - `**负数**`的补码是在其反码的基础上加 `1`\n\n以上总结就是，如下图：\n\n- 正数的原码、反码、补码相同\n- 负数的原码、反码、补码需要转化 \n   - 反码：除符号位外的所有位`取反`\n   - 补码：反码的基础上加 `1`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/7a428419ec7a8b880d1accde153d13cc.png)\n\n**原码** 最直观，但数字以**补码**存到计算机中，为什么呢？这是因为**原码的 2 个局限性**\n\n1、 `负数的原码`不能直接用于运算，如 `1 + (-2)` 不应该等于 `-1` 吗 ？但使用原码计算为 `-3`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/89d0d312c18f68ae9e728e99449a621e.png)\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/23e1a2b5c9cabedd0cba022864901f61.png)\n\n2、数字`零` 的原码有 `+0` 和 `-0` 两种表示方式 ， 即 **正 0 和 负 0 的原码不同，但补码相同**\n\n### （二）为什么是 `[-128,127]` ，128 的特殊性\n\n这里，再来回答 `1 byte` 的取值范围是 `[-128,127]`  为什么不是 `[-127,127]`？\n\n因为， `[-127,127]` 区间内，所有整数的源码，反码、及补码都可以相互转化，但是 `-128` 的补码是 `1000 0000`  ，与 `+0` 的补码相同，所以计算机规定 **补码1000 0000 没有原码，它代表 -128**\n\n总之，`-128`的补码比较特殊，和 `+0` 冲突了，计算机做特殊处理。\n\n### （三）计算机所有运算都是加法\n\n**计算机内部的硬件电路主要是基于加法运算设计的**。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，从而提高运算速度；如：\n\n- 减法：如  `a - b` 其实就是 `a + (-b)`\n- 乘法和除法：可以转换为计算多次加法或减法\n\n### （四）计算机使用补码的原因\n\n我们可以总结出**计算机使用补码的原因**：基于补码表示，计算机可以用同样的**电路**和操作来处理正数和负数的加法，不需要设计特殊的硬件电路来处理减法，并且无需特别处理正负零的歧义问题。这大大简化了硬件设计，并提高了运算效率。\n\n### （五）浮点数编码：float 与 double\n\n一个违反直觉的事情：`int` 和 `float` 长度相同，都是 `4 bytes`，但 **为什么 float 的取值范围远大于 int ？** 这非常反直觉，因为按理说 float 需要表示小数，取值范围应该变小才对\n\n简单来说就是，`float` 采用了不同的表示方式。如下\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/8848b451c9932afb71fb6d460b7d6d76.png)\n\n具体的不必展开了，真有需要可以参考 [https://www.hello-algo.com/chapter_data_structure/number_encoding/`#332](https://www.hello-algo.com/chapter_data_structure/number_encoding/``#332)`\n\n> [!info]\n1、尽管浮点数 `float` 扩展了取值范围，但其副作用是牺牲了精度\n2、双精度 `double` 也采用类似 `float` 的表示方法，具体的需要再去查吧，这里点到即可\n\n## 四、字符编码\n\n### （一）ASCII 字符集\n\n「ASCII 码」是最早出现的字符集，全称为“美国标准信息交换代码” ，采用 **7 位二进制** ，所以最多能够表示 **128 个不同的字符** ，如下图\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/8163e2b24c6b4bc277ee3211f8ad877c.png)\n\n### （二）GBK 字符集\n\n- 汉字大约有近十万个\n- `GB2312` 无法处理部分的罕见字和繁体字，所以扩展得到了 **GBK 字符集**\n- ASCII 字符使用`一个字节`表示，汉字使用`两个字节`表示。\n\n### （三）Unicode 字符集、UTF-8/16/32 编码\n\n#### 1、为何需要 Unicode 字符集？\n\n如果推出一个足够完整的字符集，**将世界范围内的所有语言和符号都收录其中**，不就可以解决跨语言环境和乱码问题了吗？\n\n#### 2、UTF-8/16/32 编码\n\n- UTF-8 已成为国际上使用最广泛的 `Unicode 编码方法`。它是一种**可变长**的编码\n- 除了 `UTF-8` 之外，常见的编码方式还包括 `UTF-16` 和 `UTF-32`\n- `UTF-16` 编码：使用 2 或 4 个字节来表示一个字符\n- `UTF-32` 编码：每个字符都使用 4 个字节\n- 从**存储空间**的角度看 \n   - 使用 `UTF-8` 表示英文字符非常高效，因为它仅需 1 个字节\n   - 使用 `UTF-16` 编码某些非英文字符（例如中文）会更加高效，因为它只需要 2 个字节，而 UTF-8 可能需要 3 个字节\n- 从**兼容性**的角度看，`UTF-8` 的通用性最佳，所以许多工具和库都优先支持 `UTF-8`\n\n#### 3、各语言使用的编码情况\n\n- Java 的 `String 类型`使用 `UTF-16 编码`，每个字符占用 2 字节\n- JavaScript 和 TypeScript 的字符串使用 `UTF-16 编码`的原因与 Java 类似\n- C# 使用 `UTF-16 编码`\n- Python 3 使用一种灵活的字符串表示 ， 如 对于全部是 ASCII 字符的字符串，每个字符占用 1 个字节\n- Go 语言的 string 类型在内部使用 UTF-8 编码。Go 语言还提供了 rune 类型，它用于表示单个 Unicode 码点。\n- Rust 语言的 str 和 String 类型在内部使用 UTF-8 编码，Rust 也提供了 char 类型，用于表示单个 Unicode 码点。\n\n#### 4、文件存储或网络传输场景中\n\n**字符串在编程语言中的存储方式  和  在文件中存储或在网络中传输  是两个不同的问题**。在文件存储或网络传输中，我们一般会将字符串编码为 UTF-8 格式，以达到最优的兼容性和空间效率。\n\n## 最后：QA\n\n**1、为什么哈希表同时包含线性数据结构和非线性数据结构？**\n\n哈希表可能同时包含线性（数组、链表）和非线性（树）数据结构，比如 拉链法？\n\n**2、char 类型的长度是 1 byte 吗？**\n\n跟具体编程语言有关，比如 Java, JS, TS, C# 都采用 UTF-16 编码（保存 Unicode 码点），因此 char 类型的长度为 2 bytes 。\n\n**3、为什么出现了不同的编码字符编码，比如 ascii utf8/16/32 等 ？**\n\n`能表示更多字符`  和 `存储成本` 的 平衡；\n\n**4、如何 UTF-8 是一种可变长的编码？**  见下图：\n\n- 对于长度为 `1字节`的字符，将最高位设置为 0  、其余 7 位设置为 **Unicode 码点**，即**向下兼容了 ascii 码**\n- 剩余的对于长度为 `n字节`的字符，如下：\n- 所以说 Unicode 是一种字符集标准，本质上是给每个字符分配一个编号（称为“码点”），但  **它并没有规定在计算机中如何存储这些字符码点**\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/a643995d558c19d0971dce7138e4d274.png)\n\n**5、UTF-32 编码：每个字符都使用 4 个字节，虽然占空间，但很好理解，如下图**\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/196bc7de47e9a0e2ad3f88f18f68e88c.png)\n\n> 上图只是表达这种编码方式都有 等长字节\n\n## 参考\n\n- [https://www.hello-algo.com/chapter_data_structure/](https://www.hello-algo.com/chapter_data_structure/)\n","e30086f54e0c550082bb0259461b553a":"\n# 前言\n\n`#2024/08/11` `#算法` `#数据结构` \n\n数组与链表\n","c0c46bd89ce456c5a75fa8e9bb3efd04":"\n# 前言\n\n`#2024/08/11` `#算法` `#数据结构` \n\n栈与队列\n","31e2c462753056f7a01c0fc98c3274b1":"\n# 前言\n\n`#2024/08/11` `#算法` `#数据结构` \n\n哈希表（Hash Table）：使用哈希函数将键映射到存储桶的位置，实现快速查找。\n哈希集合（Hash Set）：一种去重集合，通常使用哈希表实现。\n","27ea20717ac258a7bbdac33f9fc6c571":"\n# 前言\n\n`#2024/08/11` `#算法` `#数据结构` ","5f6707cb7a1e5f05aecf7d2448f55097":"\n# 树的基础概念\n\n\n\n`#算法/二叉树` `#算法/树`  `#算法/数据结构` `#2023/04/18`\n\n\n## 目录\n<!-- toc -->\n ## 二叉树、满二叉树、完全二叉树 \n\n这里着重说下`完全二叉树`：\n\n- 叶子节点都在 `最底下两层`\n- 最后一层叶子节都靠`左排列`\n- 并且`除了最后一层`，其他层的节点个数都要达到最大\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/9a9462b0ae355f83607ec904d5df7553.png)\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/05dd6048d8688e6a58ef6e8518485942.png)\n\n## 堆、大顶堆、小顶堆\n\n### 堆的基本概念\n\n- `堆`是一个`完全二叉树`。\n- `堆`中 `每个节点`的值都 `大于等于（或者小于等于）`其`左右子节点`的值\n   - 大的再上面，`大顶堆`\n   - 小的再上面，`小顶堆`\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/c75df744c97e5b34e295bbd2eacaf267.png)\n\n### 堆的价值\n\n#### **大顶堆**的价值\n\n- 优先队列\n- 高效排序\n- 高效的动态中位数\n\n#### **小顶堆**的价值\n主要价值和应用：\n\n- 优先队列：小顶堆也常用于实现优先队列，支持快速获取和删除最小元素。\n- 图算法：在图算法中，小顶堆用于实现 Dijkstra 最短路径算法和 Prim 最小生成树算法，以快速找到权重最小的边或路径。\n- 合并有序列表：小顶堆可以高效地合并多个有序列表，例如用于外部排序或归并排序\n\n##### 堆的总体价值\n\n- **高效的插入和删除操作**：堆支持 `O(log n)` 的插入和删除操作，使其在需要频繁调整元素顺序的场景中非常高效。\n- **内存利用率高**：堆是一种基于数组实现的数据结构，内存利用率高，不需要额外的指针或链接。\n- 广泛应用：堆在各种算法和系统中有广泛应用，包括调度系统、内存管理、图算法、实时数据处理等。\n\n总之，堆结构因其高效的插入、删除和查找操作，在许多需要维护动态有序集合的场景中具有重要价值。\n\n### 实现一个`小顶堆`\n使用`数组`来存储，代码如下：\n\n- 关键是 `this.head = []`  来存储\n\n```javascript\nfunction swap(array, a, b) {\n    [array[a], array[b]] = [array[b], array[a]];\n}\n\nclass MinHeap {\n    constructor() {\n        // 使用数组来存储\n        this.heap = [];\n    }\n\n    // 左孩子的索引\n    getLeftIndex(index) {\n        return (2 * index) + 1;\n    }\n\n    // 右孩子的索引\n    getRightIndex(index) {\n        return (2 * index) + 2;\n    }\n\n    // 父节点的索引\n    getParentIndex(index) {\n        if (index === 0) {\n            return 0;\n        }\n        return Math.floor((index - 1) / 2);\n    }\n\n    // 返回个数\n    size() {\n        return this.heap.length;\n    }\n\n    isEmpty() {\n        return this.size() <= 0;\n    }\n\n    clear() {\n        this.heap = [];\n    }\n    // ::::小顶堆，最小的肯定在最上面\n    findMinimum() {\n        return this.isEmpty() ? null : this.heap[0];\n    }\n\n    // 插入一个值，插入的元素添加到堆底的最后，然后让其上浮到正确位置（如果大顶的话）\n    insert(value) {\n        if (value != null) {\n            const index = this.heap.length;\n            // 先放在最后一位\n            this.heap.push(value);\n            // 父节点向上移动，直到父节点小于插入的值\n            this.siftUp(index);\n            return true;\n        }\n        return false;\n    }\n\n    // 下沉，堆化，递归\n    siftDown(index) {\n        // 插入的元素的位置\n        let element = index;\n        const left = this.getLeftIndex(index);\n        const right = this.getRightIndex(index);\n        const size = this.size();\n\n        if (left < size  // base 判断\n            && this.heap[element] > this.heap[left]\n            // 如果该元素大于它的左子节点，则下沉\n        ) {\n            element = left;\n        }\n\n        if (right < size // base判断\n            && this.heap[element] > this.heap[left]\n            // 如果该元素大于它的右子节点，则下沉\n        ) {\n            element = right;\n        }\n\n        // 如果element 最后 和传入的index不一样了，说明需要交换数据，然后继续下沉递归\n        if (index !== element) {\n            swap(this.heap, index, element);\n            this.siftDown(element);\n        }\n\n    }\n\n    // 向上移动，直到父节点的值小于插入的值\n    siftUp(index) {\n        let parent = this.getParentIndex(index);\n        while (\n            index > 0 // base 判断\n            && this.heap[parent] > this.heap[index]) // 父节点的元素大于子元素的时候，才需要移动\n        {\n            swap(this.heap, parent, index);\n            index = parent;\n            parent = this.getParentIndex(index);\n        }\n    }\n\n    // delete min 堆顶元素（最小值）和 堆底元素 对调\n    // 1、删除删除堆顶元素\n    // 2、让堆底元素沉到正确位置\n    deleteMin() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.size() === 1) {\n            return this.heap.shift();\n        }\n        const removedValue = this.heap[0]; // 堆顶元素\n        const lastElement = this.heap.pop();  // 移除堆底元素\n        this.heap[0] = lastElement; // 将 堆顶元素 赋值为 堆底元素\n        // 从堆顶开始下沉\n        this.siftDown(0);\n        return removedValue;\n    }\n\n    getAsArray() {\n        return this.heap;\n    }\n}\n\nlet arr = [5, 3, 7, 9, 0, 0, -1, -2, 7, -8];\n\nlet heapObj = new MinHeap();\narr.forEach((item) => {\n    heapObj.insert(item)\n})\nconsole.log(heapObj);\nconsole.log('************************')\n\nconsole.log(heapObj.findMinimum());\n\n// MinHeap { heap: [\n//     -8, -2, 0, 3, -1,\n//      7,  0, 9, 7,  5\n//   ] }\n// ************************\n// -8\n\n```\n\n## 疑问：数据结构中的`堆栈` 与 内存中的`堆栈` 的区别？\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/1b4993fbc44e95f344a1f3bd840babd4.png)\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/86921645374e40f809a54fb522b7f5f1.png)\n\n堆内存（Heap Memory）和栈内存（Stack Memory）是计算机内存管理中两种不同的内存分配区域。它们在用途、管理方式、生命周期和性能上有显著区别。以下是它们的主要区别：\n\n### 1. 用途\n\n- **堆内存**\n   - 用于动态分配内存，通常由程序运行时分配和释放。\n   - 适用于需要在运行时决定大小和生命周期的对象和数据结构，例如动态数组、链表等。\n- **栈内存**\n   - 用于静态分配内存，主要用于函数调用、局部变量和函数参数。\n   - 适用于生命周期明确且较短的变量，例如局部变量和函数参数。\n\n### 2. 管理方式\n\n- **堆内存**：\n   - 内存管理较复杂，容易导致内存泄漏和碎片化问题。\n   - 由程序员显式分配（如 `malloc` 在 C/C++ 中，`new` 在 C++/Java 中）和释放（如 `free` 在 C/C++ 中，垃圾回收在 Java 中）。\n- **栈内存**：\n   - 内存管理简单，不会出现内存泄漏问题，但栈空间有限，不能用于大对象或长生命周期对象。\n   - 由编译器自动管理，内存分配和释放在函数调用和返回时自动进行。\n\n### 3. 生命周期\n\n- **堆内存**：\n   - 对象的生命周期由程序员控制，可以在程序运行过程中**动态分配和释放**。\n   - 对象在不再使用后需要显式释放，否则会导致**内存泄漏**。\n- **栈内存**\n   - 对象的生命周期由函数调用栈决定，当函数返回时，栈上的所有**局部变量自动销毁**。\n   - 生命周期短暂且明确，不需要显式释放。\n\n### 4. 性能\n\n- **堆内存**：\n   - 动态分配和释放内存的开销较大，因为需要查找合适的内存块，并处理碎片化问题。\n   - 常见于需要灵活管理内存的大型复杂应用中。\n- **栈内存**：\n   - 更适合小型、短生命周期的数据，具有更高的访问速度。\n   - 内存分配和释放速度快，仅通过移动栈指针即可完成。\n\n### 总结\n\n- **堆内存**：适用于动态分配的对象，生命周期由程序员控制，管理复杂但灵活。\n- **栈内存**：适用于局部变量和函数调用，生命周期短暂且由编译器自动管理，性能高但空间有限。\n\n理解堆和栈的区别对于高效编写和调试代码至关重要，尤其是涉及到内存管理和性能优化时。\n\n## 查找二叉树（二叉搜索树）\n\n- 一种特殊的二叉树，`较小`的值保存在`左节点`中，`较大`的值保存在`右节点`中\n   - `根节点的左子树`都比`根节点的值`小，`右子树的值`都比`根节点的值`大。\n   - `二叉查找树`是一种`有序的树`，所以支持`快速查找、快速插入、删除`一个数据\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/26939446c9517db965095fb586848172.png)\n\n## 平衡二叉查找树\n二叉树中`任意一个节点的左右子树`的`高度相差不能大于 1`\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/42e64492eba910a231f01894b3811630.png)\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/2130d9f3b6d123735105cd614780218d.png)\n\n## 二叉树的存储方式\n\n### 链式存储 - 对象\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/1f57396c6c7d0ec0908c8fd1d70696d0.png)\n\n### 顺序存储 - 数组\n`完全二叉树`用`数组`来存储是最省内存的方式\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/e29fe4038c62a7dc643d94fc78940983.png)\n非完全二叉树则会浪费空间，如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/cf10cd1cdb8a374b53403b941b9b9e96.png)\n\n## 数据结构设计 - 实现一个`二叉搜索树`\n\n### 插入节点\n看下面一张图，在下图的树中插入健值为 `6` 的节点，过程如下：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/8963bb8f3b7b3a6a1fa71319e058bde3.png)\n\n### 移除节点\n关键看下删除有`两个子节点`的节点：\n1、【该节点与右子树中最小值位置置换】找到将右侧子树中的最小值，替换到要删除的位置\n2、 然后 递归 从 从右侧子树中移除最小节点\n如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ef6da5215ad8e2ff32b2ea49faaa631f.png)\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ac3f6d93656aceb38de5dfe7f1e81277.png)\n\n### 代码部分\n```javascript\n// node节点类\nclass Node {\n    constructor(key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n    }\n    toString() {\n        return `${this.key}`;\n    }\n}\n\nexport default class BinarySearchTree {\n\n    constructor() {\n        this.root = null;\n    }\n\n    // 向树中插入一个新的键。\n    insert(key) {\n        // special case: first key\n        if (this.root == null) {\n            this.root = new Node(key);\n        } else {\n            // 从root开始遍历查找合适的位置插入\n            this.insertNode(this.root, key);\n        }\n    }\n\n    // 遍历树，将插入节点的键值与遍历到的节点键值比较，如果前者大于后者，继续递归遍历右子节点，\n    // 反之，继续遍历左子节点，直到找到一个空的节点，在该位置插入。\n    insertNode(node, key) {\n        // 如果插入节点的键值小于当前节点的键值，则需要插入左边\n        if (key < node.key) {\n            // 左节点没有值，则直接插入\n            if (node.left == null) {\n                node.left = new Node(key);\n            } else {\n                this.insertNode(node.left, key);\n            }\n            // 否则需要插入右边\n        } else {\n            if (node.right == null) {\n                node.right = new Node(key);\n            } else {\n                this.insertNode(node.right, key);\n            }\n        }\n    }\n    getRoot() {\n        return this.root;\n    }\n    inOrderTraverse(callback) {\n        this.inOrderTraverseNode(this.root, callback);\n    }\n    inOrderTraverseNode(node, callback) {\n        if (node != null) {\n            this.inOrderTraverseNode(node.left, callback);\n            callback(node.key);\n            this.inOrderTraverseNode(node.right, callback);\n        }\n    }\n\n    preOrderTraverse(callback) {\n        this.preOrderTraverseNode(this.root, callback);\n    }\n\n    preOrderTraverseNode(node, callback) {\n        if (node != null) {\n            callback(node.key);\n            this.preOrderTraverseNode(node.left, callback);\n            this.preOrderTraverseNode(node.right, callback);\n        }\n    }\n\n    postOrderTraverse(callback) {\n        this.postOrderTraverseNode(this.root, callback);\n    }\n\n    postOrderTraverseNode(node, callback) {\n        if (node != null) {\n            this.postOrderTraverseNode(node.left, callback);\n            this.postOrderTraverseNode(node.right, callback);\n            callback(node.key);\n        }\n    }\n\n    search(key) {\n        return this.searchNode(this.root, key);\n    }\n\n    // 搜索特定值的处理与插入值的处理类似。遍历树，\n    // 将要搜索的值与遍历到的节点比较，如果前者大于后者，\n    // 则递归遍历右侧子节点，反之，则递归遍历左侧子节点。\n    searchNode(node, key) {\n        if (node == null) {\n            return false;\n        }\n        // 如果要查找的值小于该节点，继续递归遍历其左侧节点\n        if (key < node.key) {\n            return this.searchNode(node.left, key);\n        }\n        // 如果要查找的值大于该节点，继续递归遍历其右侧节点\n        if (key > node.key) {\n            return this.searchNode(node.right, key);\n        }\n        return true;\n    }\n\n    min() {\n        return this.minNode(this.root);\n    }\n\n    // 在二叉搜索树里，不管是整个树还是其子树，最小值一定在树最左侧的最底层。\n    // 因此给定一颗树或其子树，只需要一直向左节点遍历到底就行了。\n    minNode(node) {\n        let current = node;\n        while (current != null && current.left != null) {\n            current = current.left;\n        }\n        return current;\n    }\n\n    max() {\n        return this.maxNode(this.root);\n    }\n\n    // 搜索最大值与搜索最小值类似，只是沿着树的右侧遍历。\n    maxNode(node) {\n        let current = node;\n        while (current != null && current.right != null) {\n            current = current.right;\n        }\n        return current;\n    }\n\n    // 移除节点，首先要在树中查找到要移除的节点，再判断该节点是否有子节点、有一个子节点或者有两个子节点，最后分别处理。\n    remove(key) {\n        // 同样从root开始遍历查找\n        this.root = this.removeNode(this.root, key);\n    }\n\n    removeNode(node, key) {\n        // 如果 node 不存在，直接返回\n        if (node == null) {\n            return null;\n        }\n        // 找到要删除的node\n        node = this.searchNode(node, key)\n\n        // 第一种情况，该节点没有子节点\n        if (node.left == null && node.right == null) {\n            node = null;\n            return node;\n        }\n        // 第二种情况，该节点只有一个子节点的节点\n        if (node.left == null) {\n            // 将右子节点替换自己\n            node = node.right;\n            return node;\n        }\n        if (node.right == null) {\n            // 将左子节点替换自己\n            node = node.left;\n            return node;\n        }\n        // 第三种情况，有有两个子节点的节点\n        // 1、找到将右侧子树中的最小值，替换到要删除的位置\n        // 2、从右侧子树中移除最小节点\n        const aux = this.minNode(node.right);\n        node.key = aux.key;\n        node.right = this.removeNode(node.right, aux.key);\n        return node;\n    }\n}\n\n```\n\n---\n\n## 阅读原文\n\n- [https://liguwe.github.io/post/de7d537f-1a3d-572c-baaa-a98b3e5ff9d5](https://liguwe.github.io/post/de7d537f-1a3d-572c-baaa-a98b3e5ff9d5)\n","fb9afc375957539890b8372de2704627":"\n# 前言\n\n\n`#2024/08/11` `#算法` `#数据结构` \n\n","a7d27fa7f4c15177b9efbb88cd32247e":"\n# 前言\n\n","ac203c8c36f95e4180fb2fb0c125a5d3":"\n# 前言\n\n","8561aae078c95b7ea1ec308e3f199566":"\n# 前言\n\n","895d087e9843507aa4ab2f3f57e9be47":"\n# 算法复杂度\n\n\n`#2023/07/27`  `#算法/基础`\n\n> [!info]\n> - 空间复杂度的计算的方式可以再读读，挺有意思\n\n\n## 目录\n<!-- toc -->\n ## 一、综述 \n\n1. 数据结构和算法解决是  “如何让计算机更快时间、更省空间的解决问题”。\n2. 因此需从`执行时间`和`占用空间`两个维度来评估数据结构和算法的性能。\n3. 分别用`时间复杂度`和 `空间复杂度` 两个概念来描述性能问题，二者统称为`复杂度`。\n4. 复杂度描述的是算法`执行时间`（或`占用空间`）与 `数据规模`的  `增长趋势` 关系。\n\n## 二、时间复杂度\n\n### （一）什么是时间复杂度\n统计的是 算法运行时间随着数据量变大时的  `增长趋势` ，而不是 `具体运行时间`\n下面函数展示了随着 `n` 的增加，算法的 `时间的复杂度`\n```javascript\n// 算法 A 时间复杂度：常数阶\nfunction algorithm_A(n) {\n    console.log(0);\n}\n// 算法 B 时间复杂度：线性阶\nfunction algorithm_B(n) {\n    for (let i = 0; i < n; i++) {\n        console.log(0);\n    }\n}\n// 算法 C 时间复杂度：常数阶\nfunction algorithm_C(n) {\n    for (let i = 0; i < 1000000; i++) {\n        console.log(0);\n    }\n}\n```\n上面代码的的**增长趋势**如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ea5f6229f7163afc408a23aef0728791.png)\n时间复杂度由多项式 `T(n)` 中最高阶的项来决定。这是因为在趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以被忽略。即 **“系数无法撼动阶数”** ， 当趋于无穷大时，这些常数变得无足轻重，如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/dfa3c541c8fde0817d043413d5a96f39.png)\n\n### （二）如何计算时间复杂度\n```javascript\nfunction aFun() {\n    console.log(\"Hello, World!\");      //  需要执行 1 次\n    return 0;       // 需要执行 1 次\n}\n\n// 需要执行 2 次运算\nfunction bFun(n) {\n    for(let i = 0; i < n; i++) {         // 需要执行 (n + 1) 次\n        console.log(\"Hello, World!\");      // 需要执行 n 次\n    }\n    return 0;       // 需要执行 1 次\n}\n// 需要执行 ( n + 1 + n + 1 ) = 2n +2 次运算\n\n function cal(n) {\n   let sum = 0; // 1 次\n   let i = 1; // 1 次\n   let j = 1; // 1 次\n   for (; i <= n; ++i) {  // n 次\n     j = 1;  // n 次\n     for (; j <= n; ++j) {  // n * n ，也即是  n平方次\n       sum = sum +  i * j;  // n * n ，也即是  n平方次\n     }\n   }\n }\n// 那么这个方法需要执行 ( n^2 + n^2 + n + n + 1 + 1 +1 ) = 2n^2 +2n + 3\n```\n如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/4e79ed2e30c215179f648fdd5000f363.png)\n\n### （三）几个时间复杂度的分析原则\n\n- 只关注 `循环执行次数最多`的一段代码，即 **“系数无法撼动阶数”**\n- 加法法则：总复杂度  等于  **量级最大** 的那段代码的复杂度\n- 乘法法则：嵌套代码的复杂度等于 **嵌套内外代码复杂度的乘积**\n- 多个规模求加法：`O(m+n)`\n- 多个规模求乘法：`O(m*n)`\n\n### （四）常见的算法时间复杂度\n\n#### 1、常数阶：O(1)\n```javascript\n/* 常数阶 */\nfunction constant(n) {\n    let count = 0;\n    const size = 100000; // size 是固定的\n    for (let i = 0; i < size; i++) count++;\n    return count;\n}\n```\n\n#### 2、线性阶：O(n)\n通常出现在单层循环中，`遍历数组和遍历链表`等操作的时间复杂度均为 `O(n)`\n\n#### 3、平方阶：O(n^2)\n通常出现在 `嵌套循环` 中，如冒泡排序。\n> [!info]\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/88cb8b3a7d878706742e70be0d6f2b23.png)\n\n#### 4、指数阶：O(2^n)\n\n- 实际场景，**细胞分裂**：初始状态为 `1` 个细胞，分裂一轮后变为 `2` 个，分裂`两轮`后变个`4` 细胞 ...\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ac00b7799791dc9505590961d2bbb4bb.png)\n\n- `指数阶`常出现于`递归函数` 中，如下代码：\n```javascript\n/* 指数阶（递归实现） */\nfunction expRecur(n) {\n    if (n == 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n```\n\n#### 5、对数阶：O(log n)\n\n- 与`指数阶`相反，对数阶反映了  **“每轮缩减到一半的情况”**\n- 常出于「二分查找」和「分治算法」中\n- `每轮缩减到一半`的代码示例及图例如下：\n```javascript\n/* 对数阶（循环实现） */\nfunction logarithmic(n) {\n    let count = 0;\n    while (n > 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n```\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/3ff8899588e1ffa4f4b94073eabdef94.png)\n\n- 与 `指数阶` 一样，对数阶也常出于 `递归函数` 中，如下代码\n```javascript\n/* 对数阶（递归实现） */\nfunction logRecur(n) {\n    if (n <= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n```\n\n#### 6、线性对数阶：`O(n*log n)`\n\n如主流排序算法 快速排序、归并排序、堆排序等\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/27ec8375a419fee15f4b37ce2a8cc49f.png)\n\n#### 7、阶乘阶：O(n!)\n即 `「全排列」` 问题\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/ae31393acb0b846e96cc6e127721d0d1.png)\n> [!question]\n画出一张 `阶乘阶` 的 分裂图？\n\n### （五）最差、最佳、平均时间复杂度\n\n- `「最差时间复杂度」`更为实用，因为它给出了一个 **“效率安全值”**\n- 至于其他，如 `平均情况时间复杂度`  等忽略吧\n\n## 三、空间复杂度\n「空间复杂度 Space Complexity」用于衡量算法使用**内存空间随着数据量变大时的增长趋势**\n\n### （一）算法相关 `空间`\n\n- **「输入空间」** 用于存储算法的输入数据。\n- **「暂存空间」** 用于存储算法运行过程中的变量、对象、函数上下文等数据。\n   - 「暂存数据」用于保存算法运行过程中的各种常量、变量、对象等。\n   - 「栈帧空间」用于保存调用函数的上下文数据。\n      - 系统在每次调用函数时都会在栈顶部`创建`一个栈帧，\n      - 函数返回后，栈帧空间会被`释放`。\n   - 「指令空间」用于保存编译后的程序指令，在实际统计中`通常忽略不计`。\n- **「输出空间」** 用于存储算法的输出数据。\n\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/4c8a91efffc89dcd586e114161a7ea49.png)\n```javascript\n/* 类 */\nclass Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val === undefined ? 0 : val; // 节点值\n        this.next = null;                       // 指向下一节点的引用\n    }\n}\n\n/* 函数 */\nfunction constFunc() {\n    // do something\n    return 0;\n}\n\nfunction algorithm(n) {       // 输入数据: 输入空间，即函数\n    const a = 0;              // 暂存数据（常量）\n    let b = 0;                // 暂存数据（变量）\n    const node = new Node(0); // 暂存数据（对象）\n    const c = constFunc();    // 栈帧空间（调用函数）\n    return a + b + c;         // 输出数据：返回数据，即 return\n}\n\n```\n\n### （二）如何推算空间复杂度\n通常只关注 `最差空间复杂度` , 看下面代码就懂了，因为我们必须要有 足够的内存空间预留，所以：\n\n- 以`最差`输入数据为准\n- 以算法运行过程中的`峰值内存`为准\n```javascript\nfunction algorithm(n) {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n > 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n```\n以下代码的空间复杂度分析：\n```javascript\nfunction constFunc() {\n    // do something\n    return 0;\n}\n/* 循环 O(1) */\n// 因为每轮循环后，调用的函数都会 释放了栈帧空间，所以空间复杂度为 O(1)\nfunction loop(n) {\n    for (let i = 0; i < n; i++) {\n        constFunc();\n    }\n}\n/* 递归 O(n) */\n// 递归函数 recur() 在运行过程中会同时存在 个未返回的 recur()\n// 所以，会有 O(n) 的栈帧空间\nfunction recur(n) {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n\n```\n\n### （三）常见的空间复杂度类型\n\n#### 1、常数阶：O(1)\n常数阶常见于 **数量与输入数据大小 n 无关的常量、变量、对象**\n```javascript\n/* 常数阶 */\nfunction constant(n) {\n    // 常量、变量、对象占用 O(1) 空间\n    const a = 0;\n    const b = 0;\n    const nums = new Array(10000);\n    const node = new ListNode(0);\n    // 循环中的变量占用 O(1) 空间\n    for (let i = 0; i < n; i++) {\n        const c = 0;\n    }\n    // 循环中的函数占用 O(1) 空间\n    for (let i = 0; i < n; i++) {\n        constFunc();\n    }\n}\n```\n> [!tip]\n需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，即不会累积占用空间，空间复杂度仍为`O(1)`\n\n#### 2、线性阶：O(n)\n线性阶常见于 **元素数量与 输入数据大小 **`n`** 成正比的数组、链表、栈、队列等。**\n```javascript\n/* 线性阶 */\nfunction linear(n) {\n    // 长度为 n 的数组占用 O(n) 空间\n    const nums = new Array(n);\n    // 长度为 n 的列表占用 O(n) 空间\n    const nodes = [];\n    for (let i = 0; i < n; i++) {\n        nodes.push(new ListNode(i));\n    }\n    // 长度为 n 的哈希表占用 O(n) 空间\n    const map = new Map();\n    for (let i = 0; i < n; i++) {\n        map.set(i, i.toString());\n    }\n}\n```\n\n以下递归函数会同时存在 `n` 个未返回的 `algorithm()` 函数， 会占用 `O(n)`大小的栈帧空间：\n```javascript\n/* 线性阶（递归实现） */\nfunction linearRecur(n) {\n    console.log(`递归 n = ${n}`);\n    if (n === 1) return;\n    linearRecur(n - 1);\n}\n```\n如下图：\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/dfe9b1eb0d0a84c7053f69f794a367b6.png)\n\n#### 3、平方阶：O(n^2)\n平方阶常见于**矩阵 和 图** ，如下代码：\n```javascript\n/* 平方阶 */\nfunction quadratic(n) {\n    // 矩阵占用 O(n^2) 空间\n    const numMatrix = Array(n)\n        .fill(null)\n        .map(() => Array(n).fill(null));\n\n    // 二维列表占用 O(n^2) 空间\n    const numList = [];\n    for (let i = 0; i < n; i++) {\n        const tmp = [];\n        for (let j = 0; j < n; j++) {\n            tmp.push(0);\n        }\n        numList.push(tmp);\n    }\n}\n```\n看看递归的场景：注意，需要关注 `nums` 的长度。\n```javascript\n/* 平方阶（递归实现） */\nfunction quadraticRecur(n) {\n    if (n <= 0) return 0;\n    const nums = new Array(n);\n    console.log(`递归 n = ${n} 中的 nums 长度 = ${nums.length}`);\n    return quadraticRecur(n - 1);\n}\n\n```\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/f6b5154844af6165acfa600c31d34e64.png)\n\n#### 4、指数阶：O(2^n)\n常见与构造二叉树，且关注最终的 `节点个数`，即占用的空间。\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/5147e79065e5fab121c166b6a62a25ac.png)\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/4f6e32f2f25b2223ae034964af127da9.png)\n\n#### 5、对数阶：O(log n)\n![](https://832-1310531898.cos.ap-beijing.myqcloud.com/1061ba6d1caec553eef45ce34c47290b.png)\n> [!question]\n 最后，数字转成字符串的表述，其实没太理解。\n\n## 四、其他\n\n- 理论上，尾递归函数的空间复杂度可以被优化为 `O(1)` ，但跟编程语言有关系\n- 当前的计算机系统，以空间换时间场景较多\n\n## 参考\n[https://www.hello-algo.com/chapter_computational_complexity/time_complexity/`#222](https://www.hello-algo.com/chapter_computational_complexity/time_complexity/``#222)`\n\n","c8bd2bf2defd5845899e55aeb44d20b6":"\n# 前言\n\n`#算法` `#算法/数据结构算法`  `#2024/08/11`\n\n基础数据结构相关的算法，包括以下数据\n\n- 数组\n- 链表\n\t- 单链表\n\t- 双向链表\n- 队列\n\t- 单调队列\n- 栈\n\t- 单调栈\n\n","494b14ecf85a5333913480a48f6a6459":"\n# 单调列队算法\n\n\n`#leetcode`  `#2024/08/11`  `#算法/单调列队`  `#算法/数据结构算法`   \n\n\n## 目录\n<!-- toc -->\n ## 1. 定义 \n\n**队列**中的元素全都是**单调递增（或递减）的** \n\n## 2. 用途\n\n- 它可以快速**确定滑动窗口中的最大或最小值**\n\t- **单调队列**结合**滑动窗口方法**可以在`O(1)`时间内计算当前窗口中的**最大值或最小值**\n\t- 同时保持队列先进先出的特性\n\n## 3. 单调递减队列的实现\n\n先看看 **普通的队列的标准 API**\n\n```javascript\n// 普通的队列的标准 API\nclass Queue {\n  // enqueue 操作，在队尾加入元素 n\n  push(n) {}\n\n  // dequeue 操作，删除队头元素\n  pop() {}\n}\n```\n\n**单调递减队列的标准 API**\n\n```javascript \n// 单调递减队列的标准 API\nclass MonotonicQueue {\n  // 在队尾添加元素 n\n  push(n) {}\n\n  // 返回队头元素\n  max() {}\n\n  // 删除队头元素\n  pop() {}\n}\n```\n\n下面是**具体实现**\n\n```javascript  hl:14,32,26\n// 单调递增队列的标准 API\nclass MonotonicQueue {\n  constructor() {\n    // 维护其中的元素自尾部到头部单调递增\n    this.maxq = [];\n  }\n\n  // 在队尾添加元素 item\n  // 在尾部添加一个元素 item，维护 maxq 的单调性质\n  // 将前面小于自己的元素都删\n  push(item) {\n    // 将前面小于自己的元素都删除\n    while (this.maxq.length > 0 && this.maxq[this.maxq.length - 1] < item) {\n      // 删除数组的最后一个元素\n      this.maxq.pop();\n    }\n    this.maxq.push(item);\n  }\n\n  // 返回队头元素, 即 maxq 队首元素\n  // 队头的元素肯定是最大的\n  max() {\n    return this.maxq[0];\n  }\n\n  // 删除队头元素,\n  pop(item) {\n    // 如果要删除的元素是队头元素，就删除\n    // 否则不做任何操作\n    // 想删除的队头元素 item 可能已经被「压扁」了\n    if (this.maxq[0] === item) {\n      // 删除数组的第一个元素\n      this.maxq.shift();\n    }\n  }\n}\n```\n\n### 3.1. push(item) 的逻辑\n\n关于 `push(item)` 的逻辑，可以参考下图\n\n![图片&文件](./files/Pastedimage20240811093920.png)\n\n> [!danger]\n>  会有疑问❓，都 `pop` 删除了，那岂不是队列里没值了，不是因为每次都会 push ，长度都会`+1` ，即使把前面的元素都干掉了，长度还是持续增加\n\n### 3.2. pop(item) 的逻辑\n\n删除队首，需要传一个参数，如果它是队首元素才需要删除\n\n![图片&文件](./files/Pastedimage20240811095429.png)\n\n## 4. 示例：滑动窗口最大值\n\n### 4.1. 题目\n\n![图片&文件](./files/Pastedimage20240811080541.png)\n\n### 4.2. 使用单调列队来解\n\n![图片&文件](./files/Pastedimage20240811101243.png)\n\n- 解题思路\n\t- ① 初始化一个单调队列，用于维护**移动窗口**\n\t- ② 遍历数组\n\t\t- 先填满窗口，每次 `push` 时，window 都会维护一个单调递减队列\n\t\t- 填满了，每次先后移动一次，需要做以下事情\n\t\t\t- window.push(item)\n\t\t\t- res.push(window.max())\n\t\t\t- 删除对首元素，因为**需要保证 window 的长度为 k**\n\n```javascript hl:55,42\n// 单调递增队列的标准 API\nclass MonotonicQueue {\n  constructor() {\n    // 维护其中的元素自尾部到头部单调递增\n    this.maxq = [];\n  }\n\n  // 在队尾添加元素 item\n  // 在尾部添加一个元素 item，维护 maxq 的单调性质\n  // 将前面小于自己的元素都删\n  push(item) {\n    // 将前面小于自己的元素都删除\n    while (this.maxq.length > 0 && this.maxq[this.maxq.length - 1] < item) {\n      this.maxq.pop();\n    }\n    this.maxq.push(item);\n  }\n\n  // 返回队头元素, 即 maxq 队首元素\n  // 队头的元素肯定是最大的\n  max() {\n    return this.maxq[0];\n  }\n\n  // 删除队头元素\n  pop(item) {\n    // 如果要删除的元素是队头元素，就删除\n    // 否则不做任何操作\n    // 想删除的队头元素 item 可能已经被「压扁」了\n    if (this.maxq[0] === item) {\n      this.maxq.shift();\n    }\n  }\n}\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function (nums, k) {\n  // ① 初始化一个单调队列，用来维护窗口的最大值\n  // 变量 window 是一个 MonotonicQueue 类型的实例\n  let window = new MonotonicQueue();\n\n  let res = [];\n\n  // 遍历 nums\n  for (let i = 0; i < nums.length; i++) {\n    // ①  如果 i < k - 1，先填满窗口的前 k - 1\n    if (i < k - 1) {\n      window.push(nums[i]);\n    } else {\n      // ②  窗口向前滑动，加入最后一个元素\n      // 每次 push时，window 都会维护一个单调递减队列\n      window.push(nums[i]);\n      // 记录当前窗口的最大值\n      res.push(window.max());\n      // 窗口向前滑动，删除第一个元素\n      window.pop(nums[i - k + 1]);\n    }\n  }\n\n  return res;\n};\n\n```\n\n### 4.3. 复杂度分析\n\n- 时间复杂度：O(n)\n   - 主循环遍历整个数组 nums，这需要 `O(n)` 时间，其中 n 是数组的长度。\n      - 在循环中，我们执行以下操作：\n         - push(): 虽然这个操作包含一个**while循环**，看起来可能是`O(n)`\n            -  但是每个元素最多被 push 和 pop 一次。\n            -  所以整个数组，push操 作的均摊时间复杂度是`O(1)` \n         - max(): 这是一个`O(1)`操作，因为它只是返回队列的第一个元素。\n         - pop(): 这也是一个`O(1)`操作，因为它只是检查并可能删除队列的第一个元素。\n   - 综上所述，尽管有嵌套的循环，但是由于**每个元素最多被处理两次（一次入队，一次出队）**，所以总的时间复杂度是O(n)\n- 空间复杂度：O(k)\n\t- MonotonicQueue 中的 **maxq 数组在最坏情况下可能会存储 k 个元素**，其中 k 是滑动窗口的大小。\n\t- 结果`数组 res` 的大小为 `n - k + 1`，但这是必要的输出空间，通常不计入空间复杂度。\n\n","6a9e42a4ed7456baafecac8f96c04702":"\n#  0. 前言\n\n\n\n\n包括\n- 所有二叉树\n- 二叉搜索树\n- 多叉树\n- 二叉树的遍历\n- 二叉树的深度\n","31a972075ef25aaba62c7c0c38ca1f34":"\n# 前言\n\n","f54cfb71409c5f78af2f9fa70d4bf663":"\n# 前言\n\n","6cb33579e86e5f03882452321c1c9627":"\n# 前言\n\n","2bbcbba8bcc056d8879a6b0f061954b2":"\n# 前言\n\n\n\n- 其他算法\n","b058e1e203625f08a26d2c0ac670a8b7":"\n# 前言\n\n\n`#leetcode` \n\n- LeetCode 精华 75 题：[https://leetcode.cn/studyplan/leetcode-75/](https://leetcode.cn/studyplan/leetcode-75/)\n- LeetCode 经典 150 题：[https://leetcode.cn/studyplan/top-interview-150/](https://leetcode.cn/studyplan/top-interview-150/)\n- LeetCode 热题 100 题：[https://leetcode.cn/studyplan/top-100-liked/](https://leetcode.cn/studyplan/top-100-liked/)\n- labuladong 算法刷题：[labuladong 的算法笔记](https://labuladong.online/algo/)\n\n ","625107968ebd57918381720ad6d1e0a0":"\n# 前言\n\n`#leetcode` \n\n>  LeetCode 精华 75 题：[https://leetcode.cn/studyplan/leetcode-75/](https://leetcode.cn/studyplan/leetcode-75/)\n\n","8927f8bc0b495997821a086ccab0862e":"\n# 确定两个字符串是否接近\n\n\n`#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|622](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407260859792.png?imageSlim)\n\n## 解题思路\n\n需要满足以下三个条件：\n\n- 包含的字符集需要相同\n- **每种字符出现的频率排序后相同**\n\t- 如何理解呢？\n\t\t- `word1 = \"cabbba\" `  对应的频率  `[ 2, 3, 1 , 0, 0, ..., 0]`\n\t\t- `word2 = \"abbccc\"`    对应的频率  `[1, 2, 3, 0, 0, ..., 0]`\n\n## 代码实现\n\n```javascript\n/**  \n * @param {string} word1  \n * @param {string} word2  \n * @return {boolean}  \n */  \nvar closeStrings = function (word1, word2) {  \n  // 两个字符串的长度不相等，直接返回 false  if (word1.length !== word2.length) {  \n    return false;  \n  }  \n  \n  // 用于记录两个字符串中字符出现的次数  \n  const arr1 = new Array(26).fill(0);  \n  const arr2 = new Array(26).fill(0);  \n  \n  // 遍历两个字符串，记录字符出现的次数  \n  for (let i = 0; i < word1.length; i++) {  \n    arr1[word1.charCodeAt(i) - 97]++;  \n  }  \n  for (let i = 0; i < word2.length; i++) {  \n    arr2[word2.charCodeAt(i) - 97]++;  \n  }  \n  \n  // 包含相同字符  \n  // 转成数组，排序，转成字符串，去重  \n  const str1 = arr1.sort().join(\"\");  \n  const str2 = arr2.sort().join(\"\");  \n  \n  return str1 === str2;  \n};\n```\n\n> [!info]\n> `word1.charCodeAt(i) - 97` 这个平时不怎么常用，需要能够写出来！\n\n## 错误日志\n\n> [!danger]\n> 题意理解有误，一定是需要保证`互相更换相同的次数`后能够`互相得到`\n\n```javascript\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {boolean}\n */\nvar closeStrings = function (word1, word2) {\n  // 两个字符串的长度不相等，直接返回 false\n  if (word1.length !== word2.length) {\n    return false;\n  }\n  // 包含相同字符\n  // 转成数组，排序，转成字符串，去重\n  const str1 = word1.split(\"\").sort().join(\"\");\n  const str2 = word2.split(\"\").sort().join(\"\");\n  return str1 === str2;\n};\n\n```","16a0475db2a256c0bfff3d7221053fdc":"\n# 定长子串中元音的最大数目\n\n\n`#2024/07/28` `#leetcode`  `#算法/滑动窗口`\n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/019ec18db0ccfeb560170c4fd4b24b5a.png)\n\n## 解题思路\n\n1. 使用`滑动窗口`技术，维护一个`固定长度为 k 的窗口`。\n2. 在窗口内统计元音字母的数量。\n3. 随着窗口的滑动，更新元音字母的数量，并记录最大值。\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\n\nvar maxVowels = function (s, k) {\n  // 辅助函数：判断字符是否为元音\n  const isVowel = (c) => {\n    return [\"a\", \"e\", \"i\", \"o\", \"u\"].includes(c);\n  };\n\n  // 结果\n  let res = 0;\n  // 记录滑动窗口中的元音字母个数，即【滑动窗口】中的元音字母个数，用于更新 res 的值\n  let count = 0;\n\n  // 初始化滑动窗口,先统计前 k 个元素中的元音字母个数\n  for (let i = 0; i < k; i++) {\n    if (isVowel(s[i])) {\n      count++;\n    }\n  }\n\n  // 更新 res 的值\n  res = count;\n\n  // 开始滑动窗口，从 k 开始，每次移动一位，动态维护 count 和 res 的值\n  for (let i = k; i < s.length; i++) {\n    // 先移除滑动窗口的前一个元素，如果是元音字母，则 count 减一\n    if (isVowel(s[i - k])) {\n      count--;\n    }\n    // 新添加的元素是元音字母，则 count 加一\n    if (isVowel(s[i])) {\n      count++;\n    }\n\n    // 更新 res 的值\n    res = Math.max(res, count);\n\n    // 如果 res 等于 k，直接返回 k,可以提前结束循环\n    if (res === k) {\n      break;\n    }\n  }\n\n  return res;\n};\n\n```\n\n> - 真正滑动窗口时，\n>    - 需要先判断上一个字母是否元音，是的话，`count --`\n>    - 然后再判断当前的元素，是的话，`count++`\n\n### 复杂度分析\n\n- 时间复杂度是 O(n)，其中 n 是字符串的长度。我们只需要遍历一次字符串。\n- 空间复杂度是 O(1)，因为我们只使用了几个变量来存储状态，不需要额外的数据结构。\n\n优化点：\n\n1. 使用`**Set**`来存储元音字母集合，可以稍微提高查找效率。\n2. 当找到长度为 k 的全是元音的子串时，`**可以提前结束循环**`，因为这已经是最大可能值。\n\n## 错误记录\n\n","5e1ecf3d29455445ada9e37cdd903991":"\n# 独一无二的出现次数\n\n`#2024/07/28` `#leetcode` `#算法/哈希` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/51c99350178f71d2c19ebb91fce2e509.png)\n\n## 解题思路\n\n- 使用  `哈希`\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {boolean}\n */\nvar uniqueOccurrences = function (arr) {\n  const map = new Map();\n  for (let i = 0; i < arr.length; i++) {\n    map.set(arr[i], (map.get(arr[i]) || 0) + 1);\n  }\n  const set = new Set();\n  for (const value of map.values()) {\n    // 如果 set 中已经存在 value，说明出现次数重复,直接返回 false\n    if (set.has(value)) {\n      return false;\n    }\n    set.add(value);\n  }\n  // 如果没有出现次数重复，返回 true\n  return true;\n};\n\n```\n\n### 复杂度分析\n\n## 错误记录\n\n","2be361fd25ee54d8a7d167c149482a27":"\n# 反转字符串中的单词\n\n`#2024/07/28` `#leetcode` `#算法/反转` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/08a29ef8ddbb835cf3d278a38cfa500a.png)\n\n## 解题思路\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/8b5f7205a78d8eedaed7e17010c7aff6.png)\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function (s) {\n  // 1、去除首尾空格，并将多个空格替换为单个空格\n  s = s.trim().replace(/\\s+/g, \" \");\n  // 2、将字符串反转\n  s = s.split(\"\").reverse().join(\"\");\n  // 3、将字符串按空格分割为数组\n  const words = s.split(\" \");\n  // 4、遍历数组，将每个单词反转\n  for (let i = 0; i < words.length; i++) {\n    words[i] = words[i].split(\"\").reverse().join(\"\");\n  }\n  // 5、将反转后的单词数组重新组合成字符串\n  return words.join(\" \");\n};\n\n```\n\n> - 如果不能使用 `Array.reverse`，则可以使用`双指针`自己写一个`辅助函数`\n\n","bc21f8f6fe665068be82c066de6720ca":"\n# 反转字符串中的元音字母\n\n`#2024/07/28` `#leetcode`  `#算法/双指针`  \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/e0cc283efc425dcc42f1db528e1cf695.png)\n\n## 解题思路\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/c3bf82b3e851ebcc70cdaeda2ff02021.png)\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar reverseVowels = function (s) {\n  // 元音字母\n  const vowels = \"aeiouAEIOU\";\n  // 将字符串转换为数组\n  const arr = s.split(\"\");\n  // 左指针\n  let left = 0;\n  // 右指针\n  let right = arr.length - 1;\n  // 当左指针小于右指针时，执行循环\n  while (left < right) {\n    // 当左指针对应的字符不是元音字母时，左指针右移\n    while (left < right && vowels.indexOf(arr[left]) === -1) {\n      left++;\n    }\n    // 当右指针对应的字符不是元音字母时，右指针左移\n    while (left < right && vowels.indexOf(arr[right]) === -1) {\n      right--;\n    }\n    // 这时，左指针对应的字符是元音字母，右指针对应的字符也是元音字母\n    // 交换左右指针对应的字符\n    [arr[left], arr[right]] = [arr[right], arr[left]];\n    // 左指针右移\n    left++;\n    // 右指针左移\n    right--;\n  }\n  return arr.join(\"\");\n};\n\n```\n\n## 错误记录\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/10e8be78b37b1a4031f14dae7dcab7e5.png)\n\n","cf1987321e5a59eeaba20c394fb3bbcf":"\n# 交替合并字符串\n\n\n`#算法/双指针`  `#2024/07/28` `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/d4ea1f26f2d3ac5e04cf57f5500ed2e4.png)\n\n### 题目重点\n\n- 交替合并\n- 最后的直接到末尾即可\n\n## 思路\n\n- 也是`双指针技巧`\n- 从 `0` 开始\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nvar mergeAlternately = function (word1, word2) {\n  let res = \"\"; // 保存结果\n  const m = word1.length;\n  const n = word2.length;\n  const max = Math.max(m, n); // 取最大长度\n\n  for (let k = 0; k < max; k++) {\n    // 如果k小于m, 则将word1的第k个字符加入到res中\n    if (k < m) {\n      res += word1[k];\n    }\n    // 如果k小于n, 则将word2的第k个字符加入到res中\n    if (k < n) {\n      res += word2[k];\n    }\n  }\n\n  return res;\n};\n\n```\n\n> **注意：就没有最后字符串拼接环节，正常遍历就好**\n\n## 参考\n\n- [https://leetcode.cn/problems/merge-strings-alternately/submissions/548008565/?envType=study-plan-v2&envId=leetcode-75](https://leetcode.cn/problems/merge-strings-alternately/submissions/548008565/?envType=study-plan-v2&envId=leetcode-75)\n\n","b0540d73e742538c9dc6415b0ef24882":"\n# 判断子序列\n\n\n`#2024/07/28` `#算法/双指针`  `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/100200a42cdfb5c4b386f9fa25baf3b1.png)\n\n## 解题思路\n\n![640.gif](https://832-1310531898.cos.ap-beijing.myqcloud.com/fd27ca36abe5b0ffbc24048d5e39f11e.gif)\n\n- 使用`快慢指针`遍历\n- 遍历完后看`慢指针是否等于子序列的长度`\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function (s, t) {\n  let slow = 0; // 慢指针\n  let fast = 0; // 快指针\n\n  // 使用快慢指针，遍历字符串 t\n  while (fast < t.length) {\n    // 当 s[slow] 与 t[fast] 相等时，慢指针向后移动一位\n    if (s[slow] === t[fast]) {\n      slow++;\n    }\n    // 快指针向后移动一位，正常速度移动\n    fast++;\n  }\n  // 如果慢指针的值等于 s 的长度，说明 s 是 t 的子序列\n  return slow === s.length;\n};\n\n```\n\n### 复杂度分析\n\n## 进阶\n\n比较困难，详细题解：[二分查找高效判定子序列](https://labuladong.online/algo/frequency-interview/binary-search-subsequence/)\n\n## 错误记录\n\n","15ab388462f25420bf62bdfec75b6ec7":"\n# 删掉一个元素以后全为 1 的最长子数组\n\n\n`#leetcode`  `#算法/滑动窗口`  `#2024/07/28` `#算法/双指针`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n> 题意就是标题：`删掉一个元素以后全为 1 的最长子数组`\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/f25f1a142fcf530dcaf2a1695946b6da.png)\n\n>  一般是删除 0 ，但有可能也需要删除  1，比如全部为 1 的场景\n\n## 解题思路\n\n> **使用滑动窗口技术：滑动窗口的方法非常适合解决这类\"最长子数组\"或\"最短子数组\"的问题**\n\n### 问题分析\n\n- 我们需要找到一个`最长的子数组`, 这个子数组最多包含一个`0`。\n- 删除这个`0`(如果存在)后，子数组应该全部由`1`组成。\n- 如果整个数组都是`1,`我们仍然需要删除一个元素。\n\n### 具体思路\n\n- 使用两个指针 (`left` 和 `right`)来定义一个窗口，这个窗口代表我们当前考虑的子数组\n   - 扩大窗口：`right++`\n   - 缩小窗口：`left++`\n- 计数策略\n   - 我们需要找到一个`最长的子数组`**, 这个子数组**`最多包含一个0`\n   - **下面就是维护 0 的个数：**`zeroCount`\n- `zeroCount > 1` 时，需要缩小窗口，即 `left++ `\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestSubarray = function (nums) {\n  let left = 0; // 左指针\n  let right = 0; // 右指针\n  let zeroCount = 0; // 0 的个数\n  let res = 0; // 最长的连续的 1 的个数\n\n  // 使用快指针，遍历数组\n  for (; right < nums.length; right++) {\n    \n    // 如果当前元素是 0，就增加 0 的个数\n    if (nums[right] === 0) {\n      zeroCount++;\n    }\n\n    // 如果 0 的个数大于 1，就需要移动左指针,来减少0的数量\n    // 说明窗口内 0 的数量超过了允许的最大值，这时需要收缩窗口\n    while (zeroCount > 1) {\n      // 如果左指针对应的元素是 0，就减少 0 的个数\n      if (nums[left] === 0) {\n        zeroCount--;\n      }\n      // 左指针右移\n      left++;\n    }\n\n    // 在每次迭代中更新最大窗口长度\n    res = Math.max(res, right - left + 1);\n  }\n\n  // 题目要求返回的是 1 的个数，所以需要减去 1\n  // 如果整个数组都是1，我们仍然需要删除一个元素\n  return res < nums.length ? res - 1 : nums.length - 1;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度是 O(n)，其中 n 是数组的长度，因为我们只遍历数组一次。\n- 空间复杂度是 O(1)，因为我们只使用了常数级的额外空间。\n\n## 错误记录\n\n- 边界条件处理：`如果整个数组都是1，我们仍然需要删除一个元素` \n\n","21efc1a5ac02508da2a57b8d2248503a":"\n# 盛最多水的容器\n\n\n`#leetcode`  `#算法/双指针`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/1177bd34d377d88a18b423f085b603ef.png)\n\n## 解题思路\n\n- 左右指针技巧\n- 用 `left` 和 `right` 两个指针从两端向中心收缩，一边收缩一边计算 `[left, right]` 之间的`矩形面积`，取`最大的面积`值即是答案\n   - `矩形面积 =  left 的高度 * right 的高度`\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function (height) {\n  let left = 0; // 左指针\n  let right = height.length - 1; // 右指针\n  let max = 0; // 最大面积\n\n  // 当左指针小于右指针时，执行循环\n  // 这里的循环条件是left < right，而不是left <= right\n  while (left < right) {\n    // 计算当前左右指针对应的面积\n    //  [left, right] 之间的矩形面积 为什么是这个公式？\n    // 因为矩形的面积是由两个因素决定的：底边和高度，底边是两个指针之间的距离，高度是两个指针对应的元素中的较小值\n    const area = Math.min(height[left], height[right]) * (right - left);\n    // 更新最大面积\n    max = Math.max(max, area);\n    // 如果左指针对应的元素小于右指针对应的元素\n    if (height[left] < height[right]) {\n      // 左指针右移\n      left++;\n    } else {\n      // 右指针左移\n      right--;\n    }\n  }\n\n  return max;\n};\n\n```\n\n### 复杂度分析\n\n## 错误记录\n\n> 注意下面的公式，别搞混了\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/5015126dadf1d8fb35a2abe46218b231.png)\n\n## 参考\n\n- [如何高效解决接雨水问题](https://labuladong.online/algo/frequency-interview/trapping-rain-water/`#%E6%89%A9%E5%B1%95%E5%BB%B6%E4%BC%B8)`\n\n","7646de6d494c5f2c9bc18fa430cc4f2f":"\n# 寻找数组的中心下标\n\n`#2024/07/28` `#leetcode`  `#算法/前缀和`  \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/806cae66a6a82c0cf9ac12cab22d1c66.png)\n\n## 解题思路\n\n- 前缀和 `preSum`\n- 假设原数组 nums = [1, 7, 3, 6, 5, 6]\n   - 前缀和数组 `prefixSum` 就会是：[0, 1, 8, 11, 17, 22, 28]\n      - 长度为 `length + 1 ` \n      - 第一个元素为 `0`，表示前 `0` 个元素的和\n      - `preSum[i]` 表示前 `i` 个元素的和\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar pivotIndex = function (nums) {\n  // 前缀和数组\n  // 注意：前缀和数组的长度为 nums.length + 1，第一个元素为 0，表示前 0 个元素的和\n  // preSum[i] 表示前 i 个元素的和\n  // 这种方式可以：避免判断边界条件\n  let preSum = new Array(nums.length + 1).fill(0);\n  // 初始化前缀和数组\n  for (let i = 1; i <= nums.length; i++) {\n    // 当前元素的前缀和 = 前一个元素的前缀和 + 当前元素\n    preSum[i] = preSum[i - 1] + nums[i - 1];\n  }\n  // 根据前缀和判断左半边数组和右半边数组的元素和是否相同\n  for (let i = 0; i < nums.length; i++) {\n    // 当前元素之前的元素和 = 当前元素之后的元素的和\n    // 当前元素右边的元素和 = 当前元素之前的元素的和，\n    // 注意①：当前元素不参与计算\n    // 注意②：preSum[nums.length] 表示整个数组的和\n    // 注意③：当前元素右边的元素和 = 整个数组的和 - 当前元素之后的元素的前缀和\n    if (preSum[i] === preSum[nums.length] - preSum[i + 1]) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n```\n\n### 复杂度分析\n\n## 错误记录\n\n- 而`当前元素`不参与计算\n- 注意前缀和初始化遍历是从`1` 开始的\n\n","f9bf9fba97875b8ba3543da177a90fb6":"\n# 压缩字符串\n\n\n`#算法/双指针`  `#leetcode`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/b269dbb6ca9b010349e814b8bfbfb370.png)\n\n## 解题思路\n\n- 快慢指针\n   - `write` 代表`原地`写入\n      - write 需要正常写入字母 + 出现的次数\n   - `read` 代表往后面`读`\n\n## 代码实现\n\n```javascript\n/**\n * @param {character[]} chars\n * @return {number}\n */\nvar compress = function (chars) {\n  // 快慢指针,都从0开始\n  // write 为慢指针，read 为快指针\n  let write = 0;\n  let read = 0;\n  let n = chars.length;\n  // 快指针遍历数组\n  while (read < n) {\n    // 当前字符\n    let c = chars[read];\n    // 计数器，用于记录当前字符出现的次数\n    let count = 0;\n    // 当快指针对应的元素等于快指针对应的元素时，快指针向后移动一位，计数器加一\n    while (read < n && chars[read] === c) {\n      read++;\n      count++;\n    }\n    // 将当前字符及其出现次数写入数组\n    chars[write++] = c;\n    // 仅在出现次数大于 1 时，才将次数写入数组\n    if (count > 1) {\n      // String(count).split(\"\") 将数字转换为字符串，再转换为字符数组,比如 b12 -> ['b','1', '2']\n      for (let i of String(count).split(\"\")) {\n        chars[write++] = i;\n      }\n    }\n  }\n\n  return write;\n};\n\n```\n\n> - 严格说还需要把数组后面的元素干掉\n> - `String(count).split(\"\")` 用于处理 `count = 12` 这种场景\n\n### 复杂度分析\n\n## 错误记录\n\n","2153dae3e6845c73b2e370facab20b73":"\n# 相等行列对\n\n`#leetcode` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407260948859.png?imageSlim)\n\n## 解题思路\n \n- 第一步：创建一个`哈希表（Map）`来存储每一行的信息。 \n- 第二步：遍历矩阵的每一行\n\t- 将行转换为一个`唯一的字符串`表示（例如，用逗号连接元素）。\n\t- 在哈希表中记录这个字符串表示及其出现次数。 \n- 第三步：遍历矩阵的每一列，重点逻辑都在这里面\n\t- 同样将列转换为字符串表示。\n\t- 检查这个字符串是否在哈希表中存在。\n\t\t- 如果存在，将`计数器`增加哈希表中记录的出现次数。 \n- 最后：返回最终的计数器值。\n\n## 代码实现\n\n```javascript\n/**  \n * @param {number[][]} grid  n x n grid  \n * @return {number}  \n */  \nvar equalPairs = function (grid) {  \n    // 结果  \n    let res = 0;  \n    const len = grid.length;  \n    // 处理行  \n    // 用于记录每一行出现的次数, key 为行字符串，value 为出现次数  \n    const rowMap = new Map();  \n    for (let i = 0; i < len; i++) {  \n        const rowStr = grid[i].join(',');  \n        rowMap.set(rowStr, (rowMap.get(rowStr) || 0) + 1);  \n    }  \n    // 处理列，判断是否在行中出现过  \n    for (let i = 0; i < len; i++) {  \n        let cols = [];  \n        for (let j = 0; j < len; j++) {  \n            cols.push(grid[j][i]);  \n        }  \n        let colStr = cols.join(',');  \n        // 判断是否在行中出现过  \n        if (rowMap.has(colStr)) {  \n            // ::::这里不能只是+1，出现多少次就得加多少次  \n            res += rowMap.get(colStr);  \n        }  \n    }  \n    return res;  \n};\n```\n\n### 复杂度分析\n\n- **时间复杂度**：`O(n^2)`\n\t- 很简单，看处理列里面，两个 for 循环\n- **空间复杂度**：`O(n^2)`\n\t- 虽然 `cols` 看起来就是一个数组，但是每次都会处理  `cols.push(grid[j][i]);` 所以，复杂度也是 `O(n^2)`\n\n## 错误记录","69d1c61cc81b5ad7b6c32f12cac3d5ae":"\n# 移动零\n\n\n`#算法/双指针`  `#leetcode` `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/4d1151bf396c03af984ebd8f5e3bcad9.png)\n\n## 解题思路\n\n> 其实就是 [移除元素](https://www.yuque.com/liguwe/agorithms/wftg17qn12ytlsrc) （指定移动哪个元素） 的特殊版本，这里指定移动` 0 `\n\n- 双指针：`slow` 和 `fast`\n- `slow` 之后的值换成 `0` 即可\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function (nums) {\n  let slow = 0;\n  let fast = 0;\n  while (fast < nums.length) {\n    if (nums[fast] !== 0) {\n      nums[slow] = nums[fast];\n      slow++;\n    }\n    fast++;\n  }\n  for (let i = slow; i < nums.length; i++) {\n    nums[i] = 0;\n  }\n  return nums;\n};\n\n```\n\n## 错误记录\n\n","9f7000795c7b5519ae5d4cd87c656194":"\n# 拥有最多糖果的孩子\n\n`#leetcode`  `#算法` `#2024/07/28` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/37d8e71190091812bedc616e3e431748.png)\n\n## 解题思路\n\n1. 找到最大值： 找到当前 `candies` 数组中的最大元素，这代表孩子们目前拥有的最多的糖果数量。\n2. 计算每个孩子加上额外糖果后的数量： 遍历数组 `candies`，对于每个孩子，计算其拥有的糖果加上 `extraCandies` 后的总和。\n3. 与最大值比较： 比较每个孩子加上额外糖果后的数量是否大于或等于第一步中找到的最大值。\n4. 返回结果数组： 根据比较结果，生成对应的布尔值数组 `result`。\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} candies\n * @param {number} extraCandies\n * @return {boolean[]}\n */\nvar kidsWithCandies = function (candies, extraCandies) {\n  // ① 找到candies中的最大值\n  const max = Math.max(...candies);\n  // ② 遍历candies数组，判断是否满足条件\n  return candies.map((candy) => candy + extraCandies >= max);\n};\n\n```\n\n","aff998aadcb4529c81b0fc2b2f91a3e0":"\n# 找出两数组的不同\n\n`#算法` `#leetcode`  `#2024/07/28` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/2957c151de2e1cf09ca75212d17676ae.png)\n\n## 解题思路\n\n1. `nums1` 中有，但 nums2 `中没有的数字`\n2. `nums2` 中有，但 `nums1` 中没有的数字\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[][]}\n */\nvar findDifference = function (nums1, nums2) {\n  const s1 = new Set(nums1);\n  const s2 = new Set(nums2);\n\n  const res1 = [...s1].filter((num) => !s2.has(num));\n  const res2 = [...s2].filter((num) => !s1.has(num));\n\n  return [res1, res2];\n};\n```\n\n### 复杂度分析\n\n## 错误记录\n\n","9ee8aa36fea25106b05c6be001013231":"\n# 找到最高海拔\n\n\n`#算法` `#2024/07/28` `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/0b67ca13731e85886bdfa6b3502dd319.png)\n\n## 解题思路\n\n1. 初始化一个变量 `max` 来记录最高海拔，初始值为 0。\n2. 初始化一个变量 `current` 来记录当前海拔，初始值为 0。\n3. 遍历 `gain` 数组：\n   - 将当前的高度变化加到 `current` 上。\n   - 比较 `current` 和 `max`，更新 `max` 如果需要。\n4. 返回 `max`。\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} gain\n * @return {number}\n */\nvar largestAltitude = function (gain) {\n  let max = 0; // 最大高度\n  let current = 0; // 当前高度，因为自行车手从海拔为 0 的地方开始骑行，所以当前高度为 0\n  for (let i = 0; i < gain.length; i++) {\n    //  gain[i] 是点 i 和点 i + 1 的 净海拔高度差（\n    //  当前高度 = 当前高度 + gain[i]\n    current += gain[i];\n    max = Math.max(max, current);\n  }\n\n  return max;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度是 O(n)，其中 n 是 `gain` 数组的长度，因为我们只需要遍历一次数组。\n- 空间复杂度是 O(1)，因为我们只使用了常数级的额外空间\n\n## 错误记录\n\n- let 和 const 用混了\n\n","c038f6b3d1805125b4f54f5f4a026a16":"\n# 种花问题\n\n\n`#算法` `#leetcode`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/3f1ea7b209fa83f23540a2c340ecfa50.png)\n\n### 重点\n\n- 转成规则：即上图中红色文字部分\n\n## 思路\n\n1. `遍历数组`：从头到尾遍 `flowerbed` 数组。\n2. `检查位`：如果当前位置是 `0`，并且其两侧（如果存在的话）也是 `0` 或 `1`，则表示这里可以种花。\n3. 种花并调整`**计数器**`：每种一朵，减少 `n` 的值。当 `n` 减到 `0` 以下时，表示可以种下 `n` 朵花，返回 `true`。\n4. `最终检查`：遍历完数组后，检查 `n` 是否小或等于 `0`。\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} flowerbed\n * @param {number} n\n * @return {boolean}\n */\nvar canPlaceFlowers = function (flowerbed, n) {\n  for (let i = 0; i < flowerbed.length; i++) {\n    // 检查当前位置及左、右位置是否可以种花，需要满足以下条件：\n    // 条件①： 当前元素为0\n    if (flowerbed[i] === 0) {\n      // 条件②： 第一个元素 或者 前一个元素为0时\n      if (i === 0 || flowerbed[i - 1] === 0) {\n        // 条件③： 最后一个元素 或者 后一个元素为0时\n        if (i === flowerbed.length - 1 || flowerbed[i + 1] === 0) {\n          flowerbed[i] = 1;\n          n--;\n        }\n      }\n    }\n  }\n  return n <= 0;\n};\n\n```\n\n> - 上面的写法，只是为了表达递进的关系，其实可以不这么写！\n> - 注意每个条件里面是`或者`的关系\n\n## 参考\n\n- [https://leetcode.cn/problems/can-place-flowers/submissions/548039007/?envType=study-plan-v2&envId=leetcode-75](https://leetcode.cn/problems/can-place-flowers/submissions/548039007/?envType=study-plan-v2&envId=leetcode-75)\n\n","78441e9463a3533b88874e1e678fcd58":"\n# 字符串的最大公因子\n\n\n`#算法` `#2024/07/28` `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/85bd009b5d64c17b72e1ab92ba43cb31.png)\n\n### 题目重点\n\n- 最大公因子\n\n## 思路\n\n1. 检查  `str1 + str2` 是否等于 `str2 + str1`。 不相等，说明没有公共前缀字符串，直接返回空字符串。\n2. 如果相等，找到 `str1` 和 `str2` 长度的`最大公约数`（GCD）。\n3. 返回 `str1` 的前 `G` 个字符。\n\n## 代码实现\n\n```javascript\n/\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar gcdOfStrings = function (str1, str2) {\n  // 如果str1和str2的长度拼接不相等, 则返回空字符串\n  if (str1 + str2 !== str2 + str1) {\n    return \"\";\n  }\n  // 代码走到这里，说明 str1 和 str2 是符合条件的\n  // m 和 n 一定是有最大公约数的\n  const m = str1.length;\n  const n = str2.length;\n  const max = gcd(m, n); // 求最大公约数\n  return str1.substring(0, max); // 返回str1的前max个字符\n};\n\n/\n * 求最大公约数\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nvar gcd = function (a, b) {\n  // a % b的结果赋值给a, b的值赋值给a, 直到b为0\n  // 为什么 b 为 0 时, a 就是最大公约数呢?\n  while (b !== 0) {\n    const temp = a % b;\n    a = b;\n    b = temp;\n  }\n  return a;\n};\n\n```\n\n## 参考\n\n- [https://leetcode.cn/problems/greatest-common-divisor-of-strings/submissions/548029044/?envType=study-plan-v2&envId=leetcode-75](https://leetcode.cn/problems/greatest-common-divisor-of-strings/submissions/548029044/?envType=study-plan-v2&envId=leetcode-75)\n\n","79ea85ebb4085f88b192349535abce8f":"\n# 子数组最大平均数 I\n\n\n`#leetcode` `#算法/滑动窗口` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/400755e6e2354c1f2047b7ed1977227b.png)\n\n> **注意：返回的是最大平均树**\n\n## 解题思路\n\n### 解法一：滑动窗口，看下面几张图\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/d519707b0a58722271e07e52f00ca916.png)\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/67925ec639e4c341ddabdba40ca16863.png)\n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/c0a15fa222bab11b280369e83f570392.png)\n\n### 解法二：前缀和\n\n> 不展开了\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findMaxAverage = function (nums, k) {\n  // sum 用于记录滑动窗口中的元素之和\n  let sum = 0;\n  // 前 k 个元素之和，即滑动窗口的初始值，即【滑动窗口】的前 k 个元素之和\n  // 初始化 sum，代表【滑动窗口】的前 k 个元素之和\n  for (let i = 0; i < k; i++) {\n    sum += nums[i];\n  }\n\n  // max 用于记录滑动窗口中元素之和的最大值\n  let max = sum;\n\n  // 开始滑动窗口，从 k 开始，每次移动一位，动态维护 sum 和 max 的值\n  // 遍历数组，从 k 开始\n  for (let i = k; i < nums.length; i++) {\n    // 滑动窗口，每次移动一位\n    sum = sum + nums[i] - nums[i - k];\n    // 比较 sum 和 max 的大小，取最大值\n    max = Math.max(max, sum);\n  }\n\n  // 最后返回 max / k，即最大平均值\n  return max / k;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(n)，其中 n 是数组的长度。我们只遍历了一次数组。 \n- 空间复杂度：O(1)，我们只使用了常数额外空间。\n\n## 错误记录\n\n","689824e8811051838d7c85c53e2c5f34":"\n# 最大连续 1 的个数 III\n\n\n`#leetcode`  `#2024/07/28` `#算法/滑动窗口`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/090a868fc6988e29390058bac437720d.png)\n\n### 原题不好理解，换种问法\n\n> - 如果我可以改变`最多 k 个 0`，那么我能得到的`最长的连续 1 序列`有多长 ？ \n> - 看题目是：最大连续 1 的个数\n\n## 解题思路\n\n1. 使用两个指针 `left` 和 `right`，初始都指向数组开头。\n   1. 向右移动 right 指针，`扩大窗口`。\n   2. 如果遇到 0，就将 k 减 1。\n2. 当 k 小于 0 时，说明窗口内 0 的数量超过了允许的最大值，这时需要`收缩窗口`：\n   - 移动 left 指针\n   - 如果 left 指针经过的是 0，就将 k 加 1\n3. 在`每次迭代中`更新最大窗口长度。\n\n## 代码实现\n```javascript\n/**\n * @param {number[]}  nums\n * @param {number} k  0 的个数\n * @return {number}\n */\nvar longestOnes = function (nums, k) {\n  // 左指针\n  let left = 0;\n  // 右指针\n  let right = 0;\n\n  // 结果：最长的连续的 1 的个数\n  let res = 0;\n\n  // 向右移动 right 指针，扩大窗口\n  for (; right < nums.length; right++) {\n    // 如果遇到 0，就将 k 减 1\n    // 如果当前数字是 0，就减少可用的 k\n    if (nums[right] === 0) {\n      k--;\n    }\n\n    // 如果 k 小于 0，需要移动左指针\n    // 说明窗口内 0 的数量超过了允许的最大值，这时需要收缩窗口\n    if (k < 0) {\n      // 如果左指针指向的是 0，增加可用的 k\n      if (nums[left] === 0) {\n        k++;\n      }\n      left++;\n    }\n\n    // 在每次迭代中更新最大窗口长度\n    res = Math.max(res, right - left + 1);\n  }\n\n  return res;\n};\n\n```\n\n> 为什么是 `right - left + 1`，而不是 `right - left` ？\n> - 在数组中，索引是从 0 开始的。例如，如果 `left = 0，right = 3`，那么实际上包含了 4 个元素（`索引 0, 1, 2, 3`）\n\n### 复杂度分析\n\n- 时间复杂度：`O(n)`，其中 n 是数组的长度。我们只遍历了一次数组。\n- 空间复杂度：`O(1)`，我们只使用了常数额外空间\n\n## 错误记录\n\n","db0e050a0f82503e804f6e69792665f8":"\n# K 和数对的最大数目\n\n\n`#leetcode`  `#算法/哈希`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/ce8d96510f9e7129cb173c644ceb5657.png)\n\n## 2. 解题思路\n\n- 思路一：使用 hash 正常遍历思路即可\n   - 边界情况处理：如果存在两个相同的值的场景\n- 思路二：先排序，然后使用双指针，这里没写代码了\n\n## 3. 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maxOperations = function (nums, k) {\n  // 用于记录重复元素的个数\n  let map = new Map();\n  // 初始化 map\n  for (const num of nums) {\n    map.set(num, (map.get(num) || 0) + 1);\n  }\n\n  // 代表最大操作次数\n  let count = 0;\n\n  for (const num of nums) {\n    // 需要的另一个数，即 num + need = k\n    const need = k - num;\n    // 确保 num 和 need 存在的个数都大于 0，才能进行操作\n    if (map.get(need) > 0 && map.get(num) > 0) {\n      // 如果 num === need，且 map 中的值小于 2，则不满足条件\n      if (num === need && map.get(num) < 2) continue;\n\n      // 更新 map 中的值\n      map.set(num, map.get(num) - 1);\n      map.set(need, map.get(need) - 1);\n      // 更新 count\n      count++;\n    }\n  }\n\n  return count;\n};\n\n```\n\n> 1. 两个 for 循环为了更好的理解\n\n### 3.1. 复杂度分析\n\n## 4. 代码实现二\n\n- 先排序，然后使用双指针，这里没写代码了\n\n## 5. 错误记录\n\n1. 不能使用 `map.has` ，代表是否有某个属性值\n\n","be1631acdad95205b825d27ed529f561":"\n# 删除链表的中间节点\n\n\n`#双指针` `#链表` `#快慢指针` `#2024/07/30` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407300745016.png?imageSlim)\n\n> 注意上面的标注的意思\n## 2. 解题思路\n\n1. **base case 特殊情况处理**：\n    - 如果链表为空或只有一个节点，我们直接返回 null。\n2. **使用快慢指针**：\n    - 初始化三个指针：`slow`、`fast` 和 `prev`。\n        - `slow` 和 `fast` 都从 `head` 开始。\n        - `prev` 用来跟踪 `slow` 的前一个节点\n3. **移动指针**：\n    - 在每次循环中，`fast` 移动`两步`，`slow` 移动`一步`。\n    - 当循环结束时，`slow` 将指向中间节点。\n4. **删除中间节点**：\n    - 循环结束后，`prev` 指向中间节点的前一个节点。\n    - 我们通过设置 `prev.next = slow.next` 来删除中间节点。\n5. **返回结果**：\n    - 返回修改后的链表头部 `head`。\n\n## 3. 代码实现\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteMiddle = function (head) {\n  // 1. **base case 特殊情况处理**：\n  //     - 如果链表为空或只有一个节点，我们直接返回 null。\n  if (head === null || head.next === null) {\n    return null;\n  }\n\n  // 2. **使用快慢指针**：\n  //     - 初始化三个指针：`slow`、`fast` 和 `prev`。\n  //         - `slow` 和 `fast` 都从 `head` 开始。\n  //         - `prev` 用来跟踪 `slow` 的前一个节点\n  let slow = head;\n  let fast = head;\n  let prev = null;\n\n  // 3. **移动指针**：\n  //     - 在每次循环中，`fast` 移动`两步`，`slow` 移动`一步`。\n  //     - 当循环结束时，`slow` 将指向中间节点。\n\n  while (fast !== null && fast.next !== null) {\n    // 快指针移动两步\n    fast = fast.next.next;\n    // 先记录slow的位置，使用prev指针\n    prev = slow;\n    // 慢指针移动一步\n    slow = slow.next;\n  }\n\n  // 4. **删除中间节点**：\n  //     - 循环结束后，`prev` 指向中间节点的前一个节点。\n  //     - 我们通过设置 `prev.next = slow.next` 来删除中间节点。\n\n  prev.next = slow.next; // 删除中间节点\n\n  // 5. **返回结果**：\n  //     - 返回修改后的链表头部 `head`。\n\n  return head;\n};\n\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 `n` 是链表的长度。我们只需要遍历链表一次。\n- 空间复杂度是 `O(1)`，因为我们只使用了固定数量的额外空间（几个指针）。\n\n## 4. 错误记录","f2b5508ab37950f58b750e7e4292ac73":"\n# 从字符串中移除星号\n\n\n`#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407271718841.png?imageSlim)\n\n## 解题思路\n\n1.  我们使用一个`栈`来存储字符。\n2.  遍历输入字符串 `s` 中的每个字符：\n    - 如果当前字符`不是星号`，我们就把它`推入栈`中。\n    - 如果当前字符`是星号`，我们就从`栈顶弹出一个字符`（如果栈不为空）。\n3. 最后，栈中剩下的字符就是我们的结果。\n\t- 我们使用 `join()` 方法将栈中的字符连接成一个字符串\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar removeStars = function (s) {\n  // 使用栈\n  let stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"*\") {\n      stack.pop();\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join(\"\");\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 n 是字符串的长度。\n- 空间复杂度也是 `O(n)`，因为在最坏的情况下（没有星号）\n\n## 错误记录\n\n","dbb62c23d6dc5049abd8a21d3eefca7e":"\n# 奇偶链表\n\n\n`#单链表`  `#2024/07/30`  `#单链表/双指针` `#单链表/快慢指针`  \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407300802267.png?imageSlim)\n\n## 2. 解题思路\n\n1. 处理特殊情况：base case\n    - 如果`链表为空`或`只有一个节点`，直接返回原链表。\n2. 初始化指针：三个变量\n    - odd：指向奇数索引节点，初始为 head\n    - even：指向偶数索引节点，初始为 head.next\n    - evenHead：保存偶数链表的头节点，用于最后的连接\n3. 遍历链表，分离奇偶节点\n    - 奇数节点连接到奇数链表\n    - 偶数节点连接到偶数链表\n4. 连接奇偶链表\n    - 将`奇数链表的尾部`与`偶数链表的头部`相连\n5. 返回重组后的链表头\n\n## 3. 代码实现\n\n```javascript\n/**  \n * @description 解题思路步骤：  \n * 1. 处理特殊情况：base case  \n *     - 如果`链表为空`或`只有一个节点`，直接返回原链表。  \n * 2. 初始化指针：三个变量  \n *     - odd：指向奇数索引节点，初始为 head  \n *     - even：指向偶数索引节点，初始为 head.next  \n *     - evenHead：保存偶数链表的头节点，用于最后的连接  \n * 3. 遍历链表，分离奇偶节点  \n *     - 奇数节点连接到奇数链表  \n *     - 偶数节点连接到偶数链表  \n * 4. 连接奇偶链表  \n *     - 将`奇数链表的尾部`与`偶数链表的头部`相连  \n * 5. 返回重组后的链表头  \n * */  \n  \n/**  \n * Definition for singly-linked list. * function ListNode(val, next) {  \n *     this.val = (val===undefined ? 0 : val)  \n *     this.next = (next===undefined ? null : next) * }  \n */  \n/**  \n * @param {ListNode} head  \n * @return {ListNode}  \n */  \nvar oddEvenList = function (head) {  \n  \n    // ① 处理特殊情况：base case  \n    if (head === null || head.next === null) {  \n        return head;  \n    }  \n    // ② 初始化指针：三个变量  \n    let odd = head; // 奇数链表的头节点  \n    let even = head.next; // 偶数链表的头节点  \n    let evenHead = even;  // 保存偶数链表的头节点，用于最后的连接  \n  \n    // ③ 遍历链表，分离奇偶节点  \n    while (even !== null && even.next !== null) {  \n        // 奇数节点连接到奇数链表  \n        // 奇数节点的下一个节点 指向 偶数节点的下一个节点（自然是下一个技术节点了）  \n        odd.next = even.next; \n        odd = odd.next;       // 奇数节点指针后移  \n  \n        // 偶数节点连接到偶数链表  \n        // 偶数节点的下一个节点 指向 奇数节点的下一个节点（自然是下一个偶数节点了）  \n        even.next = odd.next;  \n        even = even.next;      // 偶数节点指针后移  \n    }  \n  \n    // ④ 连接奇偶链表  \n    odd.next = evenHead; // 将奇数链表的尾部与偶数链表的头部相连  \n  \n    // ⑤ 返回重组后的链表头  \n    return head;  \n  \n};\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度：`O(n)`，其中 `n` 是链表的长度，我们只遍历了一次链表。 \n- 空间复杂度：`O(1)`，我们只使用了`常数级`的额外空间\n\n## 4. 错误记录","1c8143dd7ec35d2cb2342baeac9eac51":"\n# 反转链表\n\n\n`#leetcode`   `#2024/08/10`  `#算法/链表`   `#算法/链表`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![图片&文件](./files/Pastedimage20240810173705.png)\n\n## 解题思路\n\n### 思路一：递归魔法\n\n![图片&文件](./files/Pastedimage20240810173541.png)\n\n#### 代码实现\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n  // base case 1: 如果 head 为空，返回 null\n  if (head === null) {\n    return null;\n  }\n  // base case 2: 链表只有一个节点（head.next === null），直接返回这个节点。\n  // 递归到最后一个节点，返回最后一个节点\n  if (head.next === null) {\n    return head;\n  }\n\n  let last = reverseList(head.next);\n  head.next.next = head;\n  head.next = null;\n\n  return last;\n};\n\n```\n\n> `head.next === null` 时，代表链表只有一个节点\n\n#### 复杂度分析\n\n- 时间复杂度：`O(n)`\n    - 其中 n 是链表的长度\n    - 函数会递归 n 次，每次递归的操作是常数时间\n- 空间复杂度：`O(n)`\n    - 递归调用会使用栈空间，最大深度为 n\n    - 没有使用额外的数据结构，所有额外空间都来自递归调用栈\n\n","87a786e725c45185b19bdce97d557ea2":"\n# 链表最大孪生和\n\n\n`#leetcode`   `#2024/08/10`  `#算法/链表`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![图片&文件](./files/Pastedimage20240810174638.png)\n\n- 理解\n\t- 你先选第一个节点和最后一个节点，计算它们的和。\n\t- 然后选第二个节点和倒数第二个节点，计算和。\n\t- 依此类推，直到你到达链表的中间。\n- 举个例子：假设链表是：`[5,4,2,1]`\n    - 第一对孪生节点：5 和 1，和是 6\n    - 第二对孪生节点：4 和 2，和是 6\n    - 所有孪生和中最大的是 6，所以答案是 6\n\n## 解题思路\n\n1. **找到链表的中点**：\n    - 我们可以使用**快慢指针**的方法。快指针每次走两步，慢指针每次走一步\n    - 当快指针到达链表末尾时，慢指针会到达链表的**中点位置**\n        - 因此，**慢指针可以用来分割链表**。\n2. **反转链表的后半部分**：可参考 【31.  反转链表】\n    - 通过`慢指针`，我们可以获取到链表的后半部分\n    - 反转完后，一定要**断开**前后两部分，让 `slow.next = null` 即可\n3. **计算孪生和并找出最大值**：\n    - 定义两个指针：`second` 和 `first`\n        - 一个从链表头开始（指向前半部分）\n        - 一个从反转后的链表头开始（指向新的后半部分）。\n    - 同时移动两个指针，计算两个对应节点的和并持续更新最大孪生和。\n4. **恢复链表结构（可选）**：\n    - 如果不需要保存链表的原始状态，这步可以省略。\n    - 否则，我们可以再反转一次后半部分的链表，将其恢复为原始状态。\n\n### 代码实现\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar pairSum = function (head) {\n  // ① 先使用快慢指针找到链表的中间节点\n  let slow = head;\n  let fast = head;\n  while (fast !== null && fast.next !== null) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n\n  // ② 反转后半部分链表\n  let secondHalf = reverseList(slow);\n\n  // 断开前半部分链表和后半部分链表的连接\n  slow.next = null;\n\n  // ③ 遍历，找到最大值\n  let sum = 0;\n  let first = head;\n  let second = secondHalf;\n\n  while (first !== null && second !== null) {\n    sum = Math.max(sum, first.val + second.val);\n    first = first.next;\n    second = second.next;\n  }\n\n  return sum;\n};\n\nvar reverseList = function (head) {\n  // base case: 如果 head 为空，返回 null\n  if (head === null) {\n    return null;\n  }\n  // base case: 如果 head.next 为空，返回 head\n  // 递归到最后一个节点，返回最后一个节点\n  if (head.next === null) {\n    return head;\n  }\n\n  let last = reverseList(head.next);\n  head.next.next = head;\n  head.next = null;\n\n  return last;\n};\n\n```\n\n> 完全反转链表可参考 【31.  反转链表】\n### 复杂度分析\n\n- 时间复杂度：`O(n)`\n\t- 其中 n 是链表的长度\n\t- 我们遍历链表找中点，反转后半部分，然后再次遍历计算最大和，每步操作都是 `O(n)`。\n- 空间复杂度：`O(1)`，只使用了常数额外空间\n\n","2d70f6daa4305790a0da640db7adc1d3":"\n# 二叉树的最大深度\n\n`#算法/二叉树` `#2023/04/22`  `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目 \n\nhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/\n\n## 2. 思路 1：遍历一遍二叉树的思路\n\n- `遍历`一遍二叉树\n\t- 用一个`外部变量 res`记录每个节点所在的深度\n\t- 变量`depth` 记录当前递归到的节点深度\n- 最后，取 `depth` 和 `res` 的最大值就可以得到最大深度，代码如下：\n\n```javascript\nvar maxDepth = function(root) {\n    let res = 0;\n    // depth 记录当前递归到的节点深度\n    let depth = 0;\n    function traverse(root) {\n        if(root === null) return;\n        depth++;\n        // 到达叶子节点\n        if(root.left === null && root.right === null){\n            res = Math.max(depth, res);\n        }\n        traverse(root.left);\n        traverse(root.right);\n        depth--;\n    }\n    traverse(root);\n    return res;\n};\n```\n\n> [!warning]\n> 注意：函数命名和框架 `traverse` ，这种规范的好处是直接套用就行，主要精力放在具体逻辑上就好，架子的东西都是个人习惯，但要统一，不然给自己添加成本\n\n### 2.1. 复杂度分析\n\n- 时间复杂度：O(n)\n\t- 其中 n 是**二叉树中的节点数**。\n\t- 这个算法会遍历二叉树的每个节点一次，因此时间复杂度是 O(n)。\n- 空间复杂度：O(h)\n\t- 其中 h 是**二叉树的高度**。\n\t- 空间复杂度主要来自于**递归调用栈的深度**。\n\t- 在最坏情况下（树完全不平衡，呈现为一条链），树的高度可能达到 n，此时空间复杂度为 `O(n)`。\n\t- 在最好情况下（完全平衡二叉树），树的高度为 log(n)，空间复杂度为 `O(log n)`。\n\t- 因此，空间复杂度可以表示为 O(h)，其中 h 是树的高度。\n\n## 3. 思路 2：分解问题的思路\n\n- 即通过`子树的最大深度`推导出`原树的深度`\n- 所以必然主要逻辑都在 `后序位置`，因为`后序位置`能够得到子树的深度。\n\n```js\nvar maxDepth = function (root) {\n\t// base case\n    if (root == null) {\n        return 0;\n    }\n    // 利用定义，计算左右子树的最大深度\n    var leftMax = maxDepth(root.left);\n    var rightMax = maxDepth(root.right);\n    // 整棵树的最大深度等于左右子树的最大深度取最大值，\n    // 然后再加上根节点自己\n    var res = Math.max(leftMax, rightMax) + 1;\n    return res;\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n\t- 其中 n 是**二叉树中的节点数**。\n\t- 这个算法会访问二叉树的每个节点一次，对每个节点进行常数时间的操作。\n\t- 因此，总的时间复杂度是 O(n)。\n- 空间复杂度：O(h)\n\t- 其中 h 是二叉树的高度。\n\t- 空间复杂度主要来自于递归调用栈的深度。\n\t- 在最坏情况下（树完全不平衡，呈现为一条链），树的高度可能达到 n，此时空间复杂度为 O(n)。\n\t- 在最好情况下（完全平衡二叉树），树的高度为 log(n)，空间复杂度为 O(log n)。\n\t- 因此，空间复杂度可以表示为 O(h)，其中 h 是树的高度。","bb0585b467575456a544858302d29829":"\n# 叶子相似的树\n\n\n`#leetcode`   `#2024/08/11`  `#算法/二叉树` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![图片&文件](./files/Pastedimage20240811164506.png)\n\n## 2. 解题思路\n\n1. 分别获取两棵树的**叶值序列**\n\t- 遍历一遍树\n\t- 当遇到叶节点（**左右子节点都为空**）时，将其值加入序列\n2. 比较两个序列是否相同\n\n## 3. 代码实现\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {boolean}\n */\nvar leafSimilar = function (root1, root2) {\n    // 获取叶子节点的序列\n    const getSeq = (root) => {\n        const res = [];\n        // 前序遍历\n        const traverse = (node) => {\n            if (!node) {\n                return;\n            }\n            if (!node.left && !node.right) {\n                res.push(node.val);\n            }\n            traverse(node.left);\n            traverse(node.right);\n        }\n        traverse(root);\n        return res;\n    }\n    const seq1 = getSeq(root1);\n    const seq2 = getSeq(root2);\n    // 比较两个序列是否相同\n    // 如果长度不同，直接返回 false\n    if (seq1.length !== seq2.length) {\n        return false;\n    }\n    // 逐个比较, 如果有不同的元素，直接返回 false\n    for (let i = 0; i < seq1.length; i++) {\n        if (seq1[i] !== seq2[i]) {\n            return false;\n        }\n    }\n    // 最后，两个序列完全相同，返回 true\n    return true;\n};\n```\n\n## 4. 复杂度分析\n\n- 时间复杂度：`O(n1 + n2)`\n\t- n1 和 n2 分别是两棵树的节点数。\n\t- `getSeq 函数`对每棵树进行一次完整的遍历，时间复杂度为 O(n)。\n\t\t- 对于root1 和 root2，我们分别调用一次getSeq，所以这部分的时间复杂度是 `O(n1 + n2)`。\n\t- 最后的比较过程，最坏情况下需要比较所有叶子节点，但这个操作的时间复杂度不会超过 `O(min(n1, n2))`。\n\t- 因此，总的时间复杂度是 O(n1 + n2)。\n- 空间复杂度：`O(h1 + h2 + L)`\n\t-  h1 和 h2 分别是两棵树的高度。\n\t- L 是叶子节点的数量，最坏情况下 `L = min(n1, n2)`。\n\t- 递归调用栈的深度最大为树的高度，因此需要 O(h1) 和 O(h2) 的空间。\n\t- seq1 和 seq2 数组存储叶子节点值，共需要 `O(L)` 的空间。\n\t- 因此，总的空间复杂度是 `O(h1 + h2 + L)`。\n- 最坏情况分析：\n\t- 在最坏情况下，当树完全不平衡（如链状结构）时，h1 可能等于 n1，h2 可能等于 n2。\n\t- 此时，空间复杂度可能退化为 `O(n1 + n2)`。\n- 平均情况分析：\n\t- 对于较为平衡的树，h1 和 h2 通常远小于 n1 和 n2。\n\t- 在这种情况下，空间复杂度会更接近 O(log(n1) + log(n2) + L)。\n\n## 5. 优化建议\n\n- 可以考虑**使用迭代器或生成器**来逐个生成和比较叶子节点，而不是先存储完整的序列。\n\t- 这样可以将空间复杂度降低到 **O(h1 + h2)**，但可能会稍微增加时间复杂度\n\n## 6. 错误记录\n\n> [!danger]\n> 注意最后返回 ture","5a304d3644045d47a81eb81a9475b2f9":"\n# 统计二叉树中好节点的数目\n\n\n`#leetcode`   `#2024/08/11`  `#算法/二叉树` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![图片&文件](./files/Pastedimage20240811201951.png)\n\n### 好节点定义\n\n如果从根节点到这个节点的路径上的所有节点值都不大于这个节点的值，那么这个节点被称为\"好节点\"。\n\n举个例子：\n\n![图片&文件](./files/Pastedimage20240811202056.png)\n\n这个树的结构是：\n- 根节点是 3\n- 左子节点是 1\n\t- 左子节点是 3\n- 右子节点是 4\n\t- 左子节点是 1\n\t- 右子节点是 5\n\n现在，让我们再次分析这个树中的\"好节点\"：\n1. 根节点 3 是好节点（路径上只有它自己）\n2. 左子树的 1 不是好节点（因为 3 > 1）\n3. 左子树的 3 是好节点（因为 3 >= 3）\n4. 右子树的 4 是好节点（因为 4 > 3）\n5. 右子树的 1 不是好节点（因为 3 > 1 且 4 > 1）\n6. 右子树的 5 是好节点（因为 5 > 3 且 5 > 4）\n\n因此，这个树中共有 4 个好节点\n\n## 解题思路：遍历一遍二叉树的思路\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar goodNodes = function (root) {\n  // 好节点的数量\n  let res = 0;\n  // 递归函数\n  /**\n   * @param {TreeNode} node 当前节点\n   * @param {number} max 当前路径上的最大值, 初始值为根节点的值,\n   *                     后面会不断更新，需要传递给子节点\n   * */\n  function traverse(node, max) {\n    if (!node) {\n      return;\n    }\n    // 前序位置\n    // 先判断当前节点是否是好节点\n    // 如果是，好节点数量加 1，同时更新 max\n    if (node.val >= max) {\n      res++;\n      max = node.val;\n    }\n    // 继续递归左右子树\n    traverse(node.left, max);\n    traverse(node.right, max);\n  }\n  traverse(root, root.val);\n  return res;\n};\n\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n    - 这里的 `n` 是**树中节点的数量**。\n    - 函数 traverse 会访问树中的每个节点一次，因此时间复杂度是线性的。\n- 空间复杂度：`O(h)`\n    - **h** 是树的高度。\n    - 空间复杂度主要来自**递归调用栈**。在最坏情况下（树完全不平衡，呈现为一条链），高度可能达到 n，此时空间复杂度为 O(n)。\n    - 在平衡树的情况下，高度约为 `log(n)`，空间复杂度为 `O(log n)`\n\n## 注意点\n\n- 更新 `max` 和 `res` 是在前序位置上\n\n","fd3cf851d24b5886b126c66efbf5ad02":"\n# 路径总和 III\n\n\n`#leetcode`   `#2024/08/17` `#算法/二叉树` `#算法/前缀和` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![图片&文件](./files/Pastedimage20240817143510.png)\n\n## 2. 解题思路\n\n- 二叉树的前序后序遍历\n- 前缀和技巧\n\n## 3. 代码实现\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number}\n */\nvar pathSum = function(root, targetSum) {\n\n    // key 是前缀和，value 是前缀和为 pathSum 的个数\n    const preSumCount = new Map();\n    // 初始化，前缀和为 0 的路径有一条\n    // 为什么要初始化呢？\n    // 这个设置可以被理解为代表一个\"空路径\"，其和为 0\n    preSumCount.set(0, 1);\n    // pathSum 记录当前路径和，即从根节点到当前节点的路径和\n    let pathSum = 0;\n    // res 记录满足条件的路径条数\n    let res = 0;\n    const traverse = function(root) {\n        // 递归终止条件\n        // base case\n        if (root == null) {\n            return;\n        }\n\n        /*************************************************\n         * ::::::::::::::::::::: 前序遍历位置 ::::::::::::::::::\n         ************************************************/\n        // 前序遍历位置, 计算路径和\n        pathSum += root.val;\n\n        // 先看一下路径和为 pathSum - targetSum 的路径有多少条\n        // :::: pathSum - targetSum 代表的是从根节点到当前节点的路径和为 targetSum\n        // 即满足条件的路径，所以更新 res 的值\n        res += preSumCount.get(pathSum - targetSum) || 0;\n        // 记录从二叉树的根节点开始，路径和为 pathSum 的路径条数\n        preSumCount.set(pathSum, (preSumCount.get(pathSum) || 0) + 1);\n\n        traverse(root.left);\n        traverse(root.right);\n\n        /*************************************************\n         * ::::::::::::::: 后序遍历位置 ::::::::::::::\n         ************************************************/\n        preSumCount.set(pathSum, preSumCount.get(pathSum) - 1);\n        pathSum -= root.val;\n    }\n\n    traverse(root);\n    return res;\n};\n\n\n```\n\n## 4. 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 是树中的节点数。\n- 空间复杂度：O(N)，主要由递归调用栈和 `preSumCount` Map 贡献。\n\n## 5. 错误记录\n\n初始化空路径的处理：`preSumCount.set(0, 1);`\n\n","125d953cf7d65f088db4a1bedf7e70c8":"\n# 小行星碰撞\n\n`#2024/07/28`  `#算法/栈`  `#leetcode` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407271746254.png?imageSlim)\n\n## 解题思路\n\n1. 初始化一个`空栈`，用于存储当前状态的“小行星”。\n2. 遍历输入的小行星数组：\n    - ① 定义一个变量`destroyed` ，标识当前元素是否被摧毁\n    - ② **while循环**：如果栈不为空，且当前元素为负数 `向左移动`，且栈顶元素为正数，向右移动\n\t\t- 如果栈顶小行星更小，则`栈顶小行星`被摧毁，`continue`  while 遍历\n\t\t- 如果栈顶小行星更大，则`当前小行星`被摧毁，`break`  while 遍历\n\t\t- 若两者质量相等，则它们相互抵消，`都被摧毁`，`break` while 遍历\n    - ③ 如果当前元素`没有被摧毁`，入栈\n3. 最后 `res`\n\n>  栈顶元素被销毁，代表 `出栈`\n>  当前元素被销毁，代表 `不入栈`\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} items\n * @return {number[]}\n */\nvar itemCollision = function (items) {\n  const stack = [];\n\n  // 遍历数组\n  for (let item of items) {\n    // ① 定义一个变量`destroyed` ，标识当前元素是否被摧毁\n    let destroyed = false;\n\n    // 如果栈不为空，且当前元素为负数，且栈顶元素为正数\n    while (stack.length > 0 && item < 0 && stack[stack.length - 1] > 0) {\n      let top = stack[stack.length - 1];\n      // 如果栈顶元素的绝对值小于当前元素的绝对值，则栈顶元素被销毁\n      if (top < -item) {\n        stack.pop();\n        continue;\n      }\n      // 如果栈顶元素的绝对值大于当前元素的绝对值，则当前元素被销毁\n      else if (top > -item) {\n        destroyed = true;\n        break;\n      }\n      // 如果栈顶元素的绝对值等于当前元素的绝对值，则栈顶元素和当前元素都被销毁\n      else if (top === -item) {\n        stack.pop();\n        destroyed = true;\n        break;\n      }\n    }\n\n    // 如果当前元素没有被销毁，则入栈\n    if (!destroyed) {\n      stack.push(item);\n    }\n  }\n\n  return stack;\n};\n\n```\n\n### 复杂度分析\n\n#### 时间复杂度\n\n遍历数组是 `O(n)`，而内部的 `while` 循环在整个算法过程中也为 `O(2)`（每个元素最多只会进出栈一次），所以整体时间复杂度为 `O(n)`\n\n#### 空间复杂度\n\n1. **栈的使用**：\n    - 由于算法使用了一个栈 `stack` 来存储未被摧毁的元素。\n    - 最坏情况下，所有元素都不会相互碰撞（例如，全为正数或全为负数），则栈的大小为 `n`。\n2. **额外空间**：\n    - 除了栈之外，没有使用额外的显著空间。\n\n因此，空间复杂度也是 `O(n)`。\n\n## 错误记录\n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407280720119.png?imageSlim)\n","2153167ba7f459a18e01ea483f941c29":"\n# 字符串解码\n\n\n`#2024/07/28` `#算法/栈` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407280730257.png?imageSlim)\n\n## 解题思路\n\n**栈结构**可以很好地处理嵌套问题\n1. **使用两个栈**：\n    - 一个栈存储重复次数（数字部分）。\n    - 另一个栈存储字符串（字符部分）。\n2. **遍历字符串**：\n    - ① 遇到`数字`时，将完整的数字提取出来。\n    - ② 遇到 `[` 时，表示接下来会是一个新的子字符串，准备入栈。\n    - ③ 遇到 `]` 时，表示当前子字符串结束，需要出栈并进行处理重复。\n    - ④ 遇到`普通字符`时，直接累加到当前的字符串段中。\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  // ① 使用两个栈，分别存储倍数和字符串\n  let countStack = [];\n  let strStack = [];\n  // 代表当前的字符串\n  let currentStr = \"\";\n  //代表出现的次数\n  let k = 0;\n\n  // 遍历字符串\n  for (let i = 0; i < s.length; i++) {\n    // ①\n    // 如果是数字，可能是多位数，比如 \"12[abc]\"，所有处理两次遍历到的数字，计算出真正的数字\n    // 例如：第一次遍历到的是1，第二次遍历到的是2，那么真正的数字就是 1 * 10 + 2 = 12\n    if (!isNaN(s[i])) {\n      k = k * 10 + parseInt(s[i]);\n    }\n    // ② 如果是左括号\n    else if (s[i] === \"[\") {\n      // 将出现的次数入栈\n      countStack.push(k);\n      // 字符串入栈\n      strStack.push(currentStr);\n      // 重置出现次数和字符串\n      k = 0;\n      currentStr = \"\";\n    }\n    // ③ 如果是右括号\n    else if (s[i] === \"]\") {\n      // 出栈\n      let count = countStack.pop();\n      // 出栈\n      let str = strStack.pop();\n      // 拼接字符串\n      currentStr = str + currentStr.repeat(count);\n    }\n    // ④ 如果是字母，即普通字符，更新当前字符串，用于后面拼接逻辑\n    else {\n      // 拼接字符串, 例如 \"abc\"，\"abc\" 就是一个字符串\n      // 例如 \"12[abc]\"，\"abc\" 就是一个字符串\n      currentStr += s[i];\n    }\n  }\n\n  return currentStr;\n};\n\n```\n\n### 复杂度分析\n\n- **时间复杂度**：\n    - 遍历字符串的次数为 `O(n)`，每个字符在栈中操作的时间为 `O(1)`，所以总时间复杂度为 `O(n)`。\n- **空间复杂度**：\n    - 空间复杂度主要由栈占用，最坏情况下需要 `O(n)` 的空间，因为所有字符和数字可能都需要入栈。\n\n## 错误记录","532a6977ffe45ffb805a60c18ceafa72":"\n# 最近的请求次数\n\n`#2024/07/28` `#算法/列队` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407280800350.png?imageSlim)\n\n## 解题思路\n\n使用列队：\n1. **初始化队列**：\n    - 使用一个`队列`来存储所有请求的时间。\n2. **处理每个 `ping(t)` 请求**：\n    - 将时间 `t` 入队。\n    - 遍历：从队列的前面（即最老的请求）开始检查，如果有请求已经不在 `[t-3000, t]` 这个时间范围，移除它们。\n    - 返回队列的长度。\n\n## 代码实现\n\n```javascript\nvar RecentCounter = function () {\n  // 使用队列来存储ping的时间\n  this.q = [];\n};\n\n/**\n * @description:在时间t 时 ping了一下\n * @param {number} t\n * @return {number}\n */\nRecentCounter.prototype.ping = function (t) {\n  // 把当前的 t 入队\n  this.q.push(t);\n  // 如果队头小于 t - 3000，就删除队头，即只保留 3000 毫秒内的请求\n  while (this.q[0] < t - 3000) {\n    // t 是递增的，所以可以从队头删除 3000 毫秒之前的请求\n    this.q.shift();\n  }\n  // 返回队列的长度\n  return this.q.length;\n};\n\n```\n\n### 复杂度分析\n\n- **时间复杂度**：\n    - 每个请求最多只执行一次入队和一次出队操作，因此对于每个 `ping`请求，其操作的时间复杂度是 `O(1)`。\n    - 综上，处理 `n` 个 `ping` 请求的总时间复杂度是 `O(n)`。\n- **空间复杂度**：\n    - 队列在最坏情况下需要存储所有在时间范围 `[t-3000, t]` 内的请求。因此，空间复杂度是 `O(n)`，其中 `n` 是最大同时存在的请求数（理论上可看为所有请求数）\n\n## 错误记录\n\n> [!danger]\n>  每次入队后，还需要 while 遍历一遍保证每个元素都在 `3000ms` 内","7b60281b5b2452748ffeaafb7266beaa":"\n# Dota2 参议院\n\n\n`#2024/07/28` `#leetcode`  `#算法/列队` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281543283.png?imageSlim)\n\n### 更通俗的解释\n\n你可以把这题想象成一个`“淘汰赛”`的过程。每个参议员在“发言”后可以让对方阵营中的一个人`闭嘴`（无法再发言）。这个过程一直持续，直到某一阵营的所有人都被关闭，另外一阵营获胜。\n\n#### 题目中的“参议院”\n\n- **输入**：一个字符串，代表所有参议员的`初始顺序`。\n- **输出**：一个字符串，代表`最终获胜的阵营`。\n    **举例**：\n    - 输入：`\"RDD\"`\n    - 输出：\"D\"（夜魇阵营获胜）\n        - 因为 R 先让\n\n## 解题思路\n\n为了简化处理，可以使用队列来模拟这个过程：\n1. **初始化**：\n    - 用`两个队列`分别存储天辉参议员和夜魇参议员的`索引位置`。\n2. **模拟投票过程**：\n    - 比较`两个队列头部的索引`，投票次序取决于小的索引值。\n    - 被“禁言”的参议员的索引需要被移除。\n    - 并且被移动的参议员要被放到新位置上（假设投票结束的参议员可以重新排队）。\n3. **判断胜利**：\n    - `队列为空的一方`即为`失败方`\n    - `一个队列中的参议员`即为`胜利方`\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} senate\n * @return {string}\n */\nvar predictPartyVictory = function (senate) {\n  // ① 定义两个队列，分别存储 R 和 D 的索引\n  const radiant = [];\n  const dire = [];\n\n  // ② 遍历字符串，将 R 和 D 的索引分别入队\n  for (let i = 0; i < senate.length; i++) {\n    if (senate[i] === \"R\") {\n      radiant.push(i);\n    } else {\n      dire.push(i);\n    }\n  }\n\n  // ③ 模拟投票过程\n  while (radiant.length > 0 && dire.length > 0) {\n    // 分别取出 R 和 D 的索引\n    let rIndex = radiant.shift();\n    let dIndex = dire.shift();\n\n    // 比较索引决定谁先投票，如果radiant先投票则dire被禁言，反之亦然\n    if (rIndex < dIndex) {\n      //  这个 R 其实可以继续参加，所以把他放到最后，才能循环参与投票。\n      //  每个参议员在投票后并不是退出游戏，而是要回到队列末尾，等待下一轮投票机会\n      //  `rIndex` 是当前参议员在原始字符串中的索引位置。\n      //  `rIndex + senate.length` 是为了确保这个参议员在下一轮投票时,仍然保持正确的相对顺序。\n      radiant.push(rIndex + senate.length); // 重新排队，以确保顺序循环进行\n    } else {\n      dire.push(dIndex + senate.length); // 重新排队，以确保顺序循环进行\n    }\n  }\n\n  // ④ 返回结果: 如果 R 的队列长度大于 0，则返回 Radiant，否则返回 Dire\n  return radiant.length > 0 ? \"Radiant\" : \"Dire\";\n};\n\n```\n\n每个参议员在投票后并不是退出游戏，而是要回到队列末尾，等待下一轮投票机会。\n\n### 为什么要加上 senate.length\n\n假设有字符串 `\"RDDR\"`，长度为 `4` \n\n初始状态:\n\n```javascript\nradiant = `[0, 3]`  // R在位置0和3\ndire = `[1, 2]`     // D在位置1和2\n```\n\n第一轮投票后:\n- `R(0)` 投票并禁言 `D(1)`\n- 我们需要把 `R(0)` 放回队列末尾\n\t- 如果直接 `push(0)`，变成 `radiant = [3, 0]`\n\t- 这样就打乱了原有顺序。正确的应该是：`radiant = [3, 4]`  其中 `4 = 0 + 4(字符串长度)` 这样就维持了相对顺序\n\n通过加上字符串长度,我们保证了:\n- 新加入的元素总是大于当前队列中的所有元素\n- 同时保持了参议员之间的相对顺序不变\n\n### 复杂度分析\n\n- **时间复杂度**：\n    - 初始化队列需要 `O(n)` 时间，每个字符入队和出队的操作均为 `O(1)`，整体时间复杂度为 `O(n)`。\n- **空间复杂度**：\n    - 队列存储所有参议员的索引，因此需要 `O(n)` 的空间。\n\n## 错误记录","3ee5129a31b1511db72a0e9a806c239e":"\n# 除自身以外数组的乘积\n\n`#leetcode`  `#2024/07/28`  `#算法/前缀和`  `#算法/前缀积` \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/065e86225fe756d152dd30d51cee831b.png)\n\n## 解题思路\n\n- 构造一个 `prefix` 数组记录`「前缀积」`\n- 再用一个 `suffix` 记录 **「后缀积」**\n- `当前元素之外其他元素的积` = `当前元素的前缀积` * `当前元素的后缀积`\n\n> 不能先所有数的乘积（假如为` sum`），然后遍历每个元素计算 `sum/item` ，不行，见下面错误记录\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function (nums) {\n  // 前缀积\n  const prefix = new Array(nums.length).fill(1);\n  // 后缀积\n  const suffix = new Array(nums.length).fill(1);\n\n  // 初始化前缀积\n  for (let i = 1; i < nums.length; i++) {\n    prefix[i] = prefix[i - 1] * nums[i - 1];\n  }\n\n  // 初始化后缀积\n  for (let i = nums.length - 2; i >= 0; i--) {\n    suffix[i] = suffix[i + 1] * nums[i + 1];\n  }\n\n  // 结果\n  const result = [];\n  // 遍历数组，计算结果，即前缀积 * 后缀积\n  for (let i = 0; i < nums.length; i++) {\n    result.push(prefix[i] * suffix[i]);\n  }\n  return result;\n};\n\n```\n\n### 空间复杂度再压缩？\n\n遍历的时候再动态更新`result` ，如下\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number[]}  \n */  \nvar productExceptSelf = function (nums) {  \n  const length = nums.length;  \n  const result = new Array(length).fill(1);  \n\n  // 计算前缀积并存储在结果数组中  \n  let prefixProduct = 1;  \n  for (let i = 0; i < length; i++) {  \n    result[i] = prefixProduct;  \n    prefixProduct *= nums[i];  \n  }  \n\n  // 计算后缀积并更新结果数组  \n  let suffixProduct = 1;  \n  for (let i = length - 1; i >= 0; i--) {  \n    result[i] *= suffixProduct;  \n    suffixProduct *= nums[i];  \n  }  \n\n  return result;  \n};\n```\n\n## 错误记录\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function (nums) {\n  const sum = nums.reduce((acc, cur) => acc * cur, 1);\n  return nums.map((num) => sum / num);\n};\n\n```\n\n","32c7a6a26cb353b18444fbed500cf5ab":"\n# 递增的三元子序列\n\n\n`#leetcode` `#2024/07/28`  `#算法` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png](https://832-1310531898.cos.ap-beijing.myqcloud.com/13c6ebae35cee42b11c377759cf0b779.png)\n\n## 解题思路\n\n- 两个变量：`第一最大值` 和 `第二最大值`\n- 遍历，根据当前遍历的元素\n   - 更新第一最大值\n   - 更新第二最大值，他一定小于第一最大值\n   - 否则：小于第一最大值，也许与第二最大值\n      - 那么 当前值、第二最大值、第一最大值不就满足题设了吗？\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar increasingTriplet = function (nums) {\n  // base case\n  if (nums.length < 3) {\n    return false;\n  }\n\n  // 先定义两个最大值\n  // first 为第一个最大值\n  let first = Number.MAX_SAFE_INTEGER;\n  // second 为第二个最大值\n  let second = Number.MAX_SAFE_INTEGER;\n\n  // 遍历数组\n  for (let i = 0; i < nums.length; i++) {\n    // ① 当当前元素小于第一个最大值时，确保 first 是遍历到当前元素之前的最小值\n    if (nums[i] <= first) {\n      // 更新第一个最大值\n      first = nums[i];\n      //②  用于更新第二小值 second，确保 second 是遍历到当前元素之前的第二小值，并且大于 first。\n    } else if (nums[i] <= second) {\n      // 当当前元素小于第二个最大值时\n      // 更新第二个最大值\n      second = nums[i];\n      //③ 否则， 当 num 大于 second 时，说明找到了一个递增的三元组，返回 true\n    } else {\n      // 当当前元素大于第二个最大值时\n      // 返回 true\n      return true;\n    }\n  }\n\n  return false;\n};\n\n```\n\n### 注意📢\n\n>  如果手写不出来` Number.MAX_SAFE_INTEGER` 可以参考下面写法\n\n```javascript\nconst first =  Number.MAX_SAFE_INTEGER; \nconst first = Math.min() // 返回无穷大 Infinity \n\n\n// 先定义两个最大值\nlet first = 2**31 -1;\nlet second = 2**31 -1;\n```\n\n>  `const  first =  Number.MAX_SAFE_INTEGER;` \n>  `const first =  2^31 -1 ;`\n\n### 复杂度分析\n\n## 错误记录\n\n","77d439a781ef5295a4973824f8fe975f":"\n# 前言\n\n`#leetcode` \n\n> LeetCode 热题 100 题：[https://leetcode.cn/studyplan/top-100-liked/](https://leetcode.cn/studyplan/top-100-liked/)\n\n","8c6c664c97a05cc9b6dd2f139db15ef8":"\n# 两数之和\n\n\n`#算法/哈希` `#leetcode`  `#2024/07/28` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281617385.png?imageSlim)\n\n### 题目重点\n\n- 返回下标\n- 复杂度小于 `O(n^2)` \n- 可能会重复，比如`[3,3]` \n\n## 思路\n\n- 思路一：排序思路，数组排序后双指针会更好，但会破坏原数组索引，题设中需要返回下标\n- 思路二：**哈希存储**\n\n## 代码实现\n\n### 错题一\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281617386.png?imageSlim)\n\n> 想着两个 `for` 逻辑更清晰，但有`两个问题`，如下图：\n> ![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281617387.png?imageSlim)\n\n### 错误二\n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281617388.png?imageSlim)\n\n### 标准答案\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n\n    // 维护 val-index 的 map\n    let valToIndexMap = new Map();\n\n    // 遍历每个元素是否存在，这样的组合\n    for (let i = 0; i < nums.length; i++) {\n        let need = target - nums[i];\n        if (valToIndexMap.has(need)) {\n            // 存在，直接返回\n            return [valToIndexMap.get(need), i];\n        }\n        // 之前的记录到 map 里， 供后续元素检查\n        valToIndexMap.set(nums[i], i);\n    }\n\n    // 不存在，返回 null\n    return null;\n\n};\n```\n\n## 参考\n\n- [一个方法团灭 nSum 问题](https://labuladong.online/algo/practice-in-action/nsum/`#%E4%B8%80%E3%80%81twosum-%E9%97%AE%E9%A2%98)`\n- [https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)\n\n","c40fe1a902795e848742e1b9924be369":"\n# 最小覆盖子串\n\n\n`#leetcode`   `#2024/08/11`  `#算法/滑动窗口`  `#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![图片&文件](./files/Pastedimage20240811134319.png)\n\n## 2. 解题思路：滑动窗口\n\n- 定义 7 个变量\n\t- 两个 Map：`need` 和 `window`\n\t\t- `need` 存储 `t` 中每个字符需要的数量\n\t\t- `window` 存储当前窗口中每个字符的数量\n\t- 两个指针 `left` 和 `right` ：用于定义滑动窗口\n\t-  `valid 变量`来记录当前窗口中**已经满足条件的字符数量**\n\t- `start` 和 `len` 记录最小覆盖子串的起始索引及长度\n- 滑动窗口\n\t-  `右指针 right` 不断向右移动，**扩大窗口**，将字符加入 `window`。\n\t- 当 `valid === need` 时\n\t\t- 说明窗口中已经包含了 `t` 的所有字符，此时开始尝试**缩小窗口**\n\t\t\t- 当一个字符加入 window 后，如果它的数量与 need 中的数量相等，则 valid 加 1。\n\t\t\t\t- `左指针 left` 向右移动，缩小窗口，同时更新 window 和 valid。\n\t\t\t\t- 在每次找到可行解时，更新最小覆盖子串的`起始位置`和`长度`。\n- 最后返回最小覆盖子串，如果没有找到，则返回空字符串。\n\n## 3. 代码实现\n\n```javascript hl:8,27,43\n/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function (s, t) {\n    /*************************************************\n     * ::::① 第一步： 定义 7 个变量并初始化\n     ************************************************/\n        // 记录窗口所需要的字符及其个数\n    const need = new Map();\n    // 初始化 need\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    // 记录当前窗口中的字符及其个数\n    const window = new Map();\n    // 双指针\n    let left = 0;\n    let right = 0;\n    // 已经符合条件的字符个数\n    let valid = 0;\n    // 记录最小覆盖子串的起始索引及长度\n    let start = 0;\n    let len = Infinity;\n    /*************************************************\n     * :::::② 第二步：开始移动右指针，扩大窗口\n     ************************************************/\n    for (let i = 0; i < s.length; i++) {\n        const c = s[i]; // c 是将移入窗口的字符\n        right++;// 右移窗口\n        // 如果 c 是所需字符，则更新窗口数据\n        if (need.has(c)) {\n            window.set(c, (window.get(c) || 0) + 1);\n            // 如果 window 中字符 c 的数量达到 need 中字符 c 的数量，则 valid++\n            // valid 表示窗口中满足 need 条件的字符个数，所以它是去重的\n            // 例如 need 中有 2 个 a，window 中也有 2 个 a，那么 valid 只会加 1\n            if (window.get(c) === need.get(c)) {\n                valid++;\n            }\n        }\n        /*************************************************\n         * ::::③ 第三步：判断左侧窗口是否要收缩，条件是 valid === need.size\n         ************************************************/\n        while (valid === need.size) {\n            // 这个时候满足条件，记录最小覆盖子串\n            // 更新 start 和 len, 用于最后返回结果\n            if (right - left < len) {\n                start = left;\n                len = right - left;\n            }\n\n            const d = s[left];// d 是将移出窗口的字符\n            // 左移窗口\n            left++;\n\n            // 如果 d 是所需字符，同事需要更新窗口数据 和 valid 值\n            if (need.has(d)) {\n                if (window.get(d) === need.get(d)) {\n                    valid--;\n                }\n                window.set(d, window.get(d) - 1);\n            }\n        }\n    }\n    return len === Infinity ? '' : s.substr(start, len);\n};\n\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 n 是**字符串 s 的长度**。\n- 空间复杂度是 `O(k)`，其中 k 是**字符集的大小**（在这个问题中，**k 最大为 52**，因为字母区分大小写）\n\n","8e69581ef0b65973b5ff64871d2467dc":"\n# 字母异位词分组\n\n`#2024/07/28` `#leetcode`  `#算法/哈希`  \n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281620623.png?imageSlim)\n\n## 解题思路\n\n- 先分组：按照由同相同字母组合成的单词来分组\n   - 使用 `hash` 特定的 `key 值` 来分组\n- 然后再把`分组后的 hash` 转成 `二维数组`\n\n## 代码实现\n```javascript\nvar groupAnagrams = function (strs) {\n  // 编码到分组的映射\n  let codeToGroup = new Map();\n  for (let s of strs) {\n    // 对字符串进行编码\n    let code = encode(s);\n    // 把编码相同的字符串放在一起\n    if (!codeToGroup.has(code)) {\n      codeToGroup.set(code, []);\n    }\n    codeToGroup.get(code).push(s);\n  }\n\n  // 获取结果\n  let res = [];\n  for (let group of codeToGroup.values()) {\n    res.push(group);\n  }\n\n  return res;\n};\n\n/*\n * @description: 利用每个字符的出现次数进行编码\n * @param {string} s\n * @return {string}\n * @example 1: encode(\"abc\") => \"1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\"\n * @example 2: encode(\"abbccc\") => \"1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\"\n * @example 3: encode(\"aabbcc\") => \"2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\"\n */\nfunction encode(s) {\n  // 初始化一个长度为 26 的数组，用于记录每个字符的出现次数\n  let arr = new Array(26).fill(0);\n  for (let c of s) {\n    // 返回 c 的 Ascii 码值, 减去 'a' 的 Ascii 码值, 得到 c 相对于 'a' 的偏移量\n    // 即 a -> 0, b -> 1, c -> 2, ..., z -> 25\n    let delta = c.charCodeAt() - \"a\".charCodeAt();\n    // 更新字符 c 的出现次数\n    arr[delta]++;\n  }\n  return arr.toString();\n}\n\n```\n\n## 错误记录\n\n","fb1436f5ac335d86bb7d001e784b30a7":"\n# 最长连续序列\n\n\n`#2024/07/28` `#leetcode` `#算法/哈希`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![iShot_2024-07-20_09.28.52.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281623327.png?imageSlim)\n\n## 解题思路\n\n- 使用 Set 来，空间复杂度换时间复杂度\n   - 去重了也没关系，因为这里需要找连续的个数\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestConsecutive = function (nums) {\n  // 使用集合存储数组中的元素，方便查找，判断是否存在\n  const set = new Set(nums);\n  // 用于记录最长连续序列的长度\n  let longest = 0;\n  // 遍历数组中的元素\n  // 直接遍历 set 集合，去重也没关系\n  for (const num of set) {\n    // 当前元素的前一个元素不存在时，才开始计算连续序列的长度\n    // 这样可以避免重复计算\n    if (!set.has(num - 1)) {\n      // 当前元素\n      let currentNum = num;\n      // 当前连续序列的长度\n      let currentStreak = 1;\n      // 当前元素的后一个元素存在时，就继续计算连续序列的长度\n      while (set.has(currentNum + 1)) {\n        currentNum += 1;\n        currentStreak += 1;\n      }\n      // 更新最长连续序列的长度\n      longest = Math.max(longest, currentStreak);\n    }\n  }\n  return longest;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度： `O(n)`\n   - 遍历：`for (const num of set) { `  ，这个复杂度是 `O(n)`\n   - `while` 查找\n      - **每个元素最多会经历一次查找前一个元素和若干次查找后续元素的操作**。而查找操作在集合中平均时间复杂度为 `O(1)`，因此对于每个元素，整个查找操作的时间复杂度可以视为 `O(1)`\n- 空间复杂度： O(n)\n\n## 错误记录\n\n","f5180c168514553e96d4fae64a4cedf3":"\n# 三数之和\n\n\n`#leetcode`   `#2024/07/31`  `#双指针` `#算法/双指针`   `#算法/Nsum` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![image.png600600|476](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407310756023.png?imageSlim)\n\n## 2. 解题思路\n\n### 2.1. 先看二数之和\n\n思路：先对 `nums` 排序，然后使用`左右双指针技巧`，从两端相向而行即可，如下代码：\n\n```javascript\nvar twoSum = function (nums, target) {  \n    // ① 先排序  \n    nums.sort((a, b) => a - b);  \n    let res = [];  \n      \n    // ② 定义左右指针，分别指向数组的头和尾  \n    let lo = 0, hi = nums.length - 1;  \n      \n    // ③ 循环条件，从两端向中间靠拢  \n    while (lo < hi) {  \n        let sum = nums[lo] + nums[hi];  \n        // 根据 sum 和 target 的比较，移动左右指针  \n        if (sum < target) {  \n            lo++;  \n        } else if (sum > target) {  \n            hi--;  \n        } else {  \n            res.push([nums[lo], nums[hi]]);  \n            lo++;  \n            hi--;  \n        }  \n    }  \n    return res;  \n};\n```\n\n`nums` 中可能有多对儿元素之和都等于 `target`，请你的算法返回所有和为 `target` 的元素对儿，其中不能出现重复，上面代码有点问题，比如：\n\n![image.png600|432](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407310806671.png?imageSlim)\n\n所以我们遍历时需要 `跳过相同的元素`，如下代码：\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @return {number[][]}  \n */  \nvar twoSumTarget = function (nums, target) {  \n    // nums 数组必须有序  \n    nums.sort((a, b) => a - b);  \n    let lo = 0, hi = nums.length - 1;  \n    let res = [];  \n    while (lo < hi) {  \n        let sum = nums[lo] + nums[hi];  \n        let left = nums[lo];  \n        let right = nums[hi];  \n        // 根据 sum 和 target 的比较，移动左右指针  \n        if (sum < target) {  \n            // ① 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] == left) lo++;  \n        } else if (sum > target) {  \n            // ② 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] == right) hi--;  \n        } else {  \n            res.push([left, right]);  \n            // ③ 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] == left) lo++;  \n            // ④ 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] == right) hi--;  \n        }  \n    }  \n    return res;  \n};\n```\n\n### 2.2. 三数之和等 `0`\n\n#### 2.2.1.   泛化：`target` 不为 `0` 呢？\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number[][]}  \n */  \nvar threeSum = function (nums) {  \n    // 求和为 0 的三元组  \n    return threeSumTarget(nums, 0);  \n};\n\n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @return {number[][]}  \n */  \nvar threeSumTarget = function (nums, target) {\n\t// ....\n}\n```\n\n#### 2.2.2. `threeSumTarget` 思路\n\n-  从 `nums` 中找  `[a,b,c] `  使得  `a + b + c = target` \n\t- 遍历 `nums`\n\t\t-  `a = nums[i]` 时\n\t\t\t- 这个时候需要从 `nums` 中的下标 `i` 开始找两数之和为 `target - a`\n\t\t\t\t- 问题转化成两数之和  `threeSumTarget`\n\n#### 2.2.3. 问题转成两数之和：`threeSumTarget`\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @param {number} start 从 start 开始找  \n * @return {number[][]}  \n */  \nvar twoSumTarget = function (nums, start, target) {  \n    // nums 数组必须有序  \n    nums.sort((a, b) => a - b);  \n    let lo = start;  \n    let hi = nums.length - 1;  \n    let res = [];  \n    while (lo < hi) {  \n        let sum = nums[lo] + nums[hi];  \n        let left = nums[lo];  \n        let right = nums[hi];  \n        // 根据 sum 和 target 的比较，移动左右指针  \n        if (sum < target) {  \n            // ① 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] === left) lo++;  \n        } else if (sum > target) {  \n            // ② 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] === right) hi--;  \n        } else {  \n            res.push([left, right]);  \n            // ③ 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] === left) lo++;  \n            // ④ 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] === right) hi--;  \n        }  \n    } \n    return res;  \n};\n```\n\n## 3. 代码实现\n\n最终代码如下：\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number[][]}  \n */  \nvar threeSum = function (nums) {  \n    // 求和为 0 的三元组  \n    return threeSumTarget(nums, 0);  \n};  \n  \n  \n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @return {number[][]}  \n */  \nvar threeSumTarget = function (nums, target) {  \n    //// :::: ① 数组先排个序  \n    nums.sort(function (a, b) {  \n        return a - b  \n    });  \n    var n = nums.length;  \n    var res = [];  \n  \n    // ::::③ 遍历数组，a + b + c = target \n    //        其中 a = nums[i] ，b + c =  target - nums[i]  \n    for (var i = 0; i < n; i++) {  \n        const a = nums[i];  \n        const twoTarget = target - a;  \n        // ::::③ 递归计算 b + c = target - nums[i] 的二元组  \n        var twoSumArr = twoSumTarget(nums, i + 1, twoTarget);  \n  \n        // ::::④ 遍历二元组，将 nums[i] 加上就是结果三元组  \n        // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组  \n        for (var j = 0; j < twoSumArr.length; j++) {  \n            var tuple = twoSumArr[j];  \n            tuple.push(nums[i]);  \n            res.push(tuple);  \n        }  \n        // ::::⑤ 跳过后面，出现的数字重复的情况，否则会出现重复结果  \n        // 跳过第一个数字重复的情况，否则会出现重复结果  \n        while (i < n - 1 && nums[i] === nums[i + 1]) i++;  \n    }  \n  \n    return res;  \n}  \n  \n/**  \n * @param {number[]} nums  \n * @param {number} target  \n * @param {number} start 从 start 开始找  \n * @return {number[][]}  \n */  \nvar twoSumTarget = function (nums, start, target) {  \n    // nums 数组必须有序  \n    nums.sort((a, b) => a - b);  \n    let lo = start;  \n    let hi = nums.length - 1;  \n    let res = [];  \n    while (lo < hi) {  \n        let sum = nums[lo] + nums[hi];  \n        let left = nums[lo];  \n        let right = nums[hi];  \n        // 根据 sum 和 target 的比较，移动左右指针  \n        if (sum < target) {  \n            // ① 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] === left) lo++;  \n        } else if (sum > target) {  \n            // ② 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] === right) hi--;  \n        } else {  \n            res.push([left, right]);  \n            // ③ 左边碰到相同的元素，一直向右移动，直到不相同的元素位置  \n            while (lo < hi && nums[lo] === left) lo++;  \n            // ④ 右边碰到相同的元素，一直向左移动，直到不相同的元素位置  \n            while (lo < hi && nums[hi] === right) hi--;  \n        }  \n    }  \n    return res;  \n};\n```\n\n### 3.1. 复杂度分析\n\n- 时间复杂度上，为 `O(n^2)`\n\t- 主函数 threeSum:\n        -  调用 threeSumTarget，复杂度与 threeSumTarget 相同。\n    - threeSumTarget 函数:\n        - 排序:  `O(n log n)`\n        - 外层循环： `O(n)`\n            - 每次循环中调用 `twoSumTarget: O(n)`\n        - 总体复杂度： `O(n^2)`\n    - twoSumTarget 函数:\n        - 双指针遍历: `O(n)`\n    - 综合起来，整个算法的时间复杂度是 `O(n^2)`。\n- 空间复杂度在最坏情况下可能达到 `O(n^2)`，主要是由于存储结果所需的空间\n\t- 排序可能需要 O(log n) 的空间（取决于排序算法）。\n\t- 结果数组 res 的大小取决于==满足条件的三元组数量==，最坏情况下可能是 O(n^2)。\n\t- twoSumTarget 函数中的临时结果数组也可能在最坏情况下达到 O(n)。\n\n","951ef10196695c78ac2b549dbb549c7c":"\n# 接雨水\n\n\n`#leetcode`   `#2024/07/31`  `#算法/双指针` `#算法/备忘录`   \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407310906405.png?imageSlim)\n\n## 解题思路\n\n🌧 最多能够装多少水  =  每个柱子上能够装多少水  = `每个柱子左边和右边最高柱子的最矮的那个 - 该柱子的高度` ，如下代码\n\n```python\nwater[i] = min(\n    # 左边最高的柱子\n    max(height[0..i]),  \n    # 右边最高的柱子\n    max(height[i..end]) \n) - height[i]\n```\n\n如下图：\n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407310915725.png?imageSlim)\n\n## 代码实现\n\n### 解法一：暴力遍历\n\n按照上面的思路，直接==暴力遍历==即可，复杂度是 `O(N^2)`，空间复杂度 `O(1)`\n\n```javascript\nvar trap = function(height) {\n    var n = height.length;\n    var res = 0;\n    for (var i = 1; i < n - 1; i++) {\n        var l_max = 0, r_max = 0;\n        // 找右边最高的柱子\n        for (var j = i; j < n; j++)\n            r_max = Math.max(r_max, height[j]);\n        // 找左边最高的柱子\n        for (var j = i; j >= 0; j--)\n            l_max = Math.max(l_max, height[j]);\n        // 如果自己就是最高的话，\n        // l_max == r_max == height[i]\n        res += Math.min(l_max, r_max) - height[i];\n    }\n    return res;\n};\n```\n\n### 解法二：备忘录优化\n\n对于解法一，可以使用备忘录优化：\n\n- 定义两个数组 `r_max` 和 `l_max` 充当备忘录，预先把这两个数组计算好，避免重复计算\n\t- `l_max[i]` 表示位置 `i` 左边最高的柱子高度\n\t- `r_max[i]` 表示位置 `i` 右边最高的柱子高度\n\n### 解法三：双指针\n\n时间复杂度为 `O(n)`，空间复杂度为 `O(1)`\n\n```javascript\n/**  \n * @param {number[]} height  \n * @return {number}  \n */  \nvar trap = function (height) {  \n  \n    // 双指针  \n    let left = 0;  \n    let right = height.length - 1;  \n  \n    // 当前遍历的元素的 左边的最大值  \n    let leftMax = 0;  \n    // 当前遍历的元素的 右边的最大值  \n    let rightMax = 0;  \n    // 结果  \n    let res = 0;  \n  \n    // 遍历, 双向遍历，从两边向中间靠拢  \n    while (left < right) {  \n        // 更新左边的最大值  \n        leftMax = Math.max(leftMax, height[left]);  \n        // 更新右边的最大值  \n        rightMax = Math.max(rightMax, height[right]);  \n  \n        // 说明最小值在左边，当前元素的水量 = 左边最大值 - 当前元素的高度  \n        if (leftMax < rightMax) {  \n            // 更新结果  \n            res += leftMax - height[left];  \n            // 左指针向右移动  \n            left++;  \n            // 说明最小值在右边，当前元素的水量 = 右边最大值 - 当前元素的高度  \n        } else {  \n            // 更新结果  \n            res += rightMax - height[right];  \n            // 右指针向左移动  \n            right--;  \n        }  \n    }  \n  \n    // 返回结果  \n    return res;  \n  \n};\n```\n\n","d231787060d15095a64e48c2ce3c029b":"\n# 无重复字符的最长子串\n\n\n`#leetcode`   `#2024/08/05`  `#算法/滑动窗口`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|536](https://832-1310531898.cos.ap-beijing.myqcloud.com/202408050719710.png?imageSlim)\n\n> [!danger]\n>  返回的是最长子串的**长度**，而不是最长无重复子串本身\n\n## 解题思路\n\n**滑动窗口框架**\n\n```javascript\n// 滑动窗口算法伪码框架\nvar slidingWindow = function(s) {\n    // 用合适的数据结构记录窗口中的数据，根据具体场景变通\n    // 比如说，我想记录窗口中元素出现的次数，就用 map\n    // 如果我想记录窗口中的元素和，就可以只用一个 int\n    var window = ...;\n\n    // 左右指针，用于移动窗口\n    var left = 0\n    let right = 0;\n    while (right < s.length) {\n        // c 是将移入窗口的字符\n        var c = s[right];\n        window.add(c);\n        // 增大窗口\n        right++;\n        // 进行窗口内数据的一系列更新\n        // ...\n        // *** debug 输出的位置 ***\n        // 注意在最终的解法代码中不要 print\n        // 因为 IO 操作很耗时，可能导致超时\n        console.log(left, right);\n        // *********************\n\n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            var d = s[left];\n            window.remove(d);\n            // 缩小窗口\n            left++;\n            // 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n};\n\n```\n\n## 代码实现\n\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let left = 0;\n  let right = 0;\n  // 最长子串的长度\n  let res = 0;\n\n  // 滑动窗口, 用来记录窗口中的字符出现的次数，key为字符，value为字符出现的次数\n  // 当字符出现的次数大于1时，说明重复了，需要收缩窗口，即 left++\n  // 当字符出现的次数等于1时，说明没有重复，可以扩大窗口，即 right++\n  let win = new Map();\n\n  while (right < s.length) {\n    let c = s[right];\n    right++;\n    // 进行窗口内数据的一系列更新, 例如增加字符的次数\n    win.set(c, (win.get(c) || 0) + 1);\n\n    // 判断左侧窗口是否需要收缩\n    // 当字符的数量大于1时, 说明重复了, 需要收缩\n    while (win.get(c) > 1) {\n      let d = s[left];\n      left++;\n      // 进行窗口内数据的一系列更新, 例如减少字符的次数\n      win.set(d, win.get(d) - 1);\n    }\n    // 在这里更新答案\n    res = Math.max(res, right - left);\n  }\n\n  return res;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度：`O(n)`\n\t- 其中 `n` 是字符串的长度\n\t- 在最坏的情况下，左右指针各遍历整个字符串一次。\n-  空间复杂度：`O(min(m, n))`\n\t- 其中 `m` 是**字符集的大小**\n\t- `n` 是字符串的长度\n\n","a5f706c77ae755a084b6007363a57571":"\n# 找到字符串中所有字母异位词\n\n\n`#leetcode`   `#2024/08/10`  `#算法/滑动窗口` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![图片&文件](./files/Pastedimage20240810142206.png)\n\n关于 异位词，再举几个例子\n1. \"listen\" 和 \"silent\" 是异位词。 它们包含相同的字母，每个字母出现的次数也相同。\n2. \"debit card\" 和 \"bad credit\" 是异位词。 忽略空格后，它们包含相同的字母集合，且每个字母的出现次数相同。\n3. \"aab\" 和 \"baa\" 是异位词。 注意这里 **'a' 重复出现了两次，'b' 出现了一次**，两个词中字母出现的次数是相同的。\n4. \"egg\" 和 \"geg\" 是异位词。 这里 'g' 重复出现。\n5. \"aaabbb\" 和 \"ababab\" 是异位词。 尽管排列不同，但 'a' 和 'b' 都各出现了三次。\n\n> [!danger]\n>  所以要遍历所以字母，看每个字母出现了几次\n>  \n## 解题思路\n\n### 思路一：滑动窗口\n\n```javascript\nint left = 0, right = 0;\n\nwhile (right < nums.size()) {\n    // 增大窗口\n    window.addLast(nums[right]);\n    right++;\n    \n    while (window needs shrink) {\n        // 缩小窗口\n        window.removeFirst(nums[left]);\n        left++;\n    }\n}\n```\n\n使用 JavaScript 语言描述\n\n```javascript\n\n// 滑动窗口算法伪码框架\nvar slidingWindow = function(s) {\n    // 用合适的数据结构记录窗口中的数据，根据具体场景变通\n    // 比如说，我想记录窗口中元素出现的次数，就用 map\n    // 如果我想记录窗口中的元素和，就可以只用一个 int\n    var window = ...;\n\n    var left = 0, right = 0;\n    while (right < s.length) {\n        // c 是将移入窗口的字符\n        var c = s[right];\n        window.add(c);\n        // 增大窗口\n        right++;\n        // 进行窗口内数据的一系列更新\n        ...\n\n        // *** debug 输出的位置 ***\n        // 注意在最终的解法代码中不要 print\n        // 因为 IO 操作很耗时，可能导致超时\n        console.log(\"window: [%d, %d)\\n\", left, right);\n        // *********************\n\n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            var d = s[left];\n            window.remove(d);\n            // 缩小窗口\n            left++;\n            // 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n};\n```\n\n *  先定义 `need` 和 `win` 两个 Map\n\t * 用于记录目标字符串 p 中字符出现的次数\n\t * 窗口中字符出现的次数\n * 定义 指针 `left = 0` 和 `right = 0` \n *  遍历字符串 s，先移动右指针\n\t *  当窗口中的字符满足条件时，开始移动左指针\n\t *  当窗口中的字符不满足条件时，继续移动右指针\n\t *  当窗口中的字符满足条件时，开始移动左指针\n\t\t * 每次移动都需要更新 `need` 和 `win` 两个 `map`\n\n#### 代码实现\n\n```javascript\n/**\n * @description: 438. 找到字符串中所有字母异位词\n *  ① 先定义 need 和 win 两个 Map，用于记录目标字符串 p 中字符出现的次数和窗口中字符出现的次数\n *  ② 遍历字符串 s，先移动右指针，当窗口中的字符满足条件时，开始移动左指针\n *  ③ 当窗口中的字符不满足条件时，继续移动右指针\n *  ④ 当窗口中的字符满足条件时，开始移动左指针\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nvar findAnagrams = function (s, p) {\n  // 用于存放结果\n  const res = [];\n\n  // 记录【窗口】中的字符出现的次数\n  const win = new Map();\n  // 记录 p 中所有字符出现的次数\n  const need = new Map();\n\n  // 看每个字符出现的次数\n  for (let c of p) {\n    need.set(c, (need.get(c) || 0) + 1);\n  }\n\n  let left = 0;\n  let right = 0;\n\n  // 记录窗口中已经匹配的字符个数\n  // 如果 valid 和 need.size 的大小相同，则说明窗口已满足条件，已经完全匹配\n  let valid = 0;\n\n  // 遍历字符串，先移动右指针，当窗口内的字符符合要求时，再移动左指针\n  while (right < s.length) {\n    let c = s[right];\n    right++;\n    // 进行窗口内数据的一系列更新\n    // 判断右侧窗口是否要扩大，need 中是否有这个字符, 有的话就加入窗口\n    if (need.has(c)) {\n      // 更新窗口内数据，每个字符出现的次数\n      win.set(c, (win.get(c) || 0) + 1);\n      // 判断窗口内的字符出现的次数是否符合要求\n      // 这个时候 valid 用来记录符合要求的字符个数\n      if (win.get(c) === need.get(c)) {\n        valid++;\n      }\n    }\n\n    // 判断左侧窗口是否要收缩\n    // 当窗口大小大于 p 的长度时，就要收缩\n    while (right - left >= p.length) {\n      // 当窗口符合条件时，把起始索引 left 加入结果\n      if (valid === need.size) {\n        res.push(left);\n      }\n      // d 是将移出窗口的字符\n      let d = s[left];\n      left++;\n      // 如果 d 是需要的字符，这个时候就要更新窗口，因为要移出窗口了\n      // valid 用来记录符合要求的字符个数\n      // 如果 d 的次数和 need 中的次数相同，说明符合要求的字符个数要减少了\n      if (need.has(d)) {\n        if (win.get(d) === need.get(d)) {\n          valid--;\n        }\n        win.set(d, win.get(d) - 1);\n      }\n    }\n  }\n\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n这个算法的复杂度分析如下：\n\n- 时间复杂度：`O(n)`\n\t- n 是字符串 s 的长度。\n\t- 主循环遍历字符串 s 一次，right 指针从 0 移动到 n-1，这需要 O(n) 时间。\n\t\t- **内部的 while 循环看似可能导致二次循环**\n\t\t\t- 但实际上 left 指针最多也只会从 0 移动到 n-1，所以总的移动次数不会超过 n。\n\t\t\t- 指针 `left, right` 不会回退（它们的值只增不减）\n\t- Map 的操作（get, set, has）在平均情况下是 O(1) 的。\n\t- 因此，总的时间复杂度是 O(n)。\n空间复杂度：`O(K)`\n- **K 是字符集的大小**。在这个问题中，通常是固定的（例如，如果只考虑小写字母，**K = 26**）。\n- win 和 need 这两个 Map 的大小不会超过字符集的大小。\n- res 数组的大小最坏情况下可能接近 n，但通常会远小于 n。\n- 其他变量（left, right, valid）占用常数空间。\n- 因此，总的空间复杂度是 O(K)，其中 K 是常数。\n\n","e7fa950369ed55b29e9d24bc8c1114bf":"\n# 和为 K 的子数组\n\n\n`#leetcode`   `#2024/08/10`  `#算法/前缀和` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![图片&文件](./files/Pastedimage20240810145638.png)\n\n> [!danger]\n>  **返回的是和位 k 的子数组的个数，而不是某个子数组的元素个数（长度）**\n\n## 解题思路\n\n### 思路一\n\n关键思想：\n- 通过**前缀和**，我们将\"寻找和为 k 的子数组\"转化为\"寻找两个前缀和之差为 k\"。\n- 使用**哈希表**存储前缀和的出现次数，使得我们可以在 O(1) 时间内查找是否存在满足条件的前缀和。\n\n下面是详细介绍：\n\n- 通过**前缀和**，我们将 \"**寻找和为 k 的子数组**\"  转化为 \"**寻找两个前缀和之差为 k**\"\n\t- 即 遍历一遍数组，计算前缀和的时候，随便看看已经遍历生成的前缀和中，是否存在两个前缀和之差为 `k`\n- 寻找两个前缀和之差为 k，为了方便查找\n\t- 使用**哈希**\n \n#### 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar subarraySum = function (nums, k) {\n  // 前缀和,注意前缀和的长度是 nums.length + 1\n  // preSum[i] 表示 nums[0] 到 nums[i - 1] 的和\n  const preSum = new Array(nums.length + 1).fill(0);\n  // 返回值\n  let res = 0;\n  // countMap 存储每个前缀和出现的次数\n  const countMap = new Map();\n  // 前缀和 的第一个元素 0 出现了一次\n  countMap.set(0, 1);\n\n  // 边遍历，边计算前缀和\n  for (let i = 1; i <= nums.length; i++) {\n    // 计算前缀和\n    preSum[i] = preSum[i - 1] + nums[i - 1];\n    \n    ////////******** 然后看看：是否存在两个前缀和之差为 k ********\n    \n    // 如果 preSum[i] - k 在 countMap 中\n    // 说明存在 preSum[j] = preSum[i] - k 即 nums[j] 到 nums[i-1] 的和为 k\n    const target = preSum[i] - k;\n    // 前缀和中有 target\n    if (countMap.has(target)) {\n      res += countMap.get(target);\n    }\n    // 更新 countMap\n    countMap.set(preSum[i], (countMap.get(preSum[i]) || 0) + 1);\n  }\n\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n当然，我很乐意为你分析这个算法的复杂度。\n\n- 时间复杂度：`O(n)`\n\t- 主循环：\n\t   - 算法只有一个主循环，遍历整个数组一次。\n\t   - 循环次数为 n+1（其中 n 是数组 nums 的长度）。\n\t- 循环内的操作：\n\t   - 前缀和计算：O(1)\n\t   - 哈希表查找（countMap.has 和 countMap.get）：平均 O(1)\n\t   - 哈希表更新（countMap.set）：平均 O(1)\n\t- 总体：\n\t   - 由于循环执行 n+1 次，每次循环内的操作都是 O(1)，因此总的时间复杂度是 O(n)。\n- 空间复杂度：`O(n)`\n\t- 前缀和数组 preSum：\n\t   - 大小为 n+1，占用 O(n) 空间。\n\t- 哈希表 countMap：\n\t   - 在最坏情况下，可能需要存储所有不同的前缀和。\n\t   - 理论上最多可能有 n+1 个不同的前缀和。\n\t   - 因此，countMap 占用 O(n) 空间。\n\t- 其他变量（res, target 等）：\n\t   - 占用常数空间，O(1)。\n\t- 总体：\n\t   - 空间复杂度主要由 `preSum 数组` 和 `countMap` 决定，因此为 `O(n)`\n\n## 错误记录\n\n遍历时，需要遍历 `n+1` ，即 `i<=nums.length` ，如下：\n\n```javascript\nfor (let i = 1; i <= nums.length; i++) {\n```\n\n","88fa169cd7805e02909437483bef1d0a":"\n# 滑动窗口最大值\n\n\n`#leetcode`   `#2024/08/11`  `#算法/单调列队`   `#算法/滑动窗口` \n\n![图片&文件](./files/1.单调列队算法`#4.示例：滑动窗口最大值)`\n\n> 详见 【1. 单调列队算法】","d8ae4c0740835688b712af7e4abae7b5":"\n# 前言\n\n`#leetcode` \n\n> LeetCode 经典 150 题：[https://leetcode.cn/studyplan/top-interview-150/](https://leetcode.cn/studyplan/top-interview-150/)\n\n","1b8eb0c94a54530a8b6bbe840437edb7":"\n# 合并两个有序数组\n\n\n`#2024/07/28` `#leetcode`  `#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## 题目 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281626632.png?imageSlim)\n\n> [!danger]\n> 注意：nums 后面会使用 `0` 占位\n\n## 解题思路\n\n- 双指针技巧，分别指向数组的最后一个元素\n- 注意题设中  `num1` 的长度一定大于 `num2`的长度\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function (nums1, m, nums2, n) {\n  let i = m - 1; // 实际长度，不包括占位\n  let p = nums1.length - 1; // 实际长度，包括占位 0 ，游标\n  let j = n - 1; // 实际长度\n\n  while (i >= 0 && j >= 0) {\n    // 即比较他们之间的最后一个，最后一个肯定是最大的嘛\n    if (nums1[i] > nums2[j]) {\n      nums1[p] = nums1[i];\n      i--;\n    } else {\n      nums1[p] = nums2[j];\n      j--;\n    }\n    p--;\n  }\n\n  // 一定是 j 最大\n  while (j >= 0) {\n    nums1[p] = nums2[j];\n    j--;\n    p--;\n  }\n\n};\n```\n\n## 参考\n\n- [https://leetcode.cn/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150](https://leetcode.cn/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150)\n\n","451cd7f0d9fe5b91b4c06e4ad953af96":"\n# 跳跃游戏 II\n\n\n`#leetcode`   `#2024/08/17` `#算法/动态规划`   `#算法/贪心算法` \n\n\n## 目录\n<!-- toc -->\n ## 1. 题目及理解 \n\n![图片&文件](./files/Pastedimage20240817091058.png)\n\n保证你一定可以跳到最后一格，请问你**最少要跳多少次**，才能跳过去\n\n## 2. 解题思路\n\n### 2.1. 解题思路一：动态规划\n\n#### 2.1.1. `dp` 函数定义\n\n从`索引 p` 跳到最后一格，至少需要 `dp(nums, p)` 步\n\n#### 2.1.2. 动态规划框架模板\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @return {number}  \n */  \nvar jump = function (nums) {  \n  \n    const len = nums.length;  \n    // 默认值是 len, 因为最坏的情况就是每次只跳 1 步,最大步数就是 len - 1\n    // len 代表不可达  \n    const memo = new Array(len).fill(len);  \n  \n    return dp(nums, 0, memo);  \n  \n};  \n  \n  \n/**  \n * @description dp(nums, i, memo) 表示从第 i 个位置跳到最后一个位置所需要的最少步数  \n * @param {number[]} nums 跳跃数组  \n * @param {number} i 当前位置  \n * @param {number[]} memo 备忘录  \n * */  \nfunction dp(nums, i, memo) {  \n    // ... 待补充  \n}\n```\n\n#### 2.1.3. 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function (nums) {\n\n    const len = nums.length;\n    // 默认值是 len, 因为最坏的情况就是每次只跳 1 步,最大步数就是 len - 1\n    // len 代表不可达\n    const memo = new Array(len).fill(len);\n\n    return dp(nums, 0, memo);\n\n};\n\n/**\n * @description dp(nums, i, memo) 表示从第 i 个位置跳到最后一个位置所需要的最少步数\n * @param {number[]} nums 跳跃数组\n * @param {number} i 当前位置\n * @param {number[]} memo 备忘录\n * */\nfunction dp(nums, i, memo) {\n    // base case\n    const len = nums.length;\n    if (i >= len - 1) {\n        return 0;\n    }\n    // 之前已经计算过，直接返回备忘录的值\n    if (memo[i] !== len) {\n        return memo[i];\n    }\n    // 当前位置最多能跳的步数\n    const steps = nums[i];\n    // 从当前位置跳 steps 步\n    for (let step = 1; step <= steps; step++) {\n        // 下一个位置\n        const next = i + step;\n        // 递归求解\n        const subProblem = dp(nums, next, memo);\n        // 更新 memo\n        memo[i] = Math.min(memo[i], 1 + subProblem);\n    }\n\n    // 返回 memo[i]\n    return memo[i];\n}\n\n```\n\n#### 2.1.4. 复杂度分析\n\n- 时间复杂度：`O(n * m)`，其中 n 是数组长度，m 是数组中的最大值。但由于使用了记忆化，实际运行时间通常会更优。\n- 空间复杂度：`O(n)`\n\n> 上面的复杂度很高的，有没有更高效的算法，见下面的贪心算法题解\n\n### 2.2. 解题思路二：贪心算法\n\n我们不需要像【undefined】 那样真的「递归地」穷举出所有选择的具体结果来比较求最值，而**只需要每次选择那个最有潜力的局部最优解**，最终就能得到**全局最优解**。\n\n#### 2.2.1.1. 一个形象的例子\n\n- 想象你正在玩一个跳石头过河的游戏：\n\t- 河面上有一排石头，每个石头上有一个数字，表示你从这个石头最远可以跳多远。\n\t- 你的目标是用最少的跳跃次数到达最后一个石头。\n\t- 你总是可以到达最后一个石头。\n- **贪心算法的核心思想**是：每次跳跃时，都要选择能够使你**在下一跳到达最远位置的石头**。\n- 例子：\n\t- 假设石头上的数字是 `[2, 3, 1, 1, 4]`\n\t- 第 0 个石头（值为 2）：\n\t\t- 你站在第一个石头上，可以跳 1 步 或  2 步。\n\t\t- 如果跳 1 步到索引 1，**下一跳**最远可以到达索引 4（`1 + 3 = 4`）。\n\t\t- 如果跳 2 步到索引 2，**下一跳**最远只能到达索引 3（`2 + 1 = 3`）。\n\t\t- **贪心选择**：跳到索引 1（值为 3 的石头），**因为它能让你下一跳到达最远**。\n\t- 第 1 个石头（值为 3）：\n\t\t- 你现在在索引 1，可以跳 1、2 或 3 步。\n\t\t- 但是不管跳几步，都能直接到达最后一个石头。\n\t\t- 贪心选择：直接跳到最后一个石头。\n\t- 总跳跃次数：2 次\n\n这就像是在玩**看得最远跳得最远** 的游戏。每次跳跃，你都选择一个能让你在下一跳看得最远的地方。这样，你就能用最少的跳跃次数到达终点。\n\n这个贪心策略之所以有效，是因为题目保证了总是可以到达最后一个位置。所以我们不需要担心会跳到一个\"死胡同\"，只需要专注于如何跳得最远。\n\n#### 2.2.1.2. 再看例子，如下图\n\n![图片&文件](./files/Pastedimage20240817110226.png)\n\n### 2.2.2. 代码实现\n\n```javascript hl:19\n/**\n * @description 贪心算法解法\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function (nums) {\n    const len = nums.length;\n    // 当前位置，表示当前所在的位置，已经跳到了哪里，即索引\n    let currentPosition = 0;\n    // 步数，不是数组，而是一个数\n    let stepsNum = 0;\n    // 能跳的最远距离\n    let maxJump = 0;\n\n    // 注意这里是小于 len - 1, 因为最后一个位置不用跳\n    // 每次跳跃都选择【下一个位置】能跳的最远的地方\n    for (let i = 0; i < len - 1; i++) {\n        // 更新 maxJump\n        // 下个跳跃位置能够到达的最远距离为 【i + nums[i]】\n        maxJump = Math.max(maxJump, i + nums[i]);\n        // 到达当前位置的时候，更新 currentPosition\n        if (i === currentPosition) {\n            currentPosition = maxJump;\n            stepsNum++;\n        }\n    }\n    // 返回结果\n    return stepsNum;\n};\n\n```\n\n### 2.2.3. 复杂度分析\n\n- 时间复杂度：O(n)\n\t- 其中 n 是输入数组的长度。\n- 空间复杂度：O(1)\n\t- 算法只使用了几个额外的变量（currentPosition, stepsNum, maxJump），这些都是常数级的额外空间。\n\t- 没有使用任何与输入规模相关的额外数据结构。\n\n","3cd3a7731e0157ffa509f71ddb27b1e8":"\n# 移除元素\n\n\n`#2024/07/28` `#leetcode`  `#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281629958.png?imageSlim)\n\n## 解题思路\n\n- 快慢指针\n- 知道了 `slow`，将后面的元素重置为`_` (按照题设要求)\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function (nums, val) {\n  // 快慢指针,都从0开始\n  let fast = 0;\n  let slow = 0;\n  // 快指针遍历数组\n  while (fast < nums.length) {\n    // 当快指针对应的元素不等于 val 时\n    if (nums[fast] !== val) {\n      // 将快指针对应的元素赋值给慢指针对应的元素\n      nums[slow] = nums[fast];\n      slow++;\n    }\n    // 快指针，每遍历一个元素，就向后移动一次\n    fast++;\n  }\n  // 修改 nums 后面的元素为 _\n  for (let i = slow; i < nums.length; i++) {\n    nums[i] = \"_\";\n  }\n  return slow;\n};\n\n```\n\n## 错误记录\n\n","5ee6ec26a7c15886b795280521c84024":"\n# 删除有序数组中的重复项\n\n\n`#2024/07/28` `#leetcode`  `#算法/双指针` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281631265.png?imageSlim)\n\n## 解题思路\n\n- 双指针技巧\n- 原地修改\n\n## 代码实现\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n  // 快慢指针,都从0开始\n  let fast = 0;\n  let slow = 0;\n  // 快指针遍历数组\n  while (fast < nums.length) {\n    // 当快指针对应的元素不等于慢指针对应的元素时\n    if (nums[fast] !== nums[slow]) {\n      // 不相等时，先移动模板\n      slow++;\n      // 将快指针对应的元素赋值给慢指针对应的元素\n      nums[slow] = nums[fast];\n    }\n    // 快指针，每遍历一个元素，就向后移动一次\n    fast++;\n  }\n  // 删除后面的元素\n  nums.splice(slow + 1);\n\n  return slow + 1;\n};\n\n```\n\n## 错误记录\n\n","6f701d55d0d057c89d0a664749cd5553":"\n# 删除有序数组中的重复项 II\n\n\n`#算法/双指针`  `#2024/07/28` `#leetcode` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600](https://832-1310531898.cos.ap-beijing.myqcloud.com/202407281632176.png?imageSlim)\n\n## 解题思路\n\n- 双指针\n   - `count = 0/1/2` ，计算重复次数\n   - 记得需要重置为 0  ，当 `nums[fast] !== nums[fast - 1]`\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n  // 快慢指针,都从0开始\n  let slow = 0;\n  let fast = 0;\n  // 用于记录重复元素的个数，初始值为0，最多只能有两个重复元素\n  let count = 0;\n  // 快指针遍历数组\n  while (fast < nums.length) {\n    // 当快指针对应的元素不等于慢指针对应的元素时\n    if (nums[fast] !== nums[slow]) {\n      // 慢指针向后移动一位\n      slow++;\n      // 将快指针对应的元素赋值给慢指针对应的元素\n      nums[slow] = nums[fast];\n      // 此时，对于 nums[0..slow] 来说，nums[fast] 重复次数小于 2，也加进来\n    } else if (slow < fast && count < 2) {\n      // 慢指针向后移动一位\n      slow++;\n      // 将快指针对应的元素赋值给慢指针对应的元素\n      nums[slow] = nums[fast];\n    }\n    // 快指针，每遍历一个元素，就向后移动一次\n    fast++;\n    // 计数器，记录重复元素的个数\n    count++;\n    // fast 遇到新的不同的元素时，重置 count\n    if (fast < nums.length && nums[fast] !== nums[fast - 1]) {\n      count = 0;\n    }\n  }\n  // 删除后面的元素\n  nums.splice(slow + 1);\n  return slow + 1;\n};\n\n```\n\n> 记得最后删除元素\n\n## 错误记录\n\n","8080f9e2a1bd500e9df37f669ce35439":"\n# 多数元素\n\n\n`#leetcode`   `#2024/08/05`\n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|504](https://832-1310531898.cos.ap-beijing.myqcloud.com/202408050622674.png?imageSlim)\n\n## 解题思路\n\n### 解法 1：哈希\n\n使用一个`哈希表`来统计每个元素的出现次数，并找到出现次数超过 `⌊ n/2 ⌋` 的元素\n\n### 解法 2：排序\n\n多数元素的出现频率超过 `⌊ n/2 ⌋` ，因此排序后的数组**中间位置**的元素即为多数元素。\n\n所以排序后，返回 `nums[midIndex]` 即可\n\n### 解法 3：Boyer-Moore投票算法\n\n- 核心思想是\"对抗\"或\"抵消\"\n\t- 每个候选人都有支持者。\n\t- 支持者之间可以互相抵消。\n\t- 如果一个候选人的支持者数量超过了总人数的一半，那么即使所有其他候选人的支持者联合起来，也无法完全抵消这个候选人的支持者\n\n1. **初始化**：\n    - 设置 `candidate` 为 `null`（还没有候选人）\n    - 设置 `count` 为 0（计票器）\n2. **遍历数组**： 对于数组中的每个元素：\n    - 如果 `count` 为 0：\n        - 将当前元素设为新的 `candidate`\n        - 将 `count` 设为 1\n    - 否则：\n        - 如果当前元素等于 `candidate`，`count` 加 1\n        - 如果当前元素不等于 `candidate`，`count` 减 1\n3. **返回结果**： 遍历结束后，`candidate` 就是多数元素\n\n## 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function (nums) {\n    // 当前遍历的候选人, 初始化为 null,\n    // 刚开始，还没遍历任何元素，所以候选人是 null\n    let target = null;\n    // 该候选人 target 的票数\n    let count = 0;\n\n    for (const num of nums) {\n        // 如果 count 为 0 ，说明之前的票数抵消完了，需要重新设置候选人\n        if (count === 0) {\n            target = num;\n            count = 1;\n        } else {\n            // 如果当前的数字和候选人相同，票数 + 1\n            if (num === target) {\n                count++;\n            } else {\n                // 如果当前的数字和候选人不同，票数 - 1\n                count--;\n            }\n        }\n    }\n    return target;\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度：`O(n)`，只需要遍历数组一次。\n- 空间复杂度：`O(1)`，只使用了常数额外空间。\n\n## 算法应用\n\n- 在数据流中找到`频繁项`\n- 一群带正电的粒子和一群带负电的粒子，判断他们的`正负性`或者`中性`\n\n## 错误记录","fb45e1159f7258b6b98376281de13a92":"\n# 轮转数组\n\n\n`#leetcode`   `#2024/08/05`   \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![image.png600|656](https://832-1310531898.cos.ap-beijing.myqcloud.com/202408050809389.png?imageSlim)\n\n## 解题思路\n\n### 解法一：分割数组，然后再组合数组\n\n```javascript\n/**  \n * @param {number[]} nums  \n * @param {number} k  \n * @return {void} Do not return anything, modify nums in-place instead.  \n */// 数组分割  \nvar rotate = function (nums, k) {  \n    const n = nums.length;  \n    // base 1: 处理 k 大于数组长度的情况  \n    k %= n; \n    // base 2:  \n    // 如果 k 为 0 或数组长度为 0 或 1，无需旋转  \n    if (k === 0 || n <= 1) {  \n        return;  \n    }  \n    const part1 = nums.slice(-k);  \n    const part2 = nums.slice(0, n - k);  \n    // 直接修改 nums \n    // nums.length = 0;  \n    // nums = [...part1, ...part2];  \n    \n    // 直接修改原数组  \n    // 从 0 到 n 删除 n 个元素，然后插入 part1 和 part2  \n    nums.splice(0, n, ...part1, ...part2)  \n  \n};\n```\n\n- 时间复杂度：`O(n)` \n- 空间复杂度：`O(n)`（因为我们创建了两个临时数组 `part1` 和 `part2`）\n\n> [!danger]\n> 注意上面的两个 base 条件\n\n### 解法二：反转法\n\n假设我们有一个数组 `[1, 2, 3, 4, 5, 6, 7]`，需要向右旋转 3 步。\n\n- 步骤 1：反转整个数组 `[1, 2, 3, 4, 5, 6, 7] -> [7, 6, 5, 4, 3, 2, 1]`\n\t- 想象一下，我们把这个数组写在一条绳子上，然后把绳子翻转过来。\n- 步骤 2：反转前 k 个元素（这里 k = 3 ）\n\t- `[7, 6, 5, 4, 3, 2, 1] -> [5, 6, 7, 4, 3, 2, 1]`\n\t- 想象我们把绳子的前3个元素`（7, 6, 5）`单独拿出来翻转。\n- 步骤 3：反转剩余的元素 `[5, 6, 7, 4, 3, 2, 1] -> [5, 6, 7, 1, 2, 3, 4]`\n\t- 我们把剩下的元素`（4, 3, 2, 1）`也翻转一下。\n- 最终结果：`[5, 6, 7, 1, 2, 3, 4]`\n\n这就是我们想要的结果！\n\n为什么这个方法有效？\n\n1. **第一次**反转把整个数组颠倒，将\"需要移动到前面的元素\"放到了数组的开头，但顺序是反的。\n2. **第二次**反转**纠正了**这些元素的顺序。\n3. **第三次**反转则**纠正了**其余元素的顺序。\n\n这个方法的巧妙之处在于：\n- 它不需要额外的空间来存储元素。\n- 每个元素只被移动了常数次，所以效率很高。\n- 它可以处理各种不同的旋转步数，包括大于数组长度的情况。\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\n// 数组分割\nvar rotate = function (nums, k) {\n  // base 1 : 处理 k 大于数组长度的情况\n  k %= nums.length;\n\n  // base 2 : 如果 k 为 0 或数组长度为 0 或 1，无需旋转\n  if (k === 0 || nums.length <= 1) {\n    return;\n  }\n\n  // 翻转 ① : 翻转整个数组\n  reverse(nums, 0, nums.length - 1);\n  // 翻转 ② : 翻转前 k 个元素\n  reverse(nums, 0, k - 1);\n  // 翻转 ③ : 翻转后 n - k 个元素\n  reverse(nums, k, nums.length - 1);\n};\n\n/**\n * @description 翻转数组，从 start 到 end\n * */\nfunction reverse(nums, start, end) {\n  while (start < end) {\n    const temp = nums[start];\n    nums[start] = nums[end];\n    nums[end] = temp;\n    start++;\n    end--;\n  }\n}\n\n```\n\n- 时间复杂度为 `O(n)`\n- 空间复杂度为 `O(1)`\n\t- 直接在原数组上操作，不需要额外的空间（除了几个临时变量）。\n\n> [!danger]\n> 能够处理所有边界情况，包括 `k = 0` 和数组长度为 0 或 1 的情况 和 k > 数组长度的情况\n\n### 解法三：使用额外的数组\n\n通过创建一个新的数组来存储结果，从而实现数组的轮转\n\n这里不展示代码了\n\n## 错误记录\n\n> [!danger]\n> 解法一中： 在 JavaScript 中，当我们将一个**数组**作为参数传递给函数时，我们传递的是**数组的引用**。在函数内部，`nums = [...part1, ...part2]` 这行代码创建了一个新的数组并将 `nums` 变量指向这个新数组，但这并不会改变原始数组的内容。函数外部的原数组保持不变\n\n","03d61ca19d7450d8a994038cc6b13768":"\n# 买卖股票的最佳时机\n\n\n`#leetcode`   `#2024/08/09`  `#算法/股票` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![图片&文件](./files/iShot_2024-08-09_07.54.281.png)\n\n> [!danger]\n> 注意：**只能买卖一次**\n\n## 解题思路\n\n### 思路一\n\n```javascript\n/**  \n * @description 解题思路  \n * ① base case: 如果 prices 为空，返回 0  \n * ② 初始化买入价格 buy 为 prices[0]，初始化利润 profit 为 0  \n * ③ 遍历 prices  \n *    1、如果当前价格比买入价格低，就更新买入价格  \n *    2、否则，更新利润  \n * ④ 返回利润  \n *     \n * */\n```\n\n#### 代码实现\n\n```javascript\nvar maxProfit = function(prices) {  \n    // base case  \n    if (prices.length === 0) {  \n        return 0;  \n    }  \n    // 买入价格  \n    let buy = prices[0];  \n    // 利润  \n    let profit = 0;  \n    // 遍历  \n    for (let i = 1; i < prices.length; i++) {  \n        // 如果当前价格比买入价格低，就更新买入价格  \n        if (prices[i] < buy) {  \n            buy = prices[i];  \n        } else {  \n            // 否则，计算利润  \n            profit = Math.max(profit, prices[i] - buy);  \n        }  \n    }  \n    return profit;  \n};\n```\n\n#### 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 `n` 是价格数组的长度，因为我们只遍历了数组一次。\n- 空间复杂度是 `O(1)`，因为我们只使用了`两个额外`的变量，不管输入规模如何，额外空间都是常数级的\n\n### 思路二\n\n买卖股票通用框架，见后文**股票类型**的题目\n\n## 错误记录\n\n","a0ce04a71d275ee4a7447abb614b5018":"\n# 买卖股票的最佳时机 II\n\n\n`#leetcode`   `#2024/08/09`  `#算法/股票`   `#算法/贪心算法` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n### 只能买卖一次的场景\n\n前文 【7.  买卖股票的最佳时机】 有讲只能买卖一次的场景，如果能够买卖多次呢？\n\n### 能够买卖多次的场景：本题\n\n![图片&文件](./files/Pastedimage20240809084132.png)\n\n> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n## 解题思路\n\n### 思路一：贪心算法\n\n**贪心算法** \n\n- 核心思想是：**只要今天的价格比昨天高，我们就进行买卖**\n- 任何上涨的区间分解成若干个**相邻两天的小区间**\n\t- `Day 1: 10 ， Day 2: 15  ， Day 3: 20`\n\t\t- 我们可以看作是： (20 - 10) = (15 - 10) + (20 - 15)\n\n#### 代码实现\n\n```javascript\n/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n  // 最大利润\n  let res = 0;\n\n  // 遍历 prices\n  for (let i = 0; i < prices.length - 1; i++) {\n    // 如果当前价格比后一天的价格低，就买入，然后卖出\n    if (prices[i] < prices[i + 1]) {\n      res += prices[i + 1] - prices[i];\n    }\n  }\n\n  // 返回最大利润\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 n 是价格数组的长度，因为我们只遍历了数组一次。 \n- 空间复杂度是 `O(1)`，因为我们只使用了一个额外的变量来存储利润。\n\n### 思路二：动态规划\n\n可参考 【1.  买卖股票的最佳时机 IV】 ，这里不展开，此题还是建议使用贪心算法比较合适\n\n## 错误记录\n\n","dd0706084ded59df9fafa46d4fe76c7c":"\n# 跳跃游戏\n\n\n`#leetcode`   `#2024/08/16`  `#算法/贪心算法`  \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n[https://leetcode.cn/problems/jump-game/](https://leetcode.cn/problems/jump-game/)\n\n![图片&文件](./files/Pastedimage20240816081854.png)\n\n## 解题思路\n\n### 思路一：贪心算法\n\n1. 贪心算法： 我们可以使用贪心算法来解决这个问题。核心思想是维护一个变量 `maxReach`，表示能够到达的**最远位置**。\n2. 遍历数组： 从左到右遍历数组，对于每个位置，我们更新 `maxReach`。\n3. 更新 `maxReach`： 对于当前位置 i，我们可以跳到的最远位置是 `i + nums[i]`\n\t- 因此，`maxReach` 应该更新为 `Math.max(maxReach, i + nums[i])` \n4. 检查是否可以继续： \n\t- 如果在某个`位置 i`，`maxReach` 小于或等于 i，且 `i` 还不是最后一个位置，那么我们就无法继续前进，返回 false。\n5. 到达终点： 如果我们能够遍历完整个数组，那么就意味着我们可以到达最后一个位置，返回 true。\n\n#### 代码实现\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function (nums) {\n  // 代表当前能到达的最远位置\n  let maxReach = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    // 如果当前位置大于最远位置，说明无法到达\n    // maxReach 是当前能到达的最远位置\n    // 例如 [3, 2, 1, 0, 4]，当 i = 4 时，maxReach = 3，无法到达\n    // 例如 [2, 3, 1, 1, 4]，当 i = 4 时，maxReach = 4，可以到达\n    if (i > maxReach) {\n      return false;\n    }\n    // 更新最远位置\n    // i + nums[i] 代表当前位置能到达的最远位置,i 是当前位置，nums[i] 是当前位置的值\n    // question: 为什么要取最大值？\n    // answer: 因为当前位置的值是当前位置能到达的最远位置，所以要取最大值\n    maxReach = Math.max(maxReach, i + nums[i]);\n  }\n\n  // 如果最远位置大于等于数组长度，说明可以到达\n  return true;\n};\n\n```\n\n#### 复杂度分析\n\n- 时间复杂度是 `O(n)`，其中 n 是数组的长度，因为我们只遍历了一遍数组。\n- 空间复杂度是 `O(1)`，因为我们只使用了常数额外空间\n\n### 思路二：动态规划\n\n#### 代码实现\n\n#### 复杂度分析\n\n## 错误记录","3aa643b0df4e564bb8c0b8e417741a0e":"\n# 前言\n\n\n > labuladong 算法的刷题笔记：[labuladong 的算法笔记](https://labuladong.online/algo/)\n\n","70bfdd5a2116524ea13bbf6b140b3eb0":"\n# 买卖股票的最佳时机 IV\n\n\n`#leetcode`   `#2024/08/10` `#算法/动态规划` \n\n\n## 目录\n<!-- toc -->\n ## 题目及理解 \n\n![图片&文件](./files/Pastedimage20240810100713.png)\n\n这题是股票买卖最通用的一题，可以以他基准解决其他股票相关的问题，如下图\n\n![图片&文件](./files/Pastedimage20240810101116.png)\n\n- 第一题是只进行一次交易，相当于 `k = 1`；\n- 第二题是不限交易次数，相当于 `k = +infinity`（正无穷）；\n- 第三题是只进行 2 次交易，相当于 `k = 2`；\n- 剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理\n\n## 解题思路\n\n### 思路一：动态规划\n\n#### 框架：明确状态和选择\n\n```javascript\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 择优(选择1，选择2...)\n```\n\n- 选择：每天都有三种选择：买入、卖出、无操作\n\t- 用 `buy`, `sell`, `rest` 表示这三种选择。\n- 状态：**这个问题的「状态」有三个**，所以可以使用`三维数组`来组装下所有组合\n\t- ① 第一个是`天数`\n\t- ② 第二个是`允许交易的最大次数`\n\t- ③ 第三个是`当前的持有状态`\n\t\t- 即之前说的 `rest` 的状态\n\t\t\t- 用 `1` 表示`持有`\n\t\t\t- `0` 表示`没有持有`\n\n再看最新的框架\n\n```javascript\ndp[i][k][0 or 1]\n\n① i:  0 <= i <= n - 1 ， n 表示 `天数`\n② k:  1 <= k <= K ，K 表示`允许交易的最大次数`\n③ 0 or  1 ： 代表`当前的持有状态` ， 0 和 1 代表是否持有股票。\n\n所以 此问题共 n × K × 2 种状态，全部穷举就能搞定。\n\nfor 0 <= i < n:\n    for 1 <= k <= K:\n        for s in {0, 1}:\n            dp[i][k][s] = max(buy, sell, rest)\n```\n\n举例：\n\n  - `dp[3][2][1]` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多还可以进行 2 次交易。\n  -  `dp[2][3][0]` 的含义：今天是第二天，我现在手上没有持有股票，至今最多还可以进行 3 次交易\n\n我们想求的**最终答案**是 `dp[n - 1][K][0]`，即最后一天，最多允许 `K` 次交易，最多获得多少利润。\n\n读者可能问为什么不是 `dp[n - 1][K][1]`？\n\n- 因为 `dp[n - 1][K][1]` 代表到最后一天手上还持有股票\n- `dp[n - 1][K][0]` 表示最后一天手上的股票已经卖出去了\n- 很显然后者得到的利润一定大于前者\n\n#### 状态转移框架\n\n![图片&文件](./files/Pastedimage20240810103019.png)\n\n##### 今天没有持有股票： `dp[i][k][0]`\n\n1. 昨天没有持有，今天选择不买，`k` 不会变\n2. 昨天持有，今天选择卖掉，`k` 不会变\n\n```javascript\n// 今天我没有持有股票，有两种可能，我从这两种可能中求最大利润,如下代码：\n\ndp[i][k][0] = max( ① dp[i-1][k][0],           ② dp[i-1][k][1] + prices[i]  ) \n            = max( ① 昨天没有持有，今天选择不买   ② 昨天持有，今天选择卖掉 sell    )\n```\n\n①  `dp[i-1][k][0]` ，即我昨天就没有持有，且截至昨天最大交易次数限制为 `k`；然后我今天选择 `rest`，所以我今天还是没有持有，最大交易次数限制依然为 `k`\n\n②  `dp[i-1][k][1] + prices[i]` ，我昨天持有股票，且截至昨天最大交易次数限制为 `k`；但是今天我 `sell` 了，所以我今天没有持有股票了，最大交易次数限制依然为 `k`\n\n##### 今天持有股票： `dp[i][k][1]`\n\n- 昨天持有，今天还是继续持有，`k` 不变\n- 昨天没有持有，今天选择买，`k` 从 `k-1` 而来\n\n```javascript\ndp[i][k][1] = max( ① dp[i-1][k][1],             ② dp[i-1][k-1][0] - prices[i] )\n              max( ① 昨天持有，今天还是继续持有,    ② 昨天没有持有，今天选择买        )\n```\n\n① `dp[i-1][k][1]` ，我昨天就持有着股票，且截至昨天最大交易次数限制为 `k`；然后今天选择 `rest`，所以我今天还持有着股票，最大交易次数限制依然为 `k`。\n\n② `dp[i-1][k-1][0] - prices[i]` 我昨天本没有持有，且截至昨天最大交易次数限制为 `k - 1`；但今天我选择 `buy`，所以今天我就持有股票了，最大交易次数限制为 `k`。\n\n##### 注意点\n\n- 如果 `buy`，就要从利润中减去 `prices[i]`\n- 如果 `sell`，就要给利润增加 `prices[i]`。\n- 今天的最大利润就是这两种可能选择中较大的那个。\n- 注意 `k` 的限制，在选择 `buy` 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 `k` 应该减小 1。\n\n##### base case\n\n```javascript\ndp[-1][0 ~ k][0] = 0\n解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。\n\ndp[-1][0 ~ k][1] = -infinity\n解释：还没开始的时候，是不可能持有股票的。\n因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。\n\ndp[...][0][0] = 0\n解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。\n\ndp[...][0][1] = -infinity\n解释：不允许交易的情况下，是不可能持有股票的。\n因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。\n```\n\n##### 最后总结\n\n```javascript\nbase case：\ndp[-1][...][0] = dp[...][0][0] = 0\ndp[-1][...][1] = dp[...][0][1] = -infinity\n\n状态转移方程：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n```\n\n#### 代码实现\n\n```javascript\n/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (k, prices) {\n  let n = prices.length;\n  // 利润\n  let res = 0;\n  // 如果 n 为 0，返回 0, 无需交易，利润为 0\n  // 如果 k 为 0，返回 0, 无法交易，利润为 0\n  if (n === 0 || k === 0) {\n    return 0;\n  }\n\n  // 初始化 dp 数组，三维数组\n  // dp[i][k][0/1] 表示第 i 天，最多进行 k 次交易，持有/不持有股票时的利润\n  let dp = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= k; j++) {\n      dp[i][j] = [];\n      for (let l = 0; l < 2; l++) {\n        dp[i][j][l] = 0;\n      }\n    }\n  }\n\n  // base case 1\n  // 如果 k 为 0 , 且没有股票，利润为 0\n  // 如果 k 为 0, 且有股票，利润为 -Infinity，用于表示不可能的情况，方便后续取最大值\n  for (let i = 0; i < n; i++) {\n    dp[i][0][0] = 0;\n    dp[i][0][1] = -Infinity;\n  }\n\n  // 遍历 prices\n  for (let i = 0; i < n; i++) {\n    for (let j = 1; j <= k; j++) {\n      // base case, i 为 -1 时，越界\n      if (i === 0) {\n        dp[i][j][0] = 0;\n        dp[i][j][1] = -prices[i];\n        continue;\n      }\n      dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n      dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n    }\n  }\n\n  res = Math.max(dp[n - 1][k][0], dp[n - 1][k][1]);\n\n  // 返回最大利润\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n1. 时间复杂度：`O(n * k)`\n    - 我们有两个主要的嵌套循环：\n        - 外层循环遍历 `prices` 数组，共 `n` 次；\n        - 内层循环遍历 `k` 次交易。\n    - 在每次循环中，我们进行常数次操作（比较和赋值）。\n    - 因此，总的时间复杂度是 `O(n * k)`。\n2. 空间复杂度：`O(n * k)`\n    - 我们使用了一个三维数组 dp，其大小为 `n * (k+1) * 2`。\n    - 虽然最后一个维度是`常数（2`），但在大 O 表示法中我们通常忽略常数因子。\n    - 因此，空间复杂度为 `O(n * k)`\n\n### 思路二\n\n#### 代码实现\n\n#### 复杂度分析\n\n## 错误记录一\n\n需要移除了 `dp[-1]` 的初始化，因为这在 JavaScript 中是无效的，在遍历时特殊处理吧，如下图\n\n![图片&文件](./files/Pastedimage20240810114525.png)\n\n## 错误记录二\n\n初始化一个`二维数组`或者`三维数组`，别使用 `Array.form({lenght:n})` 之类的了，使用下面代码肯定不会出问题\n\n```javascript\n  // 初始化 dp 数组，三维数组\n  // dp[i][k][0/1] 表示第 i 天，最多进行 k 次交易，持有/不持有股票时的利润\n  let dp = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= k; j++) {\n      dp[i][j] = [];\n      for (let l = 0; l < 2; l++) {\n        dp[i][j][l] = 0;\n      }\n    }\n  }\n```\n\n","b049496c4d0f5c1cb601a8e8daaeb19c":"\n# 关于\n\n`#后记`  `#后序`   `#about`  \n\n\n## 目录\n<!-- toc -->\n ## 联系我 \n\n- 个人邮箱： liguwe@qq.com\n- 个人微信：liguwe (请备注：`832`)\n- 个人站点： [个人站点](https://liguwe.site)\n- Github：[Github](http://github.com/liguwe)\n\n## 问题反馈\n\n如果您发现了错误，您可通过以下途径来反馈给我：\n\n- **反馈方式**：[Github New Issues](https://github.com/liguwe/liguwe.github.io/issues/new)\n\n> 欢迎任何形式的改进意见和建议，请多多指教，谢谢！\n\n## 致谢\n\n- 感谢 [mdbook](https://rust-lang.github.io/mdBook/) 提供的电子书生成工具\n- 感谢 [Github](https://github.com/) 提供的代码托管服务及静态页面服务\n"}